<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Neo42</title>
  
  <subtitle>Dont&#39;t Panic,Do not go gentle into that good night :)</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yo42.github.io/"/>
  <updated>2019-04-26T13:27:49.567Z</updated>
  <id>https://yo42.github.io/</id>
  
  <author>
    <name>Neo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes生产架构</title>
    <link href="https://yo42.github.io/2019/04/26/Kubernetes%E7%94%9F%E4%BA%A7%E6%9E%B6%E6%9E%84/"/>
    <id>https://yo42.github.io/2019/04/26/Kubernetes生产架构/</id>
    <published>2019-04-26T13:04:00.198Z</published>
    <updated>2019-04-26T13:27:49.567Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes生产架构，其设计适用于绝大多数环境, 如下图所示。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="k8s-jiagou.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在该架构中，我们可以将其分为四层，如下：</p><ul><li>Client层：即Kubernetes集群外部用户、客户端等；</li><li>服务访问层：即由Traefik ingress实现服务发现、负载均衡和路由规则定义等；</li><li>业务应用层：即基于Kubernetes平台构建和运行企业业务应用，如CI/CD持续集成、微服务项目、监控告警和日志管理、私有镜像仓库等服务；</li><li>基础设施层：即由Kubernetes容器管理平台和Ceph数据持久化存储等系统组成的基础设施服务。</li></ul><p>下面，我们分别来谈谈各层的具体实现方案。</p><h2 id="基础设施层"><a href="#基础设施层" class="headerlink" title="基础设施层"></a>基础设施层</h2><p><strong>Kubernetes平台</strong></p><ul><li>部署管理：Kubernetes平台除了直接使用公有云如阿里云、AWS等云服务提供商的K8s服务外，我们还可以自己部署和管理等，如使用Kubespray工具。</li><li>网络通信：在容器和容器之间、容器和主机网络方面，可以使用Calico或Flannel等方案。</li><li>HA高可用：Kubernetes节点分为Master和Node两种类型节点，前者负责运行集群相关的控制管理服务，而后者负责运行Pod容器。在多Node节点模式下，由于Kubernetes Pod具有天然的容灾冗余HA高可用实现，因此，我们并不需要关心Node节点的HA高可用，而只需关心Master节点的HA即可，Master节点的HA高可用，通过多Master节点+HAProxy方案实现即可。从Kubernetes 1.12版本起，kube-proxy服务默认使用ipvs实现，取消了之前的iptables。这有助于提升K8s大规模集群环境下的性能和稳定性。</li><li>Docker和操作系统优化：在生产环境中，Docker和操作系统版本应当使用较新的release版本。并且，主机操作系统应当做一定程度的优化配置，如关闭swap内存交换分区，预留一定的CPU核数和内存资源给宿主机使用等。</li></ul><p><strong>Ceph/NFS数据存储</strong><br>Kubernetes平台的数据持久化存储，可以使用Ceph、NFS等存储方案。其中，Ceph适用于有其技术背景或大容量存储需求的公司；而NFS适用于存储容量需求相对较小，无专业存储技术背景的公司。</p><h2 id="业务应用层"><a href="#业务应用层" class="headerlink" title="业务应用层"></a>业务应用层</h2><ul><li>镜像管理：使用Harbor私有镜像仓库服务；</li><li>日志管理：使用Elasticsearch、Filebeat 和 Kibana技术栈；</li><li>监控告警管理：使用Cadvisor、Prometheus和Grafana技术栈；</li><li>微服务架构：使用Service Mesh服务网格中的Istio方案；</li><li>Devops：使用Gitlab、Jenkins等持续集成工具；</li><li>单体应用：无状态类服务使用deployment，有状态类服务则使用Statefulset，如果关联的服务较多且复杂则使用Helm。</li><li>规划好Namespace：应当做到每个namespace专属用于某类型的应用，如monitor namespace统一管理诸如监控告警和日志管理方面的pod、service、pvc、ingress等资源。这样，可以较为方便的管理和区分K8s上的各种应用。</li></ul><h2 id="服务访问层"><a href="#服务访问层" class="headerlink" title="服务访问层"></a>服务访问层</h2><p>外部客户端访问K8s集群内的服务、负载均衡和路由规则定义使用Traefik Ingress实现。此外，应当实现Ingress服务HA高可用，可以想象在K8s集群中，大量的出入口流量都进过Ingress，其负载是非常大的，其重要程度不言而喻，因此实现HA就非常重要。ingress controller节点（无论是基于nginx还是traefik实现）应当至少为2个节点，并在这些节点上，部署Keepalived和HAproxy共同维护一个VIP地址，将其提供给ingress使用。</p><p>架构如下图所示。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="ingress-ha.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>在该架构中，Ingress节点一般使用独立的服务器，即只做将集群外部流量接入到集群内部。除了使用external Ip来暴露ingress的Service到集群外部，还可以使用hostNetwork，如果是公有云，还可以使用LoadBalance。这样Ingress Controller将监听节点的80和443端口，通过热备的形式部署多个ingress节点，并在每个节点上部署Keepalived，多个节点共同维护一个VIP，实现Ingress服务的高可用。</p><p>如上图所示，部署两个ingress节点172.16.10.11和172.16.10.12。公网ip映射或转发到内网的VIP地址172.16.10.10上（如果VIP本身是公网IP则可以不用转发）。ingress controller的副本数replicaCount为2，将被调度到node1和node2这两个节点上。同时，使用pod反亲和性禁止ingress pod调度在同一个节点上。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""><a href="https://xuchao918.github.io/2019/03/02/浅谈Kubernetes生产架构/" target="_blank" rel="noopener">https://xuchao918.github.io/2019/03/02/%E6%B5%85%E8%B0%88Kubernetes%E7%94%9F%E4%BA%A7%E6%9E%B6%E6%9E%84/</a></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kubernetes生产架构，其设计适用于绝大多数环境, 如下图所示。&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>使用k8s service对象+ 阿里云LoadBalancer 监听公网TCP服务</title>
    <link href="https://yo42.github.io/2019/04/26/%E4%BD%BF%E7%94%A8k8s-service%E5%AF%B9%E8%B1%A1-%E9%98%BF%E9%87%8C%E4%BA%91LoadBalancer-%E7%9B%91%E5%90%AC%E5%85%AC%E7%BD%91TCP%E6%9C%8D%E5%8A%A1/"/>
    <id>https://yo42.github.io/2019/04/26/使用k8s-service对象-阿里云LoadBalancer-监听公网TCP服务/</id>
    <published>2019-04-26T08:34:27.036Z</published>
    <updated>2019-04-26T08:40:00.850Z</updated>
    
    <content type="html"><![CDATA[<p>LoadBalancer类型的Service资源</p><ul><li>LoadBalancer：某些云服务提供商会直接提供LoadBalancer模式，将服务对接到负载均衡，其原理是基于kubernetes的controller做二次开发，并集成到K8S集群，使得集群可以与云服务SDK交互</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端访问流程：集群外的客户端 –&gt; LoadBalancer –&gt; NodeIP:NodePort –&gt; ClusterIP:servicePort –&gt; PortIP:containerPort。</span><br></pre></td></tr></table></figure><p>阿里云自己提供的Kubernetes集群才可以使用LoadBalancer，但我们是在阿里云上自建k8s就能，所以不具备这个功能。</p><p>Example: tcp-ser-ds.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">tcp-server-ds</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">tcp-server-ds</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">tcp-server-ds</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">tcp-server-ds</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      hostNetwork:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - image:</span> <span class="string">maniankara/tcp-echo:1.0</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">446</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">tcp-echo-server</span></span><br><span class="line"><span class="attr">        args:</span> <span class="string">["--port",</span> <span class="string">"446"</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p>阿里云配置slb监听node节点的446端口</p><p>最终telnet 公网ip地址+tcp port连通</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LoadBalancer类型的Service资源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LoadBalancer：某些云服务提供商会直接提供LoadBalancer模式，将服务对接到负载均衡，其原理是基于kubernetes的controller做二次开发，并集成到K8S集群，使得集群
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 部署策略</title>
    <link href="https://yo42.github.io/2019/04/26/Kubernetes-%E9%83%A8%E7%BD%B2%E7%AD%96%E7%95%A5/"/>
    <id>https://yo42.github.io/2019/04/26/Kubernetes-部署策略/</id>
    <published>2019-04-26T08:16:10.530Z</published>
    <updated>2019-04-26T08:34:36.062Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>Kubernetes</code>中有几种不同的方式发布应用，所以为了让应用在升级期间依然平稳提供服务，选择一个正确的发布策略就非常重要了。</p><p>选择正确的部署策略是要依赖于我们的业务需求的，下面我们列出了一些可能会使用到的策略：</p><ul><li>重建(recreate)：停止旧版本部署新版本</li><li>滚动更新(rolling-update)：一个接一个地以滚动更新方式发布新版本</li><li>蓝绿(blue/green)：新版本与旧版本一起存在，然后切换流量</li><li>金丝雀(canary)：将新版本面向一部分用户发布，然后继续全量发布</li><li>A/B测(a/b testing)：以精确的方式（HTTP 头、cookie、权重等）向部分用户发布新版本。<code>A/B测</code>实际上是一种基于数据统计做出业务决策的技术。在 Kubernetes 中并不原生支持，需要额外的一些高级组件来完成改设置（比如Istio、Linkerd、Traefik、或者自定义 Nginx/Haproxy 等）。</li></ul><p>你可以在<code>Kubernetes</code>集群上来对上面的这些策略进行测试，下面的仓库中有需要使用到的资源清单：<a href="https://github.com/ContainerSolutions/k8s-deployment-strategies" target="_blank" rel="noopener">https://github.com/ContainerSolutions/k8s-deployment-strategies</a></p><p>接下来我们来介绍下每种策略，看看在什么场景下面适合哪种策略。</p><h3 id="重建-Recreate-最好在开发环境"><a href="#重建-Recreate-最好在开发环境" class="headerlink" title="重建(Recreate) - 最好在开发环境"></a>重建(Recreate) - 最好在开发环境</h3><p>策略定义为<code>Recreate</code>的<code>Deployment</code>，会终止所有正在运行的实例，然后用较新的版本来重新创建它们。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Recreate</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://bxdc-static.oss-cn-beijing.aliyuncs.com/images/RCXtdC.jpg" alt="Recreate" title="">                </div>                <div class="image-caption">Recreate</div>            </figure>Recreate<br><br>重新创建策略是一个虚拟部署，包括关闭版本A，然后在关闭版本A后部署版本B. 此技术意味着服务的停机时间取决于应用程序的关闭和启动持续时间。<br><br>我们这里创建两个相关的资源清单文件，app-v1.yaml：<br><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Recreate</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">        version:</span> <span class="string">v1.0.0</span></span><br><span class="line"><span class="attr">      annotations:</span></span><br><span class="line">        <span class="string">prometheus.io/scrape:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="string">prometheus.io/port:</span> <span class="string">"9101"</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">containersol/k8s-deployment-strategies</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">8086</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">VERSION</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">v1.0.0</span></span><br><span class="line"><span class="attr">        livenessProbe:</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/live</span></span><br><span class="line"><span class="attr">            port:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">          periodSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">        readinessProbe:</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/ready</span></span><br><span class="line"><span class="attr">            port:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>app-v2.yaml 文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Recreate</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">        version:</span> <span class="string">v2.0.0</span></span><br><span class="line"><span class="attr">      annotations:</span></span><br><span class="line">        <span class="string">prometheus.io/scrape:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="string">prometheus.io/port:</span> <span class="string">"9101"</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">containersol/k8s-deployment-strategies</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">8086</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">VERSION</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">v2.0.0</span></span><br><span class="line"><span class="attr">        livenessProbe:</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/live</span></span><br><span class="line"><span class="attr">            port:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">          periodSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">        readinessProbe:</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/ready</span></span><br><span class="line"><span class="attr">            port:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>上面两个资源清单文件中的 Deployment 定义几乎是一直的，唯一不同的是定义的环境变量<code>VERSION</code>值不同，接下来按照下面的步骤来验证<code>Recreate</code>策略：</p><ol><li>版本1提供服务</li><li>删除版本1</li><li>部署版本2</li><li>等待所有副本准备就绪</li></ol><p>首先部署第一个应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f app-v1.yaml</span></span><br><span class="line">service "my-app" created</span><br><span class="line">deployment.apps "my-app" created</span><br></pre></td></tr></table></figure><p>测试版本1是否部署成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -l app=my-app</span></span><br><span class="line">NAME                      READY     STATUS    RESTARTS   AGE</span><br><span class="line">my-app-7b4874cd75-m5kct   1/1       Running   0          19m</span><br><span class="line">my-app-7b4874cd75-pc444   1/1       Running   0          19m</span><br><span class="line">my-app-7b4874cd75-tlctl   1/1       Running   0          19m</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc my-app</span></span><br><span class="line">NAME      TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">my-app    NodePort   10.108.238.76   &lt;none&gt;        80:32532/TCP   5m</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:32532</span></span><br><span class="line">Host: my-app-7b4874cd75-pc444, Version: v1.0.0</span><br></pre></td></tr></table></figure><p>可以看到版本1的应用正常运行了。为了查看部署的运行情况，打开一个新终端并运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch kubectl get po -l app=my-app</span></span><br></pre></td></tr></table></figure><p>然后部署版本2的应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f app-v2.yaml</span></span><br></pre></td></tr></table></figure><p>这个时候可以观察上面新开的终端中的 Pod 列表的变化，可以看到之前的3个 Pod 都会先处于<code>Terminating</code>状态，并且3个 Pod 都被删除后才开始创建新的 Pod。</p><p>然后测试第二个版本应用的部署进度：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">while</span> sleep 0.1; <span class="keyword">do</span> curl http://127.0.0.1:32532; <span class="keyword">done</span></span></span><br><span class="line">curl: (7) Failed connect to 127.0.0.1:32532; Connection refused</span><br><span class="line">curl: (7) Failed connect to 127.0.0.1:32532; Connection refused</span><br><span class="line">......</span><br><span class="line">Host: my-app-f885c8d45-sp44p, Version: v2.0.0</span><br><span class="line">Host: my-app-f885c8d45-t8g7g, Version: v2.0.0</span><br><span class="line">Host: my-app-f885c8d45-sp44p, Version: v2.0.0</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以看到最开始的阶段服务都是处于不可访问的状态，然后到第二个版本的应用部署成功后才正常访问，可以看到现在访问的数据是版本2了。</p><p>最后，可以执行下面的命令来清空上面的资源对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl delete all -l app=my-app</span></span><br></pre></td></tr></table></figure><p>结论:</p><ul><li>应用状态全部更新</li><li>停机时间取决于应用程序的关闭和启动消耗的时间</li></ul><h3 id="滚动更新-rolling-update"><a href="#滚动更新-rolling-update" class="headerlink" title="滚动更新(rolling-update)"></a>滚动更新(rolling-update)</h3><p>滚动更新通过逐个替换实例来逐步部署新版本的应用，直到所有实例都被替换完成为止。它通常遵循以下过程：在负载均衡器后面使用版本 A 的实例池，然后部署版本 B 的一个实例，当服务准备好接收流量时(Readiness Probe 正常)，将该实例添加到实例池中，然后从实例池中删除一个版本 A 的实例并关闭，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://bxdc-static.oss-cn-beijing.aliyuncs.com/images/30iUcb.jpg" alt="ramped" title="">                </div>                <div class="image-caption">ramped</div>            </figure>ramped<br><br>下图是滚动更新过程应用接收流量的示意图：<br><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://bxdc-static.oss-cn-beijing.aliyuncs.com/images/OIhAqJ.jpg" alt="rolling-update requests" title="">                </div>                <div class="image-caption">rolling-update requests</div>            </figure>rolling-update requests<br><br>下面是 Kubernetes 中通过 Deployment 来进行滚动更新的关键参数：<br><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">RollingUpdate</span></span><br><span class="line"><span class="attr">    rollingUpdate:</span></span><br><span class="line"><span class="attr">      maxSurge:</span> <span class="number">2</span>        <span class="comment"># 一次可以添加多少个Pod</span></span><br><span class="line"><span class="attr">      maxUnavailable:</span> <span class="number">1</span>  <span class="comment"># 滚动更新期间最大多少个Pod不可用</span></span><br></pre></td></tr></table></figure><p>现在仍然使用上面的 app-v1.yaml 这个资源清单文件，新建一个定义滚动更新的资源清单文件 app-v2-rolling-update.yaml，文件内容如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="comment"># maxUnavailable设置为0可以完全确保在滚动更新期间服务不受影响，还可以使用百分比的值来进行设置。</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">RollingUpdate</span></span><br><span class="line"><span class="attr">    rollingUpdate:</span></span><br><span class="line"><span class="attr">      maxSurge:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      maxUnavailable:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">        version:</span> <span class="string">v2.0.0</span></span><br><span class="line"><span class="attr">      annotations:</span></span><br><span class="line">        <span class="string">prometheus.io/scrape:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="string">prometheus.io/port:</span> <span class="string">"9101"</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">containersol/k8s-deployment-strategies</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">8086</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">VERSION</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">v2.0.0</span></span><br><span class="line"><span class="attr">        livenessProbe:</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/live</span></span><br><span class="line"><span class="attr">            port:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">          periodSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">        readinessProbe:</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/ready</span></span><br><span class="line"><span class="attr">            port:</span> <span class="string">probe</span></span><br><span class="line">          <span class="comment"># 初始延迟设置高点可以更好地观察滚动更新过程</span></span><br><span class="line"><span class="attr">          initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line"><span class="attr">          periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>上面的资源清单中我们在环境变量中定义了版本2，然后通过设置<code>strategy.type=RollingUpdate</code>来定义该 Deployment 使用滚动更新的策略来更新应用，接下来我们按下面的步骤来验证滚动更新策略：</p><ol><li>版本1提供服务</li><li>部署版本2</li><li>等待直到所有副本都被版本2替换完成</li></ol><p>同样，首先部署版本1应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f app-v1.yaml</span></span><br><span class="line">service "my-app" created</span><br><span class="line">deployment.apps "my-app" created</span><br></pre></td></tr></table></figure><p>测试版本1是否部署成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -l app=my-app</span></span><br><span class="line">NAME                      READY     STATUS    RESTARTS   AGE</span><br><span class="line">my-app-7b4874cd75-h8c4d   1/1       Running   0          47s</span><br><span class="line">my-app-7b4874cd75-p4l8f   1/1       Running   0          47s</span><br><span class="line">my-app-7b4874cd75-qnt7p   1/1       Running   0          47s</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc my-app</span></span><br><span class="line">NAME      TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">my-app    NodePort   10.109.99.184   &lt;none&gt;        80:30486/TCP   1m</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:30486</span></span><br><span class="line">Host: my-app-7b4874cd75-qnt7p, Version: v1.0.0</span><br></pre></td></tr></table></figure><p>同样，在一个新终端中执行下面命令观察 Pod 变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch kubectl get pod -l app=my-app</span></span><br></pre></td></tr></table></figure><p>然后部署滚动更新版本2应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f app-v2-rolling-update.yaml</span></span><br><span class="line">deployment.apps "my-app" configured</span><br></pre></td></tr></table></figure><p>这个时候在上面的 watch 终端中可以看到多了很多 Pod，还在创建当中，并没有一开始就删除之前的 Pod，同样，这个时候执行下面命令，测试应用状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">while</span> sleep 0.1; <span class="keyword">do</span> curl http://127.0.0.1:30486; <span class="keyword">done</span></span></span><br><span class="line">Host: my-app-7b4874cd75-vrlj7, Version: v1.0.0</span><br><span class="line">......</span><br><span class="line">Host: my-app-7b4874cd75-vrlj7, Version: v1.0.0</span><br><span class="line">Host: my-app-6b5479d97f-2fk24, Version: v2.0.0</span><br><span class="line">Host: my-app-7b4874cd75-p4l8f, Version: v1.0.0</span><br><span class="line">......</span><br><span class="line">Host: my-app-6b5479d97f-s5ctz, Version: v2.0.0</span><br><span class="line">Host: my-app-7b4874cd75-5ldqx, Version: v1.0.0</span><br><span class="line">......</span><br><span class="line">Host: my-app-6b5479d97f-5z6ww, Version: v2.0.0</span><br></pre></td></tr></table></figure><p>我们可以看到上面的应用并没有出现不可用的情况，最开始访问到的都是版本1的应用，然后偶尔会出现版本2的应用，直到最后全都变成了版本2的应用，而这个时候看上面 watch 终端中 Pod 已经全部变成10个版本2的应用了，我们可以看到这就是一个逐步替换的过程。</p><p>如果在滚动更新过程中发现新版本应用有问题，我们可以通过下面的命令来进行一键回滚：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl rollout undo deploy my-app</span></span><br><span class="line">deployment.apps "my-app"</span><br></pre></td></tr></table></figure><p>如果你想保持两个版本的应用都存在，那么我们也可以执行 pause 命令来暂停更新：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl rollout pause deploy my-app</span></span><br><span class="line">deployment.apps "my-app" paused</span><br></pre></td></tr></table></figure><p>这个时候我们再去循环访问我们的应用就可以看到偶尔会出现版本1的应用信息了。</p><p>如果新版本应用程序没问题了，也可以继续恢复更新：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl rollout resume deploy my-app</span></span><br><span class="line">deployment.apps "my-app" resumed</span><br></pre></td></tr></table></figure><p>最后，可以执行下面的命令来清空上面的资源对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl delete all -l app=my-app</span></span><br></pre></td></tr></table></figure><p>结论：</p><ul><li>版本在实例之间缓慢替换</li><li>rollout/rollback 可能需要一定时间</li><li>无法控制流量</li></ul><h3 id="蓝-绿-blue-green-最好用来验证-API-版本问题"><a href="#蓝-绿-blue-green-最好用来验证-API-版本问题" class="headerlink" title="蓝/绿(blue/green) - 最好用来验证 API 版本问题"></a>蓝/绿(blue/green) - 最好用来验证 API 版本问题</h3><p>蓝/绿发布是版本2 与版本1 一起发布，然后流量切换到版本2，也称为红/黑部署。蓝/绿发布与滚动更新不同，版本2(<code>绿</code>) 与版本1(<code>蓝</code>)一起部署，在测试新版本满足要求后，然后更新更新 Kubernetes 中扮演负载均衡器角色的 Service 对象，通过替换 label selector 中的版本标签来将流量发送到新版本，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://bxdc-static.oss-cn-beijing.aliyuncs.com/images/mEQW8i.jpg" alt="blug/green" title="">                </div>                <div class="image-caption">blug/green</div>            </figure>blug/green<br><br>下面是蓝绿发布策略下应用方法的示例图：<br><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://bxdc-static.oss-cn-beijing.aliyuncs.com/images/FxTxRP.jpg" alt="blue/green request" title="">                </div>                <div class="image-caption">blue/green request</div>            </figure>blue/green request<br><br>在 Kubernetes 中，我们可以用两种方法来实现蓝绿发布，通过单个 Service 对象或者 Ingress 控制器来实现蓝绿发布，实际操作都是类似的，都是通过 label 标签去控制。<br><br>实现蓝绿发布的关键点就在于 Service 对象中 label selector 标签的匹配方法，比如我们重新定义版本1 的资源清单文件 app-v1-single-svc.yaml，文件内容如下：<br><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="string">http</span></span><br><span class="line">  <span class="comment"># 注意这里我们匹配 app 和 version 标签，当要切换流量的时候，我们更新 version 标签的值，比如：v2.0.0</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">    version:</span> <span class="string">v1.0.0</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-app-v1</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">      version:</span> <span class="string">v1.0.0</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">        version:</span> <span class="string">v1.0.0</span></span><br><span class="line"><span class="attr">      annotations:</span></span><br><span class="line">        <span class="string">prometheus.io/scrape:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="string">prometheus.io/port:</span> <span class="string">"9101"</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">containersol/k8s-deployment-strategies</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">8086</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">VERSION</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">v1.0.0</span></span><br><span class="line"><span class="attr">        livenessProbe:</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/live</span></span><br><span class="line"><span class="attr">            port:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">          periodSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">        readinessProbe:</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/ready</span></span><br><span class="line"><span class="attr">            port:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>上面定义的资源对象中，最重要的就是 Service 中 label selector 的定义：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line"><span class="attr">  app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">  version:</span> <span class="string">v1.0.0</span></span><br></pre></td></tr></table></figure><p>版本2 的应用定义和以前一样，新建文件 app-v2-single-svc.yaml，文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-app-v2</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">      version:</span> <span class="string">v2.0.0</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">        version:</span> <span class="string">v2.0.0</span></span><br><span class="line"><span class="attr">      annotations:</span></span><br><span class="line">        <span class="string">prometheus.io/scrape:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="string">prometheus.io/port:</span> <span class="string">"9101"</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">containersol/k8s-deployment-strategies</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">8086</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">VERSION</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">v2.0.0</span></span><br><span class="line"><span class="attr">        livenessProbe:</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/live</span></span><br><span class="line"><span class="attr">            port:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">          periodSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">        readinessProbe:</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/ready</span></span><br><span class="line"><span class="attr">            port:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>然后按照下面的步骤来验证使用单个 Service 对象实现蓝/绿部署的策略：</p><ol><li>版本1 应用提供服务</li><li>部署版本2 应用</li><li>等到版本2 应用全部部署完成</li><li>切换入口流量从版本1 到版本2</li><li>关闭版本1 应用</li></ol><p>首先，部署版本1 应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f app-v1-single-svc.yaml</span></span><br><span class="line">service "my-app" created</span><br><span class="line">deployment.apps "my-app-v1" created</span><br></pre></td></tr></table></figure><p>测试版本1 应用是否部署成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -l app=my-app</span></span><br><span class="line">NAME                         READY     STATUS    RESTARTS   AGE</span><br><span class="line">my-app-v1-7b4874cd75-7xh6s   1/1       Running   0          41s</span><br><span class="line">my-app-v1-7b4874cd75-dmq8f   1/1       Running   0          41s</span><br><span class="line">my-app-v1-7b4874cd75-t64z7   1/1       Running   0          41s</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc -l app=my-app</span></span><br><span class="line">NAME      TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">my-app    NodePort   10.106.184.144   &lt;none&gt;        80:31539/TCP   50s</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:31539</span></span><br><span class="line">Host: my-app-v1-7b4874cd75-7xh6s, Version: v1.0.0</span><br></pre></td></tr></table></figure><p>同样，新开一个终端，执行如下命令观察 Pod 变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch kubectl get pod -l app=my-app</span></span><br></pre></td></tr></table></figure><p>然后部署版本2 应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f app-v2-single-svc.yaml</span></span><br><span class="line">deployment.apps "my-app-v2" created</span><br></pre></td></tr></table></figure><p>然后在上面 watch 终端中可以看到会多3个<code>my-app-v2</code>开头的 Pod，待这些 Pod 部署成功后，我们再去访问当前的应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">while</span> sleep 0.1; <span class="keyword">do</span> curl http://127.0.0.1:31539; <span class="keyword">done</span></span></span><br><span class="line">Host: my-app-v1-7b4874cd75-dmq8f, Version: v1.0.0</span><br><span class="line">Host: my-app-v1-7b4874cd75-dmq8f, Version: v1.0.0</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>我们会发现访问到的都是版本1 的应用，和我们刚刚部署的版本2 没有任何关系，这是因为我们 Service 对象中通过 label selector 匹配的是<code>version=v1.0.0</code>这个标签，我们可以通过修改 Service 对象的匹配标签，将流量路由到标签<code>version=v2.0.0</code>的 Pod 去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl patch service my-app -p <span class="string">'&#123;"spec":&#123;"selector":&#123;"version":"v2.0.0"&#125;&#125;&#125;'</span></span></span><br><span class="line">service "my-app" patched</span><br></pre></td></tr></table></figure><p>然后再去访问应用，可以发现现在都是版本2 的信息了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">while</span> sleep 0.1; <span class="keyword">do</span> curl http://127.0.0.1:31539; <span class="keyword">done</span></span></span><br><span class="line">Host: my-app-v2-f885c8d45-r5m6z, Version: v2.0.0</span><br><span class="line">Host: my-app-v2-f885c8d45-r5m6z, Version: v2.0.0</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>如果你需要回滚到版本1，同样只需要更改 Service 的匹配标签即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl patch service my-app -p <span class="string">'&#123;"spec":&#123;"selector":&#123;"version":"v1.0.0"&#125;&#125;&#125;'</span></span></span><br></pre></td></tr></table></figure><p>如果新版本已经完全符合我们的需求了，就可以删除版本1 的应用了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl delete deploy my-app-v1</span></span><br></pre></td></tr></table></figure><p>最后，同样，执行如下命令清理上述资源对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl delete all -l app=my-app</span></span><br></pre></td></tr></table></figure><p>结论：</p><ul><li>实时部署/回滚</li><li>避免版本问题，因为一次更改是整个应用的改变</li><li>需要两倍的资源</li><li>在发布到生产之前，应该对整个应用进行适当的测试</li></ul><h3 id="金丝雀-Canary-让部分用户参与测试"><a href="#金丝雀-Canary-让部分用户参与测试" class="headerlink" title="金丝雀(Canary) - 让部分用户参与测试"></a>金丝雀(Canary) - 让部分用户参与测试</h3><p>金丝雀部署是让部分用户访问到新版本应用，在 Kubernetes 中，可以使用两个具有相同 Pod 标签的 Deployment 来实现金丝雀部署。新版本的副本和旧版本的一起发布。在一段时间后如果没有检测到错误，则可以扩展新版本的副本数量并删除旧版本的应用。</p><p>如果需要按照具体的百分比来进行金丝雀发布，需要尽可能的启动多的 Pod 副本，这样计算流量百分比的时候才方便，比如，如果你想将 1% 的流量发送到版本 B，那么我们就需要有一个运行版本 B 的 Pod 和 99 个运行版本 A 的 Pod，当然如果你对具体的控制策略不在意的话也就无所谓了，如果你需要更精确的控制策略，建议使用服务网格（如 Istio），它们可以更好地控制流量。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://bxdc-static.oss-cn-beijing.aliyuncs.com/images/RvcM4f.jpg" alt="Canary" title="">                </div>                <div class="image-caption">Canary</div>            </figure>Canary<br><br>在下面的例子中，我们使用 Kubernetes 原生特性来实现一个穷人版的金丝雀发布，如果你想要对流量进行更加细粒度的控制，请使用豪华版本的 Istio。下面是金丝雀发布的应用请求示意图：<br><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://bxdc-static.oss-cn-beijing.aliyuncs.com/images/OclNv8.jpg" alt="canary requests" title="">                </div>                <div class="image-caption">canary requests</div>            </figure>canary requests<br><br>接下来我们按照下面的步骤来验证金丝雀策略：<br><br>1. 10个副本的版本1 应用提供服务<br>2. 版本2 应用部署1个副本（意味着小于10%的流量）<br>3. 等待足够的时间来确认版本2 应用足够稳定没有任何错误信息<br>4. 将版本2 应用扩容到10个副本<br>5. 等待所有实例完成<br>6. 关闭版本1 应用<br><br>首先，创建版本1 的应用资源清单，app-v1-canary.yaml，内容如下：<br><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-app-v1</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">      version:</span> <span class="string">v1.0.0</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">        version:</span> <span class="string">v1.0.0</span></span><br><span class="line"><span class="attr">      annotations:</span></span><br><span class="line">        <span class="string">prometheus.io/scrape:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="string">prometheus.io/port:</span> <span class="string">"9101"</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">containersol/k8s-deployment-strategies</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">8086</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">VERSION</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">v1.0.0</span></span><br><span class="line"><span class="attr">        livenessProbe:</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/live</span></span><br><span class="line"><span class="attr">            port:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">          periodSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">        readinessProbe:</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/ready</span></span><br><span class="line"><span class="attr">            port:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>其中核心的部分也是 Service 对象中的 label selector 标签，不在具有版本相关的标签了，然后定义版本2 的资源清单文件，app-v2-canary.yaml，文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-app-v2</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">      version:</span> <span class="string">v2.0.0</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">        version:</span> <span class="string">v2.0.0</span></span><br><span class="line"><span class="attr">      annotations:</span></span><br><span class="line">        <span class="string">prometheus.io/scrape:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="string">prometheus.io/port:</span> <span class="string">"9101"</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">containersol/k8s-deployment-strategies</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">8086</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">VERSION</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">v2.0.0</span></span><br><span class="line"><span class="attr">        livenessProbe:</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/live</span></span><br><span class="line"><span class="attr">            port:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">          periodSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">        readinessProbe:</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/ready</span></span><br><span class="line"><span class="attr">            port:</span> <span class="string">probe</span></span><br><span class="line"><span class="attr">          periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>版本1 和版本2 的 Pod 都具有一个共同的标签<code>app=my-app</code>，所以对应的 Service 会匹配两个版本的 Pod。</p><p>首先，部署版本1 应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f app-v1-canary.yaml</span></span><br><span class="line">service "my-app" created</span><br><span class="line">deployment.apps "my-app-v1" created</span><br></pre></td></tr></table></figure><p>然后测试版本1 应用是否正确部署了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc -l app=my-app</span></span><br><span class="line">NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">my-app        NodePort    10.105.133.213   &lt;none&gt;        80:30760/TCP   47s</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:30760</span></span><br><span class="line">Host: my-app-v1-7b4874cd75-tsh2s, Version: v1.0.0</span><br></pre></td></tr></table></figure><p>同样，新开一个终端，查看 Pod 的变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch kubectl get po</span></span><br></pre></td></tr></table></figure><p>然后部署版本2 应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f app-v2-canary.yaml</span></span><br><span class="line">deployment.apps "my-app-v2" created</span><br></pre></td></tr></table></figure><p>然后在 watch 终端页面可以看到多了一个 Pod，现在一共 11 个 Pod，其中只有1 个 Pod 运行新版本应用，然后同样可以循环访问该应用，查看是否会有版本2 的应用信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">while</span> sleep 0.1; <span class="keyword">do</span> curl http://127.0.0.1:30760; <span class="keyword">done</span></span></span><br><span class="line">Host: my-app-v1-7b4874cd75-bhxbp, Version: v1.0.0</span><br><span class="line">Host: my-app-v1-7b4874cd75-wmcqc, Version: v1.0.0</span><br><span class="line">Host: my-app-v1-7b4874cd75-tsh2s, Version: v1.0.0</span><br><span class="line">Host: my-app-v1-7b4874cd75-ml58j, Version: v1.0.0</span><br><span class="line">Host: my-app-v1-7b4874cd75-spsdv, Version: v1.0.0</span><br><span class="line">Host: my-app-v2-f885c8d45-mc2fx, Version: v2.0.0</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>正常情况下可以看到大部分都是返回的版本1 的应用信息，偶尔会出现版本2 的应用信息，这就证明我们的金丝雀发布成功了，待确认了版本2 的这个应用没有任何问题后，可以将版本2 应用扩容到10 个副本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl scale --replicas=10 deploy my-app-v2</span></span><br><span class="line">deployment.extensions "my-app-v2" scaled</span><br></pre></td></tr></table></figure><p>其实这个时候访问应用的话新版本和旧版本的流量分配是1:1了，确认了版本2 正常后，就可以删除版本1 的应用了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl delete deploy my-app-v1</span></span><br><span class="line">deployment.extensions "my-app-v1" deleted</span><br></pre></td></tr></table></figure><p>最终留下的是 10 个新版本的 Pod 了，到这里我们的整个金丝雀发布就完成了。</p><p>同样，最后，执行下面的命令删除上面的资源对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl delete all -l app=my-app</span></span><br></pre></td></tr></table></figure><p>结论：</p><ul><li>部分用户获取新版本</li><li>方便错误和性能监控</li><li>快速回滚</li><li>发布较慢</li><li>流量精准控制很浪费（99％A / 1％B = 99 Pod A，1 Pod B）</li></ul><blockquote><p>如果你对新功能的发布没有信心，建议使用金丝雀发布的策略。</p></blockquote><h3 id="A-B测试-A-B-testing-最适合部分用户的功能测试"><a href="#A-B测试-A-B-testing-最适合部分用户的功能测试" class="headerlink" title="A/B测试(A/B testing) - 最适合部分用户的功能测试"></a>A/B测试(A/B testing) - 最适合部分用户的功能测试</h3><p>A/B 测试实际上是一种基于统计信息而非部署策略来制定业务决策的技术，与业务结合非常紧密。但是它们也是相关的，也可以使用金丝雀发布来实现。</p><p>除了基于权重在版本之间进行流量控制之外，A/B 测试还可以基于一些其他参数（比如 Cookie、User Agent、地区等等）来精确定位给定的用户群，该技术广泛用于测试一些功能特性的效果，然后按照效果来进行确定。</p><blockquote><p>我们经常可以在<code>今日头条</code>的客户端中就会发现有大量的 A/B 测试，同一个地区的用户看到的客户端有很大不同。</p></blockquote><p>要使用这些细粒度的控制，仍然还是建议使用 Istio，可以根据权重或 HTTP 头等来动态请求路由控制流量转发。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://bxdc-static.oss-cn-beijing.aliyuncs.com/images/b4qVNZ.jpg" alt="ab test" title="">                </div>                <div class="image-caption">ab test</div>            </figure>ab test<br><br>下面是使用 Istio 进行规则设置的示例，因为 Istio 还不太稳定，以下示例规则将来可能会更改：<br><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">route:</span></span><br><span class="line"><span class="attr">- tags:</span></span><br><span class="line"><span class="attr">  version:</span> <span class="string">v1.0.0</span></span><br><span class="line"><span class="attr">  weight:</span> <span class="number">90</span></span><br><span class="line"><span class="attr">- tags:</span></span><br><span class="line"><span class="attr">  version:</span> <span class="string">v2.0.0</span></span><br><span class="line"><span class="attr">  weight:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>关于在 Istio 中具体如何做 A/B 测试，我们这里就不再详细介绍了，我们在<code>istio-book</code>文档中有相关的介绍。</p><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://bxdc-static.oss-cn-beijing.aliyuncs.com/images/2lK8wZ.jpg" alt="ab test request" title="">                </div>                <div class="image-caption">ab test request</div>            </figure>ab test request</p><p>结论：</p><ul><li>几个版本并行运行</li><li>完全控制流量分配</li><li>特定的一个访问错误难以排查，需要分布式跟踪</li><li>Kubernetes 没有直接的支持，需要其他额外的工具</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>发布应用有许多种方法，当发布到开发/测试环境的时候，<code>重建</code>或者<code>滚动更新</code>通常是一个不错的选择。在生产环境，<code>滚动更新</code>或者<code>蓝绿发布</code>比较合适，但是新版本的提前测试是非常有必要的。如果你对新版本的应用不是很有信心的话，那应该使用<code>金丝雀</code>发布，将用户的影响降到最低。最后，如果你的公司需要在特定的用户群体中进行新功能的测试，例如，移动端用户请求路由到版本 A，桌面端用户请求路由到版本 B，那么你就看使用<code>A/B 测试</code>，通过使用 Kubernetes 服务网关的配置，可以根据某些请求参数来确定用户应路由的服务。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://container-solutions.com/kubernetes-deployment-strategies/" target="_blank" rel="noopener"><a href="https://container-solutions.com/kubernetes-deployment-strategies/" target="_blank" rel="noopener">https://container-solutions.com/kubernetes-deployment-strategies/</a></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;code&gt;Kubernetes&lt;/code&gt;中有几种不同的方式发布应用，所以为了让应用在升级期间依然平稳提供服务，选择一个正确的发布策略就非常重要了。&lt;/p&gt;
&lt;p&gt;选择正确的部署策略是要依赖于我们的业务需求的，下面我们列出了一些可能会使用到的策略：&lt;/p&gt;
&lt;ul&gt;

      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes Deployment</title>
    <link href="https://yo42.github.io/2019/04/25/Kubernetes-Deployment/"/>
    <id>https://yo42.github.io/2019/04/25/Kubernetes-Deployment/</id>
    <published>2019-04-25T10:29:40.722Z</published>
    <updated>2019-04-25T10:29:54.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/l
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 服务发现&amp;负载均衡</title>
    <link href="https://yo42.github.io/2019/04/25/Kubernetes-%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://yo42.github.io/2019/04/25/Kubernetes-服务暴露-负载均衡/</id>
    <published>2019-04-25T10:26:16.482Z</published>
    <updated>2019-04-26T13:24:51.174Z</updated>
    
    <content type="html"><![CDATA[<p>本文档记录，k8s如何暴露公网服务以及负载均衡</p><p>主要涉及两个知识点：k8s service、k8s ingress controller </p><p>对比传统单体垂直的架构，可以使用k8s service、k8s ingress controller 进行替代HAproxy+Nginx</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="edu后端架构交互时序图.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="K8s-Service"><a href="#K8s-Service" class="headerlink" title="K8s Service"></a>K8s Service</h2><p>基本每次创建k8s pod最好都提前定义好service对象，其实service的概念可以同等于CMDB中的服务组的概念。</p><p>直接通过Pod的IP地址+端口可以访问到容器应用，但是Pod的IP是动态的，当发生故障时k8s会重新调度，这时候Service服务自发现的作用就体现出来了。</p><p>其实这个概念和微服务非常类似。一个<code>Serivce</code>下面包含的<code>Pod</code>集合一般是由<code>Label Selector</code>来决定的。</p><p>要想外部可以访问创建的应用，就使用service吧。</p><p>K8S暴露服务的方法有3种：</p><ul><li>ClusterIP：集群内可访问，但外部不可访问</li><li>NodePort：通过NodeIP:NodePort方式可以在集群内访问，结合EIP或者云服务VPC负载均衡也可在集群外访问，但开放NodePort一方面不安全，另一方面随着应用的增多不方便管理</li><li>LoadBalancer：某些云服务提供商会直接提供LoadBalancer模式，将服务对接到负载均衡，其原理是基于kubernetes的controller做二次开发，并集成到K8S集群，使得集群可以与云服务SDK交互</li></ul><p>我们也了解到Pod的生命是有限的，死亡过后不会复活了。我们后面学习到的RC和Deployment可以用来动态的创建和销毁Pod。尽管每个Pod都有自己的IP地址，但是如果Pod重新启动了的话那么他的IP很有可能也就变化了。这就会带来一个问题：比如我们有一些后端的Pod的集合为集群中的其他前端的Pod集合提供API服务，如果我们在前端的Pod中把所有的这些后端的Pod的地址都写死，然后去某种方式去访问其中一个Pod的服务，这样看上去是可以工作的，对吧？但是如果这个Pod挂掉了，然后重新启动起来了，是不是IP地址非常有可能就变了，这个时候前端就极大可能访问不到后端的服务了。</p><p>遇到这样的问题该怎么解决呢？在没有使用Kubernetes之前，我相信可能很多同学都遇到过这样的问题，不一定是IP变化的问题，比如我们在部署一个WEB服务的时候，前端一般部署一个Nginx作为服务的入口，然后Nginx后面肯定就是挂载的这个服务的大量后端，很早以前我们可能是去手动更改Nginx配置中的upstream选项，来动态改变提供服务的数量，到后面出现了一些服务发现的工具，比如Consul、ZooKeeper还有我们熟悉的etcd等工具，有了这些工具过后我们就可以只需要把我们的服务注册到这些服务发现中心去就可以，然后让这些工具动态的去更新Nginx的配置就可以了，我们完全不用去手工的操作了。</p><p>在k8s体系中”有三种IP”</p><ul><li>Node IP： Node节点的IP</li><li>Pod IP：Pod的IP</li><li>Cluster IP：service的IP</li></ul><p>k8s 提供两种负载分发策略，RoundRobin、SessionAffinity(默认是RoundRobin)</p><h3 id="集群外部访问pod或service"><a href="#集群外部访问pod或service" class="headerlink" title="集群外部访问pod或service"></a>集群外部访问pod或service</h3><h4 id="将容器应用端口映射到物理机"><a href="#将容器应用端口映射到物理机" class="headerlink" title="将容器应用端口映射到物理机"></a>将容器应用端口映射到物理机</h4><ul><li>通过设置容器级别的hostport</li><li>设置pod级别的HostNetwork=true</li></ul><h4 id="将Service的端口映射到物理机-type-NodePort"><a href="#将Service的端口映射到物理机-type-NodePort" class="headerlink" title="将Service的端口映射到物理机(type=NodePort)"></a>将Service的端口映射到物理机(type=NodePort)</h4><p>Service分类：</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">ClusterIP</td><td style="text-align:left">只在集群内部可达的私网地址，集群外部无法访问</td></tr><tr><td style="text-align:left">NodePort</td><td style="text-align:left">通过节点端口映射使得集群外部可达，是在ClusterIP基础上添加一层节点端口映射，访问路径：集群外客户端–&gt;节点ip:port–&gt;ClusterIP:port–&gt;PodIP:port</td></tr><tr><td style="text-align:left">LoadBalancer</td><td style="text-align:left">如果客户端只访问一个节点，会对该节点造成很大压力，一般在NodePort之前加入负载均衡，加入负载均衡器有两种方式：一是使用公有云的LBaaS，二是自己搭建负载均衡器</td></tr><tr><td style="text-align:left">ExternalName</td><td style="text-align:left">当Pod客户端想访问集群之外的服务时，使用前几种类型Service是无法绕过集群直接访问外部服务的，使用ExternalName类型的主机名或域名映射方式可以和集群外通信</td></tr><tr><td style="text-align:left">HeadLess</td><td style="text-align:left">特殊类型Service(无头服务)，直接把服务名称映射到Pod的Ip上</td></tr></tbody></table><p>默认创建的类型是：ClusterIP</p><p>kubernetes网络分为三类：node network、pod network、cluster network，前两种是真实存在的，而cluster network是虚拟的，仅用于Service资源。</p><h3 id="发布服务-——-服务类型"><a href="#发布服务-——-服务类型" class="headerlink" title="发布服务 —— 服务类型"></a>发布服务 —— 服务类型</h3><p>对一些应用（如 Frontend）的某些部分，可能希望通过外部（Kubernetes 集群外部）IP 地址暴露 Service。</p><p>Kubernetes <code>ServiceTypes</code> 允许指定一个需要的类型的 Service，默认是 <code>ClusterIP</code> 类型。</p><p><code>Type</code> 的取值以及行为如下：</p><ul><li><code>ClusterIP</code>：通过集群的内部 IP 暴露服务，选择该值，服务只能够在集群内部可以访问，这也是默认的 <code>ServiceType</code>。</li><li><code>NodePort</code>：通过每个 Node 上的 IP 和静态端口（<code>NodePort</code>）暴露服务。<code>NodePort</code> 服务会路由到 <code>ClusterIP</code> 服务，这个 <code>ClusterIP</code> 服务会自动创建。通过请求 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>，可以从集群的外部访问一个 <code>NodePort</code> 服务。</li><li><code>LoadBalancer</code>：使用云提供商的负载均衡器，可以向外部暴露服务。外部的负载均衡器可以路由到 <code>NodePort</code> 服务和 <code>ClusterIP</code> 服务。</li><li><code>ExternalName</code>：通过返回 <code>CNAME</code> 和它的值，可以将服务映射到 <code>externalName</code> 字段的内容（例如， <code>foo.bar.example.com</code>）。 没有任何类型代理被创建，这只有 Kubernetes 1.7 或更高版本的 <code>kube-dns</code> 才支持。</li></ul><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>Kubernetes 支持2种基本的服务发现模式 —— 环境变量和 DNS。</p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>当 <code>Pod</code> 运行在 <code>Node</code> 上，kubelet 会为每个活跃的 <code>Service</code> 添加一组环境变量。 它同时支持 <a href="https://docs.docker.com/userguide/dockerlinks/" target="_blank" rel="noopener">Docker links 兼容</a> 变量（查看 makeLinkVariables）、简单的 <code>{SVCNAME}_SERVICE_HOST</code> 和 <code>{SVCNAME}_SERVICE_PORT</code> 变量，这里 <code>Service</code> 的名称需大写，横线被转换成下划线。</p><p>举个例子，一个名称为 <code>&quot;redis-master&quot;</code> 的 Service 暴露了 TCP 端口 6379，同时给它分配了 Cluster IP 地址 10.0.0.11，这个 Service 生成了如下环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REDIS_MASTER_SERVICE_HOST=10.0.0.11</span><br><span class="line">REDIS_MASTER_SERVICE_PORT=6379</span><br><span class="line">REDIS_MASTER_PORT=tcp://10.0.0.11:6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP=tcp://10.0.0.11:6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_PROTO=tcp</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_PORT=6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_ADDR=10.0.0.11</span><br></pre></td></tr></table></figure><p><em>这意味着需要有顺序的要求</em> —— <code>Pod</code> 想要访问的任何 <code>Service</code> 必须在 <code>Pod</code> 自己之前被创建，否则这些环境变量就不会被赋值。DNS 并没有这个限制</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>一个可选（尽管强烈推荐）<a href="http://releases.k8s.io/master/cluster/addons/README.md" target="_blank" rel="noopener">集群插件</a> 是 DNS 服务器。 DNS 服务器监视着创建新 <code>Service</code> 的 Kubernetes API，从而为每一个 <code>Service</code> 创建一组 DNS 记录。 如果整个集群的 DNS 一直被启用，那么所有的 <code>Pod</code>应该能够自动对 <code>Service</code> 进行名称解析。</p><p>例如，有一个名称为 <code>&quot;my-service&quot;</code> 的 <code>Service</code>，它在 Kubernetes 集群中名为 <code>&quot;my-ns&quot;</code> 的 <code>Namespace</code> 中，为 <code>&quot;my-service.my-ns&quot;</code> 创建了一条 DNS 记录。 在名称为 <code>&quot;my-ns&quot;</code> 的 <code>Namespace</code>中的 <code>Pod</code> 应该能够简单地通过名称查询找到 <code>&quot;my-service&quot;</code>。 在另一个 <code>Namespace</code> 中的 <code>Pod</code> 必须限定名称为 <code>&quot;my-service.my-ns&quot;</code>。 这些名称查询的结果是 Cluster IP。</p><p>Kubernetes 也支持对端口名称的 DNS SRV（Service）记录。 如果名称为 <code>&quot;my-service.my-ns&quot;</code> 的 <code>Service</code> 有一个名为 <code>&quot;http&quot;</code> 的 <code>TCP</code> 端口，可以对 <code>&quot;_http._tcp.my-service.my-ns&quot;</code> 执行 DNS SRV 查询，得到 <code>&quot;http&quot;</code> 的端口号。</p><p>Kubernetes DNS 服务器是唯一的一种能够访问 <code>ExternalName</code> 类型的 Service 的方式。 更多信息可以查看 <a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="noopener">DNS Pod 和 Service</a>。</p><h4 id="创建ClusterIP类型的Service资源"><a href="#创建ClusterIP类型的Service资源" class="headerlink" title="创建ClusterIP类型的Service资源"></a>创建ClusterIP类型的Service资源</h4><p>创建ClusterIP类型的Service资源配置文件service-clusterIP-demo.yml，这个Service资源关联使用Deployment创建的3个Pod，内容如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------------- Deployment资源 ----------------------</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-dm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是ReplicaSet的spec</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">nginx-pod</span></span><br><span class="line">      <span class="comment"># 注意：这里标签一定要包括上面自定义的selector标签</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        tier:</span> <span class="string">frontend</span></span><br><span class="line">    <span class="comment"># 下面就是pod的spec</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.15.2</span></span><br><span class="line"><span class="attr">        imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 资源定义分割符</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------- Service资源 ----------------------</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-svc</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 这里选择器要关联到哪些Pod资源</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nginx-ports</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看select是否匹配</span></span><br><span class="line">kubectl get deployments -o wide</span><br><span class="line">kubectl get pod --show-labels -o wide</span><br><span class="line">kubectl get service -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否关联成功，从获取service中得到虚拟ip地址10.106.176.161，</span></span><br><span class="line">curl 10.106.176.161</span><br><span class="line"></span><br><span class="line"><span class="comment"># service资源内置负载均衡器，每次访问都会随机访问到3个nginx服务中的一个。</span></span><br></pre></td></tr></table></figure><h4 id="创建-NodePort类型的Service资源"><a href="#创建-NodePort类型的Service资源" class="headerlink" title="创建 NodePort类型的Service资源"></a>创建 NodePort类型的Service资源</h4><p>NodePort类型是ClusterIp类型的增强版，是外部网络打通集群边界的一种方式。客户端访问流程：集群外的客户端 –&gt; NodeIP:NodePort –&gt; ClusterIP:servicePort –&gt; PortIP:containerPort。</p><p>创建NodePort类型的Service资源配置文件service-notePort-demo.yml，这个Service资源关联使用Deployment创建的3个Pod，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-svc-np</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 这里选择器要关联到哪些Pod资源</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nginx-ports</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="comment"># 确保节点端口没被使用过，也可不指定，让系统分配随机端口</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">30080</span></span><br></pre></td></tr></table></figure><p>测试在集群外部浏览器 http://&lt;集群节点ip&gt;:30080 是否可以访问。</p><h1 id="集群外部访问服务"><a href="#集群外部访问服务" class="headerlink" title="集群外部访问服务"></a>集群外部访问服务</h1><p>Service 的 ClusterIP 是 Kubernetes 内部的虚拟 IP 地址，无法直接从外部直接访问。但如果需要从外部访问这些服务该怎么办呢，有多种方法</p><ul><li>使用 NodePort 服务在每台机器上绑定一个端口，这样就可以通过 <code>&lt;NodeIP&gt;:NodePort</code> 来访问该服务。</li><li>使用 LoadBalancer 服务借助 Cloud Provider 创建一个外部的负载均衡器，并将请求转发到 <code>&lt;NodeIP&gt;:NodePort</code>。该方法仅适用于运行在云平台之中的 Kubernetes 集群。对于物理机部署的集群，可以使用 <a href="https://github.com/google/metallb" target="_blank" rel="noopener">MetalLB</a> 实现类似的功能。</li><li>使用 Ingress Controller 在 Service 之上创建 L7 负载均衡并对外开放。</li></ul><p>​    </p><h2 id="K8s-Ingress-Controller"><a href="#K8s-Ingress-Controller" class="headerlink" title="K8s Ingress Controller"></a>K8s Ingress Controller</h2><p>Service属于四层网络模型，是在网络协议TCP或UDP之上，而http或https属于七层网络模型，无法使用Service来解析七层的http或https，为了解决这个问题，在节点运行一个代理服务的Pod，这个Pod里的容器共享宿主机网络(host network)，外部可以直接访问，并且运行属于七层网络模型代理服务(Nginx、Traefik、Envoy)，所有的客户端的请求都先经过代理服务的Pod，代理服务Pod把请求转发给其他Pod，而且各个Pod之间是同一个网段，可以直接通信。为了解决代理服务Pod单点问题，使用DaemonSet类型的Pod控制器，DaemonSet控制的Pod会在每个node节点运行一个代理服务Pod，如果集群的节点很多的话，选择3个节点专门用来运行服务代理即可，不必每个节点都运行代理服务。</p><p>这种代理服务的Pod属于ingress controller，ingress controller是独立于集群master中manager controller。而ingress是集群的一种特殊资源，定义ingress资源时需要指明ingress controller的前端是虚拟主机或url映射。集群中运行很多组的pod(例如：用户、电商、社交、交易、物流等)，ingress controller怎么知道哪些请求是指向哪组Pod？可以使用虚拟主机或url映射(/usr/、/shop/等)，因为Pod是有生命周期的，Pod的Ip地址有可能随时改变，ingress controller经过url映射的Pod就保证存在呢？解决方法是借助headless ClusterIp类型的Service资源，Service不是用来代理，只用来对Pod进行分组，ingress实时监控Service中Pod的ip地址是否变化，如果有变化，ingress实时获取到变化后Pod的ip信息，然后注入到ingress controller的配置文件中，并触发ingress controller中容器进程重载配置文件。</p><p>而ingress controller目前有几种：</p><ul><li>k8s社区提供的ingress</li><li>nginx社区提供的ingress</li><li>Traefik</li><li>…</li></ul><p>k8s-nginx-ingress 、nginxinc-ingress两者之间的区别</p><p><a href="https://github.com/nginxinc/kubernetes-ingress/blob/master/docs/nginx-ingress-controllers.md" target="_blank" rel="noopener">https://github.com/nginxinc/kubernetes-ingress/blob/master/docs/nginx-ingress-controllers.md</a></p><h3 id="Ingress-架构图"><a href="#Ingress-架构图" class="headerlink" title="Ingress 架构图"></a>Ingress 架构图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="HTTP-Ingress.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="aliyun-ingress.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="NGINX-Ingress-Controller-4-services.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Ingress-Nginx实现"><a href="#Ingress-Nginx实现" class="headerlink" title="Ingress-Nginx实现"></a>Ingress-Nginx实现</h3><p>参考文档:</p><p><a href="https://kubernetes.github.io/ingress-nginx/deploy/" target="_blank" rel="noopener">https://kubernetes.github.io/ingress-nginx/deploy/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f /etc/ansible/manifests/ingress/nginx-ingress/nginx-ingress.yaml <span class="comment"># 创建ingress</span></span><br><span class="line">kubectl create -f /etc/ansible/manifests/ingress/nginx-ingress/nginx-ingress-svc.yaml <span class="comment"># 创建ingress-svc</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看ingress-nginx各类资源列表</span></span><br><span class="line">kubectl get ns | grep ingress-nginx</span><br><span class="line">kubectl get cm -n ingress-nginx</span><br><span class="line">kubectl get deployment -n ingress-nginx</span><br><span class="line">kubectl get pod -n ingress-nginx</span><br></pre></td></tr></table></figure><h4 id="添加外网接入的service资源"><a href="#添加外网接入的service资源" class="headerlink" title="添加外网接入的service资源"></a>添加外网接入的service资源</h4><p>在本地测试为了接入集群外的请求，需要另外创建一个NodePort类型service做转发，如果是在公有云部署的集群，建议使用LoadBalancer类型service，参考<a href="https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/provider/cloud-generic.yaml" target="_blank" rel="noopener">service</a>。</p><p>创建NodePort类型的service资源配置文件ingress-nginx-serivce.yml，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">YAMLapiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="string">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="string">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line">    <span class="string">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="string">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="comment"># 指定宿主机端口</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="number">30080</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">443</span></span><br><span class="line">      <span class="comment"># 指定宿主机端口</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="number">30443</span></span><br></pre></td></tr></table></figure><p>查看调度器nginx ingress controller是否工作正常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有从集群外进来的http使用30080，https使用30443</span></span><br><span class="line">curl mater:30080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果返回default backend - 404，说明调度器已经正常工作了，只是没有后端而已</span></span><br></pre></td></tr></table></figure><h4 id="ingress-nginx代理http示例"><a href="#ingress-nginx代理http示例" class="headerlink" title="ingress nginx代理http示例"></a>ingress nginx代理http示例</h4><p>开始部署app，创建headless类型的service资源和Deployment资源配置文件myapp-service-deployment.yml，其中service资源只用来对Deployment的Pod进行分组的，获取到Pod的ip给ingress资源使用，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">YAMLapiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myapp-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">  clusterIP:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myapp-dm</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">ikubernetes/myapp:v3</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>创建ingress资源配置文件http-myapp-ingress.yml，ingress会监听service服务myapp-svc，一旦发现myapp-svc发生改变，ingress会从myapp-svc获取最新的Pod信息，把最新配置信息注入到nginx配置信息。内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">YAMLapiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="comment"># 声明使用类型：nginx、traefik、envoy，让ingress controller匹配对应的规则</span></span><br><span class="line">    <span class="string">kubernetes.io/ingress.class:</span> <span class="string">"nginx"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line">  <span class="comment"># 这里使用虚拟主机，也可以使用url映射</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">demo.myapp.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">myapp-svc</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>测试ingress是否能够动态注入nginx.conf，并触发nginx重载配置信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BASH<span class="comment"># 获取ingress nginx的pod名称</span></span><br><span class="line">kubectl get pod -n ingress-nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it -n ingress-nginx nginx-ingress-controller-6bd7c597cb-tf7gx -- /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看nginx配置是否包含虚拟主机demo.myapp.com配置信息，Deployment类型资源myapp-dm下的pod的ip列表是否也存在</span></span><br><span class="line">cat nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果后端的Pod挂掉了，Pod的ip地址变化会被ingress通过service检测到，ingress把变化的信息重新注入到nginx配置文件中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在节点宿主机添加测试域名demo.myapp.com</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'192.168.8.90  demo.myapp.com'</span> &gt; /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在一个终端不断获取myapp名称，查看删除pod后获取的名称是否有更新</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> curl demo.myapp.com:30080/hostname.html; sleep 1;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取pod</span></span><br><span class="line">kubectl get pod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除两个pod</span></span><br><span class="line">kubectl delete pod myapp-dm-59f7c855f7-5tmhw myapp-dm-59f7c855f7-5v6zw</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从结果上看，pod后获取的名称是更新的，说明ingress能把最新pod的信息动态注入nginx配置中，并触发nginx服务重载配置。</span></span><br></pre></td></tr></table></figure><p>创建成功后，Ingress会将信息注入到ingress-controller里面去，即：会自动转换为nginx的配置文件,可以看到pod内的nginx.conf文件确实被注入了myapp相关的信息。此时，在本地机器绑定myapp.test.com为两个node的ip，就可以在本地机器的浏览器中访问 <a href="http://myapp.test.com:30080/" target="_blank" rel="noopener">http://myapp.test.com:30080/</a> 网页了。</p><h3 id="配置阿里云SLB-添加nginx-ingress组-将带有nginx-ingress的node节点添加至阿里云SLB"><a href="#配置阿里云SLB-添加nginx-ingress组-将带有nginx-ingress的node节点添加至阿里云SLB" class="headerlink" title="配置阿里云SLB,添加nginx-ingress组,将带有nginx-ingress的node节点添加至阿里云SLB"></a>配置阿里云SLB,添加nginx-ingress组,将带有nginx-ingress的node节点添加至阿里云SLB</h3><h3 id="traefik-ingress实现"><a href="#traefik-ingress实现" class="headerlink" title="traefik ingress实现"></a>traefik ingress实现</h3><p>部署 traefik ingress-controller</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f /etc/ansible/manifests/ingress/traefik/traefik-ingress.yaml</span><br></pre></td></tr></table></figure><p>验证 traefik ingress-controller</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get deploy -n kube-system traefik-ingress-controller</span></span><br><span class="line">NAME                         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">traefik-ingress-controller   1         1         1            1           4m</span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl get svc -n kube-system traefik-ingress-service</span></span><br><span class="line">NAME                      TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)                       AGE</span><br><span class="line">traefik-ingress-service   NodePort   10.68.69.170   &lt;none&gt;        80:23456/TCP,8080:34815/TCP   4m</span><br><span class="line">可以看到traefik-ingress-service 服务端口80暴露的nodePort确实为23456</span><br></pre></td></tr></table></figure><p>测试ingress</p><p>首先创建测试用K8S应用，并且该应用服务不用nodePort暴露，而是用ingress方式让外部访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl run <span class="built_in">test</span>-hello --image=nginx --expose --port=80</span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># kubectl get deploy test-hello</span></span><br><span class="line">NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line"><span class="built_in">test</span>-hello   1         1         1            1           56s</span><br><span class="line"><span class="comment"># kubectl get svc test-hello</span></span><br><span class="line">NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line"><span class="built_in">test</span>-hello   ClusterIP   10.68.124.115   &lt;none&gt;        80/TCP    1m</span><br></pre></td></tr></table></figure><p>然后为这个应用创建 ingress对象</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="bullet">-f</span> <span class="string">/etc/ansible/manifests/ingress/test-hello.ing.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># test-hello.ing.yaml内容</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">test-hello</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">hello.test.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">test-hello</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>集群内部尝试访问: curl -H Host:hello.test.com 10.68.69.170(traefik-ingress-service的服务地址) 能够看到欢迎页面 Welcome to nginx!；</p><p>在集群外部尝试访问(假定集群一个NodeIP为 192.168.1.1): curl -H Host:hello.test.com 192.168.1.1:23456，也能够看到欢迎页面 Welcome to nginx!，说明ingress测试成功</p><h5 id="traefik-WEB-管理页面"><a href="#traefik-WEB-管理页面" class="headerlink" title="traefik WEB 管理页面"></a>traefik WEB 管理页面</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># traefik-ui.ing.yaml内容</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik-web-ui</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">traefik-ui.test.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">traefik-ingress-service</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.qikqiak.com/post/use-service-in-k8s/" target="_blank" rel="noopener"><a href="https://www.qikqiak.com/post/use-service-in-k8s/" target="_blank" rel="noopener">https://www.qikqiak.com/post/use-service-in-k8s/</a></a></li><li><a href="https://zhuyasen.com/post/k8s.html#toc_28" target="_blank" rel="noopener"><a href="https://zhuyasen.com/post/k8s.html#toc_28" target="_blank" rel="noopener">https://zhuyasen.com/post/k8s.html#toc_28</a></a></li><li><a href="https://jimmysong.io/kubernetes-handbook/concepts/service.html" target="_blank" rel="noopener"><a href="https://jimmysong.io/kubernetes-handbook/concepts/service.html" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/concepts/service.html</a></a></li><li><a href="https://yq.aliyun.com/articles/603225" target="_blank" rel="noopener"><a href="https://yq.aliyun.com/articles/603225" target="_blank" rel="noopener">https://yq.aliyun.com/articles/603225</a></a></li><li><a href="https://yq.aliyun.com/articles/604570?spm=a2c4e.11153940.blogcont603225.37.2d83f94cpAHZAL" target="_blank" rel="noopener"><a href="https://yq.aliyun.com/articles/604570?spm=a2c4e.11153940.blogcont603225.37.2d83f94cpAHZAL" target="_blank" rel="noopener">https://yq.aliyun.com/articles/604570?spm=a2c4e.11153940.blogcont603225.37.2d83f94cpAHZAL</a></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文档记录，k8s如何暴露公网服务以及负载均衡&lt;/p&gt;
&lt;p&gt;主要涉及两个知识点：k8s service、k8s ingress controller &lt;/p&gt;
&lt;p&gt;对比传统单体垂直的架构，可以使用k8s service、k8s ingress controller 进行
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 实践&amp;基础概念总结</title>
    <link href="https://yo42.github.io/2019/04/24/Kubernetes-%E5%AE%9E%E8%B7%B5-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"/>
    <id>https://yo42.github.io/2019/04/24/Kubernetes-实践-基础概念总结/</id>
    <published>2019-04-24T07:33:07.611Z</published>
    <updated>2019-04-25T10:26:53.760Z</updated>
    
    <content type="html"><![CDATA[<p>本文档将对近期所学习到的k8s知识、概念进行简单的总结，并结合实践加以记录。</p><p>Kubernetes 是谷歌开源的容器集群管理系统，是 Google 多年大规模容器管理技术 Borg 的开源版本，主要功能包括：</p><ul><li>基于容器的应用部署、维护和滚动升级</li><li>负载均衡和服务发现</li><li>跨机器和跨地区的集群调度</li><li>自动伸缩</li><li>无状态服务和有状态服务</li><li>广泛的 Volume 支持</li><li>插件机制保证扩展性</li><li>….</li></ul><p>以上这些功能，几乎完美贴合一套运维架构体系。实现了运维的部署更新，动态扩容，这都交由k8s强大调度系统进行完成。</p><p>像以前单体的运维架构，无非就是：</p><p>提交代码仓库—&gt;交由CI/CD工具进行源码的编译和打包—&gt;将需要更新的应用包解压至服务器上—&gt;逐一停止业务应用—&gt;逐一启动—&gt;完成更新</p><p>以上种种步骤，取决于运维团队的自动化、规范化完善度到达何种程度。有的通过脚本进行管控，有的可能会有运维发布平台。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Docker化前后应用发布流程对比.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>目前，Kubernetes 是 DevOps 应用必须掌握的一个平台。如果要构建一套比较不错的devops 体系，那k8s是必不可少的。现在，提到容器第一个联想到的就是k8s，外加微服务时代的盛行，使用和学习k8s再适合不过了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="cloud-native-architecutre-mindnode.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><p>Kubernetes 主要由以下几个核心组件组成：</p><ul><li><p>etcd 保存了整个集群的状态；</p></li><li><p>apiserver 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制；</p></li><li><p>controller manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</p></li><li><p>scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上；</p></li><li><p>kubelet 负责维护容器的生命周期，同时也负责 Volume（CVI）和网络（CNI）的管理；</p></li><li><p>Container runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI）；</p></li><li><p>kube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡</p></li></ul><h2 id="Kubernetes-整体架构"><a href="#Kubernetes-整体架构" class="headerlink" title="Kubernetes 整体架构"></a>Kubernetes 整体架构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="k8s-cluster.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="核心组件-1"><a href="#核心组件-1" class="headerlink" title="核心组件"></a>核心组件</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="k8s核心组件.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><p>Kubernetes 多组件之间的通信原理为</p><ul><li>apiserver 负责 etcd 存储的所有操作，且只有 apiserver 才直接操作 etcd 集群</li><li>apiserver 对内（集群中的其他组件）和对外（用户）提供统一的 REST API，其他组件均通过 apiserver 进行通信<ul><li>controller manager、scheduler、kube-proxy 和 kubelet 等均通过 apiserver watch API 监测资源变化情况，并对资源作相应的操作</li><li>所有需要更新资源状态的操作均通过 apiserver 的 REST API 进行</li></ul></li><li>apiserver 也会直接调用 kubelet API（如 logs, exec, attach 等），默认不校验 kubelet 证书，但可以通过 <code>--kubelet-certificate-authority</code> 开启（而 GKE 通过 SSH 隧道保护它们之间的通信）</li></ul><p>比如典型的创建 Pod 的流程为</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LDAOok5ngY4pc1lEDes%2F-LM_rqip-tinVoiFZE0I%2F-LM_sEq_NuMALezRGMtG%2Fworkflow.png?generation=1537160054044113&alt=media" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li>用户通过 REST API 创建一个 Pod</li><li>apiserver 将其写入 etcd</li><li>scheduluer 检测到未绑定 Node 的 Pod，开始调度并更新 Pod 的 Node 绑定</li><li>kubelet 检测到有新的 Pod 调度过来，通过 container runtime 运行该 Pod</li><li>kubelet 通过 container runtime 取到 Pod 状态，并更新到 apiserver 中</li></ol><h4 id="C-S-架构"><a href="#C-S-架构" class="headerlink" title="C/S 架构"></a>C/S 架构</h4><p>从宏观上看，<strong>K8S 遵循 C/S 架构</strong>，可以用下面的图来表示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">                               +-------------+                              </span><br><span class="line">                               |             |                              </span><br><span class="line">                               |             |               +---------------+</span><br><span class="line">                               |             |       +-----&gt; |     Node 1    |</span><br><span class="line">                               | Kubernetes  |       |       +---------------+</span><br><span class="line">+-----------------+            |   Server    |       |                      </span><br><span class="line">|       CLI       |            |             |       |       +---------------+</span><br><span class="line">|    (Kubectl)    |-----------&gt;| ( Master )  |&lt;------+-----&gt; |     Node 2    |</span><br><span class="line">|                 |            |             |       |       +---------------+</span><br><span class="line">+-----------------+            |             |       |       </span><br><span class="line">                               |             |       |       +---------------+</span><br><span class="line">                               |             |       +-----&gt; |     Node 3    |</span><br><span class="line">                               |             |               +---------------+</span><br><span class="line">                               +-------------+</span><br></pre></td></tr></table></figure><h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><p><code>Master</code>是整个 <strong>K8S 集群的大脑</strong>，他有几个重要的功能：</p><ul><li><strong>接收</strong>：<strong>外部的请求</strong>和集群<strong>内部的通知反馈</strong></li><li><strong>发布</strong>：对集群整体的<strong>调度和管理</strong></li><li><strong>存储</strong>：存储<strong>集群</strong>所需持久化的<strong>状态信息</strong></li></ul><p><code>Master</code>主要包含以下几个<strong>重要的组成部分</strong>：</p><h5 id="1-Cluster-state-store"><a href="#1-Cluster-state-store" class="headerlink" title="1. Cluster state store"></a>1. Cluster state store</h5><p>用来<strong>存储集群所有需要持久化的状态</strong>，并且<strong>提供</strong><code>watch</code><strong>的功能支持</strong>，可以快速的<strong>通知各组件的变更等操作</strong>。</p><p>目前 <strong>Kubernetes 的存储层选择是</strong><code>etcd</code>，所以一般情况下，我们直接<strong>以</strong><code>etcd</code><strong>来代表集群状态存储服务</strong>，即<strong>将所有状态存储到</strong><code>etcd</code><strong>实例中</strong>。</p><h5 id="2-API-Server"><a href="#2-API-Server" class="headerlink" title="2. API Server"></a>2. API Server</h5><p>这是<strong>整个集群的入口</strong>，类似于人体的感官，<strong>接收外部的信号和请求</strong>，并<strong>将相应的信息写入到</strong><code>etcd</code><strong>中</strong>。</p><p>为了<strong>保证安全</strong>，API Server 还<strong>提供了认证相关的功能</strong>，用于<strong>判断客户端是否有权限进行操作</strong>。API Server 支持多种认证方法，不过一般情况下，我们<strong>使用</strong><code>x509</code><strong>证书来进行认证</strong>。</p><blockquote><p><strong>API Server</strong> 的目标是成为一个<strong>极简的 Server</strong>，<strong>只提供</strong><code>REST</code><strong>操作</strong>，<strong>更新</strong><code>etcd</code>，并充当着<strong>集群的网关</strong>。至于<strong>其他的业务逻辑</strong>，则<strong>通过插件或者其他组件来实现</strong></p></blockquote><h5 id="3-Controller-Manager"><a href="#3-Controller-Manager" class="headerlink" title="3. Controller Manager"></a>3. Controller Manager</h5><p><strong>Controller Manager</strong> 大概是 K8S 集群中<strong>最繁忙的部分</strong>，它在后台<strong>运行着许多不同的控制器进程</strong>，用来<strong>调节集群的状态</strong>。</p><p>当<strong>集群的配置发生改变时</strong>，控制器就会<strong>朝着预期的状态开始工作</strong>。</p><h5 id="4-Scheduler"><a href="#4-Scheduler" class="headerlink" title="4. Scheduler"></a>4. Scheduler</h5><p><strong>Scheduler</strong> 是<strong>集群的调度器</strong>，它会<strong>持续关注集群中未被调度的 Pod</strong>，并根据资源可用性、节点亲和性或是其他一些限制条件，<strong>通过绑定的 API 将 Pod 调度/绑定到 Node 上</strong>。</p><blockquote><p>在这个过程中，<strong>调度程序</strong>一般<strong>只考虑调度开始时 Node 的状态</strong>，而<strong>不考虑在调度过程中 Node 的状态变化</strong></p></blockquote><h2 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a>节点（Node）</h2><p>K8s集群中的计算能力由Node提供，最初Node称为服务节点Minion，后来改名为Node。K8s集群中的Node也就等同于Mesos集群中的Slave节点，是所有Pod运行所在的工作主机，可以是物理机也可以是虚拟机。不论是物理机还是虚拟机，工作主机的统一特征是上面要运行kubelet管理节点上运行的容器。</p><h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>K8s有很多技术概念，同时对应很多API对象，最重要的也是最基础的是微服务Pod。Pod是在K8s集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。Pod对多容器的支持是K8s最基础的设计理念。比如你运行一个操作系统发行版的软件仓库，一个Nginx容器用来发布软件，另一个容器专门用来从源仓库做同步，这两个容器的镜像不太可能是一个团队开发的，但是他们一块儿工作才能提供一个微服务；这种情况下，不同的团队各自开发构建自己的容器镜像，在部署的时候组合成一个微服务对外提供服务。</p><p>Pod是K8s集群中所有业务类型的基础，可以看作运行在K8s集群中的小机器人，不同类型的业务就需要不同类型的小机器人去执行。目前K8s中的业务主要可以分为长期伺服型（long-running）、批处理型（batch）、节点后台支撑型（node-daemon）和有状态应用型（stateful application）；分别对应的小机器人控制器为Deployment、Job、DaemonSet和StatefulSet。</p><p>Pod分类：</p><ul><li>自主式Pod</li><li>由控制器管理的Pod，管理不同类型的Pod资源<ul><li>ReplicaSet(替代ReplicationController)</li><li>Deployment(只能管理无状态的应用)</li><li>StatefulSet(管理有状态的应用)</li><li>DaemonSet(在每一个node上运行一个副本)</li><li>Job(运行结束自动删除)</li><li>Ctonjob(周期性job)</li></ul></li></ul><p>其中DaemonSet、Job、Ctonjob是给特殊应用使用，另外Deployment还支持二级控制器HPA(HorizontalPodAutoscaler)，HPA控制器自动监控资源，当前服务能力不能满足时，自动扩展Pod，当Pod资源空闲时，自动回收资源，这些阈值由用户设置。</p><p>附上k8s各种对象详细表格:</p><p>Kubernetes主要模块概念：</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Cluster</td><td style="text-align:left">Cluster是指由Kubernetes使用一系列的物理机、虚拟机和其他基础资源来运行你的应用程序。</td></tr><tr><td style="text-align:left">Node</td><td style="text-align:left">一个node就是一个运行着Kubernetes的物理机或虚拟机，并且pod可以在其上面被调度。</td></tr><tr><td style="text-align:left">Pod</td><td style="text-align:left">一个pod对应一个由相关容器和卷组成的容器组。</td></tr><tr><td style="text-align:left">Label</td><td style="text-align:left">一个label是一个被附加到资源上的键/值对，例如附加到一个Pod上，为它传递一个用户自定的并且可识别的属性，Label还可以被应用来组织和选择子网中的资源。</td></tr><tr><td style="text-align:left">selector</td><td style="text-align:left">selector是一个通过匹配labels来定义资源之间关系得表达式，例如为一个负载均衡的service指定所目标Pod。</td></tr><tr><td style="text-align:left">Replication Controller</td><td style="text-align:left">replication controller 是为了保证一定数量被指定的Pod的复制品在任何时间都能正常工作，它不仅允许复制的系统易于扩展，还会处理当pod在机器在重启或发生故障的时候再次创建一个。</td></tr><tr><td style="text-align:left">Service</td><td style="text-align:left">一个service定义了访问pod的方式，就像单个固定的IP地址和与其相对应的DNS名之间的关系。</td></tr><tr><td style="text-align:left">Volume</td><td style="text-align:left">一个volume是一个目录，可能会被容器作为未见系统的一部分来访问。</td></tr><tr><td style="text-align:left">Kubernetes volume</td><td style="text-align:left">构建在Docker Volumes之上,并且支持添加和配置volume目录或者其他存储设备。</td></tr><tr><td style="text-align:left">Secret</td><td style="text-align:left">Secret 存储了敏感数据，例如能允许容器接收请求的权限令牌。</td></tr><tr><td style="text-align:left">Name</td><td style="text-align:left">用户为Kubernetes中资源定义的名字。</td></tr><tr><td style="text-align:left">Namespace</td><td style="text-align:left">Namespace 好比一个资源名字的前缀。它帮助不同的项目、团队或是客户可以共享cluster，例如防止相互独立的团队间出现命名冲突。</td></tr><tr><td style="text-align:left">Annotation</td><td style="text-align:left">相对于label来说可以容纳更大的键值对，它对我们来说可能是不可读的数据，只是为了存储不可识别的辅助数据，尤其是一些被工具或系统扩展用来操作的数据。</td></tr></tbody></table><h2 id="一些实际应用的经验"><a href="#一些实际应用的经验" class="headerlink" title="一些实际应用的经验"></a>一些实际应用的经验</h2><ul><li>在引用一个yaml文件时，请使用–record选项，带了这个选项之后，每次升级的时都会保存到部署的日志里面，这样就提供了回滚一个变更的能力。</li><li>部署大多数应用都需要配套一个service对象，如果需要外部访问需要映射NodePort类型</li><li>使用git管理k8s yml 可以方便回滚</li><li>….</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="使用k8s创建应用"><a href="#使用k8s创建应用" class="headerlink" title="使用k8s创建应用"></a>使用k8s创建应用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; nginx-ds.yml &lt;&lt;EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line"> name: nginx-ds</span><br><span class="line"> labels:</span><br><span class="line"> app: nginx-ds</span><br><span class="line">spec:</span><br><span class="line"> <span class="built_in">type</span>: NodePort</span><br><span class="line"> selector:</span><br><span class="line"> app: nginx-ds</span><br><span class="line"> ports:</span><br><span class="line"> - name: http</span><br><span class="line"> port: 80</span><br><span class="line"> targetPort: 80</span><br><span class="line">---</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line"> name: nginx-ds</span><br><span class="line"> labels:</span><br><span class="line"> addonmanager.kubernetes.io/mode: Reconcile</span><br><span class="line">spec:</span><br><span class="line"> template:</span><br><span class="line"> metadata:</span><br><span class="line"> labels:</span><br><span class="line"> app: nginx-ds</span><br><span class="line"> spec:</span><br><span class="line"> containers:</span><br><span class="line"> - name: my-nginx</span><br><span class="line"> image: nginx:1.7.9</span><br><span class="line"> ports:</span><br><span class="line"> - containerPort: 80</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">kubectl create -f nginx-ds.yml</span><br><span class="line">kubectl get pods -o wide|grep nginx-ds</span><br><span class="line">kubectl get svc -o wide|grep nginx-ds</span><br></pre></td></tr></table></figure><h3 id="访问service资源映射的nodeport"><a href="#访问service资源映射的nodeport" class="headerlink" title="访问service资源映射的nodeport"></a>访问service资源映射的nodeport</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl k8s-node01:22462</span><br></pre></td></tr></table></figure><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="业务架构.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://jimmysong.io/kubernetes-handbook/concepts/" target="_blank" rel="noopener"><a href="https://jimmysong.io/kubernetes-handbook/concepts/" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/concepts/</a></a></li><li><a href="https://kubernetes.feisky.xyz/he-xin-yuan-li/concepts" target="_blank" rel="noopener"><a href="https://kubernetes.feisky.xyz/he-xin-yuan-li/concepts" target="_blank" rel="noopener">https://kubernetes.feisky.xyz/he-xin-yuan-li/concepts</a></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文档将对近期所学习到的k8s知识、概念进行简单的总结，并结合实践加以记录。&lt;/p&gt;
&lt;p&gt;Kubernetes 是谷歌开源的容器集群管理系统，是 Google 多年大规模容器管理技术 Borg 的开源版本，主要功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于容器的应用部署、维护
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Git Hook实践</title>
    <link href="https://yo42.github.io/2019/04/23/%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8Git-Hook/"/>
    <id>https://yo42.github.io/2019/04/23/简单使用Git-Hook/</id>
    <published>2019-04-23T10:42:14.403Z</published>
    <updated>2019-04-24T07:33:55.577Z</updated>
    
    <content type="html"><![CDATA[<p>需求: 使用Git Hook进行web资源的更新</p><h3 id="Git-Hook-简介"><a href="#Git-Hook-简介" class="headerlink" title="Git Hook 简介"></a>Git Hook 简介</h3><p>一般的开发流程都是<code>git add</code>、<code>git commit</code>，<code>git push</code>，钩子呢就是你完成每一步Git给你的“回调”，举个例子假如你想让服务器每次上传完新的代码后更新网站，如果你没有钩子，你只能自己<code>ssh</code>登录上服务器，自己更新软件，一次两次还好，多了的话你会骂娘的，所以钩子是给我偷懒的脚手架，我们可以很轻松的写一些脚步帮我们完成一些重复的步骤</p><p>介绍玩钩子的作用，我们来介绍一下钩子的分类</p><p>我们知道Git核心是<code>commit</code>和<code>push</code>两个命令，一个对应客户端，一个对应服务端，所以钩子主要分客户端和服务端，由于Git步骤分的很细，所以每个大分类下面还有很多小分类，比如<code>pre-commit</code>，<code>post-commit</code>这些。</p><p>钩子的全部放在<code>.git/hooks</code>下面，在新建一个项目仓库的时候，Git已经在这个文件夹下给我们生成了很多个<code>.sample</code>后缀的钩子，这些钩子只要把<code>.sample</code>去掉就可以运行了，我们可以在这些<code>sample</code>上面修改完成我们自己的钩子</p><h3 id="客户端钩子"><a href="#客户端钩子" class="headerlink" title="客户端钩子"></a>客户端钩子</h3><ul><li>pre-commit: 执行<code>git commit</code>命令时触发，常用于检查代码风格</li><li>prepare-commit-msg: <code>commit message</code>编辑器呼起前<code>default commit message</code>创建后触发，常用于生成默认的<a href="https://conventionalcommits.org/" target="_blank" rel="noopener">标准化的提交说明</a></li><li>commit-msg: 开发者编写完并确认<code>commit message</code>后触发，常用于校验提交说明是否标准</li><li>post-commit: 整个<code>git commit</code>完成后触发，常用于邮件通知、提醒</li><li>applypatch-msg: 执行<code>git am</code>命令时触发，常用于检查命令提取出来的提交信息是否符合特定格式</li><li>pre-applypatch: <code>git am</code>提取出补丁并应用于当前分支后，准备提交前触发，常用于执行测试用例或检查缓冲区代码</li><li>post-applypatch: <code>git am</code>提交后触发，常用于通知、或补丁邮件回复（此钩子不能停止<code>git am</code>过程）</li><li>pre-rebase: 执行<code>git rebase</code>命令时触发</li><li>post-rewrite: 执行会替换<code>commit</code>的命令时触发，比如<code>git rebase</code>或<code>git commit --amend</code></li><li>post-checkout: 执行<code>git checkout</code>命令成功后触发，可用于生成特定文档，处理大二进制文件等</li><li>post-merge: 成功完成一次 <code>merge</code>行为后触发</li><li>pre-push: 执行<code>git push</code>命令时触发，可用于执行测试用例</li><li>pre-auto-gc: 执行垃圾回收前触发</li></ul><h3 id="服务端钩子"><a href="#服务端钩子" class="headerlink" title="服务端钩子"></a>服务端钩子</h3><ul><li>pre-receive: 当服务端收到一个push操作请求时触发，可用于检测push的内容</li><li>update: 与pre-receive相似，但当一次push想更新多个分支时，pre-receive只执行一次，而此钩子会为每一分支都执行一次</li><li>post-receive: 当整个push操作完成时触发，常用于服务侧同步、通知</li></ul><h3 id="配置git-hook触发，本地客户端更新push触发服务端自动拉取更新资源"><a href="#配置git-hook触发，本地客户端更新push触发服务端自动拉取更新资源" class="headerlink" title="配置git hook触发，本地客户端更新push触发服务端自动拉取更新资源"></a>配置git hook触发，本地客户端更新push触发服务端自动拉取更新资源</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -a  hooks/post-receive.sample hooks/post-receive</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat hooks/post-receive <span class="comment"># vi编辑</span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> GIT_DIR</span><br><span class="line">/usr/bin/sudo su - apps</span><br><span class="line">ssh  apps@10.4.0.173 <span class="string">"cd /data/lt1/app/qjj &amp;&amp; git pull origin master"</span></span><br></pre></td></tr></table></figure><h3 id="本地使用"><a href="#本地使用" class="headerlink" title="本地使用"></a>本地使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone xxxx</span><br></pre></td></tr></table></figure><h5 id="后续走git-流程进行推送-便实现自动更新。"><a href="#后续走git-流程进行推送-便实现自动更新。" class="headerlink" title="后续走git 流程进行推送,便实现自动更新。"></a>后续走git 流程进行推送,便实现自动更新。</h5><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="[https://github.com/geeeeeeeeek/git-recipes/wiki/5.4-Git-%E9%92%A9%E5%AD%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81](https://github.com/geeeeeeeeek/git-recipes/wiki/5.4-Git-钩子：自定义你的工作流"><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.4-Git-钩子：自定义你的工作流" target="_blank" rel="noopener">https://github.com/geeeeeeeeek/git-recipes/wiki/5.4-Git-%E9%92%A9%E5%AD%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81</a></a>)</li><li><a href="[http://blog.zhanglun.me/2017/11/25/%E5%B7%A7%E7%94%A8Git%E9%92%A9%E5%AD%90/](http://blog.zhanglun.me/2017/11/25/巧用Git钩子/"><a href="http://blog.zhanglun.me/2017/11/25/巧用Git钩子/" target="_blank" rel="noopener">http://blog.zhanglun.me/2017/11/25/%E5%B7%A7%E7%94%A8Git%E9%92%A9%E5%AD%90/</a></a>)</li><li><a href="https://imweb.io/topic/5b13aa38d4c96b9b1b4c4e9d" target="_blank" rel="noopener">https://imweb.io/topic/5b13aa38d4c96b9b1b4c4e9d</a></li><li><a href="https://www.jianshu.com/p/f9312b51e011" target="_blank" rel="noopener">https://www.jianshu.com/p/f9312b51e011</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;需求: 使用Git Hook进行web资源的更新&lt;/p&gt;
&lt;h3 id=&quot;Git-Hook-简介&quot;&gt;&lt;a href=&quot;#Git-Hook-简介&quot; class=&quot;headerlink&quot; title=&quot;Git Hook 简介&quot;&gt;&lt;/a&gt;Git Hook 简介&lt;/h3&gt;&lt;p&gt;一般
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>使用kubeasz搭建K8s集群</title>
    <link href="https://yo42.github.io/2019/02/14/%E4%BD%BF%E7%94%A8kubeasz%E6%90%AD%E5%BB%BAK8s%E9%9B%86%E7%BE%A4/"/>
    <id>https://yo42.github.io/2019/02/14/使用kubeasz搭建K8s集群/</id>
    <published>2019-02-14T02:41:01.167Z</published>
    <updated>2019-04-23T08:24:46.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="离线本地测试环境资源计划说明："><a href="#离线本地测试环境资源计划说明：" class="headerlink" title="离线本地测试环境资源计划说明："></a>离线本地测试环境资源计划说明：</h2><table><thead><tr><th>hostname</th><th>IP</th><th>配置</th><th>系统版本</th><th>角色</th></tr></thead><tbody><tr><td>aly8-hn1-k8s-master-001</td><td></td><td></td><td>Centos7.4</td><td>master节点&amp;etcd集群</td></tr><tr><td>aly8-hn1-k8s-master-002</td><td></td><td></td><td>Centos7.4</td><td>master节点&amp;etcd集群</td></tr><tr><td>aly8-hn1-k8s-master-003</td><td></td><td></td><td>Centos7.4</td><td>master节点&amp;etcd集群</td></tr><tr><td>aly8-hn1-ops-001</td><td></td><td></td><td>Centos7.4</td><td>ansible部署节点</td></tr><tr><td>Aly8-hn1-k8s-node-001</td><td></td><td></td><td>Centos7.4</td><td>node节点</td></tr></tbody></table><h3 id="各节点安装python"><a href="#各节点安装python" class="headerlink" title="各节点安装python"></a>各节点安装python</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 文档中脚本默认均以root用户执行</span><br><span class="line"># 安装 epel 源并更新</span><br><span class="line">yum install epel-release -y</span><br><span class="line">yum update</span><br><span class="line"># 安装python</span><br><span class="line">yum install python -y</span><br></pre></td></tr></table></figure><h3 id="在deploy节点安装及准备ansible"><a href="#在deploy节点安装及准备ansible" class="headerlink" title="在deploy节点安装及准备ansible"></a>在deploy节点安装及准备ansible</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install git python-pip -y</span><br><span class="line"># pip安装ansible(国内如果安装太慢可以直接用pip阿里云加速)</span><br><span class="line">pip install pip --upgrade -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com</span><br><span class="line">pip install --no-cache-dir ansible -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com</span><br><span class="line"># pip install pip --upgrade</span><br><span class="line"># pip install ansible</span><br></pre></td></tr></table></figure><h3 id="在deploy节点配置免密码登陆"><a href="#在deploy节点配置免密码登陆" class="headerlink" title="在deploy节点配置免密码登陆"></a>在deploy节点配置免密码登陆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 2048 # 回车 回车 回车</span><br><span class="line">ssh-copy-id $IPs # $IPs为所有节点地址包括自身，按照提示输入yes 和root密码</span><br></pre></td></tr></table></figure><h3 id="kubeasz配置"><a href="#kubeasz配置" class="headerlink" title="kubeasz配置"></a>kubeasz配置</h3><h4 id="下载源码解压到同样目录"><a href="#下载源码解压到同样目录" class="headerlink" title="下载源码解压到同样目录"></a>下载源码解压到同样目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/gjmzj/kubeasz.git</span><br><span class="line">mkdir -p /etc/ansible</span><br><span class="line">mv kubeasz/* /etc/ansible</span><br><span class="line">tar xf /root/k8sfile/k8s.1-13-2.tar.gz -C /etc/ansible/</span><br></pre></td></tr></table></figure><h4 id="配置集群参数"><a href="#配置集群参数" class="headerlink" title="配置集群参数"></a>配置集群参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/ansible</span><br><span class="line">cp example/hosts.m-masters.example hosts</span><br><span class="line">vim hosts                       # 根据实际情况修改此hosts文件</span><br></pre></td></tr></table></figure><p>Hosts配置文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"># 集群部署节点：一般为运行ansible 脚本的节点</span><br><span class="line"># 变量 NTP_ENABLED (=yes/no) 设置集群是否安装 chrony 时间同步</span><br><span class="line">[deploy]</span><br><span class="line">10.1.2.66 NTP_ENABLED=no</span><br><span class="line"></span><br><span class="line"># etcd集群请提供如下NODE_NAME，注意etcd集群必须是1,3,5,7...奇数个节点</span><br><span class="line">[etcd]</span><br><span class="line">10.1.2.30 NODE_NAME=etcd1</span><br><span class="line">10.1.2.1 NODE_NAME=etcd2</span><br><span class="line">10.1.2.2 NODE_NAME=etcd3</span><br><span class="line"></span><br><span class="line">[kube-master]</span><br><span class="line">10.1.2.30</span><br><span class="line">10.1.2.1</span><br><span class="line">10.1.2.2</span><br><span class="line"></span><br><span class="line"># 负载均衡(目前已支持多于2节点，一般2节点就够了) 安装 haproxy+keepalived</span><br><span class="line">[lb]</span><br><span class="line">10.1.2.30 LB_ROLE=master</span><br><span class="line">10.1.2.1 LB_ROLE=backup</span><br><span class="line"></span><br><span class="line">[kube-node]</span><br><span class="line">10.1.2.67</span><br><span class="line"></span><br><span class="line"># 参数 NEW_INSTALL：yes表示新建，no表示使用已有harbor服务器</span><br><span class="line"># 如果不使用域名，可以设置 HARBOR_DOMAIN=&quot;&quot;</span><br><span class="line">[harbor]</span><br><span class="line">#192.168.1.8 HARBOR_DOMAIN=&quot;harbor.yourdomain.com&quot; NEW_INSTALL=no</span><br><span class="line"></span><br><span class="line"># 预留组，后续添加master节点使用</span><br><span class="line">[new-master]</span><br><span class="line">#192.168.1.5</span><br><span class="line"></span><br><span class="line"># 预留组，后续添加node节点使用</span><br><span class="line">[new-node]</span><br><span class="line">#192.168.1.xx</span><br><span class="line"></span><br><span class="line">#【可选】外部负载均衡，用于自有环境负载转发 NodePort 暴露的服务等</span><br><span class="line">[ex-lb]</span><br><span class="line">#192.168.1.6 LB_ROLE=backup EX_VIP=10.1.2.150</span><br><span class="line">#192.168.1.7 LB_ROLE=master EX_VIP=10.1.2.150</span><br><span class="line"></span><br><span class="line">[all:vars]</span><br><span class="line"># ---------集群主要参数---------------</span><br><span class="line">#集群部署模式：allinone, single-master, multi-master</span><br><span class="line">DEPLOY_MODE=multi-master</span><br><span class="line"></span><br><span class="line">#集群主版本号，目前支持: v1.8, v1.9, v1.10，v1.11, v1.12, v1.13</span><br><span class="line">K8S_VER=&quot;v1.13&quot;</span><br><span class="line"></span><br><span class="line"># 集群 MASTER IP即 LB节点VIP地址，为区别与默认apiserver端口，设置VIP监听的服务端口8443</span><br><span class="line"># 公有云上请使用云负载均衡内网地址和监听端口</span><br><span class="line">MASTER_IP=&quot;10.1.2.166&quot;</span><br><span class="line">KUBE_APISERVER=&quot;https://&#123;&#123; MASTER_IP &#125;&#125;:8443&quot;</span><br><span class="line"></span><br><span class="line"># 集群网络插件，目前支持calico, flannel, kube-router, cilium</span><br><span class="line">CLUSTER_NETWORK=&quot;flannel&quot;</span><br><span class="line"></span><br><span class="line"># 服务网段 (Service CIDR），注意不要与内网已有网段冲突</span><br><span class="line">SERVICE_CIDR=&quot;10.68.0.0/16&quot;</span><br><span class="line"></span><br><span class="line"># POD 网段 (Cluster CIDR），注意不要与内网已有网段冲突</span><br><span class="line">CLUSTER_CIDR=&quot;172.20.0.0/16&quot;</span><br><span class="line"></span><br><span class="line"># 服务端口范围 (NodePort Range)</span><br><span class="line">NODE_PORT_RANGE=&quot;20000-40000&quot;</span><br><span class="line"></span><br><span class="line"># kubernetes 服务 IP (预分配，一般是 SERVICE_CIDR 中第一个IP)</span><br><span class="line">CLUSTER_KUBERNETES_SVC_IP=&quot;10.68.0.1&quot;</span><br><span class="line"></span><br><span class="line"># 集群 DNS 服务 IP (从 SERVICE_CIDR 中预分配)</span><br><span class="line">CLUSTER_DNS_SVC_IP=&quot;10.68.0.2&quot;</span><br><span class="line"></span><br><span class="line"># 集群 DNS 域名</span><br><span class="line">CLUSTER_DNS_DOMAIN=&quot;eduskscluster.local.&quot;</span><br><span class="line"></span><br><span class="line"># 集群basic auth 使用的用户名和密码</span><br><span class="line">BASIC_AUTH_USER=&quot;admin&quot;</span><br><span class="line">BASIC_AUTH_PASS=&quot;test1234&quot;</span><br><span class="line"></span><br><span class="line"># ---------附加参数--------------------</span><br><span class="line">#默认二进制文件目录</span><br><span class="line">bin_dir=&quot;/opt/kube/bin&quot;</span><br><span class="line"></span><br><span class="line">#证书目录</span><br><span class="line">ca_dir=&quot;/etc/kubernetes/ssl&quot;</span><br><span class="line"></span><br><span class="line">#部署目录，即 ansible 工作目录，建议不要修改</span><br><span class="line">base_dir=&quot;/etc/ansible&quot;</span><br></pre></td></tr></table></figure><h3 id="测试节点主机可达"><a href="#测试节点主机可达" class="headerlink" title="测试节点主机可达"></a>测试节点主机可达</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m ping</span><br></pre></td></tr></table></figure><h3 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 分步安装</span><br><span class="line">ansible-playbook 01.prepare.yml</span><br><span class="line">ansible-playbook 02.etcd.yml</span><br><span class="line">ansible-playbook 03.docker.yml</span><br><span class="line">ansible-playbook 04.kube-master.yml</span><br><span class="line">ansible-playbook 05.kube-node.yml</span><br><span class="line">ansible-playbook 06.network.yml</span><br><span class="line">ansible-playbook 07.cluster-addon.yml</span><br><span class="line"># 一步安装</span><br><span class="line">#ansible-playbook 90.setup.yml</span><br></pre></td></tr></table></figure><h3 id="验证集群功能"><a href="#验证集群功能" class="headerlink" title="验证集群功能"></a>验证集群功能</h3><h4 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node</span><br><span class="line">kubectl cluster-info</span><br><span class="line">kubectl  top node</span><br><span class="line">kubectl get ep --all-namespaces -o yaml</span><br></pre></td></tr></table></figure><h4 id="创建测试文件"><a href="#创建测试文件" class="headerlink" title="创建测试文件"></a>创建测试文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; nginx-ds.yml &lt;&lt;EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-ds</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx-ds</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx-ds</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    port: 80</span><br><span class="line">    targetPort: 80</span><br><span class="line">---</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-ds</span><br><span class="line">  labels:</span><br><span class="line">    addonmanager.kubernetes.io/mode: Reconcile</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-ds</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: my-nginx</span><br><span class="line">        image: nginx:1.7.9</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">kubectl create -f nginx-ds.yml</span><br><span class="line"></span><br><span class="line">kubectl get pods  -o wide|grep nginx-ds</span><br><span class="line">kubectl get svc  -o wide|grep nginx-ds</span><br><span class="line"></span><br><span class="line"># 检查nodeport可用性</span><br><span class="line">curl node节点ip:svc端口</span><br><span class="line"># 出现nginx欢迎页</span><br></pre></td></tr></table></figure><h4 id="验证coredns"><a href="#验证coredns" class="headerlink" title="验证coredns"></a>验证coredns</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec  -it nginx-ds-8sd6z /bin/bash</span><br><span class="line">cat /etc/resolv.conf</span><br><span class="line">ping nginx-ds</span><br><span class="line"># 能成功解析服务到ip证明dns正常</span><br></pre></td></tr></table></figure><h4 id="验证dashboard"><a href="#验证dashboard" class="headerlink" title="验证dashboard"></a>验证dashboard</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># kube-apiserver 访问 dashboard</span><br><span class="line">kubectl cluster-info</span><br><span class="line"># 也可以通过nodeport 访问</span><br><span class="line">kubectl get svc -n kube-system</span><br><span class="line"></span><br><span class="line"># 创建登录 Dashboard 的 token 和 kubeconfig 配置文件</span><br><span class="line"># 上面提到，Dashboard 默认只支持 token 认证，所以如果使用 KubeConfig 文件，需要在该文件中指定 token，不支持使用 client 证书认证。</span><br><span class="line"></span><br><span class="line"># 创建登录 token</span><br><span class="line">kubectl create sa dashboard-admin -n kube-system</span><br><span class="line">kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin</span><br><span class="line">ADMIN_SECRET=$(kubectl get secrets -n kube-system | grep dashboard-admin | awk &apos;&#123;print $1&#125;&apos;)</span><br><span class="line">DASHBOARD_LOGIN_TOKEN=$(kubectl describe secret -n kube-system $&#123;ADMIN_SECRET&#125; | grep -E &apos;^token&apos; | awk &apos;&#123;print $2&#125;&apos;)</span><br><span class="line">echo $&#123;DASHBOARD_LOGIN_TOKEN&#125;</span><br><span class="line"></span><br><span class="line"># 创建使用 token 的 KubeConfig 文件</span><br><span class="line"># 设置集群参数</span><br><span class="line">kubectl config set-cluster kubernetes \</span><br><span class="line">  --certificate-authority=/etc/kubernetes/ssl/ca.pem \</span><br><span class="line">  --embed-certs=true \</span><br><span class="line">  --server=https://172.16.68.14:8443 \</span><br><span class="line">  --kubeconfig=dashboard.kubeconfig</span><br><span class="line"></span><br><span class="line"># 设置客户端认证参数，使用上面创建的 Token</span><br><span class="line">kubectl config set-credentials dashboard_user \</span><br><span class="line">  --token=$&#123;DASHBOARD_LOGIN_TOKEN&#125; \</span><br><span class="line">  --kubeconfig=dashboard.kubeconfig</span><br><span class="line"></span><br><span class="line"># 设置上下文参数</span><br><span class="line">kubectl config set-context default \</span><br><span class="line">  --cluster=kubernetes \</span><br><span class="line">  --user=dashboard_user \</span><br><span class="line">  --kubeconfig=dashboard.kubeconfig</span><br><span class="line"></span><br><span class="line"># 设置默认上下文</span><br><span class="line">kubectl config use-context default --kubeconfig=dashboard.kubeconfig</span><br></pre></td></tr></table></figure><h3 id="自定义修改"><a href="#自定义修改" class="headerlink" title="自定义修改"></a>自定义修改</h3><p>04.kube-master.yml # 去除了roles kube-node</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># to set up &apos;kube-master&apos; nodes</span><br><span class="line">- hosts: kube-master</span><br><span class="line">  roles:</span><br><span class="line">  - kube-master</span><br><span class="line">  tasks:</span><br><span class="line">  - name: Making master nodes SchedulingDisabled</span><br><span class="line">    shell: &quot;&#123;&#123; bin_dir &#125;&#125;/kubectl cordon &#123;&#123; inventory_hostname &#125;&#125; &quot;</span><br><span class="line">    delegate_to: &quot;&#123;&#123; groups.deploy[0] &#125;&#125;&quot;</span><br><span class="line">    when: DEPLOY_MODE != &quot;allinone&quot;</span><br><span class="line">    ignore_errors: true</span><br><span class="line"></span><br><span class="line">  - name: Setting master role name</span><br><span class="line">    shell: &quot;&#123;&#123; bin_dir &#125;&#125;/kubectl label node &#123;&#123; inventory_hostname &#125;&#125; kubernetes.io/role=master --overwrite&quot;</span><br><span class="line">    ignore_errors: true</span><br><span class="line">    delegate_to: &quot;&#123;&#123; groups.deploy[0] &#125;&#125;&quot;</span><br></pre></td></tr></table></figure><h3 id="公有云部署k8s集群hosts模板"><a href="#公有云部署k8s集群hosts模板" class="headerlink" title="公有云部署k8s集群hosts模板"></a>公有云部署k8s集群hosts模板</h3><p><strong>hosts.m-masters.example</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"># 部署节点：运行这份 ansible 脚本的节点</span><br><span class="line">[deploy]</span><br><span class="line">192.168.1.1</span><br><span class="line"></span><br><span class="line"># etcd集群请提供如下NODE_NAME、NODE_IP变量</span><br><span class="line"># 请注意etcd集群必须是1,3,5,7...奇数个节点</span><br><span class="line">[etcd]</span><br><span class="line">192.168.1.1 NODE_NAME=etcd1 NODE_IP=&quot;192.168.1.1&quot;</span><br><span class="line">192.168.1.2 NODE_NAME=etcd2 NODE_IP=&quot;192.168.1.2&quot;</span><br><span class="line">192.168.1.3 NODE_NAME=etcd3 NODE_IP=&quot;192.168.1.3&quot;</span><br><span class="line"></span><br><span class="line">[kube-master]</span><br><span class="line">192.168.1.1 NODE_IP=&quot;192.168.1.1&quot;</span><br><span class="line">192.168.1.2 NODE_IP=&quot;192.168.1.2&quot;</span><br><span class="line"></span><br><span class="line"># 负载均衡至少两个节点，安装 haproxy+keepalived</span><br><span class="line"># 根据master节点数量同步修改roles/lb/templates/haproxy.cfg.j2 </span><br><span class="line">[lb]</span><br><span class="line">192.168.1.1 LB_IF=&quot;eth0&quot; LB_ROLE=backup</span><br><span class="line">192.168.1.2 LB_IF=&quot;eth0&quot; LB_ROLE=master</span><br><span class="line">[lb:vars]</span><br><span class="line">LB_EP1=&quot;192.168.1.1:6443&quot;# api-server 实际成员地址端口</span><br><span class="line">LB_EP2=&quot;192.168.1.2:6443&quot;# api-server 实际成员地址端口</span><br><span class="line">MASTER_IP=&quot;192.168.1.10&quot;  # api-server 虚地址</span><br><span class="line">MASTER_PORT=&quot;8443&quot;# api-server 服务端口</span><br><span class="line"></span><br><span class="line">#确保node节点有变量NODE_ID=node1</span><br><span class="line">[kube-node]</span><br><span class="line">192.168.1.2 NODE_ID=node1 NODE_IP=&quot;192.168.1.2&quot;</span><br><span class="line">192.168.1.3 NODE_ID=node2 NODE_IP=&quot;192.168.1.3&quot;</span><br><span class="line">192.168.1.4 NODE_ID=node3 NODE_IP=&quot;192.168.1.4&quot;</span><br><span class="line"></span><br><span class="line">[kube-cluster:children]</span><br><span class="line">kube-node</span><br><span class="line">kube-master</span><br><span class="line"></span><br><span class="line"># 如果启用harbor，请配置后面harbor相关参数</span><br><span class="line">[harbor]</span><br><span class="line">#192.168.1.8 NODE_IP=&quot;192.168.1.8&quot;</span><br><span class="line"></span><br><span class="line"># 预留组，后续添加node节点使用</span><br><span class="line">[new-node]</span><br><span class="line">#192.168.1.xx NODE_ID=node6 NODE_IP=&quot;192.168.1.xx&quot;</span><br><span class="line">#192.168.1.xx NODE_ID=node7 NODE_IP=&quot;192.168.1.xx&quot;</span><br><span class="line"></span><br><span class="line">[all:vars]</span><br><span class="line"># ---------集群主要参数---------------</span><br><span class="line">#集群 MASTER IP, 需要负载均衡，一般为VIP地址</span><br><span class="line">MASTER_IP=&quot;192.168.1.10&quot;</span><br><span class="line">KUBE_APISERVER=&quot;https://192.168.1.10:8443&quot;</span><br><span class="line"></span><br><span class="line">#pause镜像地址</span><br><span class="line">POD_INFRA_CONTAINER_IMAGE=mirrorgooglecontainers/pause-amd64:3.0</span><br><span class="line"></span><br><span class="line">#TLS Bootstrapping 使用的 Token，使用 head -c 16 /dev/urandom | od -An -t x | tr -d &apos; &apos; 生成</span><br><span class="line">BOOTSTRAP_TOKEN=&quot;c30302226d4b810e08731702d3890f50&quot;</span><br><span class="line"></span><br><span class="line"># 集群网络插件，目前支持calico和flannel</span><br><span class="line">CLUSTER_NETWORK=&quot;calico&quot;</span><br><span class="line"></span><br><span class="line"># 部分calico相关配置，更全配置可以去roles/calico/templates/calico.yaml.j2自定义</span><br><span class="line"># 设置 CALICO_IPV4POOL_IPIP=“off”,可以提高网络性能，条件限制详见 05.安装calico网络组件.md</span><br><span class="line">CALICO_IPV4POOL_IPIP=&quot;always&quot;</span><br><span class="line"># 设置 calico-node使用的host IP，bgp邻居通过该地址建立，可手动指定端口&quot;interface=eth0&quot;或使用如下自动发现</span><br><span class="line">IP_AUTODETECTION_METHOD=&quot;can-reach=223.5.5.5&quot;</span><br><span class="line"></span><br><span class="line"># 部分flannel配置，详见roles/flannel/templates/kube-flannel.yaml.j2</span><br><span class="line">FLANNEL_BACKEND=&quot;vxlan&quot;</span><br><span class="line"></span><br><span class="line"># 服务网段 (Service CIDR），部署前路由不可达，部署后集群内使用 IP:Port 可达</span><br><span class="line">SERVICE_CIDR=&quot;10.68.0.0/16&quot;</span><br><span class="line"></span><br><span class="line"># POD 网段 (Cluster CIDR），部署前路由不可达，**部署后**路由可达</span><br><span class="line">CLUSTER_CIDR=&quot;172.20.0.0/16&quot;</span><br><span class="line"></span><br><span class="line"># 服务端口范围 (NodePort Range)</span><br><span class="line">NODE_PORT_RANGE=&quot;20000-40000&quot;</span><br><span class="line"></span><br><span class="line"># kubernetes 服务 IP (预分配，一般是 SERVICE_CIDR 中第一个IP)</span><br><span class="line">CLUSTER_KUBERNETES_SVC_IP=&quot;10.68.0.1&quot;</span><br><span class="line"></span><br><span class="line"># 集群 DNS 服务 IP (从 SERVICE_CIDR 中预分配)</span><br><span class="line">CLUSTER_DNS_SVC_IP=&quot;10.68.0.2&quot;</span><br><span class="line"></span><br><span class="line"># 集群 DNS 域名</span><br><span class="line">CLUSTER_DNS_DOMAIN=&quot;cluster.local.&quot;</span><br><span class="line"></span><br><span class="line"># etcd 集群间通信的IP和端口, **根据实际 etcd 集群成员设置**</span><br><span class="line">ETCD_NODES=&quot;etcd1=https://192.168.1.1:2380,etcd2=https://192.168.1.2:2380,etcd3=https://192.168.1.3:2380&quot;</span><br><span class="line"></span><br><span class="line"># etcd 集群服务地址列表, **根据实际 etcd 集群成员设置**</span><br><span class="line">ETCD_ENDPOINTS=&quot;https://192.168.1.1:2379,https://192.168.1.2:2379,https://192.168.1.3:2379&quot;</span><br><span class="line"></span><br><span class="line"># 集群basic auth 使用的用户名和密码</span><br><span class="line">BASIC_AUTH_USER=&quot;admin&quot;</span><br><span class="line">BASIC_AUTH_PASS=&quot;test1234&quot;</span><br><span class="line"></span><br><span class="line"># ---------附加参数--------------------</span><br><span class="line">#默认二进制文件目录</span><br><span class="line">bin_dir=&quot;/root/local/bin&quot;</span><br><span class="line"></span><br><span class="line">#证书目录</span><br><span class="line">ca_dir=&quot;/etc/kubernetes/ssl&quot;</span><br><span class="line"></span><br><span class="line">#部署目录，即 ansible 工作目录，建议不要修改</span><br><span class="line">base_dir=&quot;/etc/ansible&quot;</span><br><span class="line"></span><br><span class="line">#私有仓库 harbor服务器 (域名或者IP)</span><br><span class="line">#HARBOR_IP=&quot;192.168.1.8&quot;</span><br><span class="line">#HARBOR_DOMAIN=&quot;harbor.yourdomain.com&quot;</span><br></pre></td></tr></table></figure><h4 id="公有云deploy文件"><a href="#公有云deploy文件" class="headerlink" title="公有云deploy文件"></a>公有云deploy文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># 在deploy节点生成CA相关证书，以供整个集群使用</span><br><span class="line"># 以及初始化kubedns.yaml配置文件</span><br><span class="line">- hosts: deploy</span><br><span class="line">  roles:</span><br><span class="line">  - deploy</span><br><span class="line"></span><br><span class="line"># 集群节点的公共配置任务</span><br><span class="line">- hosts:</span><br><span class="line">  - kube-cluster</span><br><span class="line">  - deploy</span><br><span class="line">  - etcd</span><br><span class="line">  - lb</span><br><span class="line">  roles:</span><br><span class="line">  - prepare</span><br><span class="line"></span><br><span class="line"># [可选]多master部署时的负载均衡配置</span><br><span class="line">- hosts: lb</span><br><span class="line">  roles:</span><br><span class="line">  - lb</span><br><span class="line"></span><br><span class="line"># 创建etcd集群</span><br><span class="line">- hosts: etcd</span><br><span class="line">  roles:</span><br><span class="line">  - etcd</span><br><span class="line"></span><br><span class="line"># kubectl 客户端配置</span><br><span class="line">- hosts: </span><br><span class="line">  - kube-cluster</span><br><span class="line">  - deploy</span><br><span class="line">  roles:</span><br><span class="line">  - kubectl</span><br><span class="line"></span><br><span class="line"># docker服务安装</span><br><span class="line">- hosts: kube-cluster</span><br><span class="line">  roles:</span><br><span class="line">  - docker</span><br><span class="line"></span><br><span class="line"># master 节点部署</span><br><span class="line">- hosts: kube-master</span><br><span class="line">  roles:</span><br><span class="line">  - kube-master</span><br><span class="line"></span><br><span class="line"># node 节点部署</span><br><span class="line">- hosts: kube-node</span><br><span class="line">  roles:</span><br><span class="line">  - kube-node</span><br><span class="line"></span><br><span class="line"># 集群网络插件部署，只能选择一种安装</span><br><span class="line">- hosts: kube-cluster</span><br><span class="line">  roles:</span><br><span class="line">  - &#123; role: calico, when: &quot;CLUSTER_NETWORK == &apos;calico&apos;&quot; &#125;</span><br><span class="line">  - &#123; role: flannel, when: &quot;CLUSTER_NETWORK == &apos;flannel&apos;&quot; &#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://li-sen.github.io/2018/09/27/k8s-kubeasz-%E9%98%BF%E9%87%8C%E4%BA%91vpc%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/" target="_blank" rel="noopener">https://li-sen.github.io/2018/09/27/k8s-kubeasz-%E9%98%BF%E9%87%8C%E4%BA%91vpc%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/</a></li><li><a href="https://github.com/mendickxiao/kubeasz/blob/master/90.setup.yml" target="_blank" rel="noopener">https://github.com/mendickxiao/kubeasz/blob/master/90.setup.yml</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;离线本地测试环境资源计划说明：&quot;&gt;&lt;a href=&quot;#离线本地测试环境资源计划说明：&quot; class=&quot;headerlink&quot; title=&quot;离线本地测试环境资源计划说明：&quot;&gt;&lt;/a&gt;离线本地测试环境资源计划说明：&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;

      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>手动搭建k8s集群</title>
    <link href="https://yo42.github.io/2019/01/29/%E6%90%AD%E5%BB%BAk8s%E9%9B%86%E7%BE%A4/"/>
    <id>https://yo42.github.io/2019/01/29/搭建k8s集群/</id>
    <published>2019-01-29T02:34:08.394Z</published>
    <updated>2019-04-23T08:25:06.129Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集群节点-初始化"><a href="#集群节点-初始化" class="headerlink" title="集群节点 初始化"></a>集群节点 初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure><h3 id="集群环境变量-amp-节点分发"><a href="#集群环境变量-amp-节点分发" class="headerlink" title="集群环境变量&amp;节点分发"></a>集群环境变量&amp;节点分发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"># TLS Bootstrapping 使用的Token，可以使用命令 head -c 16 /dev/urandom | od -An -t x | tr -d &apos; &apos; 生成</span><br><span class="line">BOOTSTRAP_TOKEN=&quot;a4b521597f9938eaf36a82177c7c6f3a&quot;</span><br><span class="line"></span><br><span class="line"># 最好使用 当前未用的网段 来定义服务网段和 Pod 网段</span><br><span class="line"></span><br><span class="line"># 服务网段，部署前路由不可达，部署后集群内路由可达(kube-proxy 和 ipvs 保证)</span><br><span class="line">export SERVICE_CIDR=&quot;10.100.0.0/16&quot;</span><br><span class="line"></span><br><span class="line"># Pod 网段，建议 /16 段地址，部署前路由不可达，部署后集群内路由可达(flanneld 保证)</span><br><span class="line">export CLUSTER_CIDR=&quot;10.200.0.0/16&quot;</span><br><span class="line"></span><br><span class="line"># 服务端口范围 (NodePort Range)</span><br><span class="line">export NODE_PORT_RANGE=&quot;30000-32766&quot;</span><br><span class="line"></span><br><span class="line"># 集群各机器 IP 数组</span><br><span class="line">export NODE_IPS=&quot;10.1.2.30 10.1.2.1 10.1.2.2&quot;</span><br><span class="line">export NODE_IP=&quot;10.1.2.30&quot;</span><br><span class="line"></span><br><span class="line"># 集群各 IP 对应的 主机名数组</span><br><span class="line">export NODE_NAME=kube-master1</span><br><span class="line"></span><br><span class="line"># kube-apiserver 的 VIP（HA 组件 keepalived 发布的 IP）</span><br><span class="line">#export MASTER_VIP=172.27.129.253</span><br><span class="line"># MASTER API Server 地址</span><br><span class="line">MASTER_URL=&quot;hhht-k8s-api.virtual.local&quot;</span><br><span class="line"></span><br><span class="line"># kube-apiserver VIP 地址（HA 组件 haproxy 监听 6443 端口）</span><br><span class="line">export KUBE_APISERVER=&quot;https://$&#123;MASTER_URL&#125;:6443&quot;</span><br><span class="line"></span><br><span class="line"># HA 节点，配置 VIP 的网络接口名称</span><br><span class="line">#export VIP_IF=&quot;eth0&quot;</span><br><span class="line"></span><br><span class="line"># etcd 集群服务地址列表</span><br><span class="line">export ETCD_ENDPOINTS=&quot;https://10.1.2.30:2379,https://10.1.2.1:2379,https://10.1.2.2:2379&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># etcd 集群间通信的 IP 和端口</span><br><span class="line">export ETCD_NODES=&quot;kube-master1=https://10.1.2.30:2380,kube-master2=https://10.1.2.1:2380,kube-master3=https://10.1.2.2:2380&quot;</span><br><span class="line"></span><br><span class="line"># flanneld 网络配置前缀</span><br><span class="line">export FLANNEL_ETCD_PREFIX=&quot;/kubernetes/network&quot;</span><br><span class="line"></span><br><span class="line"># kubernetes 服务IP(预先分配，一般为SERVICE_CIDR中的第一个IP)</span><br><span class="line">export CLUSTER_KUBERNETES_SVC_IP=&quot;10.100.0.1&quot;</span><br><span class="line"></span><br><span class="line"># 集群 DNS 服务IP(从SERVICE_CIDR 中预先分配)</span><br><span class="line">export CLUSTER_DNS_SVC_IP=&quot;10.100.0.2&quot;</span><br><span class="line"></span><br><span class="line"># 集群 DNS 域名</span><br><span class="line">export CLUSTER_DNS_DOMAIN=&quot;hhhtcluster.local.&quot;</span><br><span class="line"></span><br><span class="line"># 将二进制目录 /opt/k8s/bin 加到 PATH 中</span><br><span class="line">PATH=/usr/k8s/bin:$PATH</span><br><span class="line"></span><br><span class="line">PATH=/apps/svr/k8s/bin:$PATH</span><br></pre></td></tr></table></figure><p>复制到所有服务器上给以上文件执行权限然后修改系统变量</p><p>echo ‘source /apps/sh/env.sh’ &gt;&gt; ~/.bash_profile</p><p>将上面变量保存为: env.sh，然后将脚本拷贝到所有机器的/apps/sh/目录。</p><p>为方便后面迁移，我们在集群内定义一个域名用于访问apiserver，在每个节点的/etc/hosts文件中添加记录：10.1.2.30 hhht-k8s-api.virtual.local</p><p>其中10.1.2.30为master01 的IP，暂时使用该IP 来做apiserver 的负载地址</p><h3 id="创建CA证书和密钥-amp-节点分发"><a href="#创建CA证书和密钥-amp-节点分发" class="headerlink" title="创建CA证书和密钥&amp;节点分发"></a>创建CA证书和密钥&amp;节点分发</h3><h4 id="安装CFSSL工具集"><a href="#安装CFSSL工具集" class="headerlink" title="安装CFSSL工具集"></a>安装CFSSL工具集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">chmod +x cfssl_linux-amd64</span><br><span class="line">mv cfssl_linux-amd64 /usr/local/bin/cfssl</span><br><span class="line"></span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">chmod +x cfssljson_linux-amd64</span><br><span class="line">mv cfssljson_linux-amd64 /usr/local/bin/cfssljson</span><br><span class="line"></span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</span><br><span class="line">chmod +x cfssl-certinfo_linux-amd64</span><br><span class="line">mv cfssl-certinfo_linux-amd64 /usr/local/bin/cfssl-certinfo</span><br><span class="line"></span><br><span class="line">export PATH=/usr/local/bin:$PATH</span><br></pre></td></tr></table></figure><p>创建目录 mkdir -p /apps/conf/kubernetes/ssl</p><p>进入/apps/conf/kubernetes/ssl 目录新建以下2个文件</p><p>ca-config.json、ca-csr.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;signing&quot;: &#123;</span><br><span class="line">        &quot;default&quot;: &#123;</span><br><span class="line">            &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;profiles&quot;: &#123;</span><br><span class="line">            &quot;kubernetes&quot;: &#123;</span><br><span class="line">                &quot;expiry&quot;: &quot;87600h&quot;,</span><br><span class="line">                &quot;usages&quot;: [</span><br><span class="line">                    &quot;signing&quot;,</span><br><span class="line">                    &quot;key encipherment&quot;,</span><br><span class="line">                    &quot;server auth&quot;,</span><br><span class="line">                    &quot;client auth&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>config.json</code>：可以定义多个profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个profile；</li><li><code>signing</code>: 表示该证书可用于签名其它证书；生成的ca.pem 证书中<code>CA=TRUE</code>；</li><li><code>server auth</code>: 表示client 可以用该CA 对server 提供的证书进行校验；</li><li><code>client auth</code>: 表示server 可以用该CA 对client 提供的证书进行验证。</li></ul><p>ca-csr.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;BeiJing&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>CN</code>: <code>Common Name</code>，kube-apiserver 从证书中提取该字段作为请求的用户名(User Name)；浏览器使用该字段验证网站是否合法；</li><li><code>O</code>: <code>Organization</code>，kube-apiserver 从证书中提取该字段作为请求用户所属的组(Group)；</li></ul><h4 id="生成CA-证书和私钥："><a href="#生成CA-证书和私钥：" class="headerlink" title="生成CA 证书和私钥："></a>生成CA 证书和私钥：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br><span class="line">ls` `ca*</span><br><span class="line">ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem</span><br></pre></td></tr></table></figure><p>创建完成后把/apps/conf/kubernetes/ssl这个目录复制到所有master节点上</p><h3 id="部署etcd集群-节点x3"><a href="#部署etcd集群-节点x3" class="headerlink" title="部署etcd集群 (节点x3)"></a>部署etcd集群 (节点x3)</h3><p>kubernetes 系统使用etcd存储所有的数据，我们这里部署3个节点的etcd 集群，这3个节点直接复用kubernetes master的3个节点，分别命名为etcd01、etcd02、etcd03:</p><p>etcd01：10.1.2.30<br>etcd02：10.1.2.1<br>etcd03：10.1.2.2</p><p>修改3台master服务器的/apps/sh/env.sh文件的第31行左右</p><p>把以下内容修改为本机信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">####OTHER</span><br><span class="line">NODE_NAME=etcd01</span><br><span class="line">NODE_IP=10.1.2.30</span><br></pre></td></tr></table></figure><p>名字可以任意只要能区分就可以</p><p>IP填写本机IP</p><p>修改以下配置填入所有正确的ETCD地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NODE_IPS=&quot;172.18.49.242 172.18.49.243 172.18.49.244&quot;</span><br><span class="line"></span><br><span class="line">ETCD_NODES=etcd01=https://172.18.49.242:2380,etcd02=https://172.18.49.243:2380,etcd03=https://172.18.49.244:2380</span><br><span class="line"></span><br><span class="line">KUBE_APISERVER=&quot;https://$&#123;MASTER_URL&#125;:6443&quot;</span><br></pre></td></tr></table></figure><p>修改完毕后执行 source /apps/sh/env.sh 命令</p><p>echo $NODE_NAME</p><p>echo $NODE_IP</p><p>echo $ETCD_NODES</p><p>输出内容是你修改的内容即正确。</p><h3 id="创建TLS-密钥和证书"><a href="#创建TLS-密钥和证书" class="headerlink" title="创建TLS 密钥和证书"></a>创建TLS 密钥和证书</h3><p>为了保证通信安全，客户端(如etcdctl)与etcd 集群、etcd 集群之间的通信需要使用TLS 加密。</p><p>创建etcd 证书签名请求：</p><p>对应路径：/apps/conf/etcd/ssl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; etcd-csr.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;etcd&quot;,</span><br><span class="line">  &quot;hosts&quot;: [</span><br><span class="line">    &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;$&#123;NODE_IP&#125;&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>生成证书</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=/apps/conf/kubernetes/ssl/ca.pem   -ca-key=/apps/conf/kubernetes/ssl/ca-key.pem   -config=/apps/conf/kubernetes/ssl/ca-config.json   -profile=kubernetes etcd-csr.json | cfssljson -bare etcd</span><br></pre></td></tr></table></figure><h3 id="创建etcd-的systemd-unit-文件"><a href="#创建etcd-的systemd-unit-文件" class="headerlink" title="创建etcd 的systemd unit 文件"></a>创建etcd 的systemd unit 文件</h3><p>需要新建目录 /apps/lib/etcd/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; etcd.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Etcd Server</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Documentation=https://github.com/coreos</span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">WorkingDirectory=/apps/lib/etcd/</span><br><span class="line">ExecStart=/apps/svr/k8s/bin/etcd \\</span><br><span class="line">  --name=$&#123;NODE_NAME&#125; \\</span><br><span class="line">  --cert-file=/apps/conf/etcd/ssl/etcd.pem \\</span><br><span class="line">  --key-file=/apps/conf/etcd/ssl/etcd-key.pem \\</span><br><span class="line">  --peer-cert-file=/apps/conf/etcd/ssl/etcd.pem \\</span><br><span class="line">  --peer-key-file=/apps/conf/etcd/ssl/etcd-key.pem \\</span><br><span class="line">  --trusted-ca-file=/apps/conf/kubernetes/ssl/ca.pem \\</span><br><span class="line">  --peer-trusted-ca-file=/apps/conf/kubernetes/ssl/ca.pem \\</span><br><span class="line">  --initial-advertise-peer-urls=https://$&#123;NODE_IP&#125;:2380 \\</span><br><span class="line">  --listen-peer-urls=https://$&#123;NODE_IP&#125;:2380 \\</span><br><span class="line">  --listen-client-urls=https://$&#123;NODE_IP&#125;:2379,http://127.0.0.1:2379 \\</span><br><span class="line">  --advertise-client-urls=https://$&#123;NODE_IP&#125;:2379 \\</span><br><span class="line">  --initial-cluster-token=etcd-cluster-0 \\</span><br><span class="line">  --initial-cluster=$&#123;ETCD_NODES&#125; \\</span><br><span class="line">  --initial-cluster-state=new \\</span><br><span class="line">  --data-dir=/apps/lib/etcd</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>指定<code>etcd</code>的工作目录和数据目录为 /apps/lib/etcd/，需要在启动服务前创建这个目录；</li><li>为了保证通信安全，需要指定etcd 的公私钥(cert-file和key-file)、Peers通信的公私钥和CA 证书(peer-cert-file、peer-key-file、peer-trusted-ca-file)、客户端的CA 证书(trusted-ca-file)；</li><li><code>--initial-cluster-state</code>值为<code>new</code>时，<code>--name</code>的参数值必须位于<code>--initial-cluster</code>列表中；</li></ul><h3 id="启动etcd-服务"><a href="#启动etcd-服务" class="headerlink" title="启动etcd 服务"></a>启动etcd 服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp etcd.service /etc/systemd/system/</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable etcd</span><br><span class="line">systemctl start etcd</span><br><span class="line">systemctl status etcd</span><br></pre></td></tr></table></figure><p>最先启动的etcd 进程会卡住一段时间，等待其他节点启动加入集群，在所有的etcd 节点重复上面的步骤，直到所有的机器etcd 服务都已经启动。</p><h4 id="验证服务"><a href="#验证服务" class="headerlink" title="验证服务"></a>验证服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for ip in $&#123;NODE_IPS&#125;; do</span><br><span class="line">  ETCDCTL_API=3 /apps/svr/k8s/bin/etcdctl \</span><br><span class="line">  --endpoints=https://$&#123;ip&#125;:2379  \</span><br><span class="line">  --cacert=/apps/conf/kubernetes/ssl/ca.pem \</span><br><span class="line">  --cert=/apps/conf/etcd/ssl/etcd.pem \</span><br><span class="line">  --key=/apps/conf/etcd/ssl/etcd-key.pem \</span><br><span class="line">  endpoint health; done</span><br></pre></td></tr></table></figure><p><a href="https://10.1.2.30:2379" target="_blank" rel="noopener">https://10.1.2.30:2379</a> is healthy: successfully committed proposal: took = 2.436477ms<br><a href="https://10.1.2.1:2379" target="_blank" rel="noopener">https://10.1.2.1:2379</a> is healthy: successfully committed proposal: took = 2.893396ms<br><a href="https://10.1.2.2:2379" target="_blank" rel="noopener">https://10.1.2.2:2379</a> is healthy: successfully committed proposal: took = 2.621429ms</p><h4 id="配置kubectl-命令行工具"><a href="#配置kubectl-命令行工具" class="headerlink" title="配置kubectl 命令行工具"></a>配置kubectl 命令行工具</h4><p>在master服务器上安装</p><p>kubectl默认从~/.kube/config配置文件中获取访问kube-apiserver 地址、证书、用户名等信息，需要正确配置该文件才能正常使用kubectl命令。</p><p>需要将下载的kubectl 二进制文件和生产的~/.kube/config配置文件拷贝到需要使用kubectl 命令的机器上。</p><h4 id="创建admin-证书"><a href="#创建admin-证书" class="headerlink" title="创建admin 证书"></a>创建admin 证书</h4><p>kubectl 与kube-apiserver 的安全端口通信，需要为安全通信提供TLS 证书和密钥。创建admin 证书签名请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; admin-csr.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;admin&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;O&quot;: &quot;system:masters&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>后续kube-apiserver使用RBAC 对客户端(如kubelet、kube-proxy、Pod)请求进行授权<br>kube-apiserver 预定义了一些RBAC 使用的RoleBindings，如cluster-admin 将Group system:masters与Role cluster-admin绑定，该Role 授予了调用kube-apiserver所有API 的权限<br>O 指定了该证书的Group 为system:masters，kubectl使用该证书访问kube-apiserver时，由于证书被CA 签名，所以认证通过，同时由于证书用户组为经过预授权的system:masters，所以被授予访问所有API 的劝降<br>hosts 属性值为空列表</p><p>新建目录/apps/conf/kubectl/ssl 在目录中生成admin 证书和私钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=/apps/conf/kubernetes/ssl/ca.pem   -ca-key=/apps/conf/kubernetes/ssl/ca-key.pem   -config=/apps/conf/kubernetes/ssl/ca-config.json   -profile=kubernetes admin-csr.json | cfssljson -bare admin</span><br></pre></td></tr></table></figure><h4 id="创建kubectl-kubeconfig-文件"><a href="#创建kubectl-kubeconfig-文件" class="headerlink" title="创建kubectl kubeconfig 文件"></a>创建kubectl kubeconfig 文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl config set-cluster kubernetes   --certificate-authority=/apps/conf/kubernetes/ssl/ca.pem   --embed-certs=true   --server=$&#123;KUBE_APISERVER&#125;</span><br><span class="line">kubectl config set-credentials admin   --client-certificate=/apps/conf/kubectl/ssl/admin.pem   --embed-certs=true   --client-key=/apps/conf/kubectl/ssl/admin-key.pem   --token=$&#123;BOOTSTRAP_TOKEN&#125;</span><br><span class="line">kubectl config set-context kubernetes   --cluster=kubernetes   --user=admin</span><br><span class="line">kubectl config use-context kubernetes</span><br></pre></td></tr></table></figure><p>admin.pem证书O 字段值为system:masters，kube-apiserver 预定义的 RoleBinding cluster-admin 将 Group system:masters 与 Role cluster-admin 绑定，该 Role 授予了调用kube-apiserver 相关 API 的权限<br>生成的kubeconfig 被保存到 ~/.kube/config 文件</p><p>注意这里是配置连接信息的。如果发现连接不通可以到 ~/.kube/config 这里查看服务器配置是否都正确</p><h4 id="分发kubeconfig-文件"><a href="#分发kubeconfig-文件" class="headerlink" title="分发kubeconfig 文件"></a>分发kubeconfig 文件</h4><p>将~/.kube/config文件拷贝到运行kubectl命令的机器的~/.kube/目录下去。</p><h3 id="部署K8s-Master节点"><a href="#部署K8s-Master节点" class="headerlink" title="部署K8s Master节点"></a>部署K8s Master节点</h3><p>kubernetes master 节点包含的组件有：</p><p>kube-apiserver<br>kube-scheduler<br>kube-controller-manager</p><p>目前这3个组件需要部署到同一台机器上：（后面再部署高可用的master）</p><p>kube-scheduler、kube-controller-manager 和 kube-apiserver 三者的功能紧密相关；<br>同时只能有一个 kube-scheduler、kube-controller-manager 进程处于工作状态，如果运行多个，则需要通过选举产生一个 leader；</p><p>master 节点与node 节点上的Pods 通过Pod 网络通信，所以需要在master 节点上部署Flannel 网络。</p><h4 id="创建kubernetes-证书"><a href="#创建kubernetes-证书" class="headerlink" title="创建kubernetes 证书"></a>创建kubernetes 证书</h4><p>创建kubernetes 证书签名请求：</p><p>进入目录  /apps/conf/kubernetes/ssl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kubernetes-csr.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="line">  &quot;hosts&quot;: [</span><br><span class="line">    &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;$&#123;NODE_IP&#125;&quot;,</span><br><span class="line">    &quot;$&#123;MASTER_URL&#125;&quot;,</span><br><span class="line">    &quot;$&#123;CLUSTER_KUBERNETES_SVC_IP&#125;&quot;,</span><br><span class="line">    &quot;kubernetes&quot;,</span><br><span class="line">    &quot;kubernetes.default&quot;,</span><br><span class="line">    &quot;kubernetes.default.svc&quot;,</span><br><span class="line">    &quot;kubernetes.default.svc.cluster&quot;,</span><br><span class="line">    &quot;kubernetes.default.svc.cluster.local&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>如果 hosts 字段不为空则需要指定授权使用该证书的 <strong>IP 或域名列表</strong>，所以上面分别指定了当前部署的 master 节点主机 IP 以及apiserver 负载的内部域名</li><li>还需要添加 kube-apiserver 注册的名为 <code>kubernetes</code> 的服务 IP (Service Cluster IP)，一般是 kube-apiserver <code>--service-cluster-ip-range</code> 选项值指定的网段的<strong>第一个IP</strong></li></ul><h4 id="生成kubernetes-证书和私钥："><a href="#生成kubernetes-证书和私钥：" class="headerlink" title="生成kubernetes 证书和私钥："></a>生成kubernetes 证书和私钥：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=/apps/conf/kubernetes/ssl/ca.pem   -ca-key=/apps/conf/kubernetes/ssl/ca-key.pem   -config=/apps/conf/kubernetes/ssl/ca-config.json   -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes</span><br></pre></td></tr></table></figure><h4 id="配置和启动kube-apiserver"><a href="#配置和启动kube-apiserver" class="headerlink" title="配置和启动kube-apiserver"></a>配置和启动kube-apiserver</h4><h4 id="创建kube-apiserver-使用的客户端token-文件"><a href="#创建kube-apiserver-使用的客户端token-文件" class="headerlink" title="创建kube-apiserver 使用的客户端token 文件"></a>创建kube-apiserver 使用的客户端token 文件</h4><p>kubelet 首次启动时向kube-apiserver 发送TLS Bootstrapping 请求，kube-apiserver 验证请求中的token 是否与它配置的token.csv 一致，如果一致则自动为kubelet 生成证书和密钥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /apps/conf/kubernetes/</span><br><span class="line">cat &gt; token.csv &lt;&lt;EOF</span><br><span class="line">$&#123;BOOTSTRAP_TOKEN&#125;,kubelet-bootstrap,10001,&quot;system:kubelet-bootstrap&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="创建kube-apiserver-的systemd-unit文件"><a href="#创建kube-apiserver-的systemd-unit文件" class="headerlink" title="创建kube-apiserver 的systemd unit文件"></a>创建kube-apiserver 的systemd unit文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">cd /apps/sh</span><br><span class="line">cat  &gt; kube-apiserver.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes API Server</span><br><span class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/apps/svr/k8s/bin/kube-apiserver \\</span><br><span class="line">  --admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota \\</span><br><span class="line">  --advertise-address=$&#123;NODE_IP&#125; \\</span><br><span class="line">  --bind-address=0.0.0.0 \\</span><br><span class="line">  --insecure-bind-address=$&#123;NODE_IP&#125; \\</span><br><span class="line">  --authorization-mode=Node,RBAC \\</span><br><span class="line">  --runtime-config=rbac.authorization.k8s.io/v1alpha1 \\</span><br><span class="line">  --kubelet-https=true \\</span><br><span class="line">  --enable-bootstrap-token-auth \\</span><br><span class="line">  --token-auth-file=/apps/conf/kubernetes/token.csv \\</span><br><span class="line">  --service-cluster-ip-range=$&#123;SERVICE_CIDR&#125; \\</span><br><span class="line">  --service-node-port-range=$&#123;NODE_PORT_RANGE&#125; \\</span><br><span class="line">  --tls-cert-file=/apps/conf/kubernetes/ssl/kubernetes.pem \\</span><br><span class="line">  --tls-private-key-file=/apps/conf/kubernetes/ssl/kubernetes-key.pem \\</span><br><span class="line">  --client-ca-file=/apps/conf/kubernetes/ssl/ca.pem \\</span><br><span class="line">  --service-account-key-file=/apps/conf/kubernetes/ssl/ca-key.pem \\</span><br><span class="line">  --etcd-cafile=/apps/conf/kubernetes/ssl/ca.pem \\</span><br><span class="line">  --etcd-certfile=/apps/conf/kubernetes/ssl/kubernetes.pem \\</span><br><span class="line">  --etcd-keyfile=/apps/conf/kubernetes/ssl/kubernetes-key.pem \\</span><br><span class="line">  --etcd-servers=$&#123;ETCD_ENDPOINTS&#125; \\</span><br><span class="line">  --enable-swagger-ui=true \\</span><br><span class="line">  --allow-privileged=true \\</span><br><span class="line">  --apiserver-count=2 \\</span><br><span class="line">  --audit-log-maxage=30 \\</span><br><span class="line">  --audit-log-maxbackup=3 \\</span><br><span class="line">  --audit-log-maxsize=100 \\</span><br><span class="line">  --audit-log-path=/apps/logs/kubernetes/audit.log \\</span><br><span class="line">  --audit-policy-file=/apps/conf/kubernetes/audit-policy.yaml \\</span><br><span class="line">  --event-ttl=1h \\</span><br><span class="line">  --logtostderr=true \\</span><br><span class="line">  --v=6</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">Type=notify</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li><strong>1.9.x</strong>版本的，一定要注意上面的参数<code>experimental-bootstrap-token-auth</code>，需要替换成<code>enable-bootstrap-token-auth</code>，因为这个参数在<strong>1.9.x</strong>里面已经废弃掉了</li><li>kube-apiserver 1.6 版本开始使用 etcd v3 API 和存储格式</li><li><code>--authorization-mode=RBAC</code> 指定在安全端口使用RBAC 授权模式，拒绝未通过授权的请求</li><li>kube-scheduler、kube-controller-manager 一般和 kube-apiserver 部署在同一台机器上，它们使用<strong>非安全端口</strong>和 kube-apiserver通信</li><li>kubelet、kube-proxy、kubectl 部署在其它 Node 节点上，如果通过<strong>安全端口</strong>访问 kube-apiserver，则必须先通过 TLS 证书认证，再通过 RBAC 授权</li><li>kube-proxy、kubectl 通过使用证书里指定相关的 User、Group 来达到通过 RBAC 授权的目的</li><li>如果使用了 kubelet TLS Boostrap 机制，则不能再指定 <code>--kubelet-certificate-authority</code>、<code>--kubelet-client-certificate</code> 和 <code>--kubelet-client-key</code> 选项，否则后续 kube-apiserver 校验 kubelet 证书时出现 ”x509: certificate signed by unknown authority“ 错误</li><li><code>--admission-control</code> 值必须包含 <code>ServiceAccount</code>，否则部署集群插件时会失败</li><li><code>--bind-address</code> 不能为 <code>127.0.0.1</code></li><li><code>--service-cluster-ip-range</code> 指定 Service Cluster IP 地址段，该地址段不能路由可达</li><li><code>--service-node-port-range=${NODE_PORT_RANGE}</code> 指定 NodePort 的端口范围</li><li>缺省情况下 kubernetes 对象保存在<code>etcd/registry</code> 路径下，可以通过 <code>--etcd-prefix</code> 参数进行调整</li><li>kube-apiserver 1.8版本后需要在<code>--authorization-mode</code>参数中添加<code>Node</code>，即：<code>--authorization-mode=Node,RBAC</code>，否则Node 节点无法注册</li><li>注意要开启审查日志功能，指定<code>--audit-log-path</code>参数是不够的，这只是指定了日志的路径，还需要指定一个审查日志策略文件：<code>--audit-policy-file</code>，我们也可以使用日志收集工具收集相关的日志进行分析</li></ul><p>新建文件 audit-policy.yaml</p><p>在目录/apps/conf/kubernetes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: audit.k8s.io/v1beta1 # This is required.</span><br><span class="line">kind: Policy</span><br><span class="line"># Don&apos;t generate audit events for all requests in RequestReceived stage.</span><br><span class="line">omitStages:</span><br><span class="line">  - &quot;RequestReceived&quot;</span><br><span class="line">rules:</span><br><span class="line">  # Log pod changes at RequestResponse level</span><br><span class="line">  - level: RequestResponse</span><br><span class="line">    resources:</span><br><span class="line">    - group: &quot;&quot;</span><br><span class="line">      # Resource &quot;pods&quot; doesn&apos;t match requests to any subresource of pods,</span><br><span class="line">      # which is consistent with the RBAC policy.</span><br><span class="line">      resources: [&quot;pods&quot;]</span><br><span class="line">  # Log &quot;pods/log&quot;, &quot;pods/status&quot; at Metadata level</span><br><span class="line">  - level: Metadata</span><br><span class="line">    resources:</span><br><span class="line">    - group: &quot;&quot;</span><br><span class="line">      resources: [&quot;pods/log&quot;, &quot;pods/status&quot;]</span><br><span class="line"> </span><br><span class="line">  # Don&apos;t log requests to a configmap called &quot;controller-leader&quot;</span><br><span class="line">  - level: None</span><br><span class="line">    resources:</span><br><span class="line">    - group: &quot;&quot;</span><br><span class="line">      resources: [&quot;configmaps&quot;]</span><br><span class="line">      resourceNames: [&quot;controller-leader&quot;]</span><br><span class="line"> </span><br><span class="line">  # Don&apos;t log watch requests by the &quot;system:kube-proxy&quot; on endpoints or services</span><br><span class="line">  - level: None</span><br><span class="line">    users: [&quot;system:kube-proxy&quot;]</span><br><span class="line">    verbs: [&quot;watch&quot;]</span><br><span class="line">    resources:</span><br><span class="line">    - group: &quot;&quot; # core API group</span><br><span class="line">      resources: [&quot;endpoints&quot;, &quot;services&quot;]</span><br><span class="line"> </span><br><span class="line">  # Don&apos;t log authenticated requests to certain non-resource URL paths.</span><br><span class="line">  - level: None</span><br><span class="line">    userGroups: [&quot;system:authenticated&quot;]</span><br><span class="line">    nonResourceURLs:</span><br><span class="line">    - &quot;/api*&quot; # Wildcard matching.</span><br><span class="line">    - &quot;/version&quot;</span><br><span class="line"> </span><br><span class="line">  # Log the request body of configmap changes in kube-system.</span><br><span class="line">  - level: Request</span><br><span class="line">    resources:</span><br><span class="line">    - group: &quot;&quot; # core API group</span><br><span class="line">      resources: [&quot;configmaps&quot;]</span><br><span class="line">    # This rule only applies to resources in the &quot;kube-system&quot; namespace.</span><br><span class="line">    # The empty string &quot;&quot; can be used to select non-namespaced resources.</span><br><span class="line">    namespaces: [&quot;kube-system&quot;]</span><br><span class="line"> </span><br><span class="line">  # Log configmap and secret changes in all other namespaces at the Metadata level.</span><br><span class="line">  - level: Metadata</span><br><span class="line">    resources:</span><br><span class="line">    - group: &quot;&quot; # core API group</span><br><span class="line">      resources: [&quot;secrets&quot;, &quot;configmaps&quot;]</span><br><span class="line"> </span><br><span class="line">  # Log all other resources in core and extensions at the Request level.</span><br><span class="line">  - level: Request</span><br><span class="line">    resources:</span><br><span class="line">    - group: &quot;&quot; # core API group</span><br><span class="line">    - group: &quot;extensions&quot; # Version of group should NOT be included.</span><br><span class="line"> </span><br><span class="line">  # A catch-all rule to log all other requests at the Metadata level.</span><br><span class="line">  - level: Metadata</span><br><span class="line">    # Long-running requests like watches that fall under this rule will not</span><br><span class="line">    # generate an audit event in RequestReceived.</span><br><span class="line">    omitStages:</span><br><span class="line">      - &quot;RequestReceived&quot;</span><br></pre></td></tr></table></figure><p>审查日志的相关配置可以查看文档了解：<a href="https://kubernetes.io/docs/tasks/debug-application-cluster/audit/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/debug-application-cluster/audit/</a></p><h4 id="启动kube-apiserver"><a href="#启动kube-apiserver" class="headerlink" title="启动kube-apiserver"></a>启动kube-apiserver</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp kube-apiserver.service /etc/systemd/system/</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable kube-apiserver</span><br><span class="line">systemctl start kube-apiserver</span><br><span class="line">systemctl status kube-apiserver</span><br></pre></td></tr></table></figure><h4 id="配置和启动kube-controller-manager"><a href="#配置和启动kube-controller-manager" class="headerlink" title="配置和启动kube-controller-manager"></a>配置和启动kube-controller-manager</h4><h4 id="启动kube-controller-manager"><a href="#启动kube-controller-manager" class="headerlink" title="启动kube-controller-manager"></a>启动kube-controller-manager</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp kube-apiserver.service /etc/systemd/system/</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable kube-apiserver</span><br><span class="line">systemctl start kube-apiserver</span><br><span class="line">systemctl status kube-apiserver</span><br></pre></td></tr></table></figure><h4 id="配置和启动kube-scheduler"><a href="#配置和启动kube-scheduler" class="headerlink" title="配置和启动kube-scheduler"></a>配置和启动kube-scheduler</h4><h4 id="创建kube-scheduler-的systemd-unit文件"><a href="#创建kube-scheduler-的systemd-unit文件" class="headerlink" title="创建kube-scheduler 的systemd unit文件"></a>创建kube-scheduler 的systemd unit文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kube-controller-manager.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Controller Manager</span><br><span class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/apps/svr/k8s/bin/kube-controller-manager \\</span><br><span class="line">  --address=127.0.0.1 \\</span><br><span class="line">  --master=http://$&#123;MASTER_URL&#125;:8080 \\</span><br><span class="line">  --allocate-node-cidrs=true \\</span><br><span class="line">  --service-cluster-ip-range=$&#123;SERVICE_CIDR&#125; \\</span><br><span class="line">  --cluster-cidr=$&#123;CLUSTER_CIDR&#125; \\</span><br><span class="line">  --cluster-name=kubernetes \\</span><br><span class="line">  --cluster-signing-cert-file=/apps/conf/kubernetes/ssl/ca.pem \\</span><br><span class="line">  --cluster-signing-key-file=/apps/conf/kubernetes/ssl/ca-key.pem \\</span><br><span class="line">  --service-account-private-key-file=/apps/conf/kubernetes/ssl/ca-key.pem \\</span><br><span class="line">  --root-ca-file=/apps/conf/kubernetes/ssl/ca.pem \\</span><br><span class="line">  --leader-elect=true \\</span><br><span class="line">  --v=2</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li><code>--address</code> 值必须为 <code>127.0.0.1</code>，因为当前 kube-apiserver 期望 scheduler 和 controller-manager 在同一台机器</li><li><code>--master=http://${MASTER_URL}:8080</code>：使用<code>http</code>(非安全端口)与 kube-apiserver 通信，需要下面的<code>haproxy</code>启动成功后才能去掉8080端口</li><li><code>--leader-elect=true</code> 部署多台机器组成的 master 集群时选举产生一处于工作状态的 <code>kube-controller-manager</code> 进程</li></ul><h3 id="启动kube-scheduler"><a href="#启动kube-scheduler" class="headerlink" title="启动kube-scheduler"></a>启动kube-scheduler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp kube-scheduler.service /etc/systemd/system/</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable kube-scheduler</span><br><span class="line">systemctl start kube-scheduler</span><br><span class="line">systemctl status kube-scheduler</span><br></pre></td></tr></table></figure><h2 id="6-4-验证master-节点"><a href="#6-4-验证master-节点" class="headerlink" title="6.4 验证master 节点"></a>6.4 验证master 节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get componentstatuses</span><br></pre></td></tr></table></figure><p>NAME STATUS MESSAGE ERROR<br>controller-manager Healthy ok<br>scheduler Healthy ok<br>etcd-1 Healthy {“health”: “true”}<br>etcd-2 Healthy {“health”: “true”}<br>etcd-0 Healthy {“health”: “true”}</p><h3 id="关于k8s-master节点高可用"><a href="#关于k8s-master节点高可用" class="headerlink" title="关于k8s master节点高可用"></a>关于k8s master节点高可用</h3><p>目前所谓的 Kubernetes HA 其实主要的就是 API Server 的 HA，master 上其他组件比如 controller-manager 等都是可以通过 Etcd 做选举；而 API Server 只是提供一个请求接收服务，所以对于 API Server 一般有两种方式做 HA；一种是对多个 API Server 做 vip，另一种使用 nginx 反向代理，本文采用 nginx 方式</p><p><strong>master 之间除 api server 以外其他组件通过 etcd 选举，api server 默认不作处理；在每个 node 上启动一个 nginx，每个 nginx 反向代理所有 api server，node 上 kubelet、kube-proxy 连接本地的 nginx 代理端口，当 nginx 发现无法连接后端时会自动踢掉出问题的 api server，从而实现 api server 的 HA</strong></p><p>实际上是通过keepalived + haproxy实现的，其中keepalived是提供一个VIP，通过VIP关联所有的Master节点；然后haproxy提供端口转发功能。由于VIP还是存在Master的机器上的，默认配置API Server的端口是6443，所以我们需要将另外一个端口关联到这个VIP上，一般用8443。</p><p><code>haproxy</code>的确可以代理我们的两个master 上的apiserver 了，但是还不是高可用的，如果master01 这个节点down 掉了，那么我们haproxy 就不能正常提供服务了。这里我们可以使用两种方法来实现高可用</p><h4 id="方式1：使用阿里云SLB"><a href="#方式1：使用阿里云SLB" class="headerlink" title="方式1：使用阿里云SLB"></a>方式1：使用阿里云SLB</h4><p>这种方式实际上是最省心的，在阿里云上建一个内网的SLB，将master01 与master02 添加到SLB 机器组中，转发80(http)和443(https)端口即可（注意下面的提示）</p><blockquote><p>注意：阿里云的负载均衡是四层TCP负责，不支持后端ECS实例既作为Real Server又作为客户端向所在的负载均衡实例发送请求。因为返回的数据包只在云服务器内部转发，不经过负载均衡，所以在后端ECS实例上去访问负载均衡的服务地址是不通的。什么意思？就是如果你要使用阿里云的SLB的话，那么你不能在<code>apiserver</code>节点上使用SLB（比如在apiserver 上安装kubectl，然后将apiserver的地址设置为SLB的负载地址使用），因为这样的话就可能造成回环了，所以简单的做法是另外用两个新的节点做<code>HA</code>实例，然后将这两个实例添加到<code>SLB</code> 机器组中。</p></blockquote><h4 id="方式2：使用keepalived"><a href="#方式2：使用keepalived" class="headerlink" title="方式2：使用keepalived"></a>方式2：使用keepalived</h4><p><code>KeepAlived</code> 是一个高可用方案，通过 VIP（即虚拟 IP）和心跳检测来实现高可用。其原理是存在一组（两台）服务器，分别赋予 Master、Backup 两个角色，默认情况下Master 会绑定VIP 到自己的网卡上，对外提供服务。Master、Backup 会在一定的时间间隔向对方发送心跳数据包来检测对方的状态，这个时间间隔一般为 2 秒钟，如果Backup 发现Master 宕机，那么Backup 会发送ARP 包到网关，把VIP 绑定到自己的网卡，此时Backup 对外提供服务，实现自动化的故障转移，当Master 恢复的时候会重新接管服务。非常类似于路由器中的虚拟路由器冗余协议（VRRP）</p><h4 id="安装haproxy、keepalived"><a href="#安装haproxy、keepalived" class="headerlink" title="安装haproxy、keepalived"></a>安装haproxy、keepalived</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y haproxy keepalived</span><br></pre></td></tr></table></figure><h4 id="配置haproxy"><a href="#配置haproxy" class="headerlink" title="配置haproxy"></a>配置haproxy</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">frontend k8s-api</span><br><span class="line">    bind 192.168.1.137:443</span><br><span class="line">    mode tcp</span><br><span class="line">    option tcplog</span><br><span class="line">    tcp-request inspect-delay 5s</span><br><span class="line">    tcp-request content accept if &#123; req.ssl_hello_type 1 &#125;</span><br><span class="line">    default_backend k8s-api</span><br><span class="line"></span><br><span class="line">backend k8s-api</span><br><span class="line">    mode tcp</span><br><span class="line">    option tcplog</span><br><span class="line">    option tcp-check</span><br><span class="line">    balance roundrobin</span><br><span class="line">    default-server inter 10s downinter 5s rise 2 fall 2 slowstart 60s maxconn 250 maxqueue 256 weight 100</span><br><span class="line">    server k8s-api-1 192.168.1.137:6443 check</span><br><span class="line">    server k8s-api-2 192.168.1.138:6443 check</span><br><span class="line"></span><br><span class="line">frontend k8s-http-api</span><br><span class="line">    bind 192.168.1.137:80</span><br><span class="line">    mode tcp</span><br><span class="line">    option tcplog</span><br><span class="line">    default_backend k8s-http-api</span><br><span class="line"></span><br><span class="line">backend k8s-http-api</span><br><span class="line">    mode tcp</span><br><span class="line">    option tcplog</span><br><span class="line">    option tcp-check</span><br><span class="line">    balance roundrobin</span><br><span class="line">    default-server inter 10s downinter 5s rise 2 fall 2 slowstart 60s maxconn 250 maxqueue 256 weight 100</span><br><span class="line">    server k8s-http-api-1 192.168.1.137:8080 check</span><br><span class="line">    server k8s-http-api-2 192.168.1.138:8080 check</span><br></pre></td></tr></table></figure><p>通过上面的配置文件我们可以看出通过<code>https</code>的访问将请求转发给apiserver 的6443端口了，http的请求转发到了apiserver 的8080端口。</p><h4 id="启动haproxy"><a href="#启动haproxy" class="headerlink" title="启动haproxy"></a>启动haproxy</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start haproxy</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> haproxy</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl status haproxy</span></span><br></pre></td></tr></table></figure><p>然后我们可以通过上面<code>9000</code>端口监控我们的<code>haproxy</code>的运行状态</p><p>上面我们的<code>haproxy</code>的确可以代理我们的两个master 上的apiserver 了，但是还不是高可用的，如果master01 这个节点down 掉了，那么我们haproxy 就不能正常提供服务了。这里我们可以使用两种方法来实现高可用</p><p><code>KeepAlived</code> 是一个高可用方案，通过 VIP（即虚拟 IP）和心跳检测来实现高可用。其原理是存在一组（两台）服务器，分别赋予 Master、Backup 两个角色，默认情况下Master 会绑定VIP 到自己的网卡上，对外提供服务。Master、Backup 会在一定的时间间隔向对方发送心跳数据包来检测对方的状态，这个时间间隔一般为 2 秒钟，如果Backup 发现Master 宕机，那么Backup 会发送ARP 包到网关，把VIP 绑定到自己的网卡，此时Backup 对外提供服务，实现自动化的故障转移，当Master 恢复的时候会重新接管服务。非常类似于路由器中的虚拟路由器冗余协议（VRRP）</p><p>我们这里将master01 设置为Master，master02 设置为Backup，修改配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi /etc/keepalived/keepalived.conf</span></span><br><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   router_id kube_api</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script check_haproxy &#123;</span><br><span class="line">    # 自身状态检测</span><br><span class="line">    script "killall -0 haproxy"</span><br><span class="line">    interval 3</span><br><span class="line">    weight 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance haproxy-vip &#123;</span><br><span class="line">    # 使用单播通信，默认是组播通信</span><br><span class="line">    unicast_src_ip 192.168.1.137</span><br><span class="line">    unicast_peer &#123;</span><br><span class="line">        192.168.1.138</span><br><span class="line">    &#125;</span><br><span class="line">    # 初始化状态</span><br><span class="line">    state MASTER</span><br><span class="line">    # 虚拟ip 绑定的网卡 （这里根据你自己的实际情况选择网卡）</span><br><span class="line">    interface eth0</span><br><span class="line">    # 此ID 要与Backup 配置一致</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    # 默认启动优先级，要比Backup 大点，但要控制量，保证自身状态检测生效</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        # 虚拟ip 地址</span><br><span class="line">        192.168.1.139</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_haproxy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.1.139 80 &#123;</span><br><span class="line">  delay_loop 5</span><br><span class="line">  lvs_sched wlc</span><br><span class="line">  lvs_method NAT</span><br><span class="line">  persistence_timeout 1800</span><br><span class="line">  protocol TCP</span><br><span class="line"></span><br><span class="line">  real_server 192.168.1.137 80 &#123;</span><br><span class="line">    weight 1</span><br><span class="line">    TCP_CHECK &#123;</span><br><span class="line">      connect_port 80</span><br><span class="line">      connect_timeout 3</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.1.139 443 &#123;</span><br><span class="line">  delay_loop 5</span><br><span class="line">  lvs_sched wlc</span><br><span class="line">  lvs_method NAT</span><br><span class="line">  persistence_timeout 1800</span><br><span class="line">  protocol TCP</span><br><span class="line"></span><br><span class="line">  real_server 192.168.1.137 443 &#123;</span><br><span class="line">    weight 1</span><br><span class="line">    TCP_CHECK &#123;</span><br><span class="line">      connect_port 443</span><br><span class="line">      connect_timeout 3</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>统一的方式在master02 节点上安装keepalived，修改配置，只需要将state 更改成BACKUP，priority更改成99，unicast_src_ip 与unicast_peer 地址修改即可。</p><p>启动keepalived:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl start keepalived</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">enable</span> keepalived</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看日志</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> journalctl -f -u keepalived</span></span><br></pre></td></tr></table></figure><p>验证虚拟IP:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用ifconfig -a 命令查看不到，要使用ip addr</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 00:16:3e:00:55:c1 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.1.137/24 brd 192.168.1.255 scope global dynamic eth0</span><br><span class="line">       valid_lft 31447746sec preferred_lft 31447746sec</span><br><span class="line">    inet 192.168.1.139/24 brd 192.168.1.255 scope global secondary eth0-vip</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><blockquote><p>到这里，我们就可以将上面的6443端口和8080端口去掉了，可以手动将<code>kubectl</code>生成的<code>config</code>文件(<code>~/.kube/config</code>)中的server 地址6443端口去掉，另外<code>kube-controller-manager</code>和<code>kube-scheduler</code>的<strong>–master</strong>参数中的8080端口去掉了，然后分别重启这两个组件即可。</p></blockquote><p>验证apiserver：关闭master01 节点上的kube-apiserver 进程，然后查看虚拟ip是否漂移到了master02 节点。</p><p>然后我们就可以将第一步在<code>/etc/hosts</code>里面设置的域名对应的IP 更改为我们的虚拟IP了</p><blockquote><p>master01 与master 02 节点都需要安装keepalived 和haproxy，实际上我们虚拟IP的自身检测应该是检测haproxy，脚本大家可以自行更改</p></blockquote><p>这样我们就实现了接入层apiserver 的高可用了，一个部分是多活的apiserver 服务，另一个部分是一主一备的haproxy 服务。</p><h4 id="kube-controller-manager-和kube-scheduler-的高可用"><a href="#kube-controller-manager-和kube-scheduler-的高可用" class="headerlink" title="kube-controller-manager 和kube-scheduler 的高可用"></a>kube-controller-manager 和kube-scheduler 的高可用</h4><p>Kubernetes 的管理层服务包括<code>kube-scheduler</code>和<code>kube-controller-manager</code>。kube-scheduler和kube-controller-manager使用一主多从的高可用方案，在<strong>同一时刻只允许一个服务</strong>处以具体的任务。Kubernetes中实现了一套简单的选主逻辑，依赖Etcd实现scheduler和controller-manager的选主功能。如果scheduler和controller-manager在启动的时候设置了<code>leader-elect</code>参数，它们在启动后会先尝试获取leader节点身份，只有在获取leader节点身份后才可以执行具体的业务逻辑。它们分别会在Etcd中创建kube-scheduler和kube-controller-manager的endpoint，endpoint的信息中记录了当前的leader节点信息，以及记录的上次更新时间。leader节点会定期更新endpoint的信息，维护自己的leader身份。每个从节点的服务都会定期检查endpoint的信息，如果endpoint的信息在时间范围内没有更新，它们会尝试更新自己为leader节点。scheduler服务以及controller-manager服务之间不会进行通信，利用Etcd的强一致性，能够保证在分布式高并发情况下leader节点的全局唯一性。整体方案如下图所示：</p><p>当集群中的leader节点服务异常后，其它节点的服务会尝试更新自身为leader节点，当有多个节点同时更新endpoint时，由Etcd保证只有一个服务的更新请求能够成功。通过这种机制sheduler和controller-manager可以保证在leader节点宕机后其它的节点可以顺利选主，保证服务故障后快速恢复。当集群中的网络出现故障时对服务的选主影响不是很大，因为scheduler和controller-manager是依赖Etcd进行选主的，在网络故障后，可以和Etcd通信的主机依然可以按照之前的逻辑进行选主，就算集群被切分，Etcd也可以保证同一时刻只有一个节点的服务处于leader状态。</p><h3 id="k8s-Node节点安装flannel网络"><a href="#k8s-Node节点安装flannel网络" class="headerlink" title="k8s Node节点安装flannel网络"></a>k8s Node节点安装flannel网络</h3><p>kubernetes 要求集群内各节点能通过Pod 网段互联互通，下面我们来使用Flannel 在所有节点上创建互联互通的Pod 网段的步骤。</p><h4 id="创建TLS-密钥和证书-1"><a href="#创建TLS-密钥和证书-1" class="headerlink" title="创建TLS 密钥和证书"></a>创建TLS 密钥和证书</h4><p>etcd 集群启用了双向TLS 认证，所以需要为flanneld 指定与etcd 集群通信的CA 和密钥。</p><p>创建flanneld 证书签名请求：</p><p>新建目录/apps/conf/flanneld/ssl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; flanneld-csr.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;flanneld&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>生成flanneld 证书和私钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=/apps/conf/kubernetes/ssl/ca.pem   -ca-key=/apps/conf/kubernetes/ssl/ca-key.pem   -config=/apps/conf/kubernetes/ssl/ca-config.json   -profile=kubernetes flanneld-csr.json | cfssljson -bare flanneld</span><br></pre></td></tr></table></figure><h4 id="向etcd-写入集群Pod-网段信息"><a href="#向etcd-写入集群Pod-网段信息" class="headerlink" title="向etcd 写入集群Pod 网段信息"></a>向etcd 写入集群Pod 网段信息</h4><p>该步骤只需在第一次部署Flannel 网络时执行，后续在其他节点上部署Flanneld 时无需再写入该信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl   --endpoints=$&#123;ETCD_ENDPOINTS&#125;   --ca-file=/apps/conf/kubernetes/ssl/ca.pem   --cert-file=/apps/conf/flanneld/ssl/flanneld.pem   --key-file=/apps/conf/flanneld/ssl/flanneld-key.pem   set $&#123;FLANNEL_ETCD_PREFIX&#125;/config &apos;&#123;&quot;Network&quot;:&quot;&apos;$&#123;CLUSTER_CIDR&#125;&apos;&quot;, &quot;SubnetLen&quot;: 24, &quot;Backend&quot;: &#123;&quot;Type&quot;: &quot;vxlan&quot;&#125;&#125;&apos;</span><br></pre></td></tr></table></figure><p>写入的 Pod 网段(${CLUSTER_CIDR}，10.200.0.0/16) 必须与<code>kube-controller-manager</code> 的 <code>--cluster-cidr</code> 选项值一致；</p><p>创建flanneld的systemd unit 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cd /apps/sh</span><br><span class="line">cat &gt; flanneld.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Flanneld overlay address etcd agent</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line">After=etcd.service</span><br><span class="line">Before=docker.service</span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/apps/svr/k8s/bin/flanneld \\</span><br><span class="line">  -etcd-cafile=/apps/conf/kubernetes/ssl/ca.pem \\</span><br><span class="line">  -etcd-certfile=/apps/conf/flanneld/ssl/flanneld.pem \\</span><br><span class="line">  -etcd-keyfile=/apps/conf/flanneld/ssl/flanneld-key.pem \\</span><br><span class="line">  -etcd-endpoints=$&#123;ETCD_ENDPOINTS&#125; \\</span><br><span class="line">  -etcd-prefix=$&#123;FLANNEL_ETCD_PREFIX&#125;</span><br><span class="line">ExecStartPost=/apps/svr/k8s/bin/mk-docker-opts.sh -k DOCKER_NETWORK_OPTIONS -d /run/flannel/docker</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">RequiredBy=docker.service</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li><code>mk-docker-opts.sh</code>脚本将分配给flanneld 的Pod 子网网段信息写入到<code>/run/flannel/docker</code> 文件中，后续docker 启动时使用这个文件中的参数值为 docker0 网桥</li><li>flanneld 使用系统缺省路由所在的接口和其他节点通信，对于有多个网络接口的机器(内网和公网)，可以用 <code>--iface</code> 选项值指定通信接口(上面的 systemd unit 文件没指定这个选项)</li></ul><h4 id="启动flanneld"><a href="#启动flanneld" class="headerlink" title="启动flanneld"></a>启动flanneld</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp flanneld.service /etc/systemd/system/</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable flanneld</span><br><span class="line">systemctl start flanneld</span><br></pre></td></tr></table></figure><h4 id="检查flanneld-服务"><a href="#检查flanneld-服务" class="headerlink" title="检查flanneld 服务"></a>检查flanneld 服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig flannel.1</span><br></pre></td></tr></table></figure><h4 id="检查分配给各flanneld-的Pod-网段信息"><a href="#检查分配给各flanneld-的Pod-网段信息" class="headerlink" title="检查分配给各flanneld 的Pod 网段信息"></a>检查分配给各flanneld 的Pod 网段信息</h4><p>查看集群 Pod 网段(/16)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">etcdctl \</span><br><span class="line"> --endpoints=$&#123;ETCD_ENDPOINTS&#125; \</span><br><span class="line"> --ca-file=/apps/conf/kubernetes/ssl/ca.pem \</span><br><span class="line"> --cert-file=/apps/conf/flanneld/ssl/flanneld.pem \</span><br><span class="line"> --key-file=/apps/conf/flanneld/ssl/flanneld-key.pem \</span><br><span class="line"> get $&#123;FLANNEL_ETCD_PREFIX&#125;/config</span><br></pre></td></tr></table></figure><p>{“Network”:”10.200.0.0/16”, “SubnetLen”: 24, “Backend”: {“Type”: “vxlan”}}</p><h3 id="部署-K8s-Node节点"><a href="#部署-K8s-Node节点" class="headerlink" title="部署 K8s Node节点"></a>部署 K8s Node节点</h3><p>kubernetes Node 节点包含如下组件：</p><ul><li>flanneld</li><li>docker</li><li>kubelet</li><li>kube-proxy</li></ul><h4 id="安装Docker基础环境"><a href="#安装Docker基础环境" class="headerlink" title="安装Docker基础环境"></a>安装Docker基础环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line">yum install docker-ce -y</span><br><span class="line">systemctl start docker &amp;&amp; systemctl enable docker</span><br></pre></td></tr></table></figure><h4 id="配置docker"><a href="#配置docker" class="headerlink" title="配置docker"></a>配置docker</h4><p>你可以用二进制或yum install 的方式来安装docker，然后修改docker 的systemd unit 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /usr/lib/systemd/system/docker.service  <span class="comment"># 用systemctl status docker 命令可查看unit 文件路径</span></span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">After=network-online.target firewalld.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line"><span class="meta">#</span><span class="bash"> the default is not to use systemd <span class="keyword">for</span> cgroups because the delegate issues still</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> exists and systemd currently does not support the cgroup feature <span class="built_in">set</span> required</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> containers run by docker</span></span><br><span class="line">EnvironmentFile=-/run/flannel/docker</span><br><span class="line">ExecStart=/usr/bin/dockerd --log-level=info $DOCKER_NETWORK_OPTIONS</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line"><span class="meta">#</span><span class="bash"> Having non-zero Limit*s causes performance problems due to accounting overhead</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> the kernel. We recommend using cgroups to <span class="keyword">do</span> container-local accounting.</span></span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line"><span class="meta">#</span><span class="bash"> Uncomment TasksMax <span class="keyword">if</span> your systemd version supports it.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Only systemd 226 and above support this version.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">TasksMax=infinity</span></span><br><span class="line">TimeoutStartSec=0</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> delegate yes so that systemd does not reset the cgroups of docker containers</span></span><br><span class="line">Delegate=yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">kill</span> only the docker process, not all processes <span class="keyword">in</span> the cgroup</span></span><br><span class="line">KillMode=process</span><br><span class="line"><span class="meta">#</span><span class="bash"> restart the docker process <span class="keyword">if</span> it exits prematurely</span></span><br><span class="line">Restart=on-failure</span><br><span class="line">StartLimitBurst=3</span><br><span class="line">StartLimitInterval=60s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>dockerd 运行时会调用其它 docker 命令，如 docker-proxy，所以需要将 docker 命令所在的目录加到 PATH 环境变量中</li><li>flanneld 启动时将网络配置写入到 <code>/run/flannel/docker</code> 文件中的变量 <code>DOCKER_NETWORK_OPTIONS</code>，dockerd 命令行上指定该变量值来设置 docker0 网桥参数</li><li>如果指定了多个 <code>EnvironmentFile</code> 选项，则必须将 <code>/run/flannel/docker</code> 放在最后(确保 docker0 使用 flanneld 生成的 bip 参数)</li><li>不能关闭默认开启的 <code>--iptables</code> 和 <code>--ip-masq</code> 选项</li><li>如果内核版本比较新，建议使用 <code>overlay</code> 存储驱动</li><li>docker 从 1.13 版本开始，可能将 <strong>iptables FORWARD chain的默认策略设置为DROP</strong>，从而导致 ping 其它 Node 上的 Pod IP 失败，遇到这种情况时，需要手动设置策略为 <code>ACCEPT</code>：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo iptables -P FORWARD ACCEPT</span></span><br></pre></td></tr></table></figure><p>如果没有开启上面的路由转发(<code>net.ipv4.ip_forward=1</code>)，则需要把以下命令写入<code>/etc/rc.local</code>文件中，防止节点重启<strong>iptables FORWARD chain的默认策略又还原为DROP</strong>（下面的开机脚本我测试了几次都没生效，不知道是不是方法有误，所以最好的方式还是开启上面的路由转发功能，一劳永逸）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep 60 &amp;&amp; /sbin/iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure><ul><li>为了加快 pull image 的速度，可以使用国内的仓库镜像服务器，同时增加下载的并发数。(如果 dockerd 已经运行，则需要重启 dockerd 生效。)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">  "max-concurrent-downloads": 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl stop firewalld</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">disable</span> firewalld</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo iptables -F &amp;&amp; sudo iptables -X &amp;&amp; sudo iptables -F -t nat &amp;&amp; sudo iptables -X -t nat</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker</span></span><br></pre></td></tr></table></figure><ul><li>需要关闭 firewalld(centos7)/ufw(ubuntu16.04)，否则可能会重复创建 iptables 规则</li><li>最好清理旧的 iptables rules 和 chains 规则</li><li>执行命令：docker version，检查docker服务是否正常</li></ul><h3 id="安装和配置kubelet"><a href="#安装和配置kubelet" class="headerlink" title="安装和配置kubelet"></a>安装和配置kubelet</h3><p>kubelet 启动时向kube-apiserver 发送TLS bootstrapping 请求，需要先将bootstrap token 文件中的kubelet-bootstrap 用户赋予system:node-bootstrapper 角色，然后kubelet 才有权限创建认证请求(certificatesigningrequests)：</p><blockquote><p>kubelet就是运行在Node节点上的，所以这一步安装是在所有的Node节点上，如果你想把你的Master也当做Node节点的话，当然也可以在Master节点上安装的。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create clusterrolebinding kubelet-bootstrap --clusterrole=system:node-bootstrapper --user=kubelet-bootstrap</span></span><br></pre></td></tr></table></figure><ul><li><code>--user=kubelet-bootstrap</code> 是文件 <code>/etc/kubernetes/token.csv</code> 中指定的用户名，同时也写入了文件 <code>/etc/kubernetes/bootstrap.kubeconfig</code></li></ul><p>另外1.8 版本中还需要为Node 请求创建一个RBAC 授权规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create clusterrolebinding kubelet-nodes --clusterrole=system:node --group=system:nodes</span></span><br></pre></td></tr></table></figure><p>然后下载最新的kubelet 和kube-proxy 二进制文件（前面下载kubernetes 目录下面其实也有）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://dl.k8s.io/v1.8.2/kubernetes-server-linux-amd64.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar -xzvf kubernetes-server-linux-amd64.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> kubernetes</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar -xzvf  kubernetes-src.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cp -r ./server/bin/&#123;kube-proxy,kubelet&#125; /usr/k8s/bin/</span></span><br></pre></td></tr></table></figure><h3 id="创建kubelet-bootstapping-kubeconfig-文件"><a href="#创建kubelet-bootstapping-kubeconfig-文件" class="headerlink" title="创建kubelet bootstapping kubeconfig 文件"></a>创建kubelet bootstapping kubeconfig 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置集群参数</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl config <span class="built_in">set</span>-cluster kubernetes \</span></span><br><span class="line">  --certificate-authority=/etc/kubernetes/ssl/ca.pem \</span><br><span class="line">  --embed-certs=true \</span><br><span class="line">  --server=$&#123;KUBE_APISERVER&#125; \</span><br><span class="line">  --kubeconfig=bootstrap.kubeconfig</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置客户端认证参数</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl config <span class="built_in">set</span>-credentials kubelet-bootstrap \</span></span><br><span class="line">  --token=$&#123;BOOTSTRAP_TOKEN&#125; \</span><br><span class="line">  --kubeconfig=bootstrap.kubeconfig</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置上下文参数</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl config <span class="built_in">set</span>-context default \</span></span><br><span class="line">  --cluster=kubernetes \</span><br><span class="line">  --user=kubelet-bootstrap \</span><br><span class="line">  --kubeconfig=bootstrap.kubeconfig</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置默认上下文</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl config use-context default --kubeconfig=bootstrap.kubeconfig</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv bootstrap.kubeconfig /etc/kubernetes/</span></span><br></pre></td></tr></table></figure><ul><li><code>--embed-certs</code> 为 <code>true</code> 时表示将 <code>certificate-authority</code> 证书写入到生成的 <code>bootstrap.kubeconfig</code> 文件中；</li><li>设置 kubelet 客户端认证参数时<strong>没有</strong>指定秘钥和证书，后续由 <code>kube-apiserver</code> 自动生成；</li></ul><h3 id="创建kubelet-的systemd-unit-文件"><a href="#创建kubelet-的systemd-unit-文件" class="headerlink" title="创建kubelet 的systemd unit 文件"></a>创建kubelet 的systemd unit 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir /var/lib/kubelet <span class="comment"># 必须先创建工作目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &gt; kubelet.service &lt;&lt;EOF</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Kubelet</span><br><span class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</span><br><span class="line">After=docker.service</span><br><span class="line">Requires=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">WorkingDirectory=/var/lib/kubelet</span><br><span class="line">ExecStart=/usr/k8s/bin/kubelet \\</span><br><span class="line">  --fail-swap-on=false \\</span><br><span class="line">  --cgroup-driver=cgroupfs \\</span><br><span class="line">  --address=$&#123;NODE_IP&#125; \\</span><br><span class="line">  --hostname-override=$&#123;NODE_IP&#125; \\</span><br><span class="line">  --experimental-bootstrap-kubeconfig=/etc/kubernetes/bootstrap.kubeconfig \\</span><br><span class="line">  --kubeconfig=/etc/kubernetes/kubelet.kubeconfig \\</span><br><span class="line">  --require-kubeconfig \\</span><br><span class="line">  --cert-dir=/etc/kubernetes/ssl \\</span><br><span class="line">  --cluster-dns=$&#123;CLUSTER_DNS_SVC_IP&#125; \\</span><br><span class="line">  --cluster-domain=$&#123;CLUSTER_DNS_DOMAIN&#125; \\</span><br><span class="line">  --hairpin-mode promiscuous-bridge \\</span><br><span class="line">  --allow-privileged=true \\</span><br><span class="line">  --serialize-image-pulls=false \\</span><br><span class="line">  --logtostderr=true \\</span><br><span class="line">  --v=2</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><blockquote><p><strong>请仔细阅读下面的注意事项，不然可能会启动失败</strong>。</p></blockquote><ul><li><code>--fail-swap-on</code>参数，这个一定要注意，<strong>Kubernetes 1.8开始要求关闭系统的Swap</strong>，如果不关闭，默认配置下kubelet将无法启动，也可以通过kubelet的启动参数<code>–fail-swap-on=false</code>来避免该问题</li><li><code>--cgroup-driver</code>参数，kubelet 用来维护主机的的 cgroups 的，默认是<code>cgroupfs</code>，但是这个地方的值需要你根据docker 的配置来确定（<code>docker info |grep cgroup</code>）</li><li><code>-address</code> 不能设置为 <code>127.0.0.1</code>，否则后续 Pods 访问 kubelet 的 API 接口时会失败，因为 Pods 访问的 <code>127.0.0.1</code>指向自己而不是 kubelet</li><li>如果设置了 <code>--hostname-override</code> 选项，则 <code>kube-proxy</code> 也需要设置该选项，否则会出现找不到 Node 的情况</li><li><code>--experimental-bootstrap-kubeconfig</code> 指向 bootstrap kubeconfig 文件，kubelet 使用该文件中的用户名和 token 向 kube-apiserver 发送 TLS Bootstrapping 请求</li><li>管理员通过了 CSR 请求后，kubelet 自动在 <code>--cert-dir</code> 目录创建证书和私钥文件(<code>kubelet-client.crt</code> 和 <code>kubelet-client.key</code>)，然后写入 <code>--kubeconfig</code> 文件(自动创建 <code>--kubeconfig</code> 指定的文件)</li><li>建议在 <code>--kubeconfig</code> 配置文件中指定 <code>kube-apiserver</code> 地址，如果未指定 <code>--api-servers</code> 选项，则必须指定 <code>--require-kubeconfig</code> 选项后才从配置文件中读取 kue-apiserver 的地址，否则 kubelet 启动后将找不到 kube-apiserver (日志中提示未找到 API Server），<code>kubectl get nodes</code> 不会返回对应的 Node 信息</li><li><code>--cluster-dns</code> 指定 kubedns 的 Service IP(可以先分配，后续创建 kubedns 服务时指定该 IP)，<code>--cluster-domain</code> 指定域名后缀，这两个参数同时指定后才会生效</li></ul><h3 id="启动kubelet"><a href="#启动kubelet" class="headerlink" title="启动kubelet"></a>启动kubelet</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cp kubelet.service /etc/systemd/system/kubelet.service</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> kubelet</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start kubelet</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl status kubelet</span></span><br></pre></td></tr></table></figure><h3 id="通过kubelet-的TLS-证书请求"><a href="#通过kubelet-的TLS-证书请求" class="headerlink" title="通过kubelet 的TLS 证书请求"></a>通过kubelet 的TLS 证书请求</h3><p>kubelet 首次启动时向kube-apiserver 发送证书签名请求，必须通过后kubernetes 系统才会将该 Node 加入到集群。查看未授权的CSR 请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get csr</span></span><br><span class="line">NAME                                                   AGE       REQUESTOR           CONDITION</span><br><span class="line">node-csr--k3G2G1EoM4h9w1FuJRjJjfbIPNxa551A8TZfW9dG-g   2m        kubelet-bootstrap   Pending</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes</span></span><br><span class="line">No resources found.</span><br></pre></td></tr></table></figure><p>通过CSR 请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl certificate approve node-csr--k3G2G1EoM4h9w1FuJRjJjfbIPNxa551A8TZfW9dG-g</span></span><br><span class="line">certificatesigningrequest "node-csr--k3G2G1EoM4h9w1FuJRjJjfbIPNxa551A8TZfW9dG-g" approved</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes</span></span><br><span class="line">NAME            STATUS    ROLES     AGE       VERSION</span><br><span class="line">192.168.1.170   Ready     &lt;none&gt;    48s       v1.8.1</span><br></pre></td></tr></table></figure><p>自动生成了kubelet kubeconfig 文件和公私钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l /etc/kubernetes/kubelet.kubeconfig</span></span><br><span class="line">-rw------- 1 root root 2280 Nov  7 10:26 /etc/kubernetes/kubelet.kubeconfig</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l /etc/kubernetes/ssl/kubelet*</span></span><br><span class="line">-rw-r--r-- 1 root root 1046 Nov  7 10:26 /etc/kubernetes/ssl/kubelet-client.crt</span><br><span class="line">-rw------- 1 root root  227 Nov  7 10:22 /etc/kubernetes/ssl/kubelet-client.key</span><br><span class="line">-rw-r--r-- 1 root root 1115 Nov  7 10:16 /etc/kubernetes/ssl/kubelet.crt</span><br><span class="line">-rw------- 1 root root 1675 Nov  7 10:16 /etc/kubernetes/ssl/kubelet.key</span><br></pre></td></tr></table></figure><h3 id="配置kube-proxy"><a href="#配置kube-proxy" class="headerlink" title="配置kube-proxy"></a>配置kube-proxy</h3><h4 id="创建kube-proxy-证书签名请求："><a href="#创建kube-proxy-证书签名请求：" class="headerlink" title="创建kube-proxy 证书签名请求："></a>创建kube-proxy 证书签名请求：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &gt; kube-proxy-csr.json &lt;&lt;EOF</span></span><br><span class="line">&#123;</span><br><span class="line">  "CN": "system:kube-proxy",</span><br><span class="line">  "hosts": [],</span><br><span class="line">  "key": &#123;</span><br><span class="line">    "algo": "rsa",</span><br><span class="line">    "size": 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  "names": [</span><br><span class="line">    &#123;</span><br><span class="line">      "C": "CN",</span><br><span class="line">      "ST": "BeiJing",</span><br><span class="line">      "L": "BeiJing",</span><br><span class="line">      "O": "k8s",</span><br><span class="line">      "OU": "System"</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>CN 指定该证书的 User 为 <code>system:kube-proxy</code></li><li><code>kube-apiserver</code> 预定义的 RoleBinding <code>system:node-proxier</code> 将User <code>system:kube-proxy</code> 与 Role <code>system:node-proxier</code>绑定，该 Role 授予了调用 <code>kube-apiserver</code> Proxy 相关 API 的权限</li><li>hosts 属性值为空列表</li></ul><h4 id="生成kube-proxy-客户端证书和私钥"><a href="#生成kube-proxy-客户端证书和私钥" class="headerlink" title="生成kube-proxy 客户端证书和私钥"></a>生成kube-proxy 客户端证书和私钥</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cfssl gencert -ca=/etc/kubernetes/ssl/ca.pem \</span></span><br><span class="line">  -ca-key=/etc/kubernetes/ssl/ca-key.pem \</span><br><span class="line">  -config=/etc/kubernetes/ssl/ca-config.json \</span><br><span class="line">  -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls kube-proxy*</span></span><br><span class="line">kube-proxy.csr  kube-proxy-csr.json  kube-proxy-key.pem  kube-proxy.pem</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mv kube-proxy*.pem /etc/kubernetes/ssl/</span></span><br></pre></td></tr></table></figure><h4 id="创建kube-proxy-kubeconfig-文件"><a href="#创建kube-proxy-kubeconfig-文件" class="headerlink" title="创建kube-proxy kubeconfig 文件"></a>创建kube-proxy kubeconfig 文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置集群参数</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl config <span class="built_in">set</span>-cluster kubernetes \</span></span><br><span class="line">  --certificate-authority=/etc/kubernetes/ssl/ca.pem \</span><br><span class="line">  --embed-certs=true \</span><br><span class="line">  --server=$&#123;KUBE_APISERVER&#125; \</span><br><span class="line">  --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置客户端认证参数</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl config <span class="built_in">set</span>-credentials kube-proxy \</span></span><br><span class="line">  --client-certificate=/etc/kubernetes/ssl/kube-proxy.pem \</span><br><span class="line">  --client-key=/etc/kubernetes/ssl/kube-proxy-key.pem \</span><br><span class="line">  --embed-certs=true \</span><br><span class="line">  --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置上下文参数</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl config <span class="built_in">set</span>-context default \</span></span><br><span class="line">  --cluster=kubernetes \</span><br><span class="line">  --user=kube-proxy \</span><br><span class="line">  --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置默认上下文</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv kube-proxy.kubeconfig /etc/kubernetes/</span></span><br></pre></td></tr></table></figure><ul><li>设置集群参数和客户端认证参数时 <code>--embed-certs</code> 都为 <code>true</code>，这会将 <code>certificate-authority</code>、<code>client-certificate</code> 和 <code>client-key</code> 指向的证书文件内容写入到生成的 <code>kube-proxy.kubeconfig</code> 文件中</li><li><code>kube-proxy.pem</code> 证书中 CN 为 <code>system:kube-proxy</code>，<code>kube-apiserver</code> 预定义的 RoleBinding <code>cluster-admin</code> 将User <code>system:kube-proxy</code> 与 Role <code>system:node-proxier</code> 绑定，该 Role 授予了调用 <code>kube-apiserver</code> Proxy 相关 API 的权限</li></ul><h4 id="创建kube-proxy-的systemd-unit-文件"><a href="#创建kube-proxy-的systemd-unit-文件" class="headerlink" title="创建kube-proxy 的systemd unit 文件"></a>创建kube-proxy 的systemd unit 文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir -p /var/lib/kube-proxy <span class="comment"># 必须先创建工作目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &gt; kube-proxy.service &lt;&lt;EOF</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Kube-Proxy Server</span><br><span class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">WorkingDirectory=/var/lib/kube-proxy</span><br><span class="line">ExecStart=/usr/k8s/bin/kube-proxy \\</span><br><span class="line">  --bind-address=$&#123;NODE_IP&#125; \\</span><br><span class="line">  --hostname-override=$&#123;NODE_IP&#125; \\</span><br><span class="line">  --cluster-cidr=$&#123;SERVICE_CIDR&#125; \\</span><br><span class="line">  --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig \\</span><br><span class="line">  --logtostderr=true \\</span><br><span class="line">  --v=2</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li><code>--hostname-override</code> 参数值必须与 kubelet 的值一致，否则 kube-proxy 启动后会找不到该 Node，从而不会创建任何 iptables 规则</li><li><code>--cluster-cidr</code> 必须与 kube-apiserver 的 <code>--service-cluster-ip-range</code> 选项值一致</li><li>kube-proxy 根据 <code>--cluster-cidr</code> 判断集群内部和外部流量，指定 <code>--cluster-cidr</code> 或 <code>--masquerade-all</code> 选项后 kube-proxy 才会对访问 Service IP 的请求做 SNAT</li><li><code>--kubeconfig</code> 指定的配置文件嵌入了 kube-apiserver 的地址、用户名、证书、秘钥等请求和认证信息</li><li>预定义的 RoleBinding <code>cluster-admin</code> 将User <code>system:kube-proxy</code> 与 Role <code>system:node-proxier</code> 绑定，该 Role 授予了调用 <code>kube-apiserver</code> Proxy 相关 API 的权限</li></ul><h4 id="启动kube-proxy"><a href="#启动kube-proxy" class="headerlink" title="启动kube-proxy"></a>启动kube-proxy</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cp kube-proxy.service /etc/systemd/system/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> kube-proxy</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start kube-proxy</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl status kube-proxy</span></span><br></pre></td></tr></table></figure><h3 id="验证集群功能"><a href="#验证集群功能" class="headerlink" title="验证集群功能"></a>验证集群功能</h3><p>定义yaml 文件：（将下面内容保存为：nginx-ds.yaml）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-ds</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx-ds</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx-ds</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-ds</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="string">addonmanager.kubernetes.io/mode:</span> <span class="string">Reconcile</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx-ds</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>创建 Pod 和服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f nginx-ds.yml</span></span><br><span class="line">service "nginx-ds" created</span><br><span class="line">daemonset "nginx-ds" created</span><br></pre></td></tr></table></figure><p>执行下面的命令查看Pod 和SVC：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -o wide</span></span><br><span class="line">NAME             READY     STATUS    RESTARTS   AGE       IP           NODE</span><br><span class="line">nginx-ds-f29zt   1/1       Running   0          23m       172.17.0.2   192.168.1.170</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc</span></span><br><span class="line">NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">nginx-ds     NodePort    10.254.6.249   &lt;none&gt;        80:30813/TCP   24m</span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li>服务IP：10.254.6.249</li><li>服务端口：80</li><li>NodePort端口：30813</li></ul><p>在所有 Node 上执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl 10.254.6.249</span><br><span class="line">$ curl 192.168.1.170:30813</span><br></pre></td></tr></table></figure><p>执行上面的命令预期都会输出nginx 欢迎页面内容，表示我们的Node 节点正常运行了。</p><h3 id="解决从k8s-gcr-io拉取镜像失败问题"><a href="#解决从k8s-gcr-io拉取镜像失败问题" class="headerlink" title="解决从k8s.gcr.io拉取镜像失败问题"></a>解决从k8s.gcr.io拉取镜像失败问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker pull mirrorgooglecontainers/kube-apiserver-amd64:v1.11.3</span><br><span class="line">docker pull mirrorgooglecontainers/kube-controller-manager-amd64:v1.11.3</span><br><span class="line">docker pull mirrorgooglecontainers/kube-scheduler-amd64:v1.11.3</span><br><span class="line">docker pull mirrorgooglecontainers/kube-proxy-amd64:v1.11.3</span><br><span class="line">docker pull mirrorgooglecontainers/pause:3.1</span><br><span class="line">docker pull mirrorgooglecontainers/etcd-amd64:3.2.18</span><br><span class="line">docker pull coredns/coredns:1.1.3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker tag docker.io/mirrorgooglecontainers/kube-proxy-amd64:v1.11.3 k8s.gcr.io/kube-proxy-amd64:v1.11.3</span><br><span class="line">docker tag docker.io/mirrorgooglecontainers/kube-scheduler-amd64:v1.11.3 k8s.gcr.io/kube-scheduler-amd64:v1.11.3</span><br><span class="line">docker tag docker.io/mirrorgooglecontainers/kube-apiserver-amd64:v1.11.3 k8s.gcr.io/kube-apiserver-amd64:v1.11.3</span><br><span class="line">docker tag docker.io/mirrorgooglecontainers/kube-controller-manager-amd64:v1.11.3 k8s.gcr.io/kube-controller-manager-amd64:v1.11.3</span><br><span class="line">docker tag docker.io/mirrorgooglecontainers/etcd-amd64:3.2.18  k8s.gcr.io/etcd-amd64:3.2.18</span><br><span class="line">docker tag docker.io/mirrorgooglecontainers/pause:3.1  k8s.gcr.io/pause:3.1</span><br><span class="line">docker tag docker.io/coredns/coredns:1.1.3  k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.qikqiak.com/post/manual-install-high-available-kubernetes-cluster/" target="_blank" rel="noopener">https://www.qikqiak.com/post/manual-install-high-available-kubernetes-cluster/</a></li><li><a href="https://github.com/mendickxiao/kubeasz/blob/master/docs/00-%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A.md" target="_blank" rel="noopener">https://github.com/mendickxiao/kubeasz/blob/master/docs/00-%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A.md</a></li><li><a href="https://jimmysong.io/kubernetes-handbook/practice/master-ha.html" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/practice/master-ha.html#</a></li><li><a href="https://www.kubernetes.org.cn/5025.html" target="_blank" rel="noopener">https://www.kubernetes.org.cn/5025.html</a></li><li><a href="https://www.kubernetes.org.cn/4963.html" target="_blank" rel="noopener">https://www.kubernetes.org.cn/4963.html</a></li><li><a href="https://k8s-install.opsnull.com/01.%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.html" target="_blank" rel="noopener">https://k8s-install.opsnull.com/01.%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.html</a></li><li><a href="https://kubernetes.feisky.xyz/bu-shu-pei-zhi/index" target="_blank" rel="noopener">https://kubernetes.feisky.xyz/bu-shu-pei-zhi/index</a></li><li><a href="https://mritd.me/2017/07/21/set-up-kubernetes-ha-cluster-by-binary/" target="_blank" rel="noopener">https://mritd.me/2017/07/21/set-up-kubernetes-ha-cluster-by-binary/</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;集群节点-初始化&quot;&gt;&lt;a href=&quot;#集群节点-初始化&quot; class=&quot;headerlink&quot; title=&quot;集群节点 初始化&quot;&gt;&lt;/a&gt;集群节点 初始化&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>DevOps &amp; SRE 必备技能清单</title>
    <link href="https://yo42.github.io/2018/10/28/DevOps-SRE-%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E6%B8%85%E5%8D%95/"/>
    <id>https://yo42.github.io/2018/10/28/DevOps-SRE-必备技能清单/</id>
    <published>2018-10-28T03:45:57.769Z</published>
    <updated>2018-10-28T06:52:44.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul><li>这个列表并非详尽无遗，只是列举了技术基础、必须知道的技能和一些随机的想法。可以用它们作为一个清单来评估你自己或其他人，或者为下一次面试DevOps/SRE（Site Reliability Engineers，网站可靠性工程师）工作做准备。补充下，这个清单是比较个人的想法。</li></ul><p><strong>下一步是什么？更了解DevOps生态系统：</strong></p><ul><li>首先，一定要了解文化要点的重要性：在这里（<a href="http://w.san.wccnw.top/browse.php?u=Gp/XsLMboegkekS/h/8BHXb0sTOQAoHmBSzaAaweVgZL9wvn3ZkrIAh8m848ZkDJvewBfBudLtEkKJwX5q6rCTiNJyF6QA==&amp;b=13" target="_blank" rel="noopener">15点DevOps检查表</a> ）可以读到更多信息。</li><li>您应该掌握类Unix系统并且很好地理解Linux发行版的工作原理。</li><li>为产品设置选择一个操作系统。不需要掌握每一个操作系统，这会让你的工作陷入困境，选择其中一个并掌握它。</li><li>能轻松使用终端，可能有一些GUI来管理服务器，但是无论如何，必须热爱终端，它更快、更安全，坦白说，一旦掌握了用起来会更容易。</li><li>如何获取CPU/系统信息（cat /proc/version，/proc/cpuinfo，uptime，等。）</li><li>cron作业如何运作。在特定日期/时间/月设置cron作业。</li><li>了解在机器上运行的操作系统是什么（cat /etc/lsb-release）</li><li>了解不同的Linux操作系统之间的区别，以及了解在机器上运行的操作系统（例如cat /etc/lsb-release）</li><li>shell之间的区别：sh/dash/bash/ash/zsh</li><li>如何设置和取消设置ENV变量。导出的ENV变量是临时的，如何导出永久的变量？</li><li>什么是shell配置文件：〜/.bashrc，.bash_profile，.environment .. 如何为程序初始化文件“添加”设置？</li><li>了解Vim，其配置（.vimrc）及其一些基本提示是必须的。</li><li>日志如何在*nix系统中运行，什么是日志记录级别以及如何使用日志管理工具（rsyslog，logstash，fluentd，logwatch，awslogs ..）</li><li>swapping如何工作。swappiness是什么。（swapon -s，/proc/sys/vm/swappiness，sysctl vm.swappiness ..）</li><li>能轻松使用脚本语言轻松自如。Bash是必须了解的（其他脚本语言也是非常有用的，如Python，Perl ..）。</li><li>掌握有用的命令，例如进程监控命令（ps，top，htop，atop ..），系统性能命令（nmon，iostat，sar，vmstat..）和网络故障排除和分析（nmap，tcpdump，ping，traceroute，airmon，airodump ..）。</li><li>你的备份策略是什么？如何测试备份的可靠性？</li><li>你知道ext4，ntfs，fat？知道联合文件系统（Union FS）吗？</li><li>如何在系统上查看/设置网络配置？</li><li>如何在具有不同子网的计算机上设置静态/动态IP地址？（提示：CIDR）</li><li>使用网络数据包分析来分析和了解网络的工作原理：tcpdump，Wireshark ..</li><li>你熟悉OSI模型和TCP/IP模型的规范吗？TCP和UDP有什么区别？你知道vxlan吗？</li><li>如何设置防火墙（iptables，至少知道ufw）：设置规则，列出规则，路由流量，阻止协议/端口 ..</li><li>如何查看/设置/备份路由器设置？</li><li>DNS如何工作？如何设置DNS服务器（Bind，Unbound，PowerDNS，Dnsmasq ..）？递归（recursive）和权威（authoritative）DNS有什么区别？如何排除DNS故障（nslookup，dig ..）</li><li>熟悉DNS和A，AAAA，C，CNAME，TXT记录</li><li>当你在浏览器中点击google.com时会发生什么？从浏览器的缓存、本地DNS缓存、本地网络配置（hosts文件）、路由、DNS、网络、Web协议中，缓存系统到Web服务器（如果深入分析，最基本的问题也很难回答）。</li><li>熟悉CDN提供商（fastly，Akamai等）</li><li>熟悉SSL/TLS的工作原理以及数字证书的工作原理（https）</li><li>了解SSL证书（需要加密）</li><li>熟悉更安全的协议和工具：TLS，STARTTLS，SCP，SSH，<br>SFTP，FTPS ..</li><li>了解PPTP，OpenVPN，L2TP/IPSec之间的区别</li><li>学习为域设置记录集（可以使用Route53或CloudFlare等托管云服务）</li><li>SSH如何工作，如何调试它，如何生成ssh密钥以及无密码登录到其他计算机</li><li>什么是init系统？你知道Systemd（自15.04以来由Ubuntu使<br>用），Upstart（由Ubuntu开发），SysV ..</li><li>用任何软件的源代码编译它（gcc，make和其他相关内容）</li><li>如何通过终端用不同的格式压缩/解压缩文件（主要是：tar/tar.gz）</li><li>如何设置Web服务器（Apache，Nginx ..）</li><li>学习使用“awk，sed，sort，uniq”操作Nginx/Apache日志文件</li><li>Nginx和Apache有什么区别？什么时候使用Nginx？什么时候使用Apache？在同一个Web应用程序中，何时以及如何同时使用它们？</li><li>如何设置反向代理（Nginx ..）</li><li>如何设置缓存服务器（Squid，Nginx，Varnish ..）</li><li>如何设置负载均衡器（HAproxy，Nginx ..）</li><li>如何为您的微服务建立API网关（Ambassador，Kong，Traefik，Nginx ..）</li><li>熟悉Systemd以及如何使用systemctl和journalctl等命令分析和管理服务</li><li>熟悉OAuth、SAML、Auth0集成</li><li>熟悉RESTful API，Webhooks，GraphQL，gRPC</li><li>确保ES集群安全（XPack（商业），OpenSource：ReadOnlyREST，Search Guard）</li><li>使用snapshot API或esdump进行ES备份（快照和增量）（注意：需要nodejs/npm）</li><li>使用DB备份</li><li>学习Python（pip + setup.py）和BASH。您是否开始使用Golang作为脚本语言？尝试一下吧。</li><li>发展云计算技能。从选择云基础架构提供商开始：Amazon Web Services，Google Cloud Platform，Digitalocean，Microsoft Azure。或者使用OpenStack创建自己的私有云。</li><li>staging服务器怎么样？单元测试的测试策略是什么？端到端？真的需要staging服务器吗？Google下“staging servers must die”。</li><li>阅读有关PaaS/Iaas/Saas/CaaS/FaaS/DaaS和无服务器架构的信息</li><li>了解如何通过CLI中的Cloud Shell，或你的程序中的Cloud SDK，来使用和配置云资源</li><li>了解如何使用至少一个配置管理和远程执行工具（Ansible，Puppet，SaltStack，Chef 等）。您的选择应基于以下标准：语法，性能，模板语言，推拉模型，性能，架构，与其他工具的集成，可伸缩性，可用性等等。</li><li>用于image构建的Packer</li><li>将Jenkins集成到CI/CD中</li><li>设置Consul（用于服务发现）</li><li>开始研究“基础架构即代码”（infrastructure as code），以及基础架构配置自动化工具，如Terraform和Packer</li><li>开始研究容器和Docker。容器是底层架构（cgroups和namespaces），它是如何工作的？</li><li>开始熟悉基本的Docker命令（logs/inspect/top/ps/rm）。另外得研究docker hub（push/pull image）</li><li>开始研究容器编排工具：Docker Swarm，Kubernetes，Mesosphere DC/OS，AWS ECS</li><li>阅读有关无状态和有状态应用程序的知识</li><li>学习为您的应用程序构建小型的docker image（alpine比较合适）。仅安装所需的包就够了。</li><li>了解默认运行服务的最常用端口号（如：SSH（22），Web（80），HTTP/S（443）等）</li><li>从分布式角度学习网络（在容器世界中建立网络）。利用分布式系统中的8个谬论，让自己轻松应对。</li><li>了解L4/L7负载均衡器。</li><li>了解如何确保代理服务器和反向代理服务器的安全（Nginx，Traefik，Ambassador ..），并了解它们的网络系统是如何工作的。</li><li>熟悉帮助创建可分发和可移植开发环境的工具（例如：Vagrant和Docker）。</li><li>部署应用程序时，管理私密信息。Hashicorp Vault会帮助你。</li><li>了解AWS SQS，Google PubSub或其它替代方案。</li><li>熟悉Kafka，AWS Kinesis或其它替代方案。</li><li>了解AWS RDS，大多数时候Ops发现很容易将普通任务委派给服务提供商以避免额外的工作，但这会带来一些费用。</li><li>如果你在使用Kubernetes，那么了解它的所有组件和工作。</li><li>学习如何首先处理K8s内置功能，然后学习Helm/Istio。</li><li>了解监控的方式和内容（从操作系统和应用程序的角度来看）。</li><li>一旦到了合适的阶段，接着会需要追踪（Tracing）来帮助理解和挖掘，并且应用程序需要直接支持它</li><li>如果您正在处理（大）数据工程相关应用程序，那么得熟悉Hadoop，HBase，Zookeeper，Spark以及如何设置相关集群</li><li>学习如何根据应用需求设置和调整Redis，如何添加身份验证。</li><li>了解应用程序的性质：CPU密集型，内存密集型，I/O密集型，然后了解如何相应地进行处理。</li><li>学习根据需要在不同类型的数据库之间进行选择：SQL，NoSQL，TSDB，图形数据库 ..</li><li>学习管理IAM角色/权限以及如何管理不同用户的密钥（AWS IAM，GCP IAM ..）。</li><li>如果您喜欢分享并帮助其他人解决遇到过的问题，请将代码发布到GitHub。</li><li>学习对基础架构和应用程序进行基准测试以填补空白。</li><li>不要直接去执行。先可视化最终目标、画图、与开发人员详细讨论、毫不犹豫地提问、让问题彻底变得愚蠢。</li><li>不时做小型演示或PoC以便更好地理解。</li><li>你熟悉IDE（Sublime Text，Atom，Eclipse ..）吗？</li><li>深入了解DB（MySQL或任何其它你喜欢的数据库）。</li><li>了解Redis/Memcache以及类似工具。</li><li>了解微服务架构的优缺点，并开始构建类似的架构。</li><li>了解如何配置和使用持续集成和持续交付工具，如Jenkins，Travis CI，Buildbot，GoCd。将这些工具与其它工具（如Selenium，构建工具，配置管理软件，Docker，云供应商的SDK等）集成是非常有帮助的。</li><li>学习分布式版本控制系统Git及其基本命令（pull/push/commit/clone/branch/merge/logs等）。了解git工作流程。你知道如何将Git存储库恢复到以前的提交吗？</li><li>如何使用SSH密钥。尝试使用Github，Bitbucket或Gitlab .. 来配置对repo/account的无密码访问。</li><li>熟悉内核版本的混乱以及如何修补它们。</li><li>了解如何生成校验（md5，SHA ..）以验证任何文件的完整性。</li><li>了解单体（Monolithic）和微服务（Microservices）架构之间的区别。</li><li>如何实现零宕机部署？制定回滚、自修复、自动扩展的策略是什么？</li><li>了解可扩展性和高度分布式系统，如何让它们一直保持运行状态？</li><li>熟悉API和服务：RESTfull，RESTful-like，API网关，Lambda函数，serverless计算，SOA，SOAP，JMS，CRUD ..</li><li>如何确保基础架构、网络和运行的应用程序的安全？</li><li>你知道什么是ChatOps吗？是否尝试过使用一个已知框架？ Hubot，Lita，Cog？</li><li>了解如何设置、配置和使用某些监控系统（Nagios，Zabix，Sensu，Prometheus ..）</li><li>无论你做什么都“记录下来”，无论多么粗糙，做吧。稍后，你会感谢自己的。</li><li>制作小的代码脚本以方便使用，记下命令或片段（通过StackOverflow，Github Gists或其它在线记事板），它会帮助你得到想要的东西。</li><li>让Google，StackExchange，Quora和其它专业论坛成为您的朋友。</li><li>读，读，读。在Twitter/StackOverflow上提问。</li><li>参加会议。可以加入我们当地的聚会，如<a href="http://w.yi.wccnw.top/browse.php?u=3%2bEbCNhA3ow7CQsuY03Ew%2b9bUDOiA8frvqmO0moiy16kn9PAhr7AbzM1BBi%2bWSf0tTYVufBAGhmEHqFP&amp;b=5" target="_blank" rel="noopener">DevOpsLinks Community会议（班加罗尔）</a>，<a href="http://w.yi.wccnw.top/browse.php?u=3%2bEbCNhA3ow7CQsuY03Ew%2b9bUDOiA8frvqmO0moiy36kn9PAhr7AbzMVBBi%2bWSf0tTQ=&amp;b=5" target="_blank" rel="noopener">DevOpsLinks Community会议（伦敦）</a>和<a href="http://w.yi.wccnw.top/browse.php?u=3%2bEbCNhA3ow7CQsuY03Ew%2b9bUDOiA8frvqmO0moiy1Cul8rchrDHO04ZExS5Hw==&amp;b=5" target="_blank" rel="noopener">DevOpsLinks Community会议（巴黎）</a>。如果想组织当地的聚会，请联系我们，我们将为您提供帮助！</li><li>与同一领域的研究员交谈并讨论您的问题。通过<a href="http://w.yi.wccnw.top/browse.php?u=lvQbQ8pBxtIlAAc0fU7Ew%2b9b&amp;b=5" target="_blank" rel="noopener">社区</a>学习。</li><li>加入我们的<a href="http://w.yi.wccnw.top/browse.php?u=lvQbQ8pBxtIlAAc0fU7Ew%2b9b&amp;b=5" target="_blank" rel="noopener">Slack频道</a>并询问您的所有（菜鸟级）问题，都没问题！我们都是从开始起步的。</li><li>不要试图解决所有问题。永远记住一件事：没有人是一座孤岛。你不能做、学习、实现一切。要了解对于手头的任务最重要的是什么。</li><li>阅读DevOps词汇表（请Google它）</li><li>关注开源项目（Kubernetes/Docker等）或者让您感到兴奋的东西。</li><li>关注来自<a href="http://w.yi.wccnw.top/browse.php?u=lvQbQ8pBxtIlAAc0fU7Ew%2b9b&amp;b=5" target="_blank" rel="noopener">社区</a>的志同道合的人，并了解最新的科技趋势。</li><li>尝试搭建良好的开发实践以及坚实的架构。</li><li>了解如何在生产级别进行扩展。</li><li>了解如何在生产服务器中实时调试和跟踪运行的应用程序。</li><li>关注一些合适的科技公司的技术博客（我们跟随：Google/Uber/Quora/Github/Netflix）。这是您可以直接从专家那里学习的地方，并有机会看到他们解决任何问题的方法。</li><li>浏览一些新闻聚合器，如Reddit，hackernews，medium等。</li><li>在twitter上关注志同道合的开发人员和技术公司。 （我总是阅读文章和观看谈话/会议，事后剖析（post-mortems）是我最喜欢的内容。我也关注一些github库看看我使用的技术发生了什么。）</li><li>加入<a href="http://w.yi.wccnw.top/browse.php?u=lvQbQ8pBxtIlAAc0fU7Ew%2b9b&amp;b=5" target="_blank" rel="noopener">DevOpsLinks</a>、<a href="http://w.yi.wccnw.top/browse.php?u=lvQbTM5H3cM/AkAib0c=&amp;b=5" target="_blank" rel="noopener">Kaptain</a>和<a href="http://w.yi.wccnw.top/browse.php?u=lvQbTcBex9E%2bBR4qc1nEw%2b9b&amp;b=5" target="_blank" rel="noopener">Shipped</a>！我们相信你会学到很多东西，即使你是专家，你仍然不得不更多地学习。</li><li>阅读各种与技术相关的博客并订阅DevOps Newsletters。顺便说一句，我们有一份<a href="http://w.yi.wccnw.top/browse.php?u=3%2bEbCMJSzcsjAUA5eVDFxOVAEAe0GeH1ppY=&amp;b=5" target="_blank" rel="noopener">出版物</a>，您可以提交您的文章并与社区分享。</li><li>了解开源以及<a href="http://w.yi.wccnw.top/browse.php?u=lvQbTdlZ2ow1DUE4elKNj7IGTkHoRLi0/9PI3Sw3g2rmg8vQm6PdeXALTByoXzzn63QnvfAKCBqeHqcF5g==&amp;b=5" target="_blank" rel="noopener">如何</a>为开源项目做出贡献。</li><li>如果系统出现问题，您应该能够进行事后剖析。详细记录出现了什么问题，以及如何防止它再次发生。</li><li>尝试学习StackOverflow的专家如何解决问题。永远记住，方法是不断变化的，不像基础知识总是保持不变。</li><li>读书。</li><li>最后这点也很重要……不要假设任何事情，永远不要把现实视为理所当然，总是去尝试并享受旅程。</li></ul><p>如果您拥有以上大部分技能，则可以确保您具备DevOps、SRE和系统工程知识的先决条件。</p><p>你无法一次性学习所有这些，但是具备这样一个思维模式是主要的。 即使去熟悉所有这些也肯定需要时间，但俗话说旅程很有趣。 你会失败很多次，并从错误中吸取教训，不要重蹈覆辙。</p><p><strong>永远记住，我们都是学生。我们通过碰撞和试验来学习。不要羞于失败，因为这就是学习的方式。</strong></p><p><strong>DevOpsLinks</strong>，一个来自世界各地的DevOps专业人士和从业者的社区。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://res.infoq.com/articles/the-must-know-checklist-for-devops-and-sre/zh/resources/4924-1539417307400.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure></p><p><strong>Shipped</strong>，一个专注于无服务计算、FaaS和其他有趣主题的技术的社区。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://res.infoq.com/articles/the-must-know-checklist-for-devops-and-sre/zh/resources/4225-1539417307128.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure></p><p><strong>Kaptain</strong>：一个Kubernetes社区中心，主要包括手工策划的时事通讯、团队聊天、培训和更多（即将推出）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://res.infoq.com/articles/the-must-know-checklist-for-devops-and-sre/zh/resources/3626-1539417306768.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="http://www.infoq.com/cn/articles/the-must-know-checklist-for-devops-and-sre" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/the-must-know-checklist-for-devops-and-sre</a></li><li><a href="https://hackernoon.com/the-must-know-checklist-for-devops-site-reliability-engineers-update-8ba44dbc824" target="_blank" rel="noopener">https://hackernoon.com/the-must-know-checklist-for-devops-site-reliability-engineers-update-8ba44dbc824</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;这个列表并非详尽无遗，只是列举了技术基础、必须知道的技能和一些随机的想法。可以用它们作为一个清单来评估你自己或其他人，或者为下一
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>初尝Node.js</title>
    <link href="https://yo42.github.io/2018/10/01/%E5%88%9D%E5%B0%9DNode-js/"/>
    <id>https://yo42.github.io/2018/10/01/初尝Node-js/</id>
    <published>2018-10-01T09:16:58.959Z</published>
    <updated>2018-10-14T09:38:36.025Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js® 是一个基于 <a href="https://developers.google.com/v8/" target="_blank" rel="noopener">Chrome V8 引擎</a> 的 JavaScript 运行时。</p><p><strong>Node.js</strong>是一个能够在服务器端运行<a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a>的<a href="https://zh.wikipedia.org/wiki/%E9%96%8B%E6%94%BE%E5%8E%9F%E5%A7%8B%E7%A2%BC" target="_blank" rel="noopener">开放源代码</a>、<a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E5%B9%B3%E5%8F%B0" target="_blank" rel="noopener">跨平台</a>JavaScript <a href="https://zh.wikipedia.org/wiki/%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener">运行环境</a>。</p><p><strong>Node.js采用了<a href="https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95" target="_blank" rel="noopener">事件驱动</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E9%9D%9E%E9%98%BB%E5%A1%9E&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">非阻塞</a>和 <a href="https://zh.wikipedia.org/w/index.php?title=%E9%9D%9E%E5%90%8C%E6%AD%A5%E8%BC%B8%E5%85%A5%E8%BC%B8%E5%87%BA&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">异步输入输出</a>模型等技术来提高性能</strong>，可优化应用程序的传输量和规模。这些技术通常用于数据密集的实时应用程序。</p><p><strong>Node.js以单线程运行，使用非阻塞I/O调用，这样既可以支持数以万计的并发连线，又不会因多线程本身的特点而带来麻烦。众多请求只使用单线程的设计意味着可以用于创建高并发应用程序。</strong>Node.js应用程序的设计目标是任何需要操作I/O的函数都使用<a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">回调函数</a>。</p><p>这种设计的缺点是，如果不使用<a href="https://nodejs.org/api/cluster.html" target="_blank" rel="noopener">cluster</a>、<a href="http://strong-pm.io/" target="_blank" rel="noopener">StrongLoop Process Manager</a>或<a href="https://github.com/Unitech/pm2" target="_blank" rel="noopener">pm2</a>等模块，Node.js就难以处理多核或多线程等情况。</p><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>nvm:Node.js版本控制器，用于切换多版本的Node.js环境。</p><p>npm:（全称 Node Package Manager，即“node包管理器”）是<a href="https://zh.wikipedia.org/wiki/Node.js" target="_blank" rel="noopener">Node.js</a>默认的、以<a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a>编写的<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94%E5%A5%97%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1" target="_blank" rel="noopener">软件包管理系统</a>。</p><p>Node.js Express 框架: 相当于Python的Flask框架</p><p>Node.js多进程:<a href="https://nodejs.org/api/cluster.html" target="_blank" rel="noopener">cluster</a>、<a href="https://github.com/Unitech/pm2" target="_blank" rel="noopener">pm2</a></p><p>Node.js核心内置模块:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http：提供HTTP服务器功能。</span><br><span class="line">url：解析URL。</span><br><span class="line">fs：与文件系统交互。</span><br><span class="line">querystring：解析URL的查询字符串。</span><br><span class="line">child_process：新建子进程。</span><br><span class="line">util：提供一系列实用小工具。</span><br><span class="line">path：处理文件路径。</span><br><span class="line">crypto：提供加密和解密功能，基本上是对OpenSSL的包装。</span><br></pre></td></tr></table></figure><h1 id="阻塞对比非阻塞一览"><a href="#阻塞对比非阻塞一览" class="headerlink" title="阻塞对比非阻塞一览"></a>阻塞对比非阻塞一览</h1><p>本概论涵盖了在 Node.js 中 <strong>阻塞</strong> and <strong>非阻塞</strong> 的区别，同时也会牵涉到时间轮询和 libuv 方面，不需要先行了解这些方面的知识也可以继续阅读。我们假定读者对于 JavaScript 语言和 Node.js 的回调机制有一个基本的了解。</p><blockquote><p>“I/O” 指的是系统磁盘和由 <a href="http://libuv.org/" target="_blank" rel="noopener">libuv</a> 支持的网络之间的交互。</p></blockquote><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p><strong>阻塞</strong> 是说 Node.js 中其它的 JavaScript 命令必须等到一个非 JavaScript 操作完成之后才可以执行。这是因为当 <strong>阻塞</strong> 发生时，事件机制无法继续运行JavaScript。</p><p>在 Node.js 中，JavaScript由于 CPU 密集操作而表现不佳。而不是等待非 JavaScript操作 （例如I/O）。这被称为 <strong>阻塞</strong>。在 Node.js 基本类库中，使用 libuv 的同步方法大多数都是 <strong>阻塞</strong> 的。原生方法也可能是 <strong>阻塞</strong> 的。</p><p>所有在 Node.js 中提供的 I/O 方法也包括异步版本，它们都是 <strong>非阻塞</strong> 的，接受回调函数。一些方法同时也具备 <strong>阻塞</strong> 功能，它们的名字结尾都以 <code>Sync</code> 结尾。</p><h2 id="代码比较"><a href="#代码比较" class="headerlink" title="代码比较"></a>代码比较</h2><p><strong>阻塞</strong> 方法执行起来是 <strong>同步地</strong>，但是 <strong>非阻塞</strong> 方法执行起来是 <strong>异步地</strong>。 如果你使用文件系统模块读取一个文件，同步方法看上去如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> data = fs.readFileSync(<span class="string">'/file.md'</span>); <span class="comment">// blocks here until file is read</span></span><br></pre></td></tr></table></figure><p>这是一个与之功能等同的 <strong>异步</strong> 版本示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'/file.md'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第一个示例看上去比第二个似乎简单些，但是有一个缺陷：第二行语句会 <strong>阻塞</strong> 其它 JavaScript 语句的执行直到整个文件全部读取完毕。注意在同步版本的代码中，任何异常都会抛出，会导致整个程序崩溃。在异步版本示例代码中，它由作者来决定是否抛出异常。</p><p>让我们扩展一点我们的同步代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> data = fs.readFileSync(<span class="string">'/file.md'</span>); <span class="comment">// blocks here until file is read</span></span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line"><span class="comment">// moreWork(); will run after console.log</span></span><br></pre></td></tr></table></figure><p>这是一个类似的，但是功能上不等同的异步代码示例版本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'/file.md'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// moreWork(); will run before console.log</span></span><br></pre></td></tr></table></figure><p>第一个示例代码中， <code>console.log</code> 将在 <code>moreWork()</code> 之前被调用。在第二个例子中， <code>fs.readFile()</code> 因为是 <strong>非阻塞</strong> 的，所以 JavaScript 会继续执行， <code>moreWork()</code> 将被首先调用。<code>moreWork()</code> 无需等待文件读完而先行执行完毕，这对于高效吞吐来说是一个绝佳的设计。</p><h2 id="并行和吞吐"><a href="#并行和吞吐" class="headerlink" title="并行和吞吐"></a>并行和吞吐</h2><p>在 Node.js 中 JavaScript 的执行是单线程的，所以并行与事件轮询能力（即在完成其它任务之后处理 JavaScript 回调函数的能力）有关。任何一个企图以并行的方式运行的代码必须让事件轮询机制以非 JavaScript 操作来运行，像 I/O 操作。</p><p>举个例子，让我们思考一个案例：案例中每个对服务器的请求消耗 50 毫秒完成，其中的 45 毫秒又是可以通过异步操作而完成的数据库操作。选择 <strong>非阻塞</strong> 操作可以释放那 45 毫秒用以处理其它的请求操作。这是在选择 <strong>阻塞</strong> 和 <strong>非阻塞</strong> 方法上的重大区别。</p><p>Node.js 中的事件轮询机制和其它语言相比而言有区别，其它语言需要创建线程来处理并行任务。</p><h2 id="把阻塞和非阻塞代码混在一起写的危险"><a href="#把阻塞和非阻塞代码混在一起写的危险" class="headerlink" title="把阻塞和非阻塞代码混在一起写的危险"></a>把阻塞和非阻塞代码混在一起写的危险</h2><p>在处理 I/O 问题时，有些东西必须避免。下面让我们看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'/file.md'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">fs.unlinkSync(<span class="string">'/file.md'</span>);</span><br></pre></td></tr></table></figure><p>在以上的例子中， <code>fs.unlinkSync()</code> 极有可能在 <code>fs.readFile()</code> 之前执行，所以在真正准备开始读取文件前此文件就已经被删除了。一个更好的处理方法就是彻底让使它变得 <strong>非阻塞化</strong>，并且保证按照正确顺序执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'/file.md'</span>, (readFileErr, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (readFileErr) <span class="keyword">throw</span> readFileErr;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  fs.unlink(<span class="string">'/file.md'</span>, (unlinkErr) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (unlinkErr) <span class="keyword">throw</span> unlinkErr;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上代码在 <code>fs.readFile()</code> 用异步方式调用 <code>fs.unlink()</code>，这就保证了执行顺序的正确。</p><h2 id="第一个应用"><a href="#第一个应用" class="headerlink" title="第一个应用"></a>第一个应用</h2><p>app.js # require命令用于指定加载模块，加载时可以省略脚本文件的后缀名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">'127.0.0.1'</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.statusCode = <span class="number">200</span>;</span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(port, hostname, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后使用 <code>node app.js</code> 运行程序，访问 <a href="http://localhost:3000%EF%BC%8C%E4%BD%A0%E5%B0%B1%E4%BC%9A%E7%9C%8B%E5%88%B0%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%EF%BC%8C%E5%86%99%E7%9D%80%E2%80%9CHello/" target="_blank" rel="noopener">http://localhost:3000，你就会看到一个消息，写着“Hello</a> World”。</p><h3 id="Run-Node-js-in-Docker"><a href="#Run-Node-js-in-Docker" class="headerlink" title="Run Node.js in Docker"></a>Run Node.js in Docker</h3><h4 id="创建-Node-js-应用"><a href="#创建-Node-js-应用" class="headerlink" title="创建 Node.js 应用"></a>创建 Node.js 应用</h4><p>首先，创建一个新文件夹以便于容纳需要的所有文件，并且在此其中创建一个 <code>package.json</code> 文件，描述你应用程序以及需要的依赖：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"docker_web_app"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Node.js on Docker"</span>,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"Neo  &lt;Neo42@mail.com&gt;"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"server.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node app2mongo.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"express"</span>: <span class="string">"^4.16.3"</span>,</span><br><span class="line">    <span class="attr">"mongodb"</span>: <span class="string">"^3.1.6"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配合着你的 <code>package.json</code> 请运行 <code>npm install</code>。如果你使用的 <code>npm</code> 是版本 5 或者之后的版本，这会自动生成一个 <code>package-lock.json</code> 文件，它将一起被拷贝进入你的 Docker 镜像中。</p><h4 id="安装-MongoDB-driver-for-Node-js"><a href="#安装-MongoDB-driver-for-Node-js" class="headerlink" title="安装 MongoDB driver for Node.js."></a>安装 <a href="https://www.mongodb.com/" target="_blank" rel="noopener">MongoDB</a> driver for Node.js.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mongodb --save</span><br></pre></td></tr></table></figure><p>App2mongo.js # 操作测试Mongodb</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertDocuments = <span class="function"><span class="keyword">function</span>(<span class="params">db, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Get the documents collection</span></span><br><span class="line">  <span class="keyword">const</span> collection = db.collection(<span class="string">'documents'</span>);</span><br><span class="line">  <span class="comment">// Insert some documents</span></span><br><span class="line">  collection.insertMany([</span><br><span class="line">    &#123;<span class="attr">Neo</span> : <span class="number">42</span>&#125;, &#123;<span class="attr">a</span> : <span class="number">2</span>&#125;, &#123;<span class="attr">a</span> : <span class="number">3</span>&#125;</span><br><span class="line">  ], <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    assert.equal(err, <span class="literal">null</span>);</span><br><span class="line">    assert.equal(<span class="number">3</span>, result.result.n);</span><br><span class="line">    assert.equal(<span class="number">3</span>, result.ops.length);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Inserted 3 documents into the collection Neo"</span>);</span><br><span class="line">    callback(result);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findDocuments = <span class="function"><span class="keyword">function</span>(<span class="params">db, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Get the documents collection</span></span><br><span class="line">  <span class="keyword">const</span> collection = db.collection(<span class="string">'documents'</span>);</span><br><span class="line">  <span class="comment">// Find some documents</span></span><br><span class="line">  collection.find(&#123;&#125;).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, docs</span>) </span>&#123;</span><br><span class="line">    assert.equal(err, <span class="literal">null</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Found the following records"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(docs)</span><br><span class="line">    callback(docs);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connection URL</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">'mongodb://192.168.0.103:27017'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Database Name</span></span><br><span class="line"><span class="keyword">const</span> dbName = <span class="string">'Neo42'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use connect method to connect to the server</span></span><br><span class="line">MongoClient.connect(url, <span class="function"><span class="keyword">function</span>(<span class="params">err, client</span>) </span>&#123;</span><br><span class="line">  assert.equal(<span class="literal">null</span>, err);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Connected correctly to server Neo42"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> db = client.db(dbName);</span><br><span class="line"></span><br><span class="line">  insertDocuments(db, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    findDocuments(db, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      client.close();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="创建Dockerfile"><a href="#创建Dockerfile" class="headerlink" title="创建Dockerfile"></a>创建Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create app directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Install app dependencies</span></span></span><br><span class="line"><span class="bash"><span class="comment"># A wildcard is used to ensure both package.json AND package-lock.json are copied</span></span></span><br><span class="line"><span class="bash"><span class="comment"># where available (npm@5+)</span></span></span><br><span class="line"><span class="bash">COPY package*.json ./</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN npm install</span></span><br><span class="line"><span class="bash"><span class="comment"># If you are building your code for production</span></span></span><br><span class="line"><span class="bash"><span class="comment"># RUN npm install --only=production</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Bundle app source</span></span></span><br><span class="line"><span class="bash">COPY . .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 8080</span></span><br><span class="line"><span class="bash">CMD [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure><h4 id="构建DockerImage"><a href="#构建DockerImage" class="headerlink" title="构建DockerImage"></a>构建DockerImage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t Neo:42/node-web-app .</span><br></pre></td></tr></table></figure><h4 id="Run-Docker"><a href="#Run-Docker" class="headerlink" title="Run Docker"></a>Run Docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -d Neo:42/node-web-app</span><br></pre></td></tr></table></figure><h4 id="运行输出"><a href="#运行输出" class="headerlink" title="运行输出"></a>运行输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Connected correctly to server Neo42 # 连接数据库</span><br><span class="line">Inserted 3 documents into the collection Neo # 插入doc</span><br><span class="line">Found the following records # 查询</span><br><span class="line">[ &#123; _id: 5bb1e06dc2bf97000f0e1886, Neo: 42 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e06dc2bf97000f0e1887, a: 2 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e06dc2bf97000f0e1888, a: 3 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e2bb0c25dc000fa94345, Neo: 42 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e2bb0c25dc000fa94346, a: 2 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e2bb0c25dc000fa94347, a: 3 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e30bb78d09000f1ff341, Neo: 42 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e30bb78d09000f1ff342, a: 2 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e30bb78d09000f1ff343, a: 3 &#125; ]</span><br></pre></td></tr></table></figure><h2 id="Node-js-PM2-Runtime"><a href="#Node-js-PM2-Runtime" class="headerlink" title="Node.js PM2 Runtime"></a>Node.js PM2 Runtime</h2><p>PM2 is a Production Runtime and Process Manager for Node.js applications with a built-in Load Balancer. It allows you to keep applications alive forever, to reload them without downtime and facilitate common Devops tasks.</p><p><strong>Advanced, production process manager for Node.js</strong></p><p><strong>PM2 Features:高效管理多进程、日志分析记录简单的监控、集群扩展、部署方便等…..</strong></p><p><strong>PM2群集模式和重新加载操作可以避免停机时间。</strong></p><h3 id="Using-PM2-with-Docker"><a href="#Using-PM2-with-Docker" class="headerlink" title="Using PM2 with Docker"></a>Using PM2 with Docker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">neo_42</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── ecosystem.config.js</span><br><span class="line">├── package.json</span><br><span class="line">└── src</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br></pre></td></tr></table></figure><p>生成ecosystem.config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 init</span><br></pre></td></tr></table></figure><p>app.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line"></span><br><span class="line">// Constants</span><br><span class="line">const PORT = 8080;</span><br><span class="line">const HOST = &apos;0.0.0.0&apos;;</span><br><span class="line"></span><br><span class="line">// App</span><br><span class="line">const app = express();</span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&apos;Hello world\n&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(PORT, HOST);</span><br><span class="line">console.log(`Running on http://$&#123;HOST&#125;:$&#123;PORT&#125;`);</span><br></pre></td></tr></table></figure><p>Dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FROM keymetrics/pm2:latest-alpine</span><br><span class="line"></span><br><span class="line">WORKDIR src/</span><br><span class="line"># Bundle APP files</span><br><span class="line">COPY src src/</span><br><span class="line">COPY package.json .</span><br><span class="line">COPY ecosystem.config.js .</span><br><span class="line"></span><br><span class="line"># Install app dependencies</span><br><span class="line">ENV NPM_CONFIG_LOGLEVEL warn</span><br><span class="line">RUN npm install --production</span><br><span class="line"></span><br><span class="line"># Expose the listening port of your app</span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line"># Show current folder structure in logs</span><br><span class="line">#RUN ls -al -R</span><br><span class="line"></span><br><span class="line">CMD [ &quot;pm2-runtime&quot;, &quot;start&quot;, &quot;ecosystem.config.js&quot; ]</span><br><span class="line">#CMD [&quot;pm2-runtime&quot;, &quot;ecosystem.config.js&quot;, &quot;--web&quot;]</span><br></pre></td></tr></table></figure><p>构建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &apos;neo/pm2:v1&apos; .</span><br></pre></td></tr></table></figure><p>Run</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:8080 -d neo/pm2:v1</span><br></pre></td></tr></table></figure><p>Pm2 Commands</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 051 pm2  ls</span><br><span class="line">docker exec -it 051 pm2 monit</span><br></pre></td></tr></table></figure><p>Pm2 Commands参考<a href="http://pm2.keymetrics.io/docs/usage/quick-start/" target="_blank" rel="noopener">http://pm2.keymetrics.io/docs/usage/quick-start/</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://nodejs.org/zh-cn/docs/guides/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/docs/guides/</a></li><li><a href="https://zh.wikipedia.org/zh-cn/Node.js" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-cn/Node.js</a></li><li><a href="https://github.com/nodejs/docker-node/tree/526c6e618300bdda0da4b3159df682cae83e14aa#dockerfile" target="_blank" rel="noopener">https://github.com/nodejs/docker-node/tree/526c6e618300bdda0da4b3159df682cae83e14aa#dockerfile</a></li><li><a href="https://github.com/Unitech/PM2/" target="_blank" rel="noopener">https://github.com/Unitech/PM2/</a></li><li><a href="https://pm2.io/doc/en/runtime/integration/docker/" target="_blank" rel="noopener">https://pm2.io/doc/en/runtime/integration/docker/</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Node.js® 是一个基于 &lt;a href=&quot;https://developers.google.com/v8/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chrome V8 引擎&lt;/a&gt; 的 JavaScript 运行时。&lt;/p&gt;
&lt;p&gt;&lt;stro
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>DevOps最全术语汇总</title>
    <link href="https://yo42.github.io/2018/09/24/DevOps%E6%9C%80%E5%85%A8%E6%9C%AF%E8%AF%AD%E6%B1%87%E6%80%BB/"/>
    <id>https://yo42.github.io/2018/09/24/DevOps最全术语汇总/</id>
    <published>2018-09-24T06:46:15.204Z</published>
    <updated>2018-09-24T06:51:59.900Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>A/B Testing</p><p><a href="https://xebialabs.com/glossary/a/b-testing/" target="_blank" rel="noopener">A/B测试</a></p><p>使用A/B测试的技术将新功能或某项功能的不同变体推向不同组别的用户，这些功能可通过比较指标和用户行为进行评估。</p><p>Acceptance Testing</p><p><a href="https://xebialabs.com/glossary/acceptance-testing/" target="_blank" rel="noopener">验收测试</a></p><p>通常对整个系统进行高级测试，以确定新功能和现有功能的整体质量是否足以让系统投入生产。</p><p>Agent</p><p><a href="https://xebialabs.com/glossary/agent/" target="_blank" rel="noopener">代理程序</a></p><p>代理程序是安装在特定物理服务器上的程序，用于在该服务器上处理不同进程的执行。</p><p>Agile</p><p><a href="https://xebialabs.com/glossary/agile/" target="_blank" rel="noopener">敏捷</a></p><p>是DevOps的前身；敏捷是一种软件开发方法，更广泛来说，是一种业务方法。敏捷强调短期迭代的规划和开发周期以提供更好的控制以及可预测性，并支持随着项目的发展而不断变化的需求。</p><p>ARA (Application Release Automation)</p><p><a href="https://xebialabs.com/glossary/ara-(application-release-automation" target="_blank" rel="noopener">ARA （应用程序发布自动化）</a>/)</p><p>可以在目标环境中自动安装和正确配置给定应用程序版本并随时可用的工具、脚本或产品。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>Behavior-Driven Development (BDD)</p><p><a href="https://xebialabs.com/glossary/behavior-driven-development-(bdd" target="_blank" rel="noopener">行为驱动开发（BDD）</a>/)</p><p>一种开发方法，强调软件应该根据应用程序的期望行为并以业务管理人员可读的语法来指定。</p><p>Black Box Testing</p><p><a href="https://xebialabs.com/glossary/black-box-testing/" target="_blank" rel="noopener">黑盒测试</a></p><p>一种测试或质量保证实践，它假设不知道被测系统内部的工作原理，因此尝试验证外部而不是内部行为或状态。</p><p>Build Agent</p><p>Build Agent</p><p>一种用于持续集成的代理程序，可以本地或远程安装，跟持续集成服务器有关。它发送和接收跟处理软件构建有关的消息。</p><p>Build Artifact Repository</p><p><a href="https://xebialabs.com/glossary/build-artifact-repository/" target="_blank" rel="noopener">构建工件存储库</a></p><p>用于组织具有元数据构造的工件，并允许自动发布和使用这些工件的工具。</p><p>Build Automation</p><p><a href="https://xebialabs.com/glossary/build-automation/" target="_blank" rel="noopener">构建自动化</a></p><p>允许将源代码自动编译为可发布的二进制代码的工具或框架。通常包括代码级的单元测试，以确保代码的各个部分按预期运行。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>Canary Release</p><p><a href="https://xebialabs.com/glossary/canary-release/" target="_blank" rel="noopener">灰度发布</a>（金丝雀发布）</p><p>一种上线策略，在该策略中，把新的应用程序版本发布到生产服务器的一小部分上，并严格监控以确定其是否按预期运行。如果一切看起来稳定，那么新版本将推广到整个生产环境。</p><p>Configuration Drift</p><p><a href="https://xebialabs.com/glossary/configuration-drift/" target="_blank" rel="noopener">配置漂移</a></p><p>由于手工的特殊更改（如热修复）没有引入到系统模版中而引起软件和硬件配置与系统模版版本漂移或不一致。</p><p>Configuration Management</p><p><a href="https://xebialabs.com/glossary/configuration-management/" target="_blank" rel="noopener">配置管理</a></p><p>用于建立和维护系统一致的设置和功能属性的术语。它包括用于IT基础设施自动化等系统管理任务的工具。</p><p>Continuous Delivery</p><p><a href="https://xebialabs.com/glossary/continuous-delivery/" target="_blank" rel="noopener">持续交付</a>（CD)</p><p>持续交付是一套流程和实践，从根本上清除软件生产过程中的浪费，能更快地交付高质量的功能，并在业务和用户之间建立快速有效的反馈环。</p><p>Continuous Integration (CI)</p><p><a href="https://xebialabs.com/glossary/continuous-integration-(ci" target="_blank" rel="noopener">持续集成（CI）</a>/)</p><p>持续集成（CI）是一种开发实践，它要求开发人员每天多次把代码集成到共享存储库中。然后通过自动构建验证每次签入，使得团队能尽早发现问题。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>Dark Launch</p><p><a href="https://xebialabs.com/glossary/dark-launch/" target="_blank" rel="noopener">灰度上线</a></p><p>一种上线策略，其中实现新功能的代码被发布到生产环境的子集，但是不可见或只是部分激活。然而，该代码是在生产环境中运行，用户并不知晓。</p><p>Delivery Pipeline</p><p><a href="https://xebialabs.com/glossary/delivery-pipeline/" target="_blank" rel="noopener">交付管道</a></p><p>一系列为新应用程序版本实施软件交付过程的编排的、自动化的任务。该管道中的每个步骤旨在提高新版本的置信度，使其能够做出合格/不合格的决策。交付管道可以被看作是组织发布流程的优化结果。</p><p>DevOps</p><p>DevOps</p><p>DevOps（开发和运维）是一个软件开发短语，用于描述开发和IT运维之间的敏捷关系。DevOps的目标是改善在软件开发周期中不同角色之间的沟通、协作和流程，以改善和加速软件交付。</p><p>DevOps Intelligence</p><p><a href="https://xebialabs.com/glossary/devops-intelligence/" target="_blank" rel="noopener">DevOps</a>智能</p><p>提供公司所需的洞察力，以更高效、更低风险和更好结果的方式交付软件，</p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>Functional Testing</p><p><a href="https://xebialabs.com/glossary/functional-testing/" target="_blank" rel="noopener">功能测试</a></p><p>进行端到端系统的测试以验证（新）功能。使用可执行规范，通过运行针对应用程序的规范来进行功能测试。</p><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>Infrastructure as a Service (IaaS)</p><p><a href="https://xebialabs.com/glossary/infrastructure-as-a-service-(iaas" target="_blank" rel="noopener">基础</a>/)<a href="https://xebialabs.com/glossary/infrastructure-as-a-service-(iaas" target="_blank" rel="noopener">设施</a>/)<a href="https://xebialabs.com/glossary/infrastructure-as-a-service-(iaas" target="_blank" rel="noopener">即服务（IaaS）</a>/)</p><p>云托管的虚拟机器通常根据“按需付费”收费。用户对机器有完全的控制，但是需要自己安装和配置所需的中间件和应用程序。</p><p>Infrastructure as Code</p><p><a href="https://xebialabs.com/glossary/infrastructure-as-code/" target="_blank" rel="noopener">基础</a><a href="https://xebialabs.com/glossary/infrastructure-as-code/" target="_blank" rel="noopener">设施</a><a href="https://xebialabs.com/glossary/infrastructure-as-code/" target="_blank" rel="noopener">即代码</a>（IaC)</p><p>一种系统配置管理技术，其中以完全自动化的形式指定机器、网络设备、操作系统、中间件等。规范或“蓝图”被认为是代码，由供应工具执行，保存在版本控制中，通常遵循用于应用程序代码开发的相同实践。</p><h3 id="L"><a href="#L" class="headerlink" title="L"></a>L</h3><p>Lean</p><p><a href="https://xebialabs.com/glossary/lean/" target="_blank" rel="noopener">精益</a></p><p>“精益制造”或“精益生产”是一种方式或方法，旨在通过专注于保护价值来减少生产过程中的浪费。它很大程度上来源于丰田公司在汽车制造业中开发的实践，精益概念已经作为敏捷方法的部分被应用于软件开发。价值流程图（VSM）试图直观地识别有价值和有浪费的流程步骤，是个关键的精益工具。</p><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>Microservices</p><p><a href="https://xebialabs.com/glossary/microservices/" target="_blank" rel="noopener">微服务</a></p><p>微服务是一种软件架构设计模式，其中复杂的应用程序由独立的小型进程构成，这些进程使用与语言无关的API进行通信。这些服务规模小，高度分离，专注于完成一个小任务。</p><h3 id="N"><a href="#N" class="headerlink" title="N"></a>N</h3><p>Non-functional Requirements (NFRs)</p><p><a href="https://xebialabs.com/glossary/non-functional-requirements-(nfrs" target="_blank" rel="noopener">非功能性需求（NFRs）</a>/)</p><p>系统质量的规范，诸如易用性，设计清晰度，延迟，速度，处理大量用户的能力等，描述了如何轻松或高效地使用某个功能，而不只是它是否存在。这些特性可以使用持续交付反馈环来解决和改善。</p><p>NoOps</p><p>NoOps</p><p>在一个公司中，应用程序运行的系统管理要么是完全由外部一方（如PaaS 供应商）来处理，要么就是全自动化的。使用NoOps旨在尽量减少或不使用内部运维能力和员工。</p><h3 id="O"><a href="#O" class="headerlink" title="O"></a>O</h3><p>Orchestration Pipeline</p><p><a href="https://xebialabs.com/glossary/orchestration-pipeline/" target="_blank" rel="noopener">编排管道</a></p><p>在适当的时间调用形成持续交付管道的不同自动化任务的工具或产品。它们通常也记录每个任务的状态和输出，并通过管道可视化特征流。</p><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>Platform as a Service (PaaS)</p><p><a href="https://xebialabs.com/glossary/platform-as-a-service-(paas" target="_blank" rel="noopener">平台即服务（PaaS）</a>/)</p><p>云托管的应用程序运行时间通常根据“按需支付”的原则计费。用户提供应用程序代码和有限的配置设置，中间件、数据库等都是提供的运行时的一部分。</p><p>Product Owner</p><p><a href="https://xebialabs.com/glossary/product-owner/" target="_blank" rel="noopener">产品负责人</a></p><p>开发团队中负责定义、确定优先级和维护未完成功能及其他工作的人或角色。产品负责人在敏捷软件开发方法中很常见，通常代表业务或客户组织。相比在更传统的软件开发过程中的同行，产品负责人需要在敏捷开发流程中扮演更积极的日常角色。</p><p>Provisioning</p><p><a href="https://xebialabs.com/glossary/provisioning/" target="_blank" rel="noopener">服务开通</a></p><p>为用户（在持续交付的场景下，通常是开发或测试团队）准备新系统的过程。该系统通常根据需要进行虚拟化和实例化。配置机器以安装操作系统、中间件等操作是由自动化的系统配置管理工具来处理，这些自动化工具还验证所需要的配置是否得到维护。</p><h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><p>Regression Testing</p><p><a href="https://xebialabs.com/glossary/regression-testing/" target="_blank" rel="noopener">回归测试</a></p><p>对端到端系统的测试，以验证应用程序的更改没有对现有功能产生负面影响。</p><p>Release Coordination</p><p><a href="https://xebialabs.com/glossary/release-coordination/" target="_blank" rel="noopener">发布协调</a></p><p>定义和执行从代码签入到生效的新功能（或功能集）所需的所有操作。在持续交付环境中，这在很大程度上是完全自动化的，并由管道执行。</p><p>Release Management</p><p><a href="https://xebialabs.com/glossary/release-management/" target="_blank" rel="noopener">发布管理</a></p><p>发布管理是管理软件发布从开发阶段到实际软件发布阶段的流程。</p><p>Release Orchestration</p><p><a href="https://xebialabs.com/glossary/release-orchestration/" target="_blank" rel="noopener">发布编排</a></p><p>发布编排是使用诸如XL发布等工具管理软件发布（从开发阶段到实际软件发布阶段）。</p><h3 id="T"><a href="#T" class="headerlink" title="T"></a>T</h3><p>Test-Driven Development (TDD)</p><p><a href="https://xebialabs.com/glossary/test-driven-development-(tdd" target="_blank" rel="noopener">测试驱动开发（TDD）</a>/)</p><p>一种开发实践，在该实践过程中，用于验证代码片段表现的小测试在编写代码前就已经写就。这些测试最初是失败的，但开发人员的目标是接着添加代码使这些测试成功。</p><h3 id="U"><a href="#U" class="headerlink" title="U"></a>U</h3><p>Unit Testing</p><p><a href="https://xebialabs.com/glossary/unit-testing/" target="_blank" rel="noopener">单元测试</a></p><p>代码级（即无需安装完整的端到端系统以运行）测试以验证各个代码段的行为。TDD广泛使用单元测试以描述和验证预期的行为。</p><h3 id="V"><a href="#V" class="headerlink" title="V"></a>V</h3><p>Value Stream Mapping</p><p><a href="https://xebialabs.com/glossary/value-stream-mapping/" target="_blank" rel="noopener">价值</a><a href="https://xebialabs.com/glossary/value-stream-mapping/" target="_blank" rel="noopener">流程</a><a href="https://xebialabs.com/glossary/value-stream-mapping/" target="_blank" rel="noopener">图</a></p><p>一种过程可视化和改善技术，大量用于精益生产和工程方法中。价值流图用于识别必要的处理步骤，而不是逐渐清除流程中的“浪费”。</p><p>Virtualization</p><p><a href="https://xebialabs.com/glossary/virtualization/" target="_blank" rel="noopener">虚拟化</a></p><p>一种系统管理方法，用户和应用程序不需要使用物理机器，而是在实际的“真实”硬件上运行的模拟系统。这样的“虚拟机”能够在几秒钟内自动生成、启动、停运、克隆和丢弃，给操作带来了巨大的便利。</p><h3 id="W"><a href="#W" class="headerlink" title="W"></a>W</h3><p>Waterfall</p><p><a href="https://xebialabs.com/glossary/waterfall/" target="_blank" rel="noopener">瀑布式（开发）</a></p><p>一种基于分阶段项目方法的软件开发方法，从“需求收集”到“开发”，再到“发布”。如果项目中前面的阶段有延迟，整个过程中靠后的阶段（通常和测试及QA相关）会因此在时间上受到挤压。</p><p>White Box Testing</p><p><a href="https://xebialabs.com/glossary/white-box-testing/" target="_blank" rel="noopener">白盒测试</a></p><p>一种测试或质量保证实践，它通过系统运行时检查系统（内部）表现和状态以验证系统内部功能是否正确。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;A&quot;&gt;&lt;a href=&quot;#A&quot; class=&quot;headerlink&quot; title=&quot;A&quot;&gt;&lt;/a&gt;A&lt;/h3&gt;&lt;p&gt;A/B Testing&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://xebialabs.com/glossary/a/b-testing/&quot; t
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>持续集成CI/CD</title>
    <link href="https://yo42.github.io/2018/09/24/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90CI-CD/"/>
    <id>https://yo42.github.io/2018/09/24/持续集成CI-CD/</id>
    <published>2018-09-24T06:08:38.669Z</published>
    <updated>2018-09-24T14:24:56.742Z</updated>
    
    <content type="html"><![CDATA[<p><strong>持续集成（Continuous Integration）</strong>指的是，频繁地（一天多次）将代码集成到主干。 </p><p>在保证质量的前提，通过持续集成使产品进行快速的迭代。</p><p>它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p><p>互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称CI）。</p><p><strong>持续交付</strong>（Continuous delivery）<em>**</em>在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（<em>production-like environments</em>）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。</p><p>持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p><p><strong>持续部署</strong>则是在持续交付的基础上，把部署到生产环境的过程自动化。</p><p>持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。</p><p>持续部署的前提是能自动化完成测试、构建、部署等步骤。</p><p>持续集成CI/CD工具:Jenkins、Travis CI、Drone、Wercker、Circle CI等等….</p><p>工具上的话，jenkins使用的较多，插件多、社区文化活跃。</p><p>常见组合:jenkins+svn+maven+ant、jenkins+GitLab</p><p>持续集成的核心价值在于：</p><ol><li>持续集成中的任何一个环节都是自动完成的，无需太多的人工干预，有利于减少重复过程以节省时间、费用和工作量；</li><li>持续集成保障了每个时间点上团队成员提交的代码是能成功集成的。换言之，任何时间点都能第一时间发现软件的集成问题，使任意时间发布可部署的软件成为了可能；</li><li>持续集成还能利于软件本身的发展趋势，这点在需求不明确或是频繁性变更的情景中尤其重要，持续集成的质量能帮助团队进行有效决策，同时建立团队对开发产品的信心。</li></ol><h3 id="为啥需要持续集成CI-CD？"><a href="#为啥需要持续集成CI-CD？" class="headerlink" title="为啥需要持续集成CI/CD？"></a>为啥需要持续集成CI/CD？</h3><p>敏捷开发、快速交付是互联网行业的标准。一个产品、一个项目团队，通过高效的敏捷开发，以及快速交付产品的流程使其能从软件行业中脱颖而出。说白了就是为了应对快速变化需求的一个解决方案或者手段。</p><p>解放运维劳动力，提高效率，减少因发布、部署、交付更新带来的失误。</p><p>随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile） 在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。</p><p>持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。</p><h3 id="持续集成CI-CD的好处"><a href="#持续集成CI-CD的好处" class="headerlink" title="持续集成CI/CD的好处"></a>持续集成CI/CD的好处</h3><p><strong>快速发现错误。</strong>每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。</p><p><strong>防止分支大幅偏离主干。</strong>如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</p><p>持续集成的大致流程:</p><blockquote><p>编码 -&gt; 构建 -&gt; 集成 -&gt; 测试 -&gt; 交付 -&gt; 部署</p></blockquote><h2 id="持续集成的原则"><a href="#持续集成的原则" class="headerlink" title="持续集成的原则"></a>持续集成的原则</h2><p>业界普遍认同的持续集成的原则包括：</p><ul><li>需要版本控制软件保障团队成员提交的代码不会导致集成失败。常用的版本控制软件有 git、svn 等；</li><li>开发人员必须及时向版本控制库中提交代码，也必须经常性地从版本控制库中更新代码到本地；</li><li>需要有专门的集成服务器来执行集成构建。根据项目的具体实际，集成构建可以被软件的修改来直接触发，也可以定时启动，如每半个小时构建一次；</li><li>必须保证构建的成功。如果构建失败，修复构建过程中的错误是优先级最高的工作。一旦修复，需要手动启动一次构建。</li></ul><h2 id="持续集成系统的组成"><a href="#持续集成系统的组成" class="headerlink" title="持续集成系统的组成"></a>持续集成系统的组成</h2><p>由此可见，一个完整的构建系统必须包括：</p><ul><li>一个自动构建过程，包括自动编译、分发、部署和测试等。</li><li>一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库。</li><li>一个持续集成服务器。</li></ul><h3 id="在实施CI-CD对整个团队文化的影响"><a href="#在实施CI-CD对整个团队文化的影响" class="headerlink" title="在实施CI/CD对整个团队文化的影响"></a>在实施CI/CD对整个团队文化的影响</h3><p>CICD是一个流程上的实践，我们把代码开发、到代码部署、到最后的交付，进行持续地迭代和交付，在这个过程中对原来的团队产生的影响是这样的：开发不再只关注他在开发这部分的实现，他需要保证从代码开发实现、到单测、到测试、到构建部署，到最后的分发发布，这样整个流程的覆盖。按照我的理解，CICD对整个团队文化的影响是，每个人对产品研发的整个流程都要全部参与进去，不再是只局限在自己的角色上。比如我是一个开发，我只做实现，我不再关注部署和测试；或者我是一个测试，我不关注开发实现，不关注部署，我只关注执行；或者我是一个运维，我对前面的所有流程都不了解，我只执行最后的运维步骤，而CICD就是把整个团队有效地集成在一起，通过一个流程持续地迭代发布验证，这样的话，整个团队就能更高效地展开合作。</p><h3 id="多分支、多版本实施CI-CD的建议"><a href="#多分支、多版本实施CI-CD的建议" class="headerlink" title="多分支、多版本实施CI/CD的建议"></a>多分支、多版本实施CI/CD的建议</h3><p>我们目前的确也遇到了多分支并行的情况，也就是说我们需要对不同的业务场景做不同的版本管理。在这种情况下，我们依然可以做CI的实施，但是要经过专门的设计，在每个分支所运行的软件，它的版本管理需要做统一的管理，比如需要规划每个分支的依赖是什么样的，要把整个路径都管理起来。如果没有这样的管理，从构建到部署到测试都是混乱的。在版本管理的基础上，我们还要把代码和测试有效地集成起来，也就是说，不光是代码到测试，是代码到配置、到测试、到部署，都要有效地集成起来。一份代码在这个分支上，它对应的配置在哪里，是什么版本，在这个分支上测试的版本在哪里，都需要管理起来；在这个分支上，代码部署的版本依赖也需要统一的管理。如果我们没有做好这些基础设施，是没有办法做CICD实施的。当我们把这些整理清楚之后，再针对每个分支做整体的实施，通过版本管理去理清楚我们实施的部署构建，到底依赖圈是什么样的，这样就可以做一个正确的实施。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;持续集成（Continuous Integration）&lt;/strong&gt;指的是，频繁地（一天多次）将代码集成到主干。 &lt;/p&gt;
&lt;p&gt;在保证质量的前提，通过持续集成使产品进行快速的迭代。&lt;/p&gt;
&lt;p&gt;它的核心措施是，代码集成到主干之前，必须通过自动化测试
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>关于游戏客户端资源热更方式&amp;流程</title>
    <link href="https://yo42.github.io/2018/09/16/%E5%85%B3%E4%BA%8E%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B5%84%E6%BA%90%E7%83%AD%E6%9B%B4%E6%96%B9%E5%BC%8F-%E6%B5%81%E7%A8%8B/"/>
    <id>https://yo42.github.io/2018/09/16/关于游戏客户端资源热更方式-流程/</id>
    <published>2018-09-16T06:41:19.561Z</published>
    <updated>2018-09-16T06:59:58.011Z</updated>
    
    <content type="html"><![CDATA[<p>应用场景:客户端人员上传更新资源至内网FTP，运维人员操作将客户端资源外放至外网CDN源站。</p><p>实现技术方案:源站架设Nginx，通过GIT远程仓库模式进行资源的更新。</p><p>改进优化的方向:目前，还是通过手动外放资源的方式进行操作，可以优化为开放HTTP Web API接口实现调用GIT命令，进行资源更新的流程。</p><p>逻辑图:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="client.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="client2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="架设部署gitolite"><a href="#架设部署gitolite" class="headerlink" title="架设部署gitolite"></a>架设部署gitolite</h3><h3 id="克隆管理库"><a href="#克隆管理库" class="headerlink" title="克隆管理库"></a>克隆管理库</h3><h3 id="修改-git2-gitolite-conf-gitolite-conf-配置客户端更新库，并提交即可完成创建操作。"><a href="#修改-git2-gitolite-conf-gitolite-conf-配置客户端更新库，并提交即可完成创建操作。" class="headerlink" title="修改 ./git2-gitolite/conf/gitolite.conf 配置客户端更新库，并提交即可完成创建操作。"></a>修改 ./git2-gitolite/conf/gitolite.conf 配置客户端更新库，并提交即可完成创建操作。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repo cilugame/h5-client</span><br><span class="line">    RW      =   @oc_users</span><br></pre></td></tr></table></figure><h3 id="创建本地库"><a href="#创建本地库" class="headerlink" title="创建本地库"></a>创建本地库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/nucleus/client/data/h5</span><br><span class="line">git init ./</span><br></pre></td></tr></table></figure><h3 id="忽略无关配置"><a href="#忽略无关配置" class="headerlink" title="忽略无关配置"></a>忽略无关配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat&lt;&lt;EOF &gt; .gitignore</span><br><span class="line">/*</span><br><span class="line">!/release</span><br><span class="line">!/release/*</span><br><span class="line">!/.gitignore</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="上传客户端资源"><a href="#上传客户端资源" class="headerlink" title="上传客户端资源"></a>上传客户端资源</h3><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git ci -minit</span><br></pre></td></tr></table></figure><h3 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@git2.cilugame.com:cilugame/h5-client.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="登录CDN源站"><a href="#登录CDN源站" class="headerlink" title="登录CDN源站"></a>登录CDN源站</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/nucleus-h5/global/client/html</span><br></pre></td></tr></table></figure><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@git2.cilugame.com:cilugame/h5-client.git ./h5/</span><br></pre></td></tr></table></figure><h3 id="安全加固"><a href="#安全加固" class="headerlink" title="安全加固"></a>安全加固</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 ./h5/.git/</span><br><span class="line">chmod 600 ./h5/.gitignore</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;应用场景:客户端人员上传更新资源至内网FTP，运维人员操作将客户端资源外放至外网CDN源站。&lt;/p&gt;
&lt;p&gt;实现技术方案:源站架设Nginx，通过GIT远程仓库模式进行资源的更新。&lt;/p&gt;
&lt;p&gt;改进优化的方向:目前，还是通过手动外放资源的方式进行操作，可以优化为开放HTT
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>关于Gitolite &amp; SSH-Config联动</title>
    <link href="https://yo42.github.io/2018/09/16/%E5%85%B3%E4%BA%8EGitolite-SSH-Config%E8%81%94%E5%8A%A8/"/>
    <id>https://yo42.github.io/2018/09/16/关于Gitolite-SSH-Config联动/</id>
    <published>2018-09-16T03:58:25.689Z</published>
    <updated>2018-09-16T07:04:42.634Z</updated>
    
    <content type="html"><![CDATA[<p>Gitolite是一款Perl语言开发的Git服务管理工具，通过公钥对用户进行认证，并能够通过配置文件对写操作进行基于分支和路径的精细授权。<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">仓库地址</a></p><p>SSH-Config:OpenSSH SSH Client config files;SSH config是SSH客户端的一个参数配置方案，可以将一些关于SSH命令的参数放到配置文件中去，执行ssh命令的时候从文件中读取，简化命令行的操作。</p><p>应用场景:开发团队，个人客户端本地通过GIT团队协作模式，实时更新服务器信息。通过配置个人ssh-config(～/.ssh/config)，结合ZSH 补全，可以实现方便、快捷的登录服务器。</p><p>效果图如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="ssh.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="服务端部署gitolite"><a href="#服务端部署gitolite" class="headerlink" title="服务端部署gitolite:"></a>服务端部署gitolite:</h3><h3 id="steps-to-install"><a href="#steps-to-install" class="headerlink" title="steps to install"></a>steps to install</h3><p>First, prepare the ssh key:</p><ul><li>login to “git” on the server</li><li>make sure <code>~/.ssh/authorized_keys</code> is empty or non-existent</li><li>make sure your ssh public key from your workstation has been copied as $HOME/YourName.pub</li></ul><p>Next, install gitolite by running these commands:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/sitaramc/gitolite</span><br><span class="line">mkdir -p $HOME/bin</span><br><span class="line">gitolite/install -to $HOME/bin</span><br></pre></td></tr></table></figure><p>Finally, setup gitolite with yourself as the administrator:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitolite setup -pk YourName.pub</span><br></pre></td></tr></table></figure><p>If the last command doesn’t run perhaps “bin” is not in your “PATH”. You can either add it, or just run:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME/bin/gitolite setup -pk YourName.pub</span><br></pre></td></tr></table></figure><p>If you get any other errors please refer to the online documentation whose URL was given at the top of this file.</p><h3 id="个人本地克隆管理库，实现维护git仓库"><a href="#个人本地克隆管理库，实现维护git仓库" class="headerlink" title="个人本地克隆管理库，实现维护git仓库"></a>个人本地克隆管理库，实现维护git仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@host:gitolite-admin</span><br></pre></td></tr></table></figure><h3 id="新增仓库、以及日常修改权限配置文件"><a href="#新增仓库、以及日常修改权限配置文件" class="headerlink" title="新增仓库、以及日常修改权限配置文件"></a>新增仓库、以及日常修改权限配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conf/gitolite.conf</span><br></pre></td></tr></table></figure><h3 id="新增个人公钥"><a href="#新增个人公钥" class="headerlink" title="新增个人公钥"></a>新增个人公钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在key/目录下新增个人公钥</span><br></pre></td></tr></table></figure><h3 id="Example："><a href="#Example：" class="headerlink" title="Example："></a>Example：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ops_users = mike jake</span><br><span class="line">@dev_users = tom jerry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">repo cilu-h5</span><br><span class="line">    RW      =   @ops_users</span><br><span class="line">    RW      =   get_host xxx</span><br><span class="line">    R       =   tom</span><br><span class="line">    R       =   jerry</span><br></pre></td></tr></table></figure><p>新增仓库只需新增一个repo配置项</p><p>按需使用仓库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@git2.cilugame.com:cilu-h5.git ~/ssh-config/cilu-h5/</span><br></pre></td></tr></table></figure><p>合并本地.ssh/config脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># vim:set et ts=2 sw=2:</span></span><br><span class="line"><span class="comment">#set -x</span></span><br><span class="line"></span><br><span class="line">current_dir=$(dirname <span class="variable">$0</span>)</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;current_dir&#125;</span> &amp;&amp; <span class="built_in">export</span> current_dir</span><br><span class="line"></span><br><span class="line">old_ssh=~/.ssh/config</span><br><span class="line">new_ssh=~/.ssh/config.new</span><br><span class="line">bak_dir=~/.ssh/backup</span><br><span class="line">bak_ssh=<span class="string">"<span class="variable">$&#123;bak_dir&#125;</span>/<span class="variable">$(date +'%F_%H%M%S')</span>"</span></span><br><span class="line">hostname=$(hostname)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="variable">$&#123;old_ssh&#125;</span> ] ;<span class="keyword">then</span></span><br><span class="line">  touch <span class="variable">$&#123;old_ssh&#125;</span></span><br><span class="line">  chmod 0644 <span class="variable">$&#123;old_ssh&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">[ -d ~/.ssh/ControlPath ] || mkdir -pv ~/.ssh/ControlPath</span><br><span class="line"></span><br><span class="line"><span class="comment"># header</span></span><br><span class="line">cat&lt;&lt;\EOF &gt; <span class="variable">$&#123;new_ssh&#125;</span></span><br><span class="line">Host github.com</span><br><span class="line">  Port 22</span><br><span class="line"></span><br><span class="line">Host cnc.cilugame.com</span><br><span class="line">  Port 11932</span><br><span class="line"></span><br><span class="line">Host git2.cilugame.com</span><br><span class="line">    ProxyCommand ssh -q h5@jump.cilugame.com socat - TCP:%h:%p</span><br><span class="line"></span><br><span class="line">Host *</span><br><span class="line">   Port 932</span><br><span class="line">   SendEnv LANG LC_*</span><br><span class="line">   SendEnv GIT_*</span><br><span class="line">   ForwardAgent yes</span><br><span class="line">   ServerAliveInterval 10</span><br><span class="line">   XAuthLocation /opt/X11/bin/xauth</span><br><span class="line">   UseRoaming no</span><br><span class="line">   ControlPersist 1h</span><br><span class="line">   ControlMaster auto</span><br><span class="line">   ControlPath ~/.ssh/ControlPath/%r@%h:%p</span><br><span class="line">   Compression yes</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># openssh 在7.2版本新增了AddKeysToAgent参数并废弃了AskPassGUI参数</span></span><br><span class="line"><span class="keyword">if</span> ssh -V 2&gt;&amp;1 | grep -q <span class="string">"OpenSSH_7.[2-9]"</span>;<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"   AddKeysToAgent yes"</span> &gt;&gt; <span class="variable">$&#123;new_ssh&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># merge</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> ../*/[0-9]*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  file_name=$(basename <span class="variable">$file</span>)</span><br><span class="line">  dir_name=$(dirname  <span class="variable">$file</span>)</span><br><span class="line">  dir_name=$(basename  <span class="variable">$dir_name</span>)</span><br><span class="line">  src_file=<span class="string">"~/ssh-config/<span class="variable">$&#123;dir_name&#125;</span>/<span class="variable">$&#123;file_name&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#echo "#========== $src_file" &gt;&amp;2</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"#========== <span class="variable">$src_file</span> ==========#"</span></span><br><span class="line"></span><br><span class="line">  cat <span class="variable">$file</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line"><span class="keyword">done</span> &gt;&gt; <span class="variable">$&#123;new_ssh&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compare and backup</span></span><br><span class="line">system=$(uname)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$system</span>"</span> == <span class="string">"xDarwin"</span> ] ;<span class="keyword">then</span></span><br><span class="line">  old_md5=$(md5 <span class="variable">$old_ssh</span> | awk <span class="string">'&#123;print $4&#125;'</span>)</span><br><span class="line">  new_md5=$(md5 <span class="variable">$new_ssh</span> | awk <span class="string">'&#123;print $4&#125;'</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  old_md5=$(md5sum <span class="variable">$old_ssh</span> | awk <span class="string">'&#123;print $1&#125;'</span>)</span><br><span class="line">  new_md5=$(md5sum <span class="variable">$new_ssh</span> | awk <span class="string">'&#123;print $1&#125;'</span>)</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo "merge to ~/.ssh/config" &gt;&amp;2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$&#123;old_md5&#125;</span>"</span> = <span class="string">"x<span class="variable">$&#123;new_md5&#125;</span>"</span> ] ;<span class="keyword">then</span></span><br><span class="line">  <span class="comment">#echo "Already up-to-date." &gt;&amp;2</span></span><br><span class="line">  rm -f <span class="variable">$new_ssh</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment">#echo "Updating..." &gt;&amp;2</span></span><br><span class="line">  [ -d <span class="string">"<span class="variable">$bak_dir</span>"</span> ] || mkdir <span class="string">"<span class="variable">$bak_dir</span>"</span></span><br><span class="line">  cp <span class="variable">$old_ssh</span> <span class="variable">$bak_ssh</span></span><br><span class="line">  mv <span class="variable">$new_ssh</span> <span class="variable">$old_ssh</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">chmod 0644 <span class="variable">$&#123;old_ssh&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释ControlPersist</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$hostname</span>"</span> == <span class="string">'oc-dev-s73'</span> ];<span class="keyword">then</span></span><br><span class="line">  sed -i <span class="string">'s/ControlPersist 1h/#ControlPersist 1h/g'</span> <span class="variable">$&#123;old_ssh&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="配置GIT钩子，实现自动触发，更新配置文件"><a href="#配置GIT钩子，实现自动触发，更新配置文件" class="headerlink" title="配置GIT钩子，实现自动触发，更新配置文件"></a>配置GIT钩子，实现自动触发，更新配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/ssh-config/</span><br><span class="line"><span class="keyword">for</span> dir <span class="keyword">in</span> *</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="variable">$dir</span> ] ;<span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">pushd</span> <span class="variable">$dir</span> &gt; /dev/null</span><br><span class="line">    [ -d <span class="string">"./.git/hooks"</span> ] || <span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'#!/bin/sh'</span>                        &gt; .git/hooks/post-merge</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'[ -x ./merge.sh ] &amp;&amp; ./merge.sh'</span> &gt;&gt; .git/hooks/post-merge</span><br><span class="line"></span><br><span class="line">    chmod +x .git/hooks/post-merge</span><br><span class="line">    <span class="built_in">popd</span> &gt; /dev/null</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>后续有更新时（成功后会自动调用勾子进行合并操作）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/ssh-config/cilu-h5/</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>通过使用Gitolite可以大大提高团队的协助效率，有时如果是需要提供第三方技术支持，也可以使用Gitolite进行一些简单的配置文件更新、及交付。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Gitolite是一款Perl语言开发的Git服务管理工具，通过公钥对用户进行认证，并能够通过配置文件对写操作进行基于分支和路径的精细授权。&lt;a href=&quot;https://github.com/sitaramc/gitolite&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-学习资料&amp;社区资讯</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker-s-Guide-to-Python-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99-%E7%A4%BE%E5%8C%BA%E8%B5%84%E8%AE%AF/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker-s-Guide-to-Python-学习资料-社区资讯/</id>
    <published>2018-09-15T10:21:59.298Z</published>
    <updated>2018-09-16T00:27:22.940Z</updated>
    
    <content type="html"><![CDATA[<h3 id="The-Python-Tutorial"><a href="#The-Python-Tutorial" class="headerlink" title="The Python Tutorial"></a>The Python Tutorial</h3><p>这个是官方教程。它包含了所有的基础，并提供了一个关于语言和标准库的教程。推荐给那些需要一份关于这门语言的快速开始指南的人们。</p><blockquote><p><a href="http://docs.python.org/tutorial/index.html" target="_blank" rel="noopener">The Python Tutorial</a></p></blockquote><h3 id="Python-for-Beginners"><a href="#Python-for-Beginners" class="headerlink" title="Python for Beginners"></a>Python for Beginners</h3><p>thepythonguru.com 是一个专注于新手程序员的教程网站。它涵盖了许多深度的 Python 概念。它也会教你一些像 lambda 表达式，正则表达式等 Python 的高级结构。 最后，它以『如何使用 Python 访问 MySQL 数据库』这篇教程结束。</p><blockquote><p><a href="http://thepythonguru.com/" target="_blank" rel="noopener">Python for beginners</a></p></blockquote><h3 id="学习-Python-交互式数据科学"><a href="#学习-Python-交互式数据科学" class="headerlink" title="学习 Python 交互式数据科学"></a>学习 Python 交互式数据科学</h3><p>如果你热衷于在线交互式环境来学习 Python 数据科学， <a href="https://www.datacamp.com/courses/intro-to-python-for-data-science?tap_a=5644-dce66f&amp;tap_s=116411-750171" target="_blank" rel="noopener">this free python tutorial by DataCamp</a> 是一个比较好的开始。如果你已经是一位对机器学习有提前了解和兴趣，并使用scikit-learn的核心开发人员，查看 <a href="https://www.datacamp.com/courses/supervised-learning-with-scikit-learn?tap_a=5644-dce66f&amp;tap_s=116411-750171" target="_blank" rel="noopener">course on Supervised Learning with scikit-learn</a> 。</p><p><a href="http://datacamp.com/?tap_a=5644-dce66f&amp;tap_s=116411-750171" target="_blank" rel="noopener">Python 数据科学</a></p><h3 id="学习交互式-Python-教程"><a href="#学习交互式-Python-教程" class="headerlink" title="学习交互式 Python 教程"></a>学习交互式 Python 教程</h3><p>Learnpython.org 是一个简单自由获取 Python 介绍的方式。这个网站采用与流行站点 <a href="http://tryruby.org/" target="_blank" rel="noopener">Try Ruby</a> 相同的方式，站点自带交互式 Python 解释器，这样你可以不用在本地安装 Python 就可以进行学习。</p><blockquote><p><a href="http://www.learnpython.org/" target="_blank" rel="noopener">Learn Python</a></p></blockquote><p>如果你想拥有传统纸质书籍，<em>Python For You and Me</em>  是一个学习这门语言各个方面的极佳资源。</p><blockquote><p><a href="https://pymbook.readthedocs.io/" target="_blank" rel="noopener">Python for You and Me</a> <a href="https://www.datacamp.com/" target="_blank" rel="noopener">Learn Python Interactively with DataCamp!</a></p></blockquote><h3 id="渐进式学习-Python"><a href="#渐进式学习-Python" class="headerlink" title="渐进式学习 Python"></a>渐进式学习 Python</h3><p>Techbeamers.com 提供渐进式教程进行 Python 教学。每一个主题的教程都添加了逻辑性的代码片段，并设置了随堂测验。这里是一份关于 <a href="http://www.techbeamers.com/python-interview-questions-programmers" target="_blank" rel="noopener">Python 面试问题</a> 的章节来帮助求职者。你也可以阅读要点 <a href="http://www.techbeamers.com/essential-python-tips-tricks-programmers" target="_blank" rel="noopener">Python tips</a> 和学习 <a href="http://www.techbeamers.com/python-code-optimization-tips-tricks" target="_blank" rel="noopener">best coding practices</a> 来撰写高质量的代码。通过下面这个链接，你将获得正确的平台来快速学习 Python 。</p><p><a href="http://www.techbeamers.com/python-tutorial-step-by-step" target="_blank" rel="noopener">Python 从入门到高级</a></p><h3 id="在线-Python-助教"><a href="#在线-Python-助教" class="headerlink" title="在线 Python 助教"></a>在线 Python 助教</h3><p>在线 Python 助教给你一个可视化的渐进步骤，来说明你的程序是如何运行的。Python 助教帮助人们理解电脑执行程序源代码每一行的方式来克服基础障碍。</p><blockquote><p><a href="http://pythontutor.com/" target="_blank" rel="noopener">在线 Python 助教</a></p></blockquote><h3 id="用-Python-创作一个属于你自己的电脑游戏"><a href="#用-Python-创作一个属于你自己的电脑游戏" class="headerlink" title="用 Python 创作一个属于你自己的电脑游戏"></a>用 Python 创作一个属于你自己的电脑游戏</h3><p>这本书，正适合编程零经验的初学者。每一个章节都有一个小游戏的源代码，利用这些例证程序来解释程序设计概念，给读者一个「感性」的程序思想。</p><blockquote><p><a href="http://inventwithpython.com/" target="_blank" rel="noopener">Invent Your Own Computer Games with Python</a></p></blockquote><h3 id="Hacking-Secret-Ciphers-with-Python"><a href="#Hacking-Secret-Ciphers-with-Python" class="headerlink" title="Hacking Secret Ciphers with Python"></a>Hacking Secret Ciphers with Python</h3><p>这本书教授完全初学者 Python 程序设计和基础密码学。章节提供各式各样的密码源代码，同时提供程序是如何破解它们的方法。</p><blockquote><p><a href="http://inventwithpython.com/hacking/" target="_blank" rel="noopener">Hacking Secret Ciphers with Python</a></p></blockquote><h3 id="Learn-Python-the-Hard-Way"><a href="#Learn-Python-the-Hard-Way" class="headerlink" title="Learn Python the Hard Way"></a>Learn Python the Hard Way</h3><p>这是一份绝佳的 Python 初级程序员指南。包含了从 console 到 web 的「 hello world 」。</p><blockquote><p><a href="http://learnpythonthehardway.org/book/" target="_blank" rel="noopener">Learn Python the Hard Way</a></p></blockquote><h3 id="Python速成"><a href="#Python速成" class="headerlink" title="Python速成"></a>Python速成</h3><p>这份指南和 <em>Python for Programmers with 3 Hours</em> 一样出名，它为使用其他开发语言的有经验的程序员提供了 Python 速成课。</p><blockquote><p><a href="http://stephensugden.com/crash_into_python/" target="_blank" rel="noopener">Python 速成</a></p></blockquote><h3 id="Dive-Into-Python-3"><a href="#Dive-Into-Python-3" class="headerlink" title="Dive Into Python 3"></a>Dive Into Python 3</h3><p>Dive Into Python 3 对于那些准备转投 Python 3 的程序员是一本好书。如果你正准备从 Python 2 过渡到 3 ，亦或者你已经具有其他语言的开发经验，这本书对你来说非常适合阅读。</p><blockquote><p><a href="http://www.diveintopython3.net/" target="_blank" rel="noopener">Dive Into Python 3</a></p></blockquote><h3 id="Think-Python-How-to-Think-Like-a-Computer-Scientist"><a href="#Think-Python-How-to-Think-Like-a-Computer-Scientist" class="headerlink" title="Think Python: How to Think Like a Computer Scientist"></a>Think Python: How to Think Like a Computer Scientist</h3><p>Think Python 尝试在使用 Python 语言时介绍一个基础的计算机科学的概念。它的目的是创造一本拥有大量练习、通俗易懂并且每个章节的每个片段都致力于解决项目问题的书。</p><p>在探索 Python 语言大量特性的可行性时，作者穿插了各式各样的设计模式和最优范例。</p><p>这本书也包含了几个案例研究，让读者将书本中讨论的主题应用到实际问题中来更好的学习。案例研究包含关于 GUI 和 Markov Analysis 的作业。</p><blockquote><p><a href="http://greenteapress.com/thinkpython/html/index.html" target="_blank" rel="noopener">Think Python</a></p></blockquote><h3 id="Python-Koans"><a href="#Python-Koans" class="headerlink" title="Python Koans"></a>Python Koans</h3><p>Python Koans 是 Edgecase’s Ruby Koans 的一个端口。它使用测试驱动的方法，参阅 TEST DRIVEN DESIGN SECTION 来提供一个交互式教程来教学基础 Python 概念。通过修复在测试脚本中失败的断言语句，这提供了一个连续的步骤来学习 Python。</p><p>对于那些习惯于使用语言并自己搞清楚问题的人来说，将是一个富有欢乐和吸引力的选择。对于那些 Python 和程序设计初学者来说，拥有额外的资源和参考将非常有帮助。</p><blockquote><p><a href="http://bitbucket.org/gregmalcolm/python_koans" target="_blank" rel="noopener">Python Koans</a></p></blockquote><p>更多关于测试驱动开发的资源请关注：</p><blockquote><p><a href="http://en.wikipedia.org/wiki/Test-driven_development" target="_blank" rel="noopener">Test Driven Development</a></p></blockquote><h3 id="A-Byte-of-Python"><a href="#A-Byte-of-Python" class="headerlink" title="A Byte of Python"></a>A Byte of Python</h3><p>A Byte of Python 是一本学习 Python 的免费入门书籍，非常适合没有编程基础的人学习。</p><blockquote><p><a href="http://www.ibiblio.org/swaroopch/byteofpython/read/" target="_blank" rel="noopener">A Byte of Python for Python 2.x</a> <a href="https://python.swaroopch.com/" target="_blank" rel="noopener">A Byte of Python for Python 3.x</a></p></blockquote><h3 id="Learn-to-Program-in-Python-with-Codeacademy"><a href="#Learn-to-Program-in-Python-with-Codeacademy" class="headerlink" title="Learn to Program in Python with Codeacademy"></a>Learn to Program in Python with Codeacademy</h3><p>这是一个适合绝大多数 Python 初学者的 Codeacademy 课程。这个免费的交互式课程主要教授 Python 编程中基础和部分深入的知识，同时会有测试来检验学者对知识的掌握程度。 这门课程也包含很多功能可以反馈你学习的情况，帮助你更好的学习。</p><blockquote><p><a href="http://www.codecademy.com/en/tracks/python" target="_blank" rel="noopener">Learn to Program in Python with Codeacademy</a></p></blockquote><h3 id="Code-the-blocks"><a href="#Code-the-blocks" class="headerlink" title="Code the blocks"></a>Code the blocks</h3><p><em>Code the blocks</em> 为初学者提供免费交互式的 Python 教程。它将 Python 程序设计和 3D 环境下「 搭砖块 」建造建筑相互结合。此教程教授你如何使用 Python 一步步创造一个精细的 3D 建筑，让你学习 Python 的过程充满欢乐。</p><blockquote><p><a href="https://codetheblocks.com/tutorials/introduction" target="_blank" rel="noopener">Code the blocks</a></p></blockquote><h2 id="Intermediate"><a href="#Intermediate" class="headerlink" title="Intermediate"></a>Intermediate</h2><h3 id="Effective-Python"><a href="#Effective-Python" class="headerlink" title="Effective Python"></a>Effective Python</h3><p>这本书包含了 59 种特定方法来提高编写 Pythonic 代码。总长度只有 227 页，列举了大量的晋升中等水平 Python 工程师必备的知识技能。</p><blockquote><p><a href="http://www.effectivepython.com/" target="_blank" rel="noopener">Effective Python</a></p></blockquote><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="Pro-Python"><a href="#Pro-Python" class="headerlink" title="Pro Python"></a>Pro Python</h3><p>这本书适用于中级到高级 Python 程序员，他们希望理解 Python 的工作原理以及怎样提升自己的代码水平。</p><blockquote><p><a href="http://propython.com/" target="_blank" rel="noopener">Pro Python</a></p></blockquote><h3 id="《Expert-Python-Programming》"><a href="#《Expert-Python-Programming》" class="headerlink" title="《Expert Python Programming》"></a>《Expert Python Programming》</h3><p>《Expert Python Programming》专注于为高级工程师提供 Python 的最佳实践的建议。</p><p>它的话题包括装饰器（伴随缓存、代理、上下文管理器、案例研究）、方法解析顺序，使用 <code>super()</code> 和元编程，还有通用的 <a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener">PEP 8</a> 最佳实践。</p><p>它花了多个章节，详细地介绍了如何编写和发布一个扩展包甚至最终发布一个应用，包含了一个使用 zc.buildout 的章节。后面的章节详细讲述了最佳实践，比如编写文档、测试驱动开发、 版本控制、优化和分析。</p><blockquote><p><a href="http://www.packtpub.com/expert-python-programming/book" target="_blank" rel="noopener">Expert Python Programming</a></p></blockquote><h3 id="《A-Guide-to-Python’s-Magic-Methods》"><a href="#《A-Guide-to-Python’s-Magic-Methods》" class="headerlink" title="《A Guide to Python’s Magic Methods》"></a>《A Guide to Python’s Magic Methods》</h3><p>这 是Rafe Kettler 发表博文的集合，解释了 Python 中的 “魔法方法”。魔法方法由双下划线包围 （比如 <strong>init</strong>），能够使类和对象表现出不同的、魔法的行为。</p><blockquote><p><a href="http://www.rafekettler.com/magicmethods.html" target="_blank" rel="noopener">A Guide to Python’s Magic Methods</a></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>Rafekettler.com 目前已关闭，您可以直接访问他们的 Github 版本。 在这里您可以找到一个 PDF 版本:  <a href="https://github.com/RafeKettler/magicmethods/blob/master/magicmethods.pdf" target="_blank" rel="noopener">A Guide to Python’s Magic Methods (repo on GitHub)</a></p></blockquote><h2 id="工程师和科学家"><a href="#工程师和科学家" class="headerlink" title="工程师和科学家"></a>工程师和科学家</h2><h3 id="A-Primer-on-Scientific-Programming-with-Python"><a href="#A-Primer-on-Scientific-Programming-with-Python" class="headerlink" title="A Primer on Scientific Programming with Python"></a>A Primer on Scientific Programming with Python</h3><p>《A Primer on Scientific Programming with Python》由 Hans Petter Langtangen 编写， 主要涵盖了 Python 在科学领域的使用。在这本书中，例子是从数学和自然科学中选出的。</p><blockquote><p><a href="http://www.springer.com/mathematics/computational+science+%26+engineering/book/978-3-642-30292-3" target="_blank" rel="noopener">A Primer on Scientific Programming with Python</a></p></blockquote><h3 id="Numerical-Methods-in-Engineering-with-Python"><a href="#Numerical-Methods-in-Engineering-with-Python" class="headerlink" title="Numerical Methods in Engineering with Python"></a>Numerical Methods in Engineering with Python</h3><p>《Numerical Methods in Engineering with Python》由 Jaan Kiusalaas 编写， 其重点是数值方法以及如何用 Python 来实现他们。</p><blockquote><p><a href="http://www.cambridge.org/us/academic/subjects/engineering/engineering-mathematics-and-programming/numerical-methods-engineering-python-2nd-edition" target="_blank" rel="noopener">Numerical Methods in Engineering with Python</a></p></blockquote><h2 id="其他话题"><a href="#其他话题" class="headerlink" title="其他话题"></a>其他话题</h2><h3 id="Problem-Solving-with-Algorithms-and-Data-Structures"><a href="#Problem-Solving-with-Algorithms-and-Data-Structures" class="headerlink" title="Problem Solving with Algorithms and Data Structures"></a>Problem Solving with Algorithms and Data Structures</h3><p>《Problem Solving with Algorithms and Data Structures》涵盖了一系列数据结构和算法。 所有概念都用 Python 代码说明，提供了可在浏览器中直接运行的交互式样例。</p><blockquote><p><a href="http://www.interactivepython.org/courselib/static/pythonds/index.html" target="_blank" rel="noopener">Problem Solving with Algorithms and Data Structures</a></p></blockquote><h3 id="Programming-Collective-Intelligence"><a href="#Programming-Collective-Intelligence" class="headerlink" title="Programming Collective Intelligence"></a>Programming Collective Intelligence</h3><p>《Programming Collective Intelligence》介绍了大量基础的机器学习和数据挖掘方法。 本书不会侧重于数据挖掘的数学原理，而是更侧重于解释底层的理论算法，以及展示如何使用 Python 来实现这些算法。</p><blockquote><p><a href="http://shop.oreilly.com/product/9780596529321.do" target="_blank" rel="noopener">Programming Collective Intelligence</a></p></blockquote><h3 id="Transforming-Code-into-Beautiful-Idiomatic-Python"><a href="#Transforming-Code-into-Beautiful-Idiomatic-Python" class="headerlink" title="Transforming Code into Beautiful, Idiomatic Python"></a>Transforming Code into Beautiful, Idiomatic Python</h3><p>《Transforming Code into Beautiful, Idiomatic Python》 是由 Raymond Hettinger 制作的视频。 通过它可以学习到如何更好地利用 Python 最好的特性和如何通过代码转换来改进现有代码。</p><blockquote><p><a href="https://www.youtube.com/watch?v=OSGv2VnC0go" target="_blank" rel="noopener">Transforming Code into Beautiful, Idiomatic Python</a></p></blockquote><h3 id="Fullstack-Python"><a href="#Fullstack-Python" class="headerlink" title="Fullstack Python"></a>Fullstack Python</h3><p>《Fullstack Python》为使用 Python 进行 Web 开发提供了完整的自上向下的资源。</p><p>技术话题范围涵盖从设置 Web 服务器到设计前端、选择数据库、优化/缩放等。</p><p>顾名思义，它涵盖了从头开始构建和运行完整的 Web 应用程序所需的所有内容。</p><blockquote><p><a href="https://www.fullstackpython.com/" target="_blank" rel="noopener">Fullstack Python</a></p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="Python-in-a-Nutshell"><a href="#Python-in-a-Nutshell" class="headerlink" title="Python in a Nutshell"></a>Python in a Nutshell</h3><p>《Python in a Nutshell》 由 Alex Martelli编写，涵盖了 Python 跨平台的多数用法， 从它的语法到内建库，再到比如说编写 C 扩展的高级主题。</p><blockquote><p><a href="http://shop.oreilly.com/product/9780596001889.do" target="_blank" rel="noopener">Python in a Nutshell</a></p></blockquote><h3 id="The-Python-Language-Reference"><a href="#The-Python-Language-Reference" class="headerlink" title="The Python Language Reference"></a>The Python Language Reference</h3><p>这是 Python 的参考手册，它涵盖了这门语言的语法和核心语义。</p><blockquote><p><a href="http://docs.python.org/reference/index.html" target="_blank" rel="noopener">The Python Language Reference</a></p></blockquote><h3 id="Python-Essential-Reference"><a href="#Python-Essential-Reference" class="headerlink" title="Python Essential Reference"></a>Python Essential Reference</h3><p>《Python Essential Reference》，由 David Beazley 撰写，是 Python 的最终参考指南。 它简明扼要地解释了标准库的核心语言和最重要的部分。 它涵盖了 Python 3 和 2.6 版本。</p><blockquote><p><a href="http://www.dabeaz.com/per.html" target="_blank" rel="noopener">Python Essential Reference</a></p></blockquote><h3 id="Python-Pocket-Reference"><a href="#Python-Pocket-Reference" class="headerlink" title="Python Pocket Reference"></a>Python Pocket Reference</h3><p>《Python Pocket Reference》由 Mark Lutz 编写，是一个了解核心语言的易于使用的参考， 介绍了常用的模块和工具集。它涵盖了 Python 3 和 Python 2。</p><blockquote><p><a href="http://shop.oreilly.com/product/9780596158095.do" target="_blank" rel="noopener">Python Pocket Reference</a></p></blockquote><h3 id="Python-Cookbook"><a href="#Python-Cookbook" class="headerlink" title="Python Cookbook"></a>Python Cookbook</h3><p>Python Cookbook 由 David Beazley 和 Brian K. Jones 编写，打包了许多具有实践意义的”食谱”。 这本书涵盖了核心 Python 语言，也涵盖了诸多不同应用的常见任务。</p><blockquote><p><a href="http://shop.oreilly.com/product/0636920027072.do" target="_blank" rel="noopener">Python Cookbook</a></p></blockquote><h3 id="Writing-Idiomatic-Python"><a href="#Writing-Idiomatic-Python" class="headerlink" title="Writing Idiomatic Python"></a>Writing Idiomatic Python</h3><p>《Writing Idiomatic Python》由 Jeff Knupp 编写，包含了最常见和最重要的 Python 习语， 其形式尽可能地有辨识度和易于理解。每个习语都是编写一些常用代码片段的推荐方式， 其后会解释为什么这个习语是重要的。每个习语均有两个代码样例：”有害的” 方式和 “理想的” 方式。</p><blockquote><p><a href="http://www.amazon.com/Writing-Idiomatic-Python-2-7-3-Knupp/dp/1482372177/" target="_blank" rel="noopener">For Python 2.7.3+</a></p><p><a href="http://www.amazon.com/Writing-Idiomatic-Python-Jeff-Knupp-ebook/dp/B00B5VXMRG/" target="_blank" rel="noopener">For Python 3.3+</a></p></blockquote><h2 id="Planet-Python"><a href="#Planet-Python" class="headerlink" title="Planet Python"></a>Planet Python</h2><p>这是一个来自日益增长的开发者提供的 Python 资讯汇总。</p><blockquote><p><a href="http://planet.python.org/" target="_blank" rel="noopener">Planet Python</a></p></blockquote><h2 id="r-python"><a href="#r-python" class="headerlink" title="/r/python"></a>/r/python</h2><p>/r/python 是 Reddit Python 社区，在这里，用户对 Python 相关的资讯进行投稿和投票。</p><blockquote><p><a href="http://reddit.com/r/python" target="_blank" rel="noopener">/r/python</a></p></blockquote><h2 id="Talk-Python-Podcast"><a href="#Talk-Python-Podcast" class="headerlink" title="Talk Python Podcast"></a>Talk Python Podcast</h2><p>头号以 Python 为重点的播客，涵盖了 Python 相关的人员和想法。</p><blockquote><p><a href="https://talkpython.fm/" target="_blank" rel="noopener">Talk Python To Me</a></p></blockquote><h2 id="Python-Bytes-Podcast"><a href="#Python-Bytes-Podcast" class="headerlink" title="Python Bytes Podcast"></a>Python Bytes Podcast</h2><p>一个涵盖最近开发人员头条的简短形式的 Python 播客。</p><blockquote><p><a href="https://pythonbytes.fm/" target="_blank" rel="noopener">Python Bytes</a></p></blockquote><h2 id="Pycoder’s-Weekly"><a href="#Pycoder’s-Weekly" class="headerlink" title="Pycoder’s Weekly"></a>Pycoder’s Weekly</h2><p>Pycoder’s Weekly 是 Python开发者为 Python开发者们准备的免费的 Python 新闻周刊（包括项目，文章，资讯，工作）。</p><blockquote><p><a href="http://www.pycoders.com/" target="_blank" rel="noopener">Pycoder’s Weekly</a></p></blockquote><h2 id="Python-Weekly"><a href="#Python-Weekly" class="headerlink" title="Python Weekly"></a>Python Weekly</h2><p>Python Weekly 是一个以策划 Python 相关的新闻，文章，新版发布，工作等为特色的周刊。</p><blockquote><p><a href="http://www.pythonweekly.com/" target="_blank" rel="noopener">Python Weekly</a></p></blockquote><h2 id="Python-News"><a href="#Python-News" class="headerlink" title="Python News"></a>Python News</h2><p>Python News 是 <a href="https://pythoncaff.com/docs/python-guide/2018/intro-news/www.python.org" target="_blank" rel="noopener">Python 官网</a> 的新闻板块。它简要地强调了 Python 社区的新闻。</p><blockquote><p><a href="http://www.python.org/news/" target="_blank" rel="noopener">Python News</a></p></blockquote><h2 id="Import-Python-Weekly"><a href="#Import-Python-Weekly" class="headerlink" title="Import Python Weekly"></a>Import Python Weekly</h2><p>Weekly Python Newsletter 包含 Python 的文章，项目，视频和你邮箱中的推文。让你的 Python 编程技巧处于更新状态。</p><blockquote><p><a href="http://www.importpython.com/newsletter/" target="_blank" rel="noopener">Import Python Weekly Newsletter</a></p></blockquote><h2 id="Awesome-Python-Newsletter"><a href="#Awesome-Python-Newsletter" class="headerlink" title="Awesome Python Newsletter"></a>Awesome Python Newsletter</h2><p>每周对最受欢迎的 Python 新闻，文章和软件包进行总结。</p><blockquote><p><a href="https://python.libhunt.com/newsletter" target="_blank" rel="noopener">Awesome Python Newsletter</a></p></blockquote><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;The-Python-Tutorial&quot;&gt;&lt;a href=&quot;#The-Python-Tutorial&quot; class=&quot;headerlink&quot; title=&quot;The Python Tutorial&quot;&gt;&lt;/a&gt;The Python Tutorial&lt;/h3&gt;&lt;p&gt;这个
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Docker Harbor镜像仓库</title>
    <link href="https://yo42.github.io/2018/09/15/Docker-Harbor%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/"/>
    <id>https://yo42.github.io/2018/09/15/Docker-Harbor镜像仓库/</id>
    <published>2018-09-15T10:08:02.715Z</published>
    <updated>2018-09-16T07:07:51.713Z</updated>
    
    <content type="html"><![CDATA[<p>场景架构:属于分布式集群的方式部署Dokcer镜像仓库，每个项目部署一个从仓库，所有从仓库共用连接一个主仓库，每次对镜像构建集成时将PUSH至主仓库，主仓库再分发至各项目的从仓库。</p><h2 id="部署Harbor"><a href="#部署Harbor" class="headerlink" title="部署Harbor"></a>部署Harbor</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构:"></a>目录结构:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /home/nucleus-oc/</span><br><span class="line">sudo mkdir /home/nucleus-oc/harbor/  # 数据目录</span><br><span class="line">sudo mkdir /home/nucleus-oc/2231/    # 控制目录</span><br></pre></td></tr></table></figure><h3 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/nucleus-oc/harbor/ssl-key/chained.pem #证书</span><br><span class="line">/home/nucleus-oc/harbor/ssl-key/server.key     # 密钥</span><br></pre></td></tr></table></figure><h3 id="下载并解压缩离线安装包："><a href="#下载并解压缩离线安装包：" class="headerlink" title="下载并解压缩离线安装包："></a>下载并解压缩离线安装包：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home/nucleus-oc/2231/</span><br><span class="line">wget https://github.com/vmware/harbor/releases/download/v1.1.2/harbor-offline-installer-v1.1.2.tgz</span><br><span class="line">tar xf harbor-offline-installer-v1.1.2.tgz</span><br></pre></td></tr></table></figure><h3 id="修改配置文件docker-compose-yml"><a href="#修改配置文件docker-compose-yml" class="headerlink" title="修改配置文件docker-compose.yml"></a>修改配置文件docker-compose.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /home/nucleus-oc/2231/harbor/</span><br><span class="line">sed -e &apos;s@ /data/@ /home/nucleus-oc/harbor/@&apos; \</span><br><span class="line">    -e &apos;s@ /var/log/harbor/@ /home/nucleus-oc/harbor/logs/@&apos; \</span><br><span class="line">    -i docker-compose.yml</span><br></pre></td></tr></table></figure><h3 id="修改harbor-cfg"><a href="#修改harbor-cfg" class="headerlink" title="修改harbor.cfg"></a>修改harbor.cfg</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5 hostname = oc-control-h9tc.mtiancity.com      #仓库域名 </span><br><span class="line">9 ui_url_protocol = https</span><br><span class="line">12 db_password = wV6QRnTkX8SQNqxu</span><br><span class="line">24 ssl_cert = /home/nucleus-oc/harbor/ssl-key/chained.pem  </span><br><span class="line">25 ssl_cert_key = /home/nucleus-oc/harbor/ssl-key/server.key</span><br><span class="line">28 secretkey_path = /home/nucleus-oc/harbor</span><br><span class="line">55 harbor_admin_password = GLcvN2Ezrh5XT3Hx</span><br><span class="line">87 self_registration = off</span><br><span class="line">95 project_creation_restriction = adminonly</span><br></pre></td></tr></table></figure><h3 id="正式安装"><a href="#正式安装" class="headerlink" title="正式安装"></a>正式安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/nucleus-oc/2231/harbor/</span><br><span class="line"> ./install.sh</span><br></pre></td></tr></table></figure><h3 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">https://github.com/goharbor/harbor</a></li><li><a href="http://www.vmtocloud.com/remote-site-replicated-docker-registries-with-vmware-harbor/" target="_blank" rel="noopener">http://www.vmtocloud.com/remote-site-replicated-docker-registries-with-vmware-harbor/</a></li><li><a href="http://www.cnblogs.com/jicki/p/5737369.html" target="_blank" rel="noopener">http://www.cnblogs.com/jicki/p/5737369.html</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;场景架构:属于分布式集群的方式部署Dokcer镜像仓库，每个项目部署一个从仓库，所有从仓库共用连接一个主仓库，每次对镜像构建集成时将PUSH至主仓库，主仓库再分发至各项目的从仓库。&lt;/p&gt;
&lt;h2 id=&quot;部署Harbor&quot;&gt;&lt;a href=&quot;#部署Harbor&quot; clas
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-优雅的包管理</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker-s-Guide-to-Python-%E4%BC%98%E9%9B%85%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker-s-Guide-to-Python-优雅的包管理/</id>
    <published>2018-09-15T09:45:48.832Z</published>
    <updated>2018-09-15T10:07:37.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打包Python项目"><a href="#打包Python项目" class="headerlink" title="打包Python项目"></a>打包Python项目</h1><p>本教程将指导您如何打包一个简单的Python项目。它将向您展示如何添加必要的文件和结构来创建包，如何构建包以及如何将其上载到Python包索引。</p><h2 id="一个简单的项目"><a href="#一个简单的项目" class="headerlink" title="一个简单的项目"></a>一个简单的项目</h2><p>本教程使用一个名为的简单项目<code>example_pkg</code>。如果您不熟悉Python的模块和<a href="https://packaging.python.org/glossary/#term-import-package" target="_blank" rel="noopener">导入包</a>，请花几分钟时间阅读包含<a href="https://docs.python.org/3/tutorial/modules.html#packages" target="_blank" rel="noopener">文件包和模块</a>的<a href="https://docs.python.org/3/tutorial/modules.html#packages" target="_blank" rel="noopener">Python文档</a>。</p><p>要在本地创建此项目，请创建以下文件结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/example_pkg</span><br><span class="line">  /example_pkg</span><br><span class="line">    __init__.py</span><br></pre></td></tr></table></figure><p>创建此结构后，您将需要在顶级文件夹中运行本教程中的所有命令 - 所以一定要确保。<code>cd example_pkg</code></p><p>您还应该编辑<code>example_pkg/__init__.py</code>并在其中放入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;example_pkg&quot;</span><br></pre></td></tr></table></figure><p>这只是为了您可以在本教程后面验证它是否正确安装。</p><h2 id="创建包文件"><a href="#创建包文件" class="headerlink" title="创建包文件"></a>创建包文件</h2><p>现在，您将创建一些文件来打包此项目并准备分发。创建下面列出的新文件 - 您将在以下步骤中向其添加内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/example_pkg</span><br><span class="line">  /example_pkg</span><br><span class="line">    __init__.py</span><br><span class="line">  setup.py</span><br><span class="line">  LICENSE</span><br><span class="line">  README.md</span><br></pre></td></tr></table></figure><h2 id="创建的setup-py"><a href="#创建的setup-py" class="headerlink" title="创建的setup.py"></a>创建的setup.py</h2><p><code>setup.py</code>是<a href="https://packaging.python.org/key_projects/#setuptools" target="_blank" rel="noopener">setuptools</a>的构建脚本。它告诉setuptools你的包（例如名称和版本）以及要包含的代码文件。</p><p>打开<code>setup.py</code>并输入以下内容，您可以根据需要个性化值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import setuptools</span><br><span class="line"></span><br><span class="line">with open(&quot;README.md&quot;, &quot;r&quot;) as fh:</span><br><span class="line">    long_description = fh.read()</span><br><span class="line"></span><br><span class="line">setuptools.setup(</span><br><span class="line">    name=&quot;example_pkg&quot;,</span><br><span class="line">    version=&quot;0.0.1&quot;,</span><br><span class="line">    author=&quot;Example Author&quot;,</span><br><span class="line">    author_email=&quot;author@example.com&quot;,</span><br><span class="line">    description=&quot;A small example package&quot;,</span><br><span class="line">    long_description=long_description,</span><br><span class="line">    long_description_content_type=&quot;text/markdown&quot;,</span><br><span class="line">    url=&quot;https://github.com/pypa/sampleproject&quot;,</span><br><span class="line">    packages=setuptools.find_packages(),</span><br><span class="line">    classifiers=[</span><br><span class="line">        &quot;Programming Language :: Python :: 3&quot;,</span><br><span class="line">        &quot;License :: OSI Approved :: MIT License&quot;,</span><br><span class="line">        &quot;Operating System :: OS Independent&quot;,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>setup()</code>有几个论点。此示例包使用相对最小的集：</p><ul><li><code>name</code>是您的包的名称。只要包含字母，数字<code>_</code>和，就可以是任何名称<code>-</code>。它也不能在pypi.org上使用。</li><li><code>version</code> 是包版本看 <a href="https://www.python.org/dev/peps/pep-0440" target="_blank" rel="noopener"><strong>PEP 440</strong></a>有关版本的更多详细信息。</li><li><code>author</code>并<code>author_email</code>用于识别包的作者。</li><li><code>description</code> 是一个简短的，一句话的包的总结。</li><li><code>long_description</code>是包的详细说明。这显示在Python Package Index的包详细信息包中。在这种情况下，加载长描述<code>README.md</code>是一种常见模式。</li><li><code>long_description_content_type</code>告诉索引什么类型的标记用于长描述。在这种情况下，它是Markdown。</li><li><code>url</code>是项目主页的URL。对于许多项目，这只是一个指向GitHub，GitLab，Bitbucket或类似代码托管服务的链接。</li><li><code>packages</code>是应包含在<a href="https://packaging.python.org/glossary/#term-distribution-package" target="_blank" rel="noopener">分发包</a>中的所有Python <a href="https://packaging.python.org/glossary/#term-import-package" target="_blank" rel="noopener">导入包</a>的列表。我们可以使用 自动发现所有包和子包，而不是手动列出每个包。在这种情况下，包列表将是example_pkg，因为它是唯一存在的包。<code>find_packages()</code></li><li><code>classifiers</code>告诉索引并<a href="https://packaging.python.org/key_projects/#pip" target="_blank" rel="noopener">点</a>一些关于你的包的其他元数据。在这种情况下，该软件包仅与Python 3兼容，根据MIT许可证进行许可，并且与操作系统无关。您应始终至少包含您的软件包所使用的Python版本，软件包可用的许可证以及您的软件包将使用的操作系统。有关分类器的完整列表，请参阅<a href="https://pypi.org/classifiers/" target="_blank" rel="noopener">https://pypi.org/classifiers/</a>。</li></ul><p>除了这里提到的还有很多。有关详细信息，请参阅 <a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/" target="_blank" rel="noopener">打包和分发项目</a>。</p><h2 id="创建README-md"><a href="#创建README-md" class="headerlink" title="创建README.md"></a>创建README.md</h2><p>打开<code>README.md</code>并输入以下内容。如果您愿意，可以自定义此项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Example Package</span><br><span class="line"></span><br><span class="line">This is a simple example package. You can use</span><br><span class="line">[Github-flavored Markdown](https://guides.github.com/features/mastering-markdown/)</span><br><span class="line">to write your content.</span><br></pre></td></tr></table></figure><h2 id="创建许可证"><a href="#创建许可证" class="headerlink" title="创建许可证"></a>创建许可证</h2><p>上传到Python Package Index的每个包都包含许可证，这一点很重要。这告诉用户安装您的软件包可以使用您的软件包的条款。有关选择许可证的帮助，请参阅 <a href="https://choosealicense.com/" target="_blank" rel="noopener">https://choosealicense.com/</a>。选择许可证后，打开 <code>LICENSE</code>并输入许可证文本。例如，如果您选择了MIT许可证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Copyright (c) 2018 The Python Packaging Authority</span><br><span class="line"></span><br><span class="line">Permission is hereby granted, free of charge, to any person obtaining a copy</span><br><span class="line">of this software and associated documentation files (the &quot;Software&quot;), to deal</span><br><span class="line">in the Software without restriction, including without limitation the rights</span><br><span class="line">to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span><br><span class="line">copies of the Software, and to permit persons to whom the Software is</span><br><span class="line">furnished to do so, subject to the following conditions:</span><br><span class="line"></span><br><span class="line">The above copyright notice and this permission notice shall be included in all</span><br><span class="line">copies or substantial portions of the Software.</span><br><span class="line"></span><br><span class="line">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span><br><span class="line">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span><br><span class="line">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span><br><span class="line">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span><br><span class="line">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span><br><span class="line">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span><br><span class="line">SOFTWARE.</span><br></pre></td></tr></table></figure><h2 id="生成分发档案"><a href="#生成分发档案" class="headerlink" title="生成分发档案"></a>生成分发档案</h2><p>下一步是为<a href="https://packaging.python.org/glossary/#term-distribution-package" target="_blank" rel="noopener">包</a>生<a href="https://packaging.python.org/glossary/#term-distribution-package" target="_blank" rel="noopener">成分发包</a>。这些是上传到包索引的档案，可以通过<a href="https://packaging.python.org/key_projects/#pip" target="_blank" rel="noopener">pip</a>安装。</p><p>确保您拥有<code>setuptools</code>并<code>wheel</code> 安装了最新版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --user --upgrade setuptools wheel</span><br></pre></td></tr></table></figure><p>小费</p><p>如果您在安装这些软件时遇到问题，请参阅 <a href="https://packaging.python.org/tutorials/installing-packages/" target="_blank" rel="noopener">安装软件包</a>教程</p><p>现在从<code>setup.py</code>位于的同一目录运行此命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 setup.py sdist bdist_wheel</span><br></pre></td></tr></table></figure><p>此命令应输出大量文本，一旦完成，应在<code>dist</code>目录中生成两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dist/</span><br><span class="line">  example_pkg-0.0.1-py3-none-any.whl</span><br><span class="line">  example_pkg-0.0.1.tar.gz</span><br></pre></td></tr></table></figure><p>注意</p><p>如果您遇到麻烦，请复制输出并提出有关<a href="https://github.com/pypa/packaging-problems/issues/new?title=Trouble+following+packaging+libraries+tutorial" target="_blank" rel="noopener">包装问题的问题</a>，我们会尽力为您提供帮助！</p><p>该<code>tar.gz</code>文件是<a href="https://packaging.python.org/glossary/#term-source-archive" target="_blank" rel="noopener">源存档，</a>而该<code>.whl</code>文件是 <a href="https://packaging.python.org/glossary/#term-built-distribution" target="_blank" rel="noopener">构建的分发</a>。较新的<a href="https://packaging.python.org/key_projects/#pip" target="_blank" rel="noopener">pip</a>版本优先安装构建的发行版，但如果需要，将回退到源代码存档。您应该始终上传源存档并为项目兼容的平台提供构建的存档。在这种情况下，我们的示例包在任何平台上都与Python兼容，因此只需要一个构建的发行版。</p><h2 id="上传分发档案"><a href="#上传分发档案" class="headerlink" title="上传分发档案"></a>上传分发档案</h2><p>最后，是时候将您的包上传到Python Package Index了！</p><p>您需要做的第一件事是在Test PyPI上注册一个帐户。Test PyPI是用于测试和实验的包索引的单独实例。这对于像我们不一定想要上传到真实索引的本教程那样很棒。要注册帐户，请访问<a href="https://test.pypi.org/account/register/" target="_blank" rel="noopener">https://test.pypi.org/account/register/</a>并完成该页面上的步骤。在您上传任何软件包之前，您还需要验证您的电子邮件地址。有关Test PyPI的更多详细信息，请参阅 <a href="https://packaging.python.org/guides/using-testpypi/" target="_blank" rel="noopener">使用TestPyPI</a>。</p><p>现在您已注册，您可以使用<a href="https://packaging.python.org/key_projects/#twine" target="_blank" rel="noopener">twine</a>上传分发包。你需要安装Twine：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --user --upgrade twine</span><br></pre></td></tr></table></figure><p>安装完成后，运行Twine上传所有存档<code>dist</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">twine upload --repository-url https://test.pypi.org/legacy/ dist/*</span><br></pre></td></tr></table></figure><p>系统将提示您输入使用Test PyPI注册的用户名和密码。命令完成后，您应该看到与此类似的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Uploading distributions to https://test.pypi.org/legacy/</span><br><span class="line">Enter your username: [your username]</span><br><span class="line">Enter your password:</span><br><span class="line">Uploading example_pkg-0.0.1-py3-none-any.whl</span><br><span class="line">100%|█████████████████████| 4.65k/4.65k [00:01&lt;00:00, 2.88kB/s]</span><br><span class="line">Uploading example_pkg-0.0.1.tar.gz</span><br><span class="line">100%|█████████████████████| 4.25k/4.25k [00:01&lt;00:00, 3.05kB/s]</span><br></pre></td></tr></table></figure><p>注意</p><p>如果您收到错误消息，则需要为您的包选择一个唯一的名称。一个不错的选择 。更新参数 ，删除文件夹，然后 <a href="https://packaging.python.org/tutorials/packaging-projects/#generating-archives" target="_blank" rel="noopener">重新生成存档</a>。<code>The user &#39;[your username]&#39; isn&#39;t allowed to upload to project&#39;example-pkg&#39;`</code>example_pkg_your_username<code>name</code>setup.py<code></code>dist`</p><p>上传后，您的包应该可以在TestPyPI上查看，例如，<a href="https://test.pypi.org/project/example-pkg" target="_blank" rel="noopener">https：</a> //test.pypi.org/project/example-pkg</p><h2 id="安装新上传的软件包"><a href="#安装新上传的软件包" class="headerlink" title="安装新上传的软件包"></a>安装新上传的软件包</h2><p>您可以使用<a href="https://packaging.python.org/key_projects/#pip" target="_blank" rel="noopener">pip</a>来安装包并验证它是否有效。创建一个新的<a href="https://packaging.python.org/key_projects/#virtualenv" target="_blank" rel="noopener">virtualenv</a>（请参阅<a href="https://packaging.python.org/tutorials/installing-packages/" target="_blank" rel="noopener">安装包</a>以获取详细说明）并从TestPyPI安装包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --index-url https://test.pypi.org/simple/ example_pkg</span><br></pre></td></tr></table></figure><p>注意</p><p>如果在预览步骤中使用了不同的包名称，请<code>example_pkg</code>在上面的命令中使用您的包名称替换 。</p><p>pip应该从Test PyPI安装包，输出应该如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collecting example_pkg</span><br><span class="line">  Downloading https://test-files.pythonhosted.org/packages/.../example_pkg-0.0.1-py3-none-any.whl</span><br><span class="line">Installing collected packages: example-pkg</span><br><span class="line">Successfully installed example-pkg-0.0.1</span><br></pre></td></tr></table></figure><p>您可以通过导入模块并引用先前<code>name</code>放置的属性来测试它是否已正确安装<code>__init__.py</code>。</p><p>运行Python解释器（确保你仍然在你的virtualenv中）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python</span><br></pre></td></tr></table></figure><p>然后导入模块并打印出<code>name</code>属性。无论您给出的<a href="https://packaging.python.org/glossary/#term-distribution-package" target="_blank" rel="noopener">分发包</a>名称是什么，这都应该是相同的 ，<code>setup.py</code>因为您的<a href="https://packaging.python.org/glossary/#term-import-package" target="_blank" rel="noopener">导入包</a>是<code>example_pkg</code>。</p><p>>&gt;&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import example_pkg</span><br><span class="line">&gt;&gt;&gt; example_pkg.name</span><br><span class="line">&apos;example_pkg&apos;</span><br></pre></td></tr></table></figure><h2 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h2><p><strong>恭喜，您已经打包并分发了一个Python项目！</strong> ✨🍰✨</p><p>请记住，本教程向您展示了如何将软件包上传到Test PyPI，而测试PyPI是短暂的。偶尔删除包和帐户并不罕见。如果您想将软件包上传到真正的Python软件包索引，可以通过在<a href="https://pypi.org/" target="_blank" rel="noopener">https://pypi.org</a>上注册帐户并按照相同的说明进行上传，但是，使用上传软件包并输入您的帐户凭据在真正的PyPI上注册。您可以使用真正的PyPI安装包 。<code>twine upload dist/*`</code>pip install your-package`</p><p>在这一点上，如果你想阅读更多关于包装的Python库，你可以做一些事情：</p><ul><li>阅读有关使用<a href="https://packaging.python.org/key_projects/#setuptools" target="_blank" rel="noopener">setuptools</a>在<a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/" target="_blank" rel="noopener">打包和分发项目中</a>打包库的 更多信息。</li><li>阅读<a href="https://packaging.python.org/guides/packaging-binary-extensions/" target="_blank" rel="noopener">包装二进制扩展</a>。</li><li>考虑诸如<a href="https://packaging.python.org/key_projects/#flit" target="_blank" rel="noopener">flit</a>，<a href="https://github.com/ofek/hatch" target="_blank" rel="noopener">hatch</a>和<a href="https://github.com/sdispater/poetry" target="_blank" rel="noopener">poetry之类的</a><a href="https://packaging.python.org/key_projects/#setuptools" target="_blank" rel="noopener">setuptools的</a>替代方案。</li></ul><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a><a href="https://packaging.python.org/" target="_blank" rel="noopener">目录</a></h3><ul><li><a href="https://packaging.python.org/overview/" target="_blank" rel="noopener">Python的打包概述</a></li><li>教程<ul><li><a href="https://packaging.python.org/tutorials/installing-packages/" target="_blank" rel="noopener">安装包</a></li><li><a href="https://packaging.python.org/tutorials/managing-dependencies/" target="_blank" rel="noopener">管理应用程序依赖项</a></li><li><a href="https://packaging.python.org/tutorials/packaging-projects/#" target="_blank" rel="noopener">打包Python项目</a></li></ul></li><li><a href="https://packaging.python.org/guides/" target="_blank" rel="noopener">指南</a></li><li><a href="https://packaging.python.org/discussions/" target="_blank" rel="noopener">讨论</a></li><li><a href="https://packaging.python.org/specifications/" target="_blank" rel="noopener">PyPA规格</a></li><li><a href="https://packaging.python.org/key_projects/" target="_blank" rel="noopener">项目摘要</a></li><li><a href="https://packaging.python.org/glossary/" target="_blank" rel="noopener">词汇表</a></li><li><a href="https://packaging.python.org/support/" target="_blank" rel="noopener">如何获得支持</a></li><li><a href="https://packaging.python.org/contribute/" target="_blank" rel="noopener">有助于本指南</a></li><li><a href="https://packaging.python.org/news/" target="_blank" rel="noopener">新闻</a></li></ul><h4 id="上一主题"><a href="#上一主题" class="headerlink" title="上一主题"></a>上一主题</h4><p><a href="https://packaging.python.org/tutorials/managing-dependencies/" target="_blank" rel="noopener">管理应用程序依赖项</a></p><h4 id="下一个主题"><a href="#下一个主题" class="headerlink" title="下一个主题"></a>下一个主题</h4><p><a href="https://packaging.python.org/guides/" target="_blank" rel="noopener">指南</a></p><h3 id="一些常见的包管理工具"><a href="#一些常见的包管理工具" class="headerlink" title="一些常见的包管理工具"></a>一些常见的包管理工具</h3><ul><li>distutils</li><li>setuptools</li><li>distribute</li><li>disutils2</li><li>distlib</li><li>pip</li></ul><p><strong><em>==创建纯 Python 或者平台 Wheels 的命令是：<code>python setup.py bdist_wheel</code></em></strong>==</p><h2 id="代码打包"><a href="#代码打包" class="headerlink" title="代码打包"></a>代码打包</h2><p>打包你的代码，将它共享出去，让其他的开发者使用。例如，将其打包成一个库分享给其他开发者，以便他们用在自己的应用中，或者共享给开发工具，比如 ‘py.test’。</p><p>这种代码发布方式具备的优势是其成熟的工具生态系统，例如 PyPI 和 pip，这些工具使得其他的开发者很容易下载和安装你的包，无论是用于偶然的实验，还是将其集成到大型专业的系统中。</p><p>Python 代码以这种方式发布共享是一个成熟的惯例。如果你的代码不是在 PyPI 上打包的，那么别的开发者很难找到它，也很难将它集成到他们现有的程序中。他们会严重质疑这些没有在 PyPI 上打包项目的槽糕管理，甚至认为这些项目已停止维护。</p><p>类似于这种发布代码的方式的缺点是，它依赖于开发者了解如何安装它所依赖的 Python 版本，并且能够和愿意使用类似 pip 这样的工具安装你的包所需要的其他依赖。这种做法适合发布代码给其他开发人员，但是不适合发布应用程序给终端用户使用。</p><p><a href="https://python-packaging-user-guide.readthedocs.io/" target="_blank" rel="noopener">Python 打包指南</a> 提供了创建和维护 Pythond 包的一个延伸的指导。</p><h2 id="打包的替代方案"><a href="#打包的替代方案" class="headerlink" title="打包的替代方案"></a>打包的替代方案</h2><p>为了发布应用程序给终端用户使用，你应该 <a href="http://docs.python-guide.org/en/latest/shipping/freezing/#freezing-your-code-ref" target="_blank" rel="noopener">冻结你的应用程序</a>。</p><p>在 Linux 平台，你可以考虑 <a href="http://docs.python-guide.org/en/latest/shipping/packaging/#packaging-for-linux-distributions-ref" target="_blank" rel="noopener">创建一个Linux发行版软件包</a> (例如 Debian or Ubuntu 系统中是一个.deb 文件)</p><h2 id="对于-Python-开发者"><a href="#对于-Python-开发者" class="headerlink" title="对于 Python 开发者"></a>对于 Python 开发者</h2><p>如果你正在写一个开源的 Python 模块，<a href="http://pypi.python.org/" target="_blank" rel="noopener">PyPI</a> 是一个适合它发布的地方，PyPI 的另一个名字 <em>The Cheeseshop</em> 更被人熟知。</p><h3 id="Pip-vs-easy-install"><a href="#Pip-vs-easy-install" class="headerlink" title="Pip vs. easy_install"></a>Pip vs. easy_install</h3><p>使用 <a href="http://pypi.python.org/pypi/pip" target="_blank" rel="noopener">pip</a>。 详情 <a href="http://stackoverflow.com/questions/3220404/why-use-pip-over-easy-install" target="_blank" rel="noopener">点击这里</a></p><h3 id="私人-PyPI"><a href="#私人-PyPI" class="headerlink" title="私人 PyPI"></a>私人 PyPI</h3><p>如果你想要使用源码安装一个 Python 包，而不是使用 PyPI，(即, 你的包<em>不对外公开</em>)，你可以通过托管一个简单的 HTTP 服务器来完成，从那些包的安装路径下运行。</p><p><strong>从一个例子入手是最好的</strong></p><p>比如你想安装一个包，它的名字是 <code>MyPackage.tar.gz</code>，假设你的目录结构使这样：</p><ul><li>archive<ul><li>MyPackage<ul><li>MyPackage.tar.gz</li></ul></li></ul></li></ul><h2 id="代码冻结"><a href="#代码冻结" class="headerlink" title="代码冻结"></a>代码冻结</h2><p>『冻结』你的代码是指创建单个可执行文件，文件里包含所有程序代码以及 Python 解释器。</p><p>像 Dropbox、星战前夜、文明 4 和 BitTorrent 客户端都是如此。</p><p>进行这种分发的好处是你的用户不需要安装所要求的 Python 版本（或其他）即可直接运行你的应用程序。 在 Windows 上，甚至许多 Linux发行版和 OS X，系统自带的 Python 版本总是不尽如人意，此时这种分发方式就会体现其价值。</p><p>此外，终端用户软件应始终是可执行的格式。 以 <code>.py</code> 结尾的文件一般适用于软件工程师和系统管理员。</p><p>冻结的一个缺点是它会增加大约 2-12 MB 的发行大小。另外，如果修补了 Python 的安全漏洞， 你将需要独立负责更新分发的应用程序。</p><h2 id="冻结的替代方案"><a href="#冻结的替代方案" class="headerlink" title="冻结的替代方案"></a>冻结的替代方案</h2><p><a href="http://pythonguidecn.readthedocs.io/zh/latest/shipping/packaging.html#packaging-your-code-ref" target="_blank" rel="noopener">打包你的代码</a> 是指把你的库或工具分发给其他开发者。</p><p>Linux 下一个冻结的替代品是 <a href="http://pythonguidecn.readthedocs.io/zh/latest/shipping/packaging.html#packaging-for-linux-distributions-ref" target="_blank" rel="noopener">Linux 分发包</a> （比如，对于 Debian 或 Ubuntu 是 .deb文件，而对于 Red Hat 与 SuSE 是 .rpm 文件）</p><h2 id="冻结工具的比较"><a href="#冻结工具的比较" class="headerlink" title="冻结工具的比较"></a>冻结工具的比较</h2><p>解决方案还有平台/特性支持性：</p><table><thead><tr><th>Solution</th><th>Windows</th><th>Linux</th><th>OS X</th><th>Python 3</th><th>License</th><th>One-file mode</th><th>Zipfile import</th><th>Eggs</th><th>pkg_resources support</th></tr></thead><tbody><tr><td>bbFreeze</td><td>yes</td><td>yes</td><td>yes</td><td>no</td><td>MIT</td><td>no</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>py2exe</td><td>yes</td><td>no</td><td>no</td><td>yes</td><td>MIT</td><td>yes</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>pyInstaller</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>GPL</td><td>yes</td><td>no</td><td>yes</td><td>no</td></tr><tr><td>cx_Freeze</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>PSF</td><td>no</td><td>yes</td><td>yes</td><td>no</td></tr><tr><td>py2app</td><td>no</td><td>no</td><td>yes</td><td>yes</td><td>MIT</td><td>no</td><td>yes</td><td>yes</td><td>yes</td></tr></tbody></table><blockquote><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在 Linux 下冻结 Windows 安装包，之前只有 PyInstaller 支持，不过后来也是  <a href="http://stackoverflow.com/questions/2950971/cross-compiling-a-python-script-on-linux-into-a-windows-executable#comment11890276_2951046" target="_blank" rel="noopener">停止支持了</a>。</p><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>所有解决方案都需要在 Windows 目标机器上安装了MS Visual C++ dll，除了 py2app 以外。只有 Pyinstaller 支持创建独立运行的绑定了dll 的 exe 文件，你需要在创建时传递参数 <code>--onefile</code> 到 <code>Configure.py</code>。</p></blockquote><h2 id="Windows-下的解决方案"><a href="#Windows-下的解决方案" class="headerlink" title="Windows 下的解决方案"></a>Windows 下的解决方案</h2><h3 id="bbFreeze"><a href="#bbFreeze" class="headerlink" title="bbFreeze"></a>bbFreeze</h3><p>前置要求是安装 <a href="http://pythonguidecn.readthedocs.io/zh/latest/starting/install/win.html#install-windows" target="_blank" rel="noopener">Python, Setuptools 以及 pywin32 的依赖项</a>。</p><ol><li>使用以下命令安装 <code>bbfreeze</code>:</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install bbfreeze</span><br></pre></td></tr></table></figure><ol><li>编写最简单的示例  <code>bb_setup.py</code>：</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from bbfreeze import Freezer</span><br><span class="line"></span><br><span class="line">freezer = Freezer(distdir=<span class="string">'dist'</span>)</span><br><span class="line">freezer.addScript(<span class="string">'foobar.py'</span>, gui_only=<span class="keyword">True</span>)</span><br><span class="line">freezer()</span><br></pre></td></tr></table></figure><blockquote><h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><p>这将适用于最基本的文件脚本。 有时候你需要高级的用法，如包含或者排除某些路径，如下：<br><code>freezer = Freezer(distdir=&#39;dist&#39;, includes=[&#39;my_code&#39;], excludes=[&#39;docs&#39;])</code></p></blockquote><ol><li>(可选) 包含图标</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freezer.setIcon(<span class="string">'my_awesome_icon.ico'</span>)</span><br></pre></td></tr></table></figure><ol><li>为冻结器（freezer）提供 Microsoft Visual C 运行时 DLL，我们有一般有两种方法，第一种是将Microsoft Visual Studio 路径 附加您的 <code>sys.path</code> 中，第二种是在脚本所在同一文件夹中放置 <code>msvcp90.dll</code> 文件。</li><li>开始冻结!</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python bb_setup.py</span><br></pre></td></tr></table></figure><h3 id="py2exe"><a href="#py2exe" class="headerlink" title="py2exe"></a>py2exe</h3><p>前置要求是安装了 <a href="http://pythonguidecn.readthedocs.io/zh/latest/starting/install/win.html#install-windows" target="_blank" rel="noopener">Python on Windows</a>。</p><ol><li>下载并且安装 <a href="http://sourceforge.net/projects/py2exe/files/py2exe/" target="_blank" rel="noopener">http://sourceforge.net/projects/py2exe/files/py2exe/</a></li><li>编写 <code>setup.py</code> (<a href="http://www.py2exe.org/index.cgi/ListOfOptions" target="_blank" rel="noopener">配置选项清单</a>):</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from distutils.core import setup</span><br><span class="line">import py2exe</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    windows=[&#123;<span class="string">'script'</span>: <span class="string">'foobar.py'</span>&#125;],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>(可选) <a href="http://www.py2exe.org/index.cgi/CustomIcons" target="_blank" rel="noopener">包含图标</a></li><li>(可选) <a href="http://stackoverflow.com/questions/112698/py2exe-generate-single-executable-file#113014" target="_blank" rel="noopener">单文件模式</a></li><li>生成 :file: <em>.exe</em> 到 <code>dist</code> 目录:</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python setup.py py2exe</span><br></pre></td></tr></table></figure><ol><li>两种方式来提供 Microsoft Visual C 运行时 DLL。两个选项: <a href="https://www.microsoft.com/en-us/download/details.aspx?id=29" target="_blank" rel="noopener">在目标机器全局安装 dll</a> 或者 <a href="http://www.py2exe.org/index.cgi/Tutorial#Step52" target="_blank" rel="noopener">与 .exe 一起分发 dll</a>。</li></ol><h3 id="PyInstaller"><a href="#PyInstaller" class="headerlink" title="PyInstaller"></a>PyInstaller</h3><p>前置条件是安装 <a href="http://pythonguidecn.readthedocs.io/zh/latest/starting/install/win.html#install-windows" target="_blank" rel="noopener">Python, Setuptools 以及pywin32 依赖项</a>.</p><ul><li><a href="http://bojan-komazec.blogspot.com/2011/08/how-to-create-windows-executable-from.html" target="_blank" rel="noopener">更多的简单教程</a></li><li><a href="https://pyinstaller.readthedocs.io/en/stable/" target="_blank" rel="noopener">官方手册</a></li></ul><h2 id="OS-X"><a href="#OS-X" class="headerlink" title="OS X"></a>OS X</h2><h3 id="py2app"><a href="#py2app" class="headerlink" title="py2app"></a>py2app</h3><h3 id="PyInstaller-1"><a href="#PyInstaller-1" class="headerlink" title="PyInstaller"></a>PyInstaller</h3><p>PyInstaller可用于在 Mac OS X 10.6（Snow Leopard）或更新版本上构建 Unix 可执行文件和窗口应用程序。</p><p>要安装 PyInstaller，使用 pip：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pyinstaller</span><br></pre></td></tr></table></figure><p>要创建标准的 Unix 可执行文件，使用 <code>script.py</code> ：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pyinstaller script.py</span><br></pre></td></tr></table></figure><p>这会创建：</p><ul><li><code>script.spec</code> 文件, 类似于 <code>make</code> 文件</li><li><code>build</code> 文件夹, 存放日志文件</li><li><code>dist</code> 文件夹, 存放主要的可执行文件 <code>script</code> ，和一些依赖的Python库</li></ul><p><code>script.py</code> 会把全部内容放在同一个文件夹中。PyInstaller 将所有 <code>script.py</code> 用到的 Python 库放到 <code>dist</code> 文件夹中。所以在分发可执行文件时，会分发整个 <code>dist</code> 文件夹。</p><p><code>script.spec</code> 文件可以编辑成 <a href="http://pythonhosted.org/PyInstaller/#spec-file-operation" target="_blank" rel="noopener">自定义构建</a> ， 比如可以：</p><ul><li>将数据文件与可执行文件绑定在一起</li><li>包含 PyInstaller 无法自动推断的运行时库（ <code>.dll</code> 或 <code>.so</code> 文件）</li><li>将 Python 运行时选项添加到可执行文件中</li></ul><p>现在：代码 <code>script.spec</code> 可以用 <code>pyinstaller</code> （而不是再次使用 <code>script.py</code> ）运行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pyinstaller script.spec</span><br></pre></td></tr></table></figure><p>要创建独立的 OS X 窗口应用程序，请使用 <code>--windowed</code> 选项：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pyinstaller --windowed script.spec</span><br></pre></td></tr></table></figure><p>这将在 <code>dist</code> 文件夹中创建一个 <code>script.app</code> 。请确保在 Python 代码中 使用 GUI 软件包，例如 <a href="https://riverbankcomputing.com/software/pyqt/intro" target="_blank" rel="noopener">PyQt</a> 或 <a href="http://wiki.qt.io/About-PySide" target="_blank" rel="noopener">PySide</a>来控制应用程序的图形部分。</p><p><code>script.spec</code> 有几个与 Mac OS X 应用程序捆绑有关的 <a href="http://pythonhosted.org/PyInstaller/spec-files.html#spec-file-options-for-a-mac-os-x-bundle" target="_blank" rel="noopener">选项</a> 。 例如，要指定应用程序的图标，请使用 <code>icon=\path\to\icon.icns</code> 选项。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://packaging.python.org/tutorials/packaging-projects/#initial-files" target="_blank" rel="noopener">Python官方文档</a></li><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li><li><a href="https://blog.zengrong.net/post/2169.html" target="_blank" rel="noopener">https://blog.zengrong.net/post/2169.html</a></li><li><a href="http://ju.outofmemory.cn/entry/106479" target="_blank" rel="noopener">http://ju.outofmemory.cn/entry/106479</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;打包Python项目&quot;&gt;&lt;a href=&quot;#打包Python项目&quot; class=&quot;headerlink&quot; title=&quot;打包Python项目&quot;&gt;&lt;/a&gt;打包Python项目&lt;/h1&gt;&lt;p&gt;本教程将指导您如何打包一个简单的Python项目。它将向您展示如何添加必要的
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-关于项目License</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AELicense/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-关于项目License/</id>
    <published>2018-09-15T04:40:43.334Z</published>
    <updated>2018-09-15T09:43:04.196Z</updated>
    
    <content type="html"><![CDATA[<p>您的源码发布 <em>需要</em> 一个许可证。在美国，如果没有指定许可证，用户就没有合法的权利下载、修改或分发。此外，除非你告诉他们要遵循什么规则，否则人们不能对你的代码做出贡献。选择一个许可证是很复杂的，所以这里有一些建议:</p><p>开源许可。 这里有许多可以选择 <a href="http://opensource.org/licenses/alphabetical" target="_blank" rel="noopener"> 开源许可 </a>  。</p><p>通常, 这些许可分为两类：</p><ol><li>一类是让使用者能自由地使用软件 (像这种更加开发的开源许可有 MIT ， BSD &amp; Apache) 。</li><li>另一类是确保代码本身–无论发生任何修改或发布–该软件代码都应该是免费的 (像这种有一定限制的免费开源软件许可有 GPL 和 LGPL) 。</li></ol><p>后者在某种意义上是不那么宽容开放的，因为他们不允许有人向软件中添加代码，并在不包括其更改的源代码的情况下发布代码。</p><p>为了帮助你为自己的项目选择一个许可证，请 <strong>使用</strong> <a href="http://choosealicense.com/" target="_blank" rel="noopener">许可证选择器</a> 。</p><p><strong>更宽容的</strong></p><ul><li>PSFL (Python Software Foundation License) – 用于对 Python 本身作出贡献。</li><li>MIT / BSD / ISC<ul><li>MIT (X11)</li><li>New BSD</li><li>ISC</li></ul></li><li>Apache</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;您的源码发布 &lt;em&gt;需要&lt;/em&gt; 一个许可证。在美国，如果没有指定许可证，用户就没有合法的权利下载、修改或分发。此外，除非你告诉他们要遵循什么规则，否则人们不能对你的代码做出贡献。选择一个许可证是很复杂的，所以这里有一些建议:&lt;/p&gt;
&lt;p&gt;开源许可。 这里有许多可以选
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-常见陷阱</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-常见陷阱/</id>
    <published>2018-09-15T04:40:16.342Z</published>
    <updated>2018-09-15T09:42:52.940Z</updated>
    
    <content type="html"><![CDATA[<p>通常，Python 旨在成为一门简洁一致的语言，避免发生意外。然而，有些情况可能会给新手们造成困惑。</p><p>在这些情况中，有一些虽是有意为之，但还是有潜在风险。还有一些则可以说是语言设计缺陷了。总之，下面列出的这些情况都是些乍一看很不好理解的行为，不过一旦您了解了这些奇怪行为背后的机理，也就基本上能理解了。</p><h2 id="可变默认参数"><a href="#可变默认参数" class="headerlink" title="可变默认参数"></a>可变默认参数</h2><p>似乎每个 Python 新手都会感到惊讶的一点是 Python 在函数定义中对待可变默认参数的方法。</p><h3 id="您所写的"><a href="#您所写的" class="headerlink" title="您所写的"></a>您所写的</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def append_to(element, to=[]):</span><br><span class="line">    to.append(element)</span><br><span class="line">    <span class="keyword">return</span> to</span><br></pre></td></tr></table></figure><h3 id="您可能期待的结果"><a href="#您可能期待的结果" class="headerlink" title="您可能期待的结果"></a>您可能期待的结果</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_list = append_to(<span class="number">12</span>)</span><br><span class="line"><span class="keyword">print</span> my_list</span><br><span class="line"></span><br><span class="line">my_other_list = append_to(<span class="number">42</span>)</span><br><span class="line"><span class="keyword">print</span> my_other_list</span><br></pre></td></tr></table></figure><p>函数每次被调用时，如果不提供第二个参数，就创建一个新的列表。所以结果就应该是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">12</span>]</span><br><span class="line">[<span class="number">42</span>]</span><br></pre></td></tr></table></figure><h3 id="实际上的结果"><a href="#实际上的结果" class="headerlink" title="实际上的结果"></a>实际上的结果</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">12</span>]</span><br><span class="line">[<span class="number">12</span>, <span class="number">42</span>]</span><br></pre></td></tr></table></figure><p><em>一旦</em> 完成了函数定义，一个新的列表就创建出来了，而且在随后的每一次函数调用中被使用的都是这个列表。</p><p><em>一旦</em> 完成了函数定义，Python 的默认参数就被赋值了，而且在随后的每一次函数调用中都不会再被默认值重复赋值（就像是在，嗯，Ruby 里那样）。这就意味着如果您使用了一个可变默认参数，并且改变了它，您也会且 <em>将会</em> 在未来的所有函数调用中改变这同一个参数对象。</p><h3 id="您实际上应该做的"><a href="#您实际上应该做的" class="headerlink" title="您实际上应该做的"></a>您实际上应该做的</h3><p>使用一个默认值来表示我们并不想给这个参数赋值，从而每次在函数被调用时我们都创建一个新的对象。（<a href="http://docs.python.org/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 作为默认值通常是个好选择）。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def append_to(element, to=None):</span><br><span class="line">    <span class="keyword">if</span> to is None:</span><br><span class="line">        to = []</span><br><span class="line">    to.append(element)</span><br><span class="line">    <span class="keyword">return</span> to</span><br></pre></td></tr></table></figure><p>可别忘了，您所传递的第二个参数仍应该是个 <em>列表</em> 对象。</p><h3 id="利用好『缺陷』"><a href="#利用好『缺陷』" class="headerlink" title="利用好『缺陷』"></a>利用好『缺陷』</h3><p>有时你可以专门 <strong>利用</strong>（或者说特地使用）这种行为来维护函数调用间的状态。这通常用于编写缓存函数。</p><h2 id="延迟绑定闭包"><a href="#延迟绑定闭包" class="headerlink" title="延迟绑定闭包"></a>延迟绑定闭包</h2><p>另一个常见的困惑是 Python 在闭包（或在周围全局作用域）中绑定变量的方式。</p><h3 id="当你写下"><a href="#当你写下" class="headerlink" title="当你写下"></a>当你写下</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def create_multipliers():</span><br><span class="line">    <span class="keyword">return</span> [lambda x : i * x <span class="keyword">for</span> i in range(<span class="number">5</span>)]</span><br></pre></td></tr></table></figure><h3 id="你期望发生"><a href="#你期望发生" class="headerlink" title="你期望发生"></a>你期望发生</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> multiplier in create_multipliers():</span><br><span class="line">    <span class="keyword">print</span> multiplier(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>一个包含五个函数的列表，每个函数有它们自己的封闭变量 <code>i</code> 乘以它们的参数，得到:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="而事实是："><a href="#而事实是：" class="headerlink" title="而事实是："></a>而事实是：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>五个函数被创建了，它们全都用 4 乘以 <code>x</code> 。</p><p>Python 的闭包是 <strong>延迟绑定的</strong> 。 这意味着闭包中用到的变量的值，是在内部函数被调用时查询得到的。</p><p>这里，不论 <strong>任何</strong> 返回的函数是如何被调用的， <code>i</code> 取的是调用时周围作用域里的值。 当循环完成时， <code>i</code> 的值最终变成了 4。</p><p>关于这个陷阱有一个普遍严重的误解，它被认为只针对 Python 的 <a href="http://docs.python.org/reference/expressions.html#lambda" target="_blank" rel="noopener">闭包 lambda</a> 定义方式。 事实上，由 <code>lambda</code> 表达式创建的函数并没什么特别，同样的问题也出现在使用普通的 <code>def</code> 上：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def create_multipliers():</span><br><span class="line">    multipliers = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">5</span>):</span><br><span class="line">        def multiplier(x):</span><br><span class="line">            <span class="keyword">return</span> i * x</span><br><span class="line">        multipliers.append(multiplier)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> multipliers</span><br></pre></td></tr></table></figure><h3 id="以上正确的做法应该是："><a href="#以上正确的做法应该是：" class="headerlink" title="以上正确的做法应该是："></a>以上正确的做法应该是：</h3><p>最简单通用的解决方案可以说是有点取巧（hack）。由于 Python 拥有在前文提到的『为函数默认参数赋值』的行为（参见 <a href="http://pythonguidecn.readthedocs.io/zh/latest/writing/gotchas.html#default-args" target="_blank" rel="noopener">可变默认参数</a> ），你可以创建一个立即绑定参数的闭包，像下面这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def create_multipliers():</span><br><span class="line">    <span class="keyword">return</span> [lambda x, i=i : i * x <span class="keyword">for</span> i in range(<span class="number">5</span>)]</span><br></pre></td></tr></table></figure><p>或者，使用 <code>functools.partial</code> 函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from functools import partial</span><br><span class="line">from operator import mul</span><br><span class="line"></span><br><span class="line">def create_multipliers():</span><br><span class="line">    <span class="keyword">return</span> [partial(mul, i) <span class="keyword">for</span> i in range(<span class="number">5</span>)]</span><br></pre></td></tr></table></figure><h3 id="缺陷并不可怕"><a href="#缺陷并不可怕" class="headerlink" title="缺陷并不可怕"></a>缺陷并不可怕</h3><p>有时你就想要闭包有如此表现，延迟绑定在很多情况下是一个很赞的特性。不幸的是，循环创建独立函数是一种会使它们出差错的情况。</p><h2 id="字节码（-pyc）文件无处不在！"><a href="#字节码（-pyc）文件无处不在！" class="headerlink" title="字节码（.pyc）文件无处不在！"></a>字节码（.pyc）文件无处不在！</h2><p>默认情况下，当你直接执行 Python 脚本文件时，Python 解释器会自动将该文件的字节码版本写入同目录下。 比如， <code>module.pyc</code>。</p><p>这些 <code>.pyc</code> 文件不应该被纳入源代码仓库。</p><p>理论上，出于性能原因，此行为默认为开启。 没有这些字节码文件， Python 会在每次加载文件时重新生成字节码文件。</p><h3 id="禁用字节码（-pyc）文件"><a href="#禁用字节码（-pyc）文件" class="headerlink" title="禁用字节码（.pyc）文件"></a>禁用字节码（.pyc）文件</h3><p>幸运的是，生成字节码的过程非常快，在开发代码时不需要担心。</p><p>那些文件很讨厌，所以让我们摆脱他们吧！</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export PYTHONDONTWRITEBYTECODE=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用 <code>$PYTHONDONTWRITEBYTECODE</code> 环境变量来命令 Python 不将这些文件写入磁盘， 开发环境将会保持整洁和干净。</p><p>我建议在你的 <code>~/.profile</code> 里设置这个环境变量。</p><h3 id="删除字节码（-pyc）文件"><a href="#删除字节码（-pyc）文件" class="headerlink" title="删除字节码（.pyc）文件"></a>删除字节码（.pyc）文件</h3><p>以下是删除所有已存在字节码文件的好方法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -type f -name <span class="string">"*.py[co]"</span> -delete -<span class="keyword">or</span> -type d -name <span class="string">"__pycache__"</span> -delete</span><br></pre></td></tr></table></figure><p>从项目根目录运行，所有 <code>.pyc</code> 文件会瞬间消失。</p><h3 id="版本控制忽略"><a href="#版本控制忽略" class="headerlink" title="版本控制忽略"></a>版本控制忽略</h3><p>如果由于性能原因仍然需要 <code>.pyc</code> 文件，你可以随时将它们添加到版本控制存储库的忽略文件中。 流行的版本控制系统能够使用文件中定义的通配符来应用特殊规则。</p><p>一份忽略文件将确保匹配的文件未被检入存储库。 <a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a> 使用 <code>.gitignore</code>，而 <a href="https://www.mercurial-scm.org/" target="_blank" rel="noopener">Mercurial</a> 使用 <code>.hgignore</code>。</p><p>忽略文件里至少应该具备以下内容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syntax:glob   <span class="comment"># This line is not needed for .gitignore files.</span></span><br><span class="line">*.py[cod]     <span class="comment"># Will match .pyc, .pyo and .pyd files.</span></span><br><span class="line">__pycache__/  <span class="comment"># Exclude the whole folder</span></span><br></pre></td></tr></table></figure><p>可按需添加更多文件和目录。下次提交到存储库时，这些文件将不被包括。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常，Python 旨在成为一门简洁一致的语言，避免发生意外。然而，有些情况可能会给新手们造成困惑。&lt;/p&gt;
&lt;p&gt;在这些情况中，有一些虽是有意为之，但还是有潜在风险。还有一些则可以说是语言设计缺陷了。总之，下面列出的这些情况都是些乍一看很不好理解的行为，不过一旦您了解了这
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
</feed>

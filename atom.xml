<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yo42</title>
  
  <subtitle>Dont&#39;t Panic,Do not go gentle into that good night~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yo42.github.io/"/>
  <updated>2018-10-01T11:34:43.970Z</updated>
  <id>https://yo42.github.io/</id>
  
  <author>
    <name>Yo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初尝Node.js</title>
    <link href="https://yo42.github.io/2018/10/01/%E5%88%9D%E5%B0%9DNode-js/"/>
    <id>https://yo42.github.io/2018/10/01/初尝Node-js/</id>
    <published>2018-10-01T09:16:58.959Z</published>
    <updated>2018-10-01T11:34:43.970Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js® 是一个基于 <a href="https://developers.google.com/v8/" target="_blank" rel="noopener">Chrome V8 引擎</a> 的 JavaScript 运行时。</p><p><strong>Node.js</strong>是一个能够在服务器端运行<a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a>的<a href="https://zh.wikipedia.org/wiki/%E9%96%8B%E6%94%BE%E5%8E%9F%E5%A7%8B%E7%A2%BC" target="_blank" rel="noopener">开放源代码</a>、<a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E5%B9%B3%E5%8F%B0" target="_blank" rel="noopener">跨平台</a>JavaScript <a href="https://zh.wikipedia.org/wiki/%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener">运行环境</a>。</p><p><strong>Node.js采用了<a href="https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95" target="_blank" rel="noopener">事件驱动</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E9%9D%9E%E9%98%BB%E5%A1%9E&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">非阻塞</a>和 <a href="https://zh.wikipedia.org/w/index.php?title=%E9%9D%9E%E5%90%8C%E6%AD%A5%E8%BC%B8%E5%85%A5%E8%BC%B8%E5%87%BA&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">异步输入输出</a>模型等技术来提高性能</strong>，可优化应用程序的传输量和规模。这些技术通常用于数据密集的实时应用程序。</p><p><strong>Node.js以单线程运行，使用非阻塞I/O调用，这样既可以支持数以万计的并发连线，又不会因多线程本身的特点而带来麻烦。众多请求只使用单线程的设计意味着可以用于创建高并发应用程序。</strong>Node.js应用程序的设计目标是任何需要操作I/O的函数都使用<a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">回调函数</a>。</p><p>这种设计的缺点是，如果不使用<a href="https://nodejs.org/api/cluster.html" target="_blank" rel="noopener">cluster</a>、<a href="http://strong-pm.io/" target="_blank" rel="noopener">StrongLoop Process Manager</a>或<a href="https://github.com/Unitech/pm2" target="_blank" rel="noopener">pm2</a>等模块，Node.js就难以处理多核或多线程等情况。</p><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>nvm:Node.js版本控制器，用于切换多版本的Node.js环境。</p><p>npm:（全称 Node Package Manager，即“node包管理器”）是<a href="https://zh.wikipedia.org/wiki/Node.js" target="_blank" rel="noopener">Node.js</a>默认的、以<a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a>编写的<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94%E5%A5%97%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1" target="_blank" rel="noopener">软件包管理系统</a>。</p><p>Node.js Express 框架: 相当于Python的Flask框架</p><p>Node.js核心内置模块:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http：提供HTTP服务器功能。</span><br><span class="line">url：解析URL。</span><br><span class="line">fs：与文件系统交互。</span><br><span class="line">querystring：解析URL的查询字符串。</span><br><span class="line">child_process：新建子进程。</span><br><span class="line">util：提供一系列实用小工具。</span><br><span class="line">path：处理文件路径。</span><br><span class="line">crypto：提供加密和解密功能，基本上是对OpenSSL的包装。</span><br></pre></td></tr></table></figure><h1 id="阻塞对比非阻塞一览"><a href="#阻塞对比非阻塞一览" class="headerlink" title="阻塞对比非阻塞一览"></a>阻塞对比非阻塞一览</h1><p>本概论涵盖了在 Node.js 中 <strong>阻塞</strong> and <strong>非阻塞</strong> 的区别，同时也会牵涉到时间轮询和 libuv 方面，不需要先行了解这些方面的知识也可以继续阅读。我们假定读者对于 JavaScript 语言和 Node.js 的回调机制有一个基本的了解。</p><blockquote><p>“I/O” 指的是系统磁盘和由 <a href="http://libuv.org/" target="_blank" rel="noopener">libuv</a> 支持的网络之间的交互。</p></blockquote><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p><strong>阻塞</strong> 是说 Node.js 中其它的 JavaScript 命令必须等到一个非 JavaScript 操作完成之后才可以执行。这是因为当 <strong>阻塞</strong> 发生时，事件机制无法继续运行JavaScript。</p><p>在 Node.js 中，JavaScript由于 CPU 密集操作而表现不佳。而不是等待非 JavaScript操作 （例如I/O）。这被称为 <strong>阻塞</strong>。在 Node.js 基本类库中，使用 libuv 的同步方法大多数都是 <strong>阻塞</strong> 的。原生方法也可能是 <strong>阻塞</strong> 的。</p><p>所有在 Node.js 中提供的 I/O 方法也包括异步版本，它们都是 <strong>非阻塞</strong> 的，接受回调函数。一些方法同时也具备 <strong>阻塞</strong> 功能，它们的名字结尾都以 <code>Sync</code> 结尾。</p><h2 id="代码比较"><a href="#代码比较" class="headerlink" title="代码比较"></a>代码比较</h2><p><strong>阻塞</strong> 方法执行起来是 <strong>同步地</strong>，但是 <strong>非阻塞</strong> 方法执行起来是 <strong>异步地</strong>。 如果你使用文件系统模块读取一个文件，同步方法看上去如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> data = fs.readFileSync(<span class="string">'/file.md'</span>); <span class="comment">// blocks here until file is read</span></span><br></pre></td></tr></table></figure><p>这是一个与之功能等同的 <strong>异步</strong> 版本示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'/file.md'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第一个示例看上去比第二个似乎简单些，但是有一个缺陷：第二行语句会 <strong>阻塞</strong> 其它 JavaScript 语句的执行直到整个文件全部读取完毕。注意在同步版本的代码中，任何异常都会抛出，会导致整个程序崩溃。在异步版本示例代码中，它由作者来决定是否抛出异常。</p><p>让我们扩展一点我们的同步代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> data = fs.readFileSync(<span class="string">'/file.md'</span>); <span class="comment">// blocks here until file is read</span></span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line"><span class="comment">// moreWork(); will run after console.log</span></span><br></pre></td></tr></table></figure><p>这是一个类似的，但是功能上不等同的异步代码示例版本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'/file.md'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// moreWork(); will run before console.log</span></span><br></pre></td></tr></table></figure><p>第一个示例代码中， <code>console.log</code> 将在 <code>moreWork()</code> 之前被调用。在第二个例子中， <code>fs.readFile()</code> 因为是 <strong>非阻塞</strong> 的，所以 JavaScript 会继续执行， <code>moreWork()</code> 将被首先调用。<code>moreWork()</code> 无需等待文件读完而先行执行完毕，这对于高效吞吐来说是一个绝佳的设计。</p><h2 id="并行和吞吐"><a href="#并行和吞吐" class="headerlink" title="并行和吞吐"></a>并行和吞吐</h2><p>在 Node.js 中 JavaScript 的执行是单线程的，所以并行与事件轮询能力（即在完成其它任务之后处理 JavaScript 回调函数的能力）有关。任何一个企图以并行的方式运行的代码必须让事件轮询机制以非 JavaScript 操作来运行，像 I/O 操作。</p><p>举个例子，让我们思考一个案例：案例中每个对服务器的请求消耗 50 毫秒完成，其中的 45 毫秒又是可以通过异步操作而完成的数据库操作。选择 <strong>非阻塞</strong> 操作可以释放那 45 毫秒用以处理其它的请求操作。这是在选择 <strong>阻塞</strong> 和 <strong>非阻塞</strong> 方法上的重大区别。</p><p>Node.js 中的事件轮询机制和其它语言相比而言有区别，其它语言需要创建线程来处理并行任务。</p><h2 id="把阻塞和非阻塞代码混在一起写的危险"><a href="#把阻塞和非阻塞代码混在一起写的危险" class="headerlink" title="把阻塞和非阻塞代码混在一起写的危险"></a>把阻塞和非阻塞代码混在一起写的危险</h2><p>在处理 I/O 问题时，有些东西必须避免。下面让我们看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'/file.md'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">fs.unlinkSync(<span class="string">'/file.md'</span>);</span><br></pre></td></tr></table></figure><p>在以上的例子中， <code>fs.unlinkSync()</code> 极有可能在 <code>fs.readFile()</code> 之前执行，所以在真正准备开始读取文件前此文件就已经被删除了。一个更好的处理方法就是彻底让使它变得 <strong>非阻塞化</strong>，并且保证按照正确顺序执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'/file.md'</span>, (readFileErr, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (readFileErr) <span class="keyword">throw</span> readFileErr;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  fs.unlink(<span class="string">'/file.md'</span>, (unlinkErr) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (unlinkErr) <span class="keyword">throw</span> unlinkErr;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上代码在 <code>fs.readFile()</code> 用异步方式调用 <code>fs.unlink()</code>，这就保证了执行顺序的正确。</p><h2 id="第一个应用"><a href="#第一个应用" class="headerlink" title="第一个应用"></a>第一个应用</h2><p>app.js # require命令用于指定加载模块，加载时可以省略脚本文件的后缀名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">'127.0.0.1'</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.statusCode = <span class="number">200</span>;</span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(port, hostname, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后使用 <code>node app.js</code> 运行程序，访问 <a href="http://localhost:3000%EF%BC%8C%E4%BD%A0%E5%B0%B1%E4%BC%9A%E7%9C%8B%E5%88%B0%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%EF%BC%8C%E5%86%99%E7%9D%80%E2%80%9CHello/" target="_blank" rel="noopener">http://localhost:3000，你就会看到一个消息，写着“Hello</a> World”。</p><h3 id="Run-Node-js-in-Docker"><a href="#Run-Node-js-in-Docker" class="headerlink" title="Run Node.js in Docker"></a>Run Node.js in Docker</h3><h4 id="创建-Node-js-应用"><a href="#创建-Node-js-应用" class="headerlink" title="创建 Node.js 应用"></a>创建 Node.js 应用</h4><p>首先，创建一个新文件夹以便于容纳需要的所有文件，并且在此其中创建一个 <code>package.json</code> 文件，描述你应用程序以及需要的依赖：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"docker_web_app"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Node.js on Docker"</span>,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"Neo  &lt;Neo42@mail.com&gt;"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"server.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node app2mongo.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"express"</span>: <span class="string">"^4.16.3"</span>,</span><br><span class="line">    <span class="attr">"mongodb"</span>: <span class="string">"^3.1.6"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配合着你的 <code>package.json</code> 请运行 <code>npm install</code>。如果你使用的 <code>npm</code> 是版本 5 或者之后的版本，这会自动生成一个 <code>package-lock.json</code> 文件，它将一起被拷贝进入你的 Docker 镜像中。</p><h4 id="安装-MongoDB-driver-for-Node-js"><a href="#安装-MongoDB-driver-for-Node-js" class="headerlink" title="安装 MongoDB driver for Node.js."></a>安装 <a href="https://www.mongodb.com/" target="_blank" rel="noopener">MongoDB</a> driver for Node.js.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mongodb --save</span><br></pre></td></tr></table></figure><p>App2mongo.js # 操作测试Mongodb</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertDocuments = <span class="function"><span class="keyword">function</span>(<span class="params">db, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Get the documents collection</span></span><br><span class="line">  <span class="keyword">const</span> collection = db.collection(<span class="string">'documents'</span>);</span><br><span class="line">  <span class="comment">// Insert some documents</span></span><br><span class="line">  collection.insertMany([</span><br><span class="line">    &#123;<span class="attr">Neo</span> : <span class="number">42</span>&#125;, &#123;<span class="attr">a</span> : <span class="number">2</span>&#125;, &#123;<span class="attr">a</span> : <span class="number">3</span>&#125;</span><br><span class="line">  ], <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    assert.equal(err, <span class="literal">null</span>);</span><br><span class="line">    assert.equal(<span class="number">3</span>, result.result.n);</span><br><span class="line">    assert.equal(<span class="number">3</span>, result.ops.length);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Inserted 3 documents into the collection Neo"</span>);</span><br><span class="line">    callback(result);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findDocuments = <span class="function"><span class="keyword">function</span>(<span class="params">db, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Get the documents collection</span></span><br><span class="line">  <span class="keyword">const</span> collection = db.collection(<span class="string">'documents'</span>);</span><br><span class="line">  <span class="comment">// Find some documents</span></span><br><span class="line">  collection.find(&#123;&#125;).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, docs</span>) </span>&#123;</span><br><span class="line">    assert.equal(err, <span class="literal">null</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Found the following records"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(docs)</span><br><span class="line">    callback(docs);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connection URL</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">'mongodb://192.168.0.103:27017'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Database Name</span></span><br><span class="line"><span class="keyword">const</span> dbName = <span class="string">'Neo42'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use connect method to connect to the server</span></span><br><span class="line">MongoClient.connect(url, <span class="function"><span class="keyword">function</span>(<span class="params">err, client</span>) </span>&#123;</span><br><span class="line">  assert.equal(<span class="literal">null</span>, err);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Connected correctly to server Neo42"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> db = client.db(dbName);</span><br><span class="line"></span><br><span class="line">  insertDocuments(db, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    findDocuments(db, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      client.close();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="创建Dockerfile"><a href="#创建Dockerfile" class="headerlink" title="创建Dockerfile"></a>创建Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create app directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Install app dependencies</span></span></span><br><span class="line"><span class="bash"><span class="comment"># A wildcard is used to ensure both package.json AND package-lock.json are copied</span></span></span><br><span class="line"><span class="bash"><span class="comment"># where available (npm@5+)</span></span></span><br><span class="line"><span class="bash">COPY package*.json ./</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN npm install</span></span><br><span class="line"><span class="bash"><span class="comment"># If you are building your code for production</span></span></span><br><span class="line"><span class="bash"><span class="comment"># RUN npm install --only=production</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Bundle app source</span></span></span><br><span class="line"><span class="bash">COPY . .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 8080</span></span><br><span class="line"><span class="bash">CMD [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure><h4 id="构建DockerImage"><a href="#构建DockerImage" class="headerlink" title="构建DockerImage"></a>构建DockerImage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t Neo:42/node-web-app .</span><br></pre></td></tr></table></figure><h4 id="Run-Docker"><a href="#Run-Docker" class="headerlink" title="Run Docker"></a>Run Docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -d Neo:42/node-web-app</span><br></pre></td></tr></table></figure><h4 id="运行输出"><a href="#运行输出" class="headerlink" title="运行输出"></a>运行输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Connected correctly to server Neo42 # 连接数据库</span><br><span class="line">Inserted 3 documents into the collection Neo # 插入doc</span><br><span class="line">Found the following records # 查询</span><br><span class="line">[ &#123; _id: 5bb1e06dc2bf97000f0e1886, Neo: 42 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e06dc2bf97000f0e1887, a: 2 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e06dc2bf97000f0e1888, a: 3 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e2bb0c25dc000fa94345, Neo: 42 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e2bb0c25dc000fa94346, a: 2 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e2bb0c25dc000fa94347, a: 3 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e30bb78d09000f1ff341, Neo: 42 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e30bb78d09000f1ff342, a: 2 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e30bb78d09000f1ff343, a: 3 &#125; ]</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://nodejs.org/zh-cn/docs/guides/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/docs/guides/</a></li><li><a href="https://zh.wikipedia.org/zh-cn/Node.js" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-cn/Node.js</a></li><li><a href="https://github.com/nodejs/docker-node/tree/526c6e618300bdda0da4b3159df682cae83e14aa#dockerfile" target="_blank" rel="noopener">https://github.com/nodejs/docker-node/tree/526c6e618300bdda0da4b3159df682cae83e14aa#dockerfile</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Node.js® 是一个基于 &lt;a href=&quot;https://developers.google.com/v8/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chrome V8 引擎&lt;/a&gt; 的 JavaScript 运行时。&lt;/p&gt;
&lt;p&gt;&lt;stro
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>DevOps最全术语汇总</title>
    <link href="https://yo42.github.io/2018/09/24/DevOps%E6%9C%80%E5%85%A8%E6%9C%AF%E8%AF%AD%E6%B1%87%E6%80%BB/"/>
    <id>https://yo42.github.io/2018/09/24/DevOps最全术语汇总/</id>
    <published>2018-09-24T06:46:15.204Z</published>
    <updated>2018-09-24T06:51:59.900Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>A/B Testing</p><p><a href="https://xebialabs.com/glossary/a/b-testing/" target="_blank" rel="noopener">A/B测试</a></p><p>使用A/B测试的技术将新功能或某项功能的不同变体推向不同组别的用户，这些功能可通过比较指标和用户行为进行评估。</p><p>Acceptance Testing</p><p><a href="https://xebialabs.com/glossary/acceptance-testing/" target="_blank" rel="noopener">验收测试</a></p><p>通常对整个系统进行高级测试，以确定新功能和现有功能的整体质量是否足以让系统投入生产。</p><p>Agent</p><p><a href="https://xebialabs.com/glossary/agent/" target="_blank" rel="noopener">代理程序</a></p><p>代理程序是安装在特定物理服务器上的程序，用于在该服务器上处理不同进程的执行。</p><p>Agile</p><p><a href="https://xebialabs.com/glossary/agile/" target="_blank" rel="noopener">敏捷</a></p><p>是DevOps的前身；敏捷是一种软件开发方法，更广泛来说，是一种业务方法。敏捷强调短期迭代的规划和开发周期以提供更好的控制以及可预测性，并支持随着项目的发展而不断变化的需求。</p><p>ARA (Application Release Automation)</p><p><a href="https://xebialabs.com/glossary/ara-(application-release-automation" target="_blank" rel="noopener">ARA （应用程序发布自动化）</a>/)</p><p>可以在目标环境中自动安装和正确配置给定应用程序版本并随时可用的工具、脚本或产品。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>Behavior-Driven Development (BDD)</p><p><a href="https://xebialabs.com/glossary/behavior-driven-development-(bdd" target="_blank" rel="noopener">行为驱动开发（BDD）</a>/)</p><p>一种开发方法，强调软件应该根据应用程序的期望行为并以业务管理人员可读的语法来指定。</p><p>Black Box Testing</p><p><a href="https://xebialabs.com/glossary/black-box-testing/" target="_blank" rel="noopener">黑盒测试</a></p><p>一种测试或质量保证实践，它假设不知道被测系统内部的工作原理，因此尝试验证外部而不是内部行为或状态。</p><p>Build Agent</p><p>Build Agent</p><p>一种用于持续集成的代理程序，可以本地或远程安装，跟持续集成服务器有关。它发送和接收跟处理软件构建有关的消息。</p><p>Build Artifact Repository</p><p><a href="https://xebialabs.com/glossary/build-artifact-repository/" target="_blank" rel="noopener">构建工件存储库</a></p><p>用于组织具有元数据构造的工件，并允许自动发布和使用这些工件的工具。</p><p>Build Automation</p><p><a href="https://xebialabs.com/glossary/build-automation/" target="_blank" rel="noopener">构建自动化</a></p><p>允许将源代码自动编译为可发布的二进制代码的工具或框架。通常包括代码级的单元测试，以确保代码的各个部分按预期运行。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>Canary Release</p><p><a href="https://xebialabs.com/glossary/canary-release/" target="_blank" rel="noopener">灰度发布</a>（金丝雀发布）</p><p>一种上线策略，在该策略中，把新的应用程序版本发布到生产服务器的一小部分上，并严格监控以确定其是否按预期运行。如果一切看起来稳定，那么新版本将推广到整个生产环境。</p><p>Configuration Drift</p><p><a href="https://xebialabs.com/glossary/configuration-drift/" target="_blank" rel="noopener">配置漂移</a></p><p>由于手工的特殊更改（如热修复）没有引入到系统模版中而引起软件和硬件配置与系统模版版本漂移或不一致。</p><p>Configuration Management</p><p><a href="https://xebialabs.com/glossary/configuration-management/" target="_blank" rel="noopener">配置管理</a></p><p>用于建立和维护系统一致的设置和功能属性的术语。它包括用于IT基础设施自动化等系统管理任务的工具。</p><p>Continuous Delivery</p><p><a href="https://xebialabs.com/glossary/continuous-delivery/" target="_blank" rel="noopener">持续交付</a>（CD)</p><p>持续交付是一套流程和实践，从根本上清除软件生产过程中的浪费，能更快地交付高质量的功能，并在业务和用户之间建立快速有效的反馈环。</p><p>Continuous Integration (CI)</p><p><a href="https://xebialabs.com/glossary/continuous-integration-(ci" target="_blank" rel="noopener">持续集成（CI）</a>/)</p><p>持续集成（CI）是一种开发实践，它要求开发人员每天多次把代码集成到共享存储库中。然后通过自动构建验证每次签入，使得团队能尽早发现问题。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>Dark Launch</p><p><a href="https://xebialabs.com/glossary/dark-launch/" target="_blank" rel="noopener">灰度上线</a></p><p>一种上线策略，其中实现新功能的代码被发布到生产环境的子集，但是不可见或只是部分激活。然而，该代码是在生产环境中运行，用户并不知晓。</p><p>Delivery Pipeline</p><p><a href="https://xebialabs.com/glossary/delivery-pipeline/" target="_blank" rel="noopener">交付管道</a></p><p>一系列为新应用程序版本实施软件交付过程的编排的、自动化的任务。该管道中的每个步骤旨在提高新版本的置信度，使其能够做出合格/不合格的决策。交付管道可以被看作是组织发布流程的优化结果。</p><p>DevOps</p><p>DevOps</p><p>DevOps（开发和运维）是一个软件开发短语，用于描述开发和IT运维之间的敏捷关系。DevOps的目标是改善在软件开发周期中不同角色之间的沟通、协作和流程，以改善和加速软件交付。</p><p>DevOps Intelligence</p><p><a href="https://xebialabs.com/glossary/devops-intelligence/" target="_blank" rel="noopener">DevOps</a>智能</p><p>提供公司所需的洞察力，以更高效、更低风险和更好结果的方式交付软件，</p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>Functional Testing</p><p><a href="https://xebialabs.com/glossary/functional-testing/" target="_blank" rel="noopener">功能测试</a></p><p>进行端到端系统的测试以验证（新）功能。使用可执行规范，通过运行针对应用程序的规范来进行功能测试。</p><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>Infrastructure as a Service (IaaS)</p><p><a href="https://xebialabs.com/glossary/infrastructure-as-a-service-(iaas" target="_blank" rel="noopener">基础</a>/)<a href="https://xebialabs.com/glossary/infrastructure-as-a-service-(iaas" target="_blank" rel="noopener">设施</a>/)<a href="https://xebialabs.com/glossary/infrastructure-as-a-service-(iaas" target="_blank" rel="noopener">即服务（IaaS）</a>/)</p><p>云托管的虚拟机器通常根据“按需付费”收费。用户对机器有完全的控制，但是需要自己安装和配置所需的中间件和应用程序。</p><p>Infrastructure as Code</p><p><a href="https://xebialabs.com/glossary/infrastructure-as-code/" target="_blank" rel="noopener">基础</a><a href="https://xebialabs.com/glossary/infrastructure-as-code/" target="_blank" rel="noopener">设施</a><a href="https://xebialabs.com/glossary/infrastructure-as-code/" target="_blank" rel="noopener">即代码</a>（IaC)</p><p>一种系统配置管理技术，其中以完全自动化的形式指定机器、网络设备、操作系统、中间件等。规范或“蓝图”被认为是代码，由供应工具执行，保存在版本控制中，通常遵循用于应用程序代码开发的相同实践。</p><h3 id="L"><a href="#L" class="headerlink" title="L"></a>L</h3><p>Lean</p><p><a href="https://xebialabs.com/glossary/lean/" target="_blank" rel="noopener">精益</a></p><p>“精益制造”或“精益生产”是一种方式或方法，旨在通过专注于保护价值来减少生产过程中的浪费。它很大程度上来源于丰田公司在汽车制造业中开发的实践，精益概念已经作为敏捷方法的部分被应用于软件开发。价值流程图（VSM）试图直观地识别有价值和有浪费的流程步骤，是个关键的精益工具。</p><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>Microservices</p><p><a href="https://xebialabs.com/glossary/microservices/" target="_blank" rel="noopener">微服务</a></p><p>微服务是一种软件架构设计模式，其中复杂的应用程序由独立的小型进程构成，这些进程使用与语言无关的API进行通信。这些服务规模小，高度分离，专注于完成一个小任务。</p><h3 id="N"><a href="#N" class="headerlink" title="N"></a>N</h3><p>Non-functional Requirements (NFRs)</p><p><a href="https://xebialabs.com/glossary/non-functional-requirements-(nfrs" target="_blank" rel="noopener">非功能性需求（NFRs）</a>/)</p><p>系统质量的规范，诸如易用性，设计清晰度，延迟，速度，处理大量用户的能力等，描述了如何轻松或高效地使用某个功能，而不只是它是否存在。这些特性可以使用持续交付反馈环来解决和改善。</p><p>NoOps</p><p>NoOps</p><p>在一个公司中，应用程序运行的系统管理要么是完全由外部一方（如PaaS 供应商）来处理，要么就是全自动化的。使用NoOps旨在尽量减少或不使用内部运维能力和员工。</p><h3 id="O"><a href="#O" class="headerlink" title="O"></a>O</h3><p>Orchestration Pipeline</p><p><a href="https://xebialabs.com/glossary/orchestration-pipeline/" target="_blank" rel="noopener">编排管道</a></p><p>在适当的时间调用形成持续交付管道的不同自动化任务的工具或产品。它们通常也记录每个任务的状态和输出，并通过管道可视化特征流。</p><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>Platform as a Service (PaaS)</p><p><a href="https://xebialabs.com/glossary/platform-as-a-service-(paas" target="_blank" rel="noopener">平台即服务（PaaS）</a>/)</p><p>云托管的应用程序运行时间通常根据“按需支付”的原则计费。用户提供应用程序代码和有限的配置设置，中间件、数据库等都是提供的运行时的一部分。</p><p>Product Owner</p><p><a href="https://xebialabs.com/glossary/product-owner/" target="_blank" rel="noopener">产品负责人</a></p><p>开发团队中负责定义、确定优先级和维护未完成功能及其他工作的人或角色。产品负责人在敏捷软件开发方法中很常见，通常代表业务或客户组织。相比在更传统的软件开发过程中的同行，产品负责人需要在敏捷开发流程中扮演更积极的日常角色。</p><p>Provisioning</p><p><a href="https://xebialabs.com/glossary/provisioning/" target="_blank" rel="noopener">服务开通</a></p><p>为用户（在持续交付的场景下，通常是开发或测试团队）准备新系统的过程。该系统通常根据需要进行虚拟化和实例化。配置机器以安装操作系统、中间件等操作是由自动化的系统配置管理工具来处理，这些自动化工具还验证所需要的配置是否得到维护。</p><h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><p>Regression Testing</p><p><a href="https://xebialabs.com/glossary/regression-testing/" target="_blank" rel="noopener">回归测试</a></p><p>对端到端系统的测试，以验证应用程序的更改没有对现有功能产生负面影响。</p><p>Release Coordination</p><p><a href="https://xebialabs.com/glossary/release-coordination/" target="_blank" rel="noopener">发布协调</a></p><p>定义和执行从代码签入到生效的新功能（或功能集）所需的所有操作。在持续交付环境中，这在很大程度上是完全自动化的，并由管道执行。</p><p>Release Management</p><p><a href="https://xebialabs.com/glossary/release-management/" target="_blank" rel="noopener">发布管理</a></p><p>发布管理是管理软件发布从开发阶段到实际软件发布阶段的流程。</p><p>Release Orchestration</p><p><a href="https://xebialabs.com/glossary/release-orchestration/" target="_blank" rel="noopener">发布编排</a></p><p>发布编排是使用诸如XL发布等工具管理软件发布（从开发阶段到实际软件发布阶段）。</p><h3 id="T"><a href="#T" class="headerlink" title="T"></a>T</h3><p>Test-Driven Development (TDD)</p><p><a href="https://xebialabs.com/glossary/test-driven-development-(tdd" target="_blank" rel="noopener">测试驱动开发（TDD）</a>/)</p><p>一种开发实践，在该实践过程中，用于验证代码片段表现的小测试在编写代码前就已经写就。这些测试最初是失败的，但开发人员的目标是接着添加代码使这些测试成功。</p><h3 id="U"><a href="#U" class="headerlink" title="U"></a>U</h3><p>Unit Testing</p><p><a href="https://xebialabs.com/glossary/unit-testing/" target="_blank" rel="noopener">单元测试</a></p><p>代码级（即无需安装完整的端到端系统以运行）测试以验证各个代码段的行为。TDD广泛使用单元测试以描述和验证预期的行为。</p><h3 id="V"><a href="#V" class="headerlink" title="V"></a>V</h3><p>Value Stream Mapping</p><p><a href="https://xebialabs.com/glossary/value-stream-mapping/" target="_blank" rel="noopener">价值</a><a href="https://xebialabs.com/glossary/value-stream-mapping/" target="_blank" rel="noopener">流程</a><a href="https://xebialabs.com/glossary/value-stream-mapping/" target="_blank" rel="noopener">图</a></p><p>一种过程可视化和改善技术，大量用于精益生产和工程方法中。价值流图用于识别必要的处理步骤，而不是逐渐清除流程中的“浪费”。</p><p>Virtualization</p><p><a href="https://xebialabs.com/glossary/virtualization/" target="_blank" rel="noopener">虚拟化</a></p><p>一种系统管理方法，用户和应用程序不需要使用物理机器，而是在实际的“真实”硬件上运行的模拟系统。这样的“虚拟机”能够在几秒钟内自动生成、启动、停运、克隆和丢弃，给操作带来了巨大的便利。</p><h3 id="W"><a href="#W" class="headerlink" title="W"></a>W</h3><p>Waterfall</p><p><a href="https://xebialabs.com/glossary/waterfall/" target="_blank" rel="noopener">瀑布式（开发）</a></p><p>一种基于分阶段项目方法的软件开发方法，从“需求收集”到“开发”，再到“发布”。如果项目中前面的阶段有延迟，整个过程中靠后的阶段（通常和测试及QA相关）会因此在时间上受到挤压。</p><p>White Box Testing</p><p><a href="https://xebialabs.com/glossary/white-box-testing/" target="_blank" rel="noopener">白盒测试</a></p><p>一种测试或质量保证实践，它通过系统运行时检查系统（内部）表现和状态以验证系统内部功能是否正确。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;A&quot;&gt;&lt;a href=&quot;#A&quot; class=&quot;headerlink&quot; title=&quot;A&quot;&gt;&lt;/a&gt;A&lt;/h3&gt;&lt;p&gt;A/B Testing&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://xebialabs.com/glossary/a/b-testing/&quot; t
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>持续集成CI/CD</title>
    <link href="https://yo42.github.io/2018/09/24/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90CI-CD/"/>
    <id>https://yo42.github.io/2018/09/24/持续集成CI-CD/</id>
    <published>2018-09-24T06:08:38.669Z</published>
    <updated>2018-09-24T14:24:56.742Z</updated>
    
    <content type="html"><![CDATA[<p><strong>持续集成（Continuous Integration）</strong>指的是，频繁地（一天多次）将代码集成到主干。 </p><p>在保证质量的前提，通过持续集成使产品进行快速的迭代。</p><p>它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p><p>互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称CI）。</p><p><strong>持续交付</strong>（Continuous delivery）<em>**</em>在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（<em>production-like environments</em>）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。</p><p>持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p><p><strong>持续部署</strong>则是在持续交付的基础上，把部署到生产环境的过程自动化。</p><p>持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。</p><p>持续部署的前提是能自动化完成测试、构建、部署等步骤。</p><p>持续集成CI/CD工具:Jenkins、Travis CI、Drone、Wercker、Circle CI等等….</p><p>工具上的话，jenkins使用的较多，插件多、社区文化活跃。</p><p>常见组合:jenkins+svn+maven+ant、jenkins+GitLab</p><p>持续集成的核心价值在于：</p><ol><li>持续集成中的任何一个环节都是自动完成的，无需太多的人工干预，有利于减少重复过程以节省时间、费用和工作量；</li><li>持续集成保障了每个时间点上团队成员提交的代码是能成功集成的。换言之，任何时间点都能第一时间发现软件的集成问题，使任意时间发布可部署的软件成为了可能；</li><li>持续集成还能利于软件本身的发展趋势，这点在需求不明确或是频繁性变更的情景中尤其重要，持续集成的质量能帮助团队进行有效决策，同时建立团队对开发产品的信心。</li></ol><h3 id="为啥需要持续集成CI-CD？"><a href="#为啥需要持续集成CI-CD？" class="headerlink" title="为啥需要持续集成CI/CD？"></a>为啥需要持续集成CI/CD？</h3><p>敏捷开发、快速交付是互联网行业的标准。一个产品、一个项目团队，通过高效的敏捷开发，以及快速交付产品的流程使其能从软件行业中脱颖而出。说白了就是为了应对快速变化需求的一个解决方案或者手段。</p><p>解放运维劳动力，提高效率，减少因发布、部署、交付更新带来的失误。</p><p>随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile） 在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。</p><p>持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。</p><h3 id="持续集成CI-CD的好处"><a href="#持续集成CI-CD的好处" class="headerlink" title="持续集成CI/CD的好处"></a>持续集成CI/CD的好处</h3><p><strong>快速发现错误。</strong>每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。</p><p><strong>防止分支大幅偏离主干。</strong>如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</p><p>持续集成的大致流程:</p><blockquote><p>编码 -&gt; 构建 -&gt; 集成 -&gt; 测试 -&gt; 交付 -&gt; 部署</p></blockquote><h2 id="持续集成的原则"><a href="#持续集成的原则" class="headerlink" title="持续集成的原则"></a>持续集成的原则</h2><p>业界普遍认同的持续集成的原则包括：</p><ul><li>需要版本控制软件保障团队成员提交的代码不会导致集成失败。常用的版本控制软件有 git、svn 等；</li><li>开发人员必须及时向版本控制库中提交代码，也必须经常性地从版本控制库中更新代码到本地；</li><li>需要有专门的集成服务器来执行集成构建。根据项目的具体实际，集成构建可以被软件的修改来直接触发，也可以定时启动，如每半个小时构建一次；</li><li>必须保证构建的成功。如果构建失败，修复构建过程中的错误是优先级最高的工作。一旦修复，需要手动启动一次构建。</li></ul><h2 id="持续集成系统的组成"><a href="#持续集成系统的组成" class="headerlink" title="持续集成系统的组成"></a>持续集成系统的组成</h2><p>由此可见，一个完整的构建系统必须包括：</p><ul><li>一个自动构建过程，包括自动编译、分发、部署和测试等。</li><li>一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库。</li><li>一个持续集成服务器。</li></ul><h3 id="在实施CI-CD对整个团队文化的影响"><a href="#在实施CI-CD对整个团队文化的影响" class="headerlink" title="在实施CI/CD对整个团队文化的影响"></a>在实施CI/CD对整个团队文化的影响</h3><p>CICD是一个流程上的实践，我们把代码开发、到代码部署、到最后的交付，进行持续地迭代和交付，在这个过程中对原来的团队产生的影响是这样的：开发不再只关注他在开发这部分的实现，他需要保证从代码开发实现、到单测、到测试、到构建部署，到最后的分发发布，这样整个流程的覆盖。按照我的理解，CICD对整个团队文化的影响是，每个人对产品研发的整个流程都要全部参与进去，不再是只局限在自己的角色上。比如我是一个开发，我只做实现，我不再关注部署和测试；或者我是一个测试，我不关注开发实现，不关注部署，我只关注执行；或者我是一个运维，我对前面的所有流程都不了解，我只执行最后的运维步骤，而CICD就是把整个团队有效地集成在一起，通过一个流程持续地迭代发布验证，这样的话，整个团队就能更高效地展开合作。</p><h3 id="多分支、多版本实施CI-CD的建议"><a href="#多分支、多版本实施CI-CD的建议" class="headerlink" title="多分支、多版本实施CI/CD的建议"></a>多分支、多版本实施CI/CD的建议</h3><p>我们目前的确也遇到了多分支并行的情况，也就是说我们需要对不同的业务场景做不同的版本管理。在这种情况下，我们依然可以做CI的实施，但是要经过专门的设计，在每个分支所运行的软件，它的版本管理需要做统一的管理，比如需要规划每个分支的依赖是什么样的，要把整个路径都管理起来。如果没有这样的管理，从构建到部署到测试都是混乱的。在版本管理的基础上，我们还要把代码和测试有效地集成起来，也就是说，不光是代码到测试，是代码到配置、到测试、到部署，都要有效地集成起来。一份代码在这个分支上，它对应的配置在哪里，是什么版本，在这个分支上测试的版本在哪里，都需要管理起来；在这个分支上，代码部署的版本依赖也需要统一的管理。如果我们没有做好这些基础设施，是没有办法做CICD实施的。当我们把这些整理清楚之后，再针对每个分支做整体的实施，通过版本管理去理清楚我们实施的部署构建，到底依赖圈是什么样的，这样就可以做一个正确的实施。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;持续集成（Continuous Integration）&lt;/strong&gt;指的是，频繁地（一天多次）将代码集成到主干。 &lt;/p&gt;
&lt;p&gt;在保证质量的前提，通过持续集成使产品进行快速的迭代。&lt;/p&gt;
&lt;p&gt;它的核心措施是，代码集成到主干之前，必须通过自动化测试
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>关于游戏客户端资源热更方式&amp;流程</title>
    <link href="https://yo42.github.io/2018/09/16/%E5%85%B3%E4%BA%8E%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B5%84%E6%BA%90%E7%83%AD%E6%9B%B4%E6%96%B9%E5%BC%8F-%E6%B5%81%E7%A8%8B/"/>
    <id>https://yo42.github.io/2018/09/16/关于游戏客户端资源热更方式-流程/</id>
    <published>2018-09-16T06:41:19.561Z</published>
    <updated>2018-09-16T06:59:58.011Z</updated>
    
    <content type="html"><![CDATA[<p>应用场景:客户端人员上传更新资源至内网FTP，运维人员操作将客户端资源外放至外网CDN源站。</p><p>实现技术方案:源站架设Nginx，通过GIT远程仓库模式进行资源的更新。</p><p>改进优化的方向:目前，还是通过手动外放资源的方式进行操作，可以优化为开放HTTP Web API接口实现调用GIT命令，进行资源更新的流程。</p><p>逻辑图:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="client.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="client2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="架设部署gitolite"><a href="#架设部署gitolite" class="headerlink" title="架设部署gitolite"></a>架设部署gitolite</h3><h3 id="克隆管理库"><a href="#克隆管理库" class="headerlink" title="克隆管理库"></a>克隆管理库</h3><h3 id="修改-git2-gitolite-conf-gitolite-conf-配置客户端更新库，并提交即可完成创建操作。"><a href="#修改-git2-gitolite-conf-gitolite-conf-配置客户端更新库，并提交即可完成创建操作。" class="headerlink" title="修改 ./git2-gitolite/conf/gitolite.conf 配置客户端更新库，并提交即可完成创建操作。"></a>修改 ./git2-gitolite/conf/gitolite.conf 配置客户端更新库，并提交即可完成创建操作。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repo cilugame/h5-client</span><br><span class="line">    RW      =   @oc_users</span><br></pre></td></tr></table></figure><h3 id="创建本地库"><a href="#创建本地库" class="headerlink" title="创建本地库"></a>创建本地库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/nucleus/client/data/h5</span><br><span class="line">git init ./</span><br></pre></td></tr></table></figure><h3 id="忽略无关配置"><a href="#忽略无关配置" class="headerlink" title="忽略无关配置"></a>忽略无关配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat&lt;&lt;EOF &gt; .gitignore</span><br><span class="line">/*</span><br><span class="line">!/release</span><br><span class="line">!/release/*</span><br><span class="line">!/.gitignore</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="上传客户端资源"><a href="#上传客户端资源" class="headerlink" title="上传客户端资源"></a>上传客户端资源</h3><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git ci -minit</span><br></pre></td></tr></table></figure><h3 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@git2.cilugame.com:cilugame/h5-client.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="登录CDN源站"><a href="#登录CDN源站" class="headerlink" title="登录CDN源站"></a>登录CDN源站</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/nucleus-h5/global/client/html</span><br></pre></td></tr></table></figure><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@git2.cilugame.com:cilugame/h5-client.git ./h5/</span><br></pre></td></tr></table></figure><h3 id="安全加固"><a href="#安全加固" class="headerlink" title="安全加固"></a>安全加固</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 ./h5/.git/</span><br><span class="line">chmod 600 ./h5/.gitignore</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;应用场景:客户端人员上传更新资源至内网FTP，运维人员操作将客户端资源外放至外网CDN源站。&lt;/p&gt;
&lt;p&gt;实现技术方案:源站架设Nginx，通过GIT远程仓库模式进行资源的更新。&lt;/p&gt;
&lt;p&gt;改进优化的方向:目前，还是通过手动外放资源的方式进行操作，可以优化为开放HTT
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>关于Gitolite &amp; SSH-Config联动</title>
    <link href="https://yo42.github.io/2018/09/16/%E5%85%B3%E4%BA%8EGitolite-SSH-Config%E8%81%94%E5%8A%A8/"/>
    <id>https://yo42.github.io/2018/09/16/关于Gitolite-SSH-Config联动/</id>
    <published>2018-09-16T03:58:25.689Z</published>
    <updated>2018-09-16T07:04:42.634Z</updated>
    
    <content type="html"><![CDATA[<p>Gitolite是一款Perl语言开发的Git服务管理工具，通过公钥对用户进行认证，并能够通过配置文件对写操作进行基于分支和路径的精细授权。<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">仓库地址</a></p><p>SSH-Config:OpenSSH SSH Client config files;SSH config是SSH客户端的一个参数配置方案，可以将一些关于SSH命令的参数放到配置文件中去，执行ssh命令的时候从文件中读取，简化命令行的操作。</p><p>应用场景:开发团队，个人客户端本地通过GIT团队协作模式，实时更新服务器信息。通过配置个人ssh-config(～/.ssh/config)，结合ZSH 补全，可以实现方便、快捷的登录服务器。</p><p>效果图如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="ssh.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="服务端部署gitolite"><a href="#服务端部署gitolite" class="headerlink" title="服务端部署gitolite:"></a>服务端部署gitolite:</h3><h3 id="steps-to-install"><a href="#steps-to-install" class="headerlink" title="steps to install"></a>steps to install</h3><p>First, prepare the ssh key:</p><ul><li>login to “git” on the server</li><li>make sure <code>~/.ssh/authorized_keys</code> is empty or non-existent</li><li>make sure your ssh public key from your workstation has been copied as $HOME/YourName.pub</li></ul><p>Next, install gitolite by running these commands:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/sitaramc/gitolite</span><br><span class="line">mkdir -p $HOME/bin</span><br><span class="line">gitolite/install -to $HOME/bin</span><br></pre></td></tr></table></figure><p>Finally, setup gitolite with yourself as the administrator:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitolite setup -pk YourName.pub</span><br></pre></td></tr></table></figure><p>If the last command doesn’t run perhaps “bin” is not in your “PATH”. You can either add it, or just run:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME/bin/gitolite setup -pk YourName.pub</span><br></pre></td></tr></table></figure><p>If you get any other errors please refer to the online documentation whose URL was given at the top of this file.</p><h3 id="个人本地克隆管理库，实现维护git仓库"><a href="#个人本地克隆管理库，实现维护git仓库" class="headerlink" title="个人本地克隆管理库，实现维护git仓库"></a>个人本地克隆管理库，实现维护git仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@host:gitolite-admin</span><br></pre></td></tr></table></figure><h3 id="新增仓库、以及日常修改权限配置文件"><a href="#新增仓库、以及日常修改权限配置文件" class="headerlink" title="新增仓库、以及日常修改权限配置文件"></a>新增仓库、以及日常修改权限配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conf/gitolite.conf</span><br></pre></td></tr></table></figure><h3 id="新增个人公钥"><a href="#新增个人公钥" class="headerlink" title="新增个人公钥"></a>新增个人公钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在key/目录下新增个人公钥</span><br></pre></td></tr></table></figure><h3 id="Example："><a href="#Example：" class="headerlink" title="Example："></a>Example：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ops_users = mike jake</span><br><span class="line">@dev_users = tom jerry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">repo cilu-h5</span><br><span class="line">    RW      =   @ops_users</span><br><span class="line">    RW      =   get_host xxx</span><br><span class="line">    R       =   tom</span><br><span class="line">    R       =   jerry</span><br></pre></td></tr></table></figure><p>新增仓库只需新增一个repo配置项</p><p>按需使用仓库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@git2.cilugame.com:cilu-h5.git ~/ssh-config/cilu-h5/</span><br></pre></td></tr></table></figure><p>合并本地.ssh/config脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># vim:set et ts=2 sw=2:</span></span><br><span class="line"><span class="comment">#set -x</span></span><br><span class="line"></span><br><span class="line">current_dir=$(dirname <span class="variable">$0</span>)</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;current_dir&#125;</span> &amp;&amp; <span class="built_in">export</span> current_dir</span><br><span class="line"></span><br><span class="line">old_ssh=~/.ssh/config</span><br><span class="line">new_ssh=~/.ssh/config.new</span><br><span class="line">bak_dir=~/.ssh/backup</span><br><span class="line">bak_ssh=<span class="string">"<span class="variable">$&#123;bak_dir&#125;</span>/<span class="variable">$(date +'%F_%H%M%S')</span>"</span></span><br><span class="line">hostname=$(hostname)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="variable">$&#123;old_ssh&#125;</span> ] ;<span class="keyword">then</span></span><br><span class="line">  touch <span class="variable">$&#123;old_ssh&#125;</span></span><br><span class="line">  chmod 0644 <span class="variable">$&#123;old_ssh&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">[ -d ~/.ssh/ControlPath ] || mkdir -pv ~/.ssh/ControlPath</span><br><span class="line"></span><br><span class="line"><span class="comment"># header</span></span><br><span class="line">cat&lt;&lt;\EOF &gt; <span class="variable">$&#123;new_ssh&#125;</span></span><br><span class="line">Host github.com</span><br><span class="line">  Port 22</span><br><span class="line"></span><br><span class="line">Host cnc.cilugame.com</span><br><span class="line">  Port 11932</span><br><span class="line"></span><br><span class="line">Host git2.cilugame.com</span><br><span class="line">    ProxyCommand ssh -q h5@jump.cilugame.com socat - TCP:%h:%p</span><br><span class="line"></span><br><span class="line">Host *</span><br><span class="line">   Port 932</span><br><span class="line">   SendEnv LANG LC_*</span><br><span class="line">   SendEnv GIT_*</span><br><span class="line">   ForwardAgent yes</span><br><span class="line">   ServerAliveInterval 10</span><br><span class="line">   XAuthLocation /opt/X11/bin/xauth</span><br><span class="line">   UseRoaming no</span><br><span class="line">   ControlPersist 1h</span><br><span class="line">   ControlMaster auto</span><br><span class="line">   ControlPath ~/.ssh/ControlPath/%r@%h:%p</span><br><span class="line">   Compression yes</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># openssh 在7.2版本新增了AddKeysToAgent参数并废弃了AskPassGUI参数</span></span><br><span class="line"><span class="keyword">if</span> ssh -V 2&gt;&amp;1 | grep -q <span class="string">"OpenSSH_7.[2-9]"</span>;<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"   AddKeysToAgent yes"</span> &gt;&gt; <span class="variable">$&#123;new_ssh&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># merge</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> ../*/[0-9]*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  file_name=$(basename <span class="variable">$file</span>)</span><br><span class="line">  dir_name=$(dirname  <span class="variable">$file</span>)</span><br><span class="line">  dir_name=$(basename  <span class="variable">$dir_name</span>)</span><br><span class="line">  src_file=<span class="string">"~/ssh-config/<span class="variable">$&#123;dir_name&#125;</span>/<span class="variable">$&#123;file_name&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#echo "#========== $src_file" &gt;&amp;2</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"#========== <span class="variable">$src_file</span> ==========#"</span></span><br><span class="line"></span><br><span class="line">  cat <span class="variable">$file</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line"><span class="keyword">done</span> &gt;&gt; <span class="variable">$&#123;new_ssh&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compare and backup</span></span><br><span class="line">system=$(uname)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$system</span>"</span> == <span class="string">"xDarwin"</span> ] ;<span class="keyword">then</span></span><br><span class="line">  old_md5=$(md5 <span class="variable">$old_ssh</span> | awk <span class="string">'&#123;print $4&#125;'</span>)</span><br><span class="line">  new_md5=$(md5 <span class="variable">$new_ssh</span> | awk <span class="string">'&#123;print $4&#125;'</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  old_md5=$(md5sum <span class="variable">$old_ssh</span> | awk <span class="string">'&#123;print $1&#125;'</span>)</span><br><span class="line">  new_md5=$(md5sum <span class="variable">$new_ssh</span> | awk <span class="string">'&#123;print $1&#125;'</span>)</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo "merge to ~/.ssh/config" &gt;&amp;2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$&#123;old_md5&#125;</span>"</span> = <span class="string">"x<span class="variable">$&#123;new_md5&#125;</span>"</span> ] ;<span class="keyword">then</span></span><br><span class="line">  <span class="comment">#echo "Already up-to-date." &gt;&amp;2</span></span><br><span class="line">  rm -f <span class="variable">$new_ssh</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment">#echo "Updating..." &gt;&amp;2</span></span><br><span class="line">  [ -d <span class="string">"<span class="variable">$bak_dir</span>"</span> ] || mkdir <span class="string">"<span class="variable">$bak_dir</span>"</span></span><br><span class="line">  cp <span class="variable">$old_ssh</span> <span class="variable">$bak_ssh</span></span><br><span class="line">  mv <span class="variable">$new_ssh</span> <span class="variable">$old_ssh</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">chmod 0644 <span class="variable">$&#123;old_ssh&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释ControlPersist</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$hostname</span>"</span> == <span class="string">'oc-dev-s73'</span> ];<span class="keyword">then</span></span><br><span class="line">  sed -i <span class="string">'s/ControlPersist 1h/#ControlPersist 1h/g'</span> <span class="variable">$&#123;old_ssh&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="配置GIT钩子，实现自动触发，更新配置文件"><a href="#配置GIT钩子，实现自动触发，更新配置文件" class="headerlink" title="配置GIT钩子，实现自动触发，更新配置文件"></a>配置GIT钩子，实现自动触发，更新配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/ssh-config/</span><br><span class="line"><span class="keyword">for</span> dir <span class="keyword">in</span> *</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="variable">$dir</span> ] ;<span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">pushd</span> <span class="variable">$dir</span> &gt; /dev/null</span><br><span class="line">    [ -d <span class="string">"./.git/hooks"</span> ] || <span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'#!/bin/sh'</span>                        &gt; .git/hooks/post-merge</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'[ -x ./merge.sh ] &amp;&amp; ./merge.sh'</span> &gt;&gt; .git/hooks/post-merge</span><br><span class="line"></span><br><span class="line">    chmod +x .git/hooks/post-merge</span><br><span class="line">    <span class="built_in">popd</span> &gt; /dev/null</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>后续有更新时（成功后会自动调用勾子进行合并操作）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/ssh-config/cilu-h5/</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>通过使用Gitolite可以大大提高团队的协助效率，有时如果是需要提供第三方技术支持，也可以使用Gitolite进行一些简单的配置文件更新、及交付。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Gitolite是一款Perl语言开发的Git服务管理工具，通过公钥对用户进行认证，并能够通过配置文件对写操作进行基于分支和路径的精细授权。&lt;a href=&quot;https://github.com/sitaramc/gitolite&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-学习资料&amp;社区资讯</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker-s-Guide-to-Python-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99-%E7%A4%BE%E5%8C%BA%E8%B5%84%E8%AE%AF/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker-s-Guide-to-Python-学习资料-社区资讯/</id>
    <published>2018-09-15T10:21:59.298Z</published>
    <updated>2018-09-16T00:27:22.940Z</updated>
    
    <content type="html"><![CDATA[<h3 id="The-Python-Tutorial"><a href="#The-Python-Tutorial" class="headerlink" title="The Python Tutorial"></a>The Python Tutorial</h3><p>这个是官方教程。它包含了所有的基础，并提供了一个关于语言和标准库的教程。推荐给那些需要一份关于这门语言的快速开始指南的人们。</p><blockquote><p><a href="http://docs.python.org/tutorial/index.html" target="_blank" rel="noopener">The Python Tutorial</a></p></blockquote><h3 id="Python-for-Beginners"><a href="#Python-for-Beginners" class="headerlink" title="Python for Beginners"></a>Python for Beginners</h3><p>thepythonguru.com 是一个专注于新手程序员的教程网站。它涵盖了许多深度的 Python 概念。它也会教你一些像 lambda 表达式，正则表达式等 Python 的高级结构。 最后，它以『如何使用 Python 访问 MySQL 数据库』这篇教程结束。</p><blockquote><p><a href="http://thepythonguru.com/" target="_blank" rel="noopener">Python for beginners</a></p></blockquote><h3 id="学习-Python-交互式数据科学"><a href="#学习-Python-交互式数据科学" class="headerlink" title="学习 Python 交互式数据科学"></a>学习 Python 交互式数据科学</h3><p>如果你热衷于在线交互式环境来学习 Python 数据科学， <a href="https://www.datacamp.com/courses/intro-to-python-for-data-science?tap_a=5644-dce66f&amp;tap_s=116411-750171" target="_blank" rel="noopener">this free python tutorial by DataCamp</a> 是一个比较好的开始。如果你已经是一位对机器学习有提前了解和兴趣，并使用scikit-learn的核心开发人员，查看 <a href="https://www.datacamp.com/courses/supervised-learning-with-scikit-learn?tap_a=5644-dce66f&amp;tap_s=116411-750171" target="_blank" rel="noopener">course on Supervised Learning with scikit-learn</a> 。</p><p><a href="http://datacamp.com/?tap_a=5644-dce66f&amp;tap_s=116411-750171" target="_blank" rel="noopener">Python 数据科学</a></p><h3 id="学习交互式-Python-教程"><a href="#学习交互式-Python-教程" class="headerlink" title="学习交互式 Python 教程"></a>学习交互式 Python 教程</h3><p>Learnpython.org 是一个简单自由获取 Python 介绍的方式。这个网站采用与流行站点 <a href="http://tryruby.org/" target="_blank" rel="noopener">Try Ruby</a> 相同的方式，站点自带交互式 Python 解释器，这样你可以不用在本地安装 Python 就可以进行学习。</p><blockquote><p><a href="http://www.learnpython.org/" target="_blank" rel="noopener">Learn Python</a></p></blockquote><p>如果你想拥有传统纸质书籍，<em>Python For You and Me</em>  是一个学习这门语言各个方面的极佳资源。</p><blockquote><p><a href="https://pymbook.readthedocs.io/" target="_blank" rel="noopener">Python for You and Me</a> <a href="https://www.datacamp.com/" target="_blank" rel="noopener">Learn Python Interactively with DataCamp!</a></p></blockquote><h3 id="渐进式学习-Python"><a href="#渐进式学习-Python" class="headerlink" title="渐进式学习 Python"></a>渐进式学习 Python</h3><p>Techbeamers.com 提供渐进式教程进行 Python 教学。每一个主题的教程都添加了逻辑性的代码片段，并设置了随堂测验。这里是一份关于 <a href="http://www.techbeamers.com/python-interview-questions-programmers" target="_blank" rel="noopener">Python 面试问题</a> 的章节来帮助求职者。你也可以阅读要点 <a href="http://www.techbeamers.com/essential-python-tips-tricks-programmers" target="_blank" rel="noopener">Python tips</a> 和学习 <a href="http://www.techbeamers.com/python-code-optimization-tips-tricks" target="_blank" rel="noopener">best coding practices</a> 来撰写高质量的代码。通过下面这个链接，你将获得正确的平台来快速学习 Python 。</p><p><a href="http://www.techbeamers.com/python-tutorial-step-by-step" target="_blank" rel="noopener">Python 从入门到高级</a></p><h3 id="在线-Python-助教"><a href="#在线-Python-助教" class="headerlink" title="在线 Python 助教"></a>在线 Python 助教</h3><p>在线 Python 助教给你一个可视化的渐进步骤，来说明你的程序是如何运行的。Python 助教帮助人们理解电脑执行程序源代码每一行的方式来克服基础障碍。</p><blockquote><p><a href="http://pythontutor.com/" target="_blank" rel="noopener">在线 Python 助教</a></p></blockquote><h3 id="用-Python-创作一个属于你自己的电脑游戏"><a href="#用-Python-创作一个属于你自己的电脑游戏" class="headerlink" title="用 Python 创作一个属于你自己的电脑游戏"></a>用 Python 创作一个属于你自己的电脑游戏</h3><p>这本书，正适合编程零经验的初学者。每一个章节都有一个小游戏的源代码，利用这些例证程序来解释程序设计概念，给读者一个「感性」的程序思想。</p><blockquote><p><a href="http://inventwithpython.com/" target="_blank" rel="noopener">Invent Your Own Computer Games with Python</a></p></blockquote><h3 id="Hacking-Secret-Ciphers-with-Python"><a href="#Hacking-Secret-Ciphers-with-Python" class="headerlink" title="Hacking Secret Ciphers with Python"></a>Hacking Secret Ciphers with Python</h3><p>这本书教授完全初学者 Python 程序设计和基础密码学。章节提供各式各样的密码源代码，同时提供程序是如何破解它们的方法。</p><blockquote><p><a href="http://inventwithpython.com/hacking/" target="_blank" rel="noopener">Hacking Secret Ciphers with Python</a></p></blockquote><h3 id="Learn-Python-the-Hard-Way"><a href="#Learn-Python-the-Hard-Way" class="headerlink" title="Learn Python the Hard Way"></a>Learn Python the Hard Way</h3><p>这是一份绝佳的 Python 初级程序员指南。包含了从 console 到 web 的「 hello world 」。</p><blockquote><p><a href="http://learnpythonthehardway.org/book/" target="_blank" rel="noopener">Learn Python the Hard Way</a></p></blockquote><h3 id="Python速成"><a href="#Python速成" class="headerlink" title="Python速成"></a>Python速成</h3><p>这份指南和 <em>Python for Programmers with 3 Hours</em> 一样出名，它为使用其他开发语言的有经验的程序员提供了 Python 速成课。</p><blockquote><p><a href="http://stephensugden.com/crash_into_python/" target="_blank" rel="noopener">Python 速成</a></p></blockquote><h3 id="Dive-Into-Python-3"><a href="#Dive-Into-Python-3" class="headerlink" title="Dive Into Python 3"></a>Dive Into Python 3</h3><p>Dive Into Python 3 对于那些准备转投 Python 3 的程序员是一本好书。如果你正准备从 Python 2 过渡到 3 ，亦或者你已经具有其他语言的开发经验，这本书对你来说非常适合阅读。</p><blockquote><p><a href="http://www.diveintopython3.net/" target="_blank" rel="noopener">Dive Into Python 3</a></p></blockquote><h3 id="Think-Python-How-to-Think-Like-a-Computer-Scientist"><a href="#Think-Python-How-to-Think-Like-a-Computer-Scientist" class="headerlink" title="Think Python: How to Think Like a Computer Scientist"></a>Think Python: How to Think Like a Computer Scientist</h3><p>Think Python 尝试在使用 Python 语言时介绍一个基础的计算机科学的概念。它的目的是创造一本拥有大量练习、通俗易懂并且每个章节的每个片段都致力于解决项目问题的书。</p><p>在探索 Python 语言大量特性的可行性时，作者穿插了各式各样的设计模式和最优范例。</p><p>这本书也包含了几个案例研究，让读者将书本中讨论的主题应用到实际问题中来更好的学习。案例研究包含关于 GUI 和 Markov Analysis 的作业。</p><blockquote><p><a href="http://greenteapress.com/thinkpython/html/index.html" target="_blank" rel="noopener">Think Python</a></p></blockquote><h3 id="Python-Koans"><a href="#Python-Koans" class="headerlink" title="Python Koans"></a>Python Koans</h3><p>Python Koans 是 Edgecase’s Ruby Koans 的一个端口。它使用测试驱动的方法，参阅 TEST DRIVEN DESIGN SECTION 来提供一个交互式教程来教学基础 Python 概念。通过修复在测试脚本中失败的断言语句，这提供了一个连续的步骤来学习 Python。</p><p>对于那些习惯于使用语言并自己搞清楚问题的人来说，将是一个富有欢乐和吸引力的选择。对于那些 Python 和程序设计初学者来说，拥有额外的资源和参考将非常有帮助。</p><blockquote><p><a href="http://bitbucket.org/gregmalcolm/python_koans" target="_blank" rel="noopener">Python Koans</a></p></blockquote><p>更多关于测试驱动开发的资源请关注：</p><blockquote><p><a href="http://en.wikipedia.org/wiki/Test-driven_development" target="_blank" rel="noopener">Test Driven Development</a></p></blockquote><h3 id="A-Byte-of-Python"><a href="#A-Byte-of-Python" class="headerlink" title="A Byte of Python"></a>A Byte of Python</h3><p>A Byte of Python 是一本学习 Python 的免费入门书籍，非常适合没有编程基础的人学习。</p><blockquote><p><a href="http://www.ibiblio.org/swaroopch/byteofpython/read/" target="_blank" rel="noopener">A Byte of Python for Python 2.x</a> <a href="https://python.swaroopch.com/" target="_blank" rel="noopener">A Byte of Python for Python 3.x</a></p></blockquote><h3 id="Learn-to-Program-in-Python-with-Codeacademy"><a href="#Learn-to-Program-in-Python-with-Codeacademy" class="headerlink" title="Learn to Program in Python with Codeacademy"></a>Learn to Program in Python with Codeacademy</h3><p>这是一个适合绝大多数 Python 初学者的 Codeacademy 课程。这个免费的交互式课程主要教授 Python 编程中基础和部分深入的知识，同时会有测试来检验学者对知识的掌握程度。 这门课程也包含很多功能可以反馈你学习的情况，帮助你更好的学习。</p><blockquote><p><a href="http://www.codecademy.com/en/tracks/python" target="_blank" rel="noopener">Learn to Program in Python with Codeacademy</a></p></blockquote><h3 id="Code-the-blocks"><a href="#Code-the-blocks" class="headerlink" title="Code the blocks"></a>Code the blocks</h3><p><em>Code the blocks</em> 为初学者提供免费交互式的 Python 教程。它将 Python 程序设计和 3D 环境下「 搭砖块 」建造建筑相互结合。此教程教授你如何使用 Python 一步步创造一个精细的 3D 建筑，让你学习 Python 的过程充满欢乐。</p><blockquote><p><a href="https://codetheblocks.com/tutorials/introduction" target="_blank" rel="noopener">Code the blocks</a></p></blockquote><h2 id="Intermediate"><a href="#Intermediate" class="headerlink" title="Intermediate"></a>Intermediate</h2><h3 id="Effective-Python"><a href="#Effective-Python" class="headerlink" title="Effective Python"></a>Effective Python</h3><p>这本书包含了 59 种特定方法来提高编写 Pythonic 代码。总长度只有 227 页，列举了大量的晋升中等水平 Python 工程师必备的知识技能。</p><blockquote><p><a href="http://www.effectivepython.com/" target="_blank" rel="noopener">Effective Python</a></p></blockquote><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="Pro-Python"><a href="#Pro-Python" class="headerlink" title="Pro Python"></a>Pro Python</h3><p>这本书适用于中级到高级 Python 程序员，他们希望理解 Python 的工作原理以及怎样提升自己的代码水平。</p><blockquote><p><a href="http://propython.com/" target="_blank" rel="noopener">Pro Python</a></p></blockquote><h3 id="《Expert-Python-Programming》"><a href="#《Expert-Python-Programming》" class="headerlink" title="《Expert Python Programming》"></a>《Expert Python Programming》</h3><p>《Expert Python Programming》专注于为高级工程师提供 Python 的最佳实践的建议。</p><p>它的话题包括装饰器（伴随缓存、代理、上下文管理器、案例研究）、方法解析顺序，使用 <code>super()</code> 和元编程，还有通用的 <a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener">PEP 8</a> 最佳实践。</p><p>它花了多个章节，详细地介绍了如何编写和发布一个扩展包甚至最终发布一个应用，包含了一个使用 zc.buildout 的章节。后面的章节详细讲述了最佳实践，比如编写文档、测试驱动开发、 版本控制、优化和分析。</p><blockquote><p><a href="http://www.packtpub.com/expert-python-programming/book" target="_blank" rel="noopener">Expert Python Programming</a></p></blockquote><h3 id="《A-Guide-to-Python’s-Magic-Methods》"><a href="#《A-Guide-to-Python’s-Magic-Methods》" class="headerlink" title="《A Guide to Python’s Magic Methods》"></a>《A Guide to Python’s Magic Methods》</h3><p>这 是Rafe Kettler 发表博文的集合，解释了 Python 中的 “魔法方法”。魔法方法由双下划线包围 （比如 <strong>init</strong>），能够使类和对象表现出不同的、魔法的行为。</p><blockquote><p><a href="http://www.rafekettler.com/magicmethods.html" target="_blank" rel="noopener">A Guide to Python’s Magic Methods</a></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>Rafekettler.com 目前已关闭，您可以直接访问他们的 Github 版本。 在这里您可以找到一个 PDF 版本:  <a href="https://github.com/RafeKettler/magicmethods/blob/master/magicmethods.pdf" target="_blank" rel="noopener">A Guide to Python’s Magic Methods (repo on GitHub)</a></p></blockquote><h2 id="工程师和科学家"><a href="#工程师和科学家" class="headerlink" title="工程师和科学家"></a>工程师和科学家</h2><h3 id="A-Primer-on-Scientific-Programming-with-Python"><a href="#A-Primer-on-Scientific-Programming-with-Python" class="headerlink" title="A Primer on Scientific Programming with Python"></a>A Primer on Scientific Programming with Python</h3><p>《A Primer on Scientific Programming with Python》由 Hans Petter Langtangen 编写， 主要涵盖了 Python 在科学领域的使用。在这本书中，例子是从数学和自然科学中选出的。</p><blockquote><p><a href="http://www.springer.com/mathematics/computational+science+%26+engineering/book/978-3-642-30292-3" target="_blank" rel="noopener">A Primer on Scientific Programming with Python</a></p></blockquote><h3 id="Numerical-Methods-in-Engineering-with-Python"><a href="#Numerical-Methods-in-Engineering-with-Python" class="headerlink" title="Numerical Methods in Engineering with Python"></a>Numerical Methods in Engineering with Python</h3><p>《Numerical Methods in Engineering with Python》由 Jaan Kiusalaas 编写， 其重点是数值方法以及如何用 Python 来实现他们。</p><blockquote><p><a href="http://www.cambridge.org/us/academic/subjects/engineering/engineering-mathematics-and-programming/numerical-methods-engineering-python-2nd-edition" target="_blank" rel="noopener">Numerical Methods in Engineering with Python</a></p></blockquote><h2 id="其他话题"><a href="#其他话题" class="headerlink" title="其他话题"></a>其他话题</h2><h3 id="Problem-Solving-with-Algorithms-and-Data-Structures"><a href="#Problem-Solving-with-Algorithms-and-Data-Structures" class="headerlink" title="Problem Solving with Algorithms and Data Structures"></a>Problem Solving with Algorithms and Data Structures</h3><p>《Problem Solving with Algorithms and Data Structures》涵盖了一系列数据结构和算法。 所有概念都用 Python 代码说明，提供了可在浏览器中直接运行的交互式样例。</p><blockquote><p><a href="http://www.interactivepython.org/courselib/static/pythonds/index.html" target="_blank" rel="noopener">Problem Solving with Algorithms and Data Structures</a></p></blockquote><h3 id="Programming-Collective-Intelligence"><a href="#Programming-Collective-Intelligence" class="headerlink" title="Programming Collective Intelligence"></a>Programming Collective Intelligence</h3><p>《Programming Collective Intelligence》介绍了大量基础的机器学习和数据挖掘方法。 本书不会侧重于数据挖掘的数学原理，而是更侧重于解释底层的理论算法，以及展示如何使用 Python 来实现这些算法。</p><blockquote><p><a href="http://shop.oreilly.com/product/9780596529321.do" target="_blank" rel="noopener">Programming Collective Intelligence</a></p></blockquote><h3 id="Transforming-Code-into-Beautiful-Idiomatic-Python"><a href="#Transforming-Code-into-Beautiful-Idiomatic-Python" class="headerlink" title="Transforming Code into Beautiful, Idiomatic Python"></a>Transforming Code into Beautiful, Idiomatic Python</h3><p>《Transforming Code into Beautiful, Idiomatic Python》 是由 Raymond Hettinger 制作的视频。 通过它可以学习到如何更好地利用 Python 最好的特性和如何通过代码转换来改进现有代码。</p><blockquote><p><a href="https://www.youtube.com/watch?v=OSGv2VnC0go" target="_blank" rel="noopener">Transforming Code into Beautiful, Idiomatic Python</a></p></blockquote><h3 id="Fullstack-Python"><a href="#Fullstack-Python" class="headerlink" title="Fullstack Python"></a>Fullstack Python</h3><p>《Fullstack Python》为使用 Python 进行 Web 开发提供了完整的自上向下的资源。</p><p>技术话题范围涵盖从设置 Web 服务器到设计前端、选择数据库、优化/缩放等。</p><p>顾名思义，它涵盖了从头开始构建和运行完整的 Web 应用程序所需的所有内容。</p><blockquote><p><a href="https://www.fullstackpython.com/" target="_blank" rel="noopener">Fullstack Python</a></p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="Python-in-a-Nutshell"><a href="#Python-in-a-Nutshell" class="headerlink" title="Python in a Nutshell"></a>Python in a Nutshell</h3><p>《Python in a Nutshell》 由 Alex Martelli编写，涵盖了 Python 跨平台的多数用法， 从它的语法到内建库，再到比如说编写 C 扩展的高级主题。</p><blockquote><p><a href="http://shop.oreilly.com/product/9780596001889.do" target="_blank" rel="noopener">Python in a Nutshell</a></p></blockquote><h3 id="The-Python-Language-Reference"><a href="#The-Python-Language-Reference" class="headerlink" title="The Python Language Reference"></a>The Python Language Reference</h3><p>这是 Python 的参考手册，它涵盖了这门语言的语法和核心语义。</p><blockquote><p><a href="http://docs.python.org/reference/index.html" target="_blank" rel="noopener">The Python Language Reference</a></p></blockquote><h3 id="Python-Essential-Reference"><a href="#Python-Essential-Reference" class="headerlink" title="Python Essential Reference"></a>Python Essential Reference</h3><p>《Python Essential Reference》，由 David Beazley 撰写，是 Python 的最终参考指南。 它简明扼要地解释了标准库的核心语言和最重要的部分。 它涵盖了 Python 3 和 2.6 版本。</p><blockquote><p><a href="http://www.dabeaz.com/per.html" target="_blank" rel="noopener">Python Essential Reference</a></p></blockquote><h3 id="Python-Pocket-Reference"><a href="#Python-Pocket-Reference" class="headerlink" title="Python Pocket Reference"></a>Python Pocket Reference</h3><p>《Python Pocket Reference》由 Mark Lutz 编写，是一个了解核心语言的易于使用的参考， 介绍了常用的模块和工具集。它涵盖了 Python 3 和 Python 2。</p><blockquote><p><a href="http://shop.oreilly.com/product/9780596158095.do" target="_blank" rel="noopener">Python Pocket Reference</a></p></blockquote><h3 id="Python-Cookbook"><a href="#Python-Cookbook" class="headerlink" title="Python Cookbook"></a>Python Cookbook</h3><p>Python Cookbook 由 David Beazley 和 Brian K. Jones 编写，打包了许多具有实践意义的”食谱”。 这本书涵盖了核心 Python 语言，也涵盖了诸多不同应用的常见任务。</p><blockquote><p><a href="http://shop.oreilly.com/product/0636920027072.do" target="_blank" rel="noopener">Python Cookbook</a></p></blockquote><h3 id="Writing-Idiomatic-Python"><a href="#Writing-Idiomatic-Python" class="headerlink" title="Writing Idiomatic Python"></a>Writing Idiomatic Python</h3><p>《Writing Idiomatic Python》由 Jeff Knupp 编写，包含了最常见和最重要的 Python 习语， 其形式尽可能地有辨识度和易于理解。每个习语都是编写一些常用代码片段的推荐方式， 其后会解释为什么这个习语是重要的。每个习语均有两个代码样例：”有害的” 方式和 “理想的” 方式。</p><blockquote><p><a href="http://www.amazon.com/Writing-Idiomatic-Python-2-7-3-Knupp/dp/1482372177/" target="_blank" rel="noopener">For Python 2.7.3+</a></p><p><a href="http://www.amazon.com/Writing-Idiomatic-Python-Jeff-Knupp-ebook/dp/B00B5VXMRG/" target="_blank" rel="noopener">For Python 3.3+</a></p></blockquote><h2 id="Planet-Python"><a href="#Planet-Python" class="headerlink" title="Planet Python"></a>Planet Python</h2><p>这是一个来自日益增长的开发者提供的 Python 资讯汇总。</p><blockquote><p><a href="http://planet.python.org/" target="_blank" rel="noopener">Planet Python</a></p></blockquote><h2 id="r-python"><a href="#r-python" class="headerlink" title="/r/python"></a>/r/python</h2><p>/r/python 是 Reddit Python 社区，在这里，用户对 Python 相关的资讯进行投稿和投票。</p><blockquote><p><a href="http://reddit.com/r/python" target="_blank" rel="noopener">/r/python</a></p></blockquote><h2 id="Talk-Python-Podcast"><a href="#Talk-Python-Podcast" class="headerlink" title="Talk Python Podcast"></a>Talk Python Podcast</h2><p>头号以 Python 为重点的播客，涵盖了 Python 相关的人员和想法。</p><blockquote><p><a href="https://talkpython.fm/" target="_blank" rel="noopener">Talk Python To Me</a></p></blockquote><h2 id="Python-Bytes-Podcast"><a href="#Python-Bytes-Podcast" class="headerlink" title="Python Bytes Podcast"></a>Python Bytes Podcast</h2><p>一个涵盖最近开发人员头条的简短形式的 Python 播客。</p><blockquote><p><a href="https://pythonbytes.fm/" target="_blank" rel="noopener">Python Bytes</a></p></blockquote><h2 id="Pycoder’s-Weekly"><a href="#Pycoder’s-Weekly" class="headerlink" title="Pycoder’s Weekly"></a>Pycoder’s Weekly</h2><p>Pycoder’s Weekly 是 Python开发者为 Python开发者们准备的免费的 Python 新闻周刊（包括项目，文章，资讯，工作）。</p><blockquote><p><a href="http://www.pycoders.com/" target="_blank" rel="noopener">Pycoder’s Weekly</a></p></blockquote><h2 id="Python-Weekly"><a href="#Python-Weekly" class="headerlink" title="Python Weekly"></a>Python Weekly</h2><p>Python Weekly 是一个以策划 Python 相关的新闻，文章，新版发布，工作等为特色的周刊。</p><blockquote><p><a href="http://www.pythonweekly.com/" target="_blank" rel="noopener">Python Weekly</a></p></blockquote><h2 id="Python-News"><a href="#Python-News" class="headerlink" title="Python News"></a>Python News</h2><p>Python News 是 <a href="https://pythoncaff.com/docs/python-guide/2018/intro-news/www.python.org" target="_blank" rel="noopener">Python 官网</a> 的新闻板块。它简要地强调了 Python 社区的新闻。</p><blockquote><p><a href="http://www.python.org/news/" target="_blank" rel="noopener">Python News</a></p></blockquote><h2 id="Import-Python-Weekly"><a href="#Import-Python-Weekly" class="headerlink" title="Import Python Weekly"></a>Import Python Weekly</h2><p>Weekly Python Newsletter 包含 Python 的文章，项目，视频和你邮箱中的推文。让你的 Python 编程技巧处于更新状态。</p><blockquote><p><a href="http://www.importpython.com/newsletter/" target="_blank" rel="noopener">Import Python Weekly Newsletter</a></p></blockquote><h2 id="Awesome-Python-Newsletter"><a href="#Awesome-Python-Newsletter" class="headerlink" title="Awesome Python Newsletter"></a>Awesome Python Newsletter</h2><p>每周对最受欢迎的 Python 新闻，文章和软件包进行总结。</p><blockquote><p><a href="https://python.libhunt.com/newsletter" target="_blank" rel="noopener">Awesome Python Newsletter</a></p></blockquote><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;The-Python-Tutorial&quot;&gt;&lt;a href=&quot;#The-Python-Tutorial&quot; class=&quot;headerlink&quot; title=&quot;The Python Tutorial&quot;&gt;&lt;/a&gt;The Python Tutorial&lt;/h3&gt;&lt;p&gt;这个
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Docker Harbor镜像仓库</title>
    <link href="https://yo42.github.io/2018/09/15/Docker-Harbor%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/"/>
    <id>https://yo42.github.io/2018/09/15/Docker-Harbor镜像仓库/</id>
    <published>2018-09-15T10:08:02.715Z</published>
    <updated>2018-09-16T07:07:51.713Z</updated>
    
    <content type="html"><![CDATA[<p>场景架构:属于分布式集群的方式部署Dokcer镜像仓库，每个项目部署一个从仓库，所有从仓库共用连接一个主仓库，每次对镜像构建集成时将PUSH至主仓库，主仓库再分发至各项目的从仓库。</p><h2 id="部署Harbor"><a href="#部署Harbor" class="headerlink" title="部署Harbor"></a>部署Harbor</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构:"></a>目录结构:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /home/nucleus-oc/</span><br><span class="line">sudo mkdir /home/nucleus-oc/harbor/  # 数据目录</span><br><span class="line">sudo mkdir /home/nucleus-oc/2231/    # 控制目录</span><br></pre></td></tr></table></figure><h3 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/nucleus-oc/harbor/ssl-key/chained.pem #证书</span><br><span class="line">/home/nucleus-oc/harbor/ssl-key/server.key     # 密钥</span><br></pre></td></tr></table></figure><h3 id="下载并解压缩离线安装包："><a href="#下载并解压缩离线安装包：" class="headerlink" title="下载并解压缩离线安装包："></a>下载并解压缩离线安装包：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home/nucleus-oc/2231/</span><br><span class="line">wget https://github.com/vmware/harbor/releases/download/v1.1.2/harbor-offline-installer-v1.1.2.tgz</span><br><span class="line">tar xf harbor-offline-installer-v1.1.2.tgz</span><br></pre></td></tr></table></figure><h3 id="修改配置文件docker-compose-yml"><a href="#修改配置文件docker-compose-yml" class="headerlink" title="修改配置文件docker-compose.yml"></a>修改配置文件docker-compose.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /home/nucleus-oc/2231/harbor/</span><br><span class="line">sed -e &apos;s@ /data/@ /home/nucleus-oc/harbor/@&apos; \</span><br><span class="line">    -e &apos;s@ /var/log/harbor/@ /home/nucleus-oc/harbor/logs/@&apos; \</span><br><span class="line">    -i docker-compose.yml</span><br></pre></td></tr></table></figure><h3 id="修改harbor-cfg"><a href="#修改harbor-cfg" class="headerlink" title="修改harbor.cfg"></a>修改harbor.cfg</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5 hostname = oc-control-h9tc.mtiancity.com      #仓库域名 </span><br><span class="line">9 ui_url_protocol = https</span><br><span class="line">12 db_password = wV6QRnTkX8SQNqxu</span><br><span class="line">24 ssl_cert = /home/nucleus-oc/harbor/ssl-key/chained.pem  </span><br><span class="line">25 ssl_cert_key = /home/nucleus-oc/harbor/ssl-key/server.key</span><br><span class="line">28 secretkey_path = /home/nucleus-oc/harbor</span><br><span class="line">55 harbor_admin_password = GLcvN2Ezrh5XT3Hx</span><br><span class="line">87 self_registration = off</span><br><span class="line">95 project_creation_restriction = adminonly</span><br></pre></td></tr></table></figure><h3 id="正式安装"><a href="#正式安装" class="headerlink" title="正式安装"></a>正式安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/nucleus-oc/2231/harbor/</span><br><span class="line"> ./install.sh</span><br></pre></td></tr></table></figure><h3 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">https://github.com/goharbor/harbor</a></li><li><a href="http://www.vmtocloud.com/remote-site-replicated-docker-registries-with-vmware-harbor/" target="_blank" rel="noopener">http://www.vmtocloud.com/remote-site-replicated-docker-registries-with-vmware-harbor/</a></li><li><a href="http://www.cnblogs.com/jicki/p/5737369.html" target="_blank" rel="noopener">http://www.cnblogs.com/jicki/p/5737369.html</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;场景架构:属于分布式集群的方式部署Dokcer镜像仓库，每个项目部署一个从仓库，所有从仓库共用连接一个主仓库，每次对镜像构建集成时将PUSH至主仓库，主仓库再分发至各项目的从仓库。&lt;/p&gt;
&lt;h2 id=&quot;部署Harbor&quot;&gt;&lt;a href=&quot;#部署Harbor&quot; clas
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-优雅的包管理</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker-s-Guide-to-Python-%E4%BC%98%E9%9B%85%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker-s-Guide-to-Python-优雅的包管理/</id>
    <published>2018-09-15T09:45:48.832Z</published>
    <updated>2018-09-15T10:07:37.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打包Python项目"><a href="#打包Python项目" class="headerlink" title="打包Python项目"></a>打包Python项目</h1><p>本教程将指导您如何打包一个简单的Python项目。它将向您展示如何添加必要的文件和结构来创建包，如何构建包以及如何将其上载到Python包索引。</p><h2 id="一个简单的项目"><a href="#一个简单的项目" class="headerlink" title="一个简单的项目"></a>一个简单的项目</h2><p>本教程使用一个名为的简单项目<code>example_pkg</code>。如果您不熟悉Python的模块和<a href="https://packaging.python.org/glossary/#term-import-package" target="_blank" rel="noopener">导入包</a>，请花几分钟时间阅读包含<a href="https://docs.python.org/3/tutorial/modules.html#packages" target="_blank" rel="noopener">文件包和模块</a>的<a href="https://docs.python.org/3/tutorial/modules.html#packages" target="_blank" rel="noopener">Python文档</a>。</p><p>要在本地创建此项目，请创建以下文件结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/example_pkg</span><br><span class="line">  /example_pkg</span><br><span class="line">    __init__.py</span><br></pre></td></tr></table></figure><p>创建此结构后，您将需要在顶级文件夹中运行本教程中的所有命令 - 所以一定要确保。<code>cd example_pkg</code></p><p>您还应该编辑<code>example_pkg/__init__.py</code>并在其中放入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;example_pkg&quot;</span><br></pre></td></tr></table></figure><p>这只是为了您可以在本教程后面验证它是否正确安装。</p><h2 id="创建包文件"><a href="#创建包文件" class="headerlink" title="创建包文件"></a>创建包文件</h2><p>现在，您将创建一些文件来打包此项目并准备分发。创建下面列出的新文件 - 您将在以下步骤中向其添加内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/example_pkg</span><br><span class="line">  /example_pkg</span><br><span class="line">    __init__.py</span><br><span class="line">  setup.py</span><br><span class="line">  LICENSE</span><br><span class="line">  README.md</span><br></pre></td></tr></table></figure><h2 id="创建的setup-py"><a href="#创建的setup-py" class="headerlink" title="创建的setup.py"></a>创建的setup.py</h2><p><code>setup.py</code>是<a href="https://packaging.python.org/key_projects/#setuptools" target="_blank" rel="noopener">setuptools</a>的构建脚本。它告诉setuptools你的包（例如名称和版本）以及要包含的代码文件。</p><p>打开<code>setup.py</code>并输入以下内容，您可以根据需要个性化值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import setuptools</span><br><span class="line"></span><br><span class="line">with open(&quot;README.md&quot;, &quot;r&quot;) as fh:</span><br><span class="line">    long_description = fh.read()</span><br><span class="line"></span><br><span class="line">setuptools.setup(</span><br><span class="line">    name=&quot;example_pkg&quot;,</span><br><span class="line">    version=&quot;0.0.1&quot;,</span><br><span class="line">    author=&quot;Example Author&quot;,</span><br><span class="line">    author_email=&quot;author@example.com&quot;,</span><br><span class="line">    description=&quot;A small example package&quot;,</span><br><span class="line">    long_description=long_description,</span><br><span class="line">    long_description_content_type=&quot;text/markdown&quot;,</span><br><span class="line">    url=&quot;https://github.com/pypa/sampleproject&quot;,</span><br><span class="line">    packages=setuptools.find_packages(),</span><br><span class="line">    classifiers=[</span><br><span class="line">        &quot;Programming Language :: Python :: 3&quot;,</span><br><span class="line">        &quot;License :: OSI Approved :: MIT License&quot;,</span><br><span class="line">        &quot;Operating System :: OS Independent&quot;,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>setup()</code>有几个论点。此示例包使用相对最小的集：</p><ul><li><code>name</code>是您的包的名称。只要包含字母，数字<code>_</code>和，就可以是任何名称<code>-</code>。它也不能在pypi.org上使用。</li><li><code>version</code> 是包版本看 <a href="https://www.python.org/dev/peps/pep-0440" target="_blank" rel="noopener"><strong>PEP 440</strong></a>有关版本的更多详细信息。</li><li><code>author</code>并<code>author_email</code>用于识别包的作者。</li><li><code>description</code> 是一个简短的，一句话的包的总结。</li><li><code>long_description</code>是包的详细说明。这显示在Python Package Index的包详细信息包中。在这种情况下，加载长描述<code>README.md</code>是一种常见模式。</li><li><code>long_description_content_type</code>告诉索引什么类型的标记用于长描述。在这种情况下，它是Markdown。</li><li><code>url</code>是项目主页的URL。对于许多项目，这只是一个指向GitHub，GitLab，Bitbucket或类似代码托管服务的链接。</li><li><code>packages</code>是应包含在<a href="https://packaging.python.org/glossary/#term-distribution-package" target="_blank" rel="noopener">分发包</a>中的所有Python <a href="https://packaging.python.org/glossary/#term-import-package" target="_blank" rel="noopener">导入包</a>的列表。我们可以使用 自动发现所有包和子包，而不是手动列出每个包。在这种情况下，包列表将是example_pkg，因为它是唯一存在的包。<code>find_packages()</code></li><li><code>classifiers</code>告诉索引并<a href="https://packaging.python.org/key_projects/#pip" target="_blank" rel="noopener">点</a>一些关于你的包的其他元数据。在这种情况下，该软件包仅与Python 3兼容，根据MIT许可证进行许可，并且与操作系统无关。您应始终至少包含您的软件包所使用的Python版本，软件包可用的许可证以及您的软件包将使用的操作系统。有关分类器的完整列表，请参阅<a href="https://pypi.org/classifiers/" target="_blank" rel="noopener">https://pypi.org/classifiers/</a>。</li></ul><p>除了这里提到的还有很多。有关详细信息，请参阅 <a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/" target="_blank" rel="noopener">打包和分发项目</a>。</p><h2 id="创建README-md"><a href="#创建README-md" class="headerlink" title="创建README.md"></a>创建README.md</h2><p>打开<code>README.md</code>并输入以下内容。如果您愿意，可以自定义此项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Example Package</span><br><span class="line"></span><br><span class="line">This is a simple example package. You can use</span><br><span class="line">[Github-flavored Markdown](https://guides.github.com/features/mastering-markdown/)</span><br><span class="line">to write your content.</span><br></pre></td></tr></table></figure><h2 id="创建许可证"><a href="#创建许可证" class="headerlink" title="创建许可证"></a>创建许可证</h2><p>上传到Python Package Index的每个包都包含许可证，这一点很重要。这告诉用户安装您的软件包可以使用您的软件包的条款。有关选择许可证的帮助，请参阅 <a href="https://choosealicense.com/" target="_blank" rel="noopener">https://choosealicense.com/</a>。选择许可证后，打开 <code>LICENSE</code>并输入许可证文本。例如，如果您选择了MIT许可证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Copyright (c) 2018 The Python Packaging Authority</span><br><span class="line"></span><br><span class="line">Permission is hereby granted, free of charge, to any person obtaining a copy</span><br><span class="line">of this software and associated documentation files (the &quot;Software&quot;), to deal</span><br><span class="line">in the Software without restriction, including without limitation the rights</span><br><span class="line">to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span><br><span class="line">copies of the Software, and to permit persons to whom the Software is</span><br><span class="line">furnished to do so, subject to the following conditions:</span><br><span class="line"></span><br><span class="line">The above copyright notice and this permission notice shall be included in all</span><br><span class="line">copies or substantial portions of the Software.</span><br><span class="line"></span><br><span class="line">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span><br><span class="line">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span><br><span class="line">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span><br><span class="line">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span><br><span class="line">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span><br><span class="line">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span><br><span class="line">SOFTWARE.</span><br></pre></td></tr></table></figure><h2 id="生成分发档案"><a href="#生成分发档案" class="headerlink" title="生成分发档案"></a>生成分发档案</h2><p>下一步是为<a href="https://packaging.python.org/glossary/#term-distribution-package" target="_blank" rel="noopener">包</a>生<a href="https://packaging.python.org/glossary/#term-distribution-package" target="_blank" rel="noopener">成分发包</a>。这些是上传到包索引的档案，可以通过<a href="https://packaging.python.org/key_projects/#pip" target="_blank" rel="noopener">pip</a>安装。</p><p>确保您拥有<code>setuptools</code>并<code>wheel</code> 安装了最新版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --user --upgrade setuptools wheel</span><br></pre></td></tr></table></figure><p>小费</p><p>如果您在安装这些软件时遇到问题，请参阅 <a href="https://packaging.python.org/tutorials/installing-packages/" target="_blank" rel="noopener">安装软件包</a>教程</p><p>现在从<code>setup.py</code>位于的同一目录运行此命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 setup.py sdist bdist_wheel</span><br></pre></td></tr></table></figure><p>此命令应输出大量文本，一旦完成，应在<code>dist</code>目录中生成两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dist/</span><br><span class="line">  example_pkg-0.0.1-py3-none-any.whl</span><br><span class="line">  example_pkg-0.0.1.tar.gz</span><br></pre></td></tr></table></figure><p>注意</p><p>如果您遇到麻烦，请复制输出并提出有关<a href="https://github.com/pypa/packaging-problems/issues/new?title=Trouble+following+packaging+libraries+tutorial" target="_blank" rel="noopener">包装问题的问题</a>，我们会尽力为您提供帮助！</p><p>该<code>tar.gz</code>文件是<a href="https://packaging.python.org/glossary/#term-source-archive" target="_blank" rel="noopener">源存档，</a>而该<code>.whl</code>文件是 <a href="https://packaging.python.org/glossary/#term-built-distribution" target="_blank" rel="noopener">构建的分发</a>。较新的<a href="https://packaging.python.org/key_projects/#pip" target="_blank" rel="noopener">pip</a>版本优先安装构建的发行版，但如果需要，将回退到源代码存档。您应该始终上传源存档并为项目兼容的平台提供构建的存档。在这种情况下，我们的示例包在任何平台上都与Python兼容，因此只需要一个构建的发行版。</p><h2 id="上传分发档案"><a href="#上传分发档案" class="headerlink" title="上传分发档案"></a>上传分发档案</h2><p>最后，是时候将您的包上传到Python Package Index了！</p><p>您需要做的第一件事是在Test PyPI上注册一个帐户。Test PyPI是用于测试和实验的包索引的单独实例。这对于像我们不一定想要上传到真实索引的本教程那样很棒。要注册帐户，请访问<a href="https://test.pypi.org/account/register/" target="_blank" rel="noopener">https://test.pypi.org/account/register/</a>并完成该页面上的步骤。在您上传任何软件包之前，您还需要验证您的电子邮件地址。有关Test PyPI的更多详细信息，请参阅 <a href="https://packaging.python.org/guides/using-testpypi/" target="_blank" rel="noopener">使用TestPyPI</a>。</p><p>现在您已注册，您可以使用<a href="https://packaging.python.org/key_projects/#twine" target="_blank" rel="noopener">twine</a>上传分发包。你需要安装Twine：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --user --upgrade twine</span><br></pre></td></tr></table></figure><p>安装完成后，运行Twine上传所有存档<code>dist</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">twine upload --repository-url https://test.pypi.org/legacy/ dist/*</span><br></pre></td></tr></table></figure><p>系统将提示您输入使用Test PyPI注册的用户名和密码。命令完成后，您应该看到与此类似的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Uploading distributions to https://test.pypi.org/legacy/</span><br><span class="line">Enter your username: [your username]</span><br><span class="line">Enter your password:</span><br><span class="line">Uploading example_pkg-0.0.1-py3-none-any.whl</span><br><span class="line">100%|█████████████████████| 4.65k/4.65k [00:01&lt;00:00, 2.88kB/s]</span><br><span class="line">Uploading example_pkg-0.0.1.tar.gz</span><br><span class="line">100%|█████████████████████| 4.25k/4.25k [00:01&lt;00:00, 3.05kB/s]</span><br></pre></td></tr></table></figure><p>注意</p><p>如果您收到错误消息，则需要为您的包选择一个唯一的名称。一个不错的选择 。更新参数 ，删除文件夹，然后 <a href="https://packaging.python.org/tutorials/packaging-projects/#generating-archives" target="_blank" rel="noopener">重新生成存档</a>。<code>The user &#39;[your username]&#39; isn&#39;t allowed to upload to project&#39;example-pkg&#39;`</code>example_pkg_your_username<code>name</code>setup.py<code></code>dist`</p><p>上传后，您的包应该可以在TestPyPI上查看，例如，<a href="https://test.pypi.org/project/example-pkg" target="_blank" rel="noopener">https：</a> //test.pypi.org/project/example-pkg</p><h2 id="安装新上传的软件包"><a href="#安装新上传的软件包" class="headerlink" title="安装新上传的软件包"></a>安装新上传的软件包</h2><p>您可以使用<a href="https://packaging.python.org/key_projects/#pip" target="_blank" rel="noopener">pip</a>来安装包并验证它是否有效。创建一个新的<a href="https://packaging.python.org/key_projects/#virtualenv" target="_blank" rel="noopener">virtualenv</a>（请参阅<a href="https://packaging.python.org/tutorials/installing-packages/" target="_blank" rel="noopener">安装包</a>以获取详细说明）并从TestPyPI安装包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --index-url https://test.pypi.org/simple/ example_pkg</span><br></pre></td></tr></table></figure><p>注意</p><p>如果在预览步骤中使用了不同的包名称，请<code>example_pkg</code>在上面的命令中使用您的包名称替换 。</p><p>pip应该从Test PyPI安装包，输出应该如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collecting example_pkg</span><br><span class="line">  Downloading https://test-files.pythonhosted.org/packages/.../example_pkg-0.0.1-py3-none-any.whl</span><br><span class="line">Installing collected packages: example-pkg</span><br><span class="line">Successfully installed example-pkg-0.0.1</span><br></pre></td></tr></table></figure><p>您可以通过导入模块并引用先前<code>name</code>放置的属性来测试它是否已正确安装<code>__init__.py</code>。</p><p>运行Python解释器（确保你仍然在你的virtualenv中）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python</span><br></pre></td></tr></table></figure><p>然后导入模块并打印出<code>name</code>属性。无论您给出的<a href="https://packaging.python.org/glossary/#term-distribution-package" target="_blank" rel="noopener">分发包</a>名称是什么，这都应该是相同的 ，<code>setup.py</code>因为您的<a href="https://packaging.python.org/glossary/#term-import-package" target="_blank" rel="noopener">导入包</a>是<code>example_pkg</code>。</p><p>>&gt;&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import example_pkg</span><br><span class="line">&gt;&gt;&gt; example_pkg.name</span><br><span class="line">&apos;example_pkg&apos;</span><br></pre></td></tr></table></figure><h2 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h2><p><strong>恭喜，您已经打包并分发了一个Python项目！</strong> ✨🍰✨</p><p>请记住，本教程向您展示了如何将软件包上传到Test PyPI，而测试PyPI是短暂的。偶尔删除包和帐户并不罕见。如果您想将软件包上传到真正的Python软件包索引，可以通过在<a href="https://pypi.org/" target="_blank" rel="noopener">https://pypi.org</a>上注册帐户并按照相同的说明进行上传，但是，使用上传软件包并输入您的帐户凭据在真正的PyPI上注册。您可以使用真正的PyPI安装包 。<code>twine upload dist/*`</code>pip install your-package`</p><p>在这一点上，如果你想阅读更多关于包装的Python库，你可以做一些事情：</p><ul><li>阅读有关使用<a href="https://packaging.python.org/key_projects/#setuptools" target="_blank" rel="noopener">setuptools</a>在<a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/" target="_blank" rel="noopener">打包和分发项目中</a>打包库的 更多信息。</li><li>阅读<a href="https://packaging.python.org/guides/packaging-binary-extensions/" target="_blank" rel="noopener">包装二进制扩展</a>。</li><li>考虑诸如<a href="https://packaging.python.org/key_projects/#flit" target="_blank" rel="noopener">flit</a>，<a href="https://github.com/ofek/hatch" target="_blank" rel="noopener">hatch</a>和<a href="https://github.com/sdispater/poetry" target="_blank" rel="noopener">poetry之类的</a><a href="https://packaging.python.org/key_projects/#setuptools" target="_blank" rel="noopener">setuptools的</a>替代方案。</li></ul><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a><a href="https://packaging.python.org/" target="_blank" rel="noopener">目录</a></h3><ul><li><a href="https://packaging.python.org/overview/" target="_blank" rel="noopener">Python的打包概述</a></li><li>教程<ul><li><a href="https://packaging.python.org/tutorials/installing-packages/" target="_blank" rel="noopener">安装包</a></li><li><a href="https://packaging.python.org/tutorials/managing-dependencies/" target="_blank" rel="noopener">管理应用程序依赖项</a></li><li><a href="https://packaging.python.org/tutorials/packaging-projects/#" target="_blank" rel="noopener">打包Python项目</a></li></ul></li><li><a href="https://packaging.python.org/guides/" target="_blank" rel="noopener">指南</a></li><li><a href="https://packaging.python.org/discussions/" target="_blank" rel="noopener">讨论</a></li><li><a href="https://packaging.python.org/specifications/" target="_blank" rel="noopener">PyPA规格</a></li><li><a href="https://packaging.python.org/key_projects/" target="_blank" rel="noopener">项目摘要</a></li><li><a href="https://packaging.python.org/glossary/" target="_blank" rel="noopener">词汇表</a></li><li><a href="https://packaging.python.org/support/" target="_blank" rel="noopener">如何获得支持</a></li><li><a href="https://packaging.python.org/contribute/" target="_blank" rel="noopener">有助于本指南</a></li><li><a href="https://packaging.python.org/news/" target="_blank" rel="noopener">新闻</a></li></ul><h4 id="上一主题"><a href="#上一主题" class="headerlink" title="上一主题"></a>上一主题</h4><p><a href="https://packaging.python.org/tutorials/managing-dependencies/" target="_blank" rel="noopener">管理应用程序依赖项</a></p><h4 id="下一个主题"><a href="#下一个主题" class="headerlink" title="下一个主题"></a>下一个主题</h4><p><a href="https://packaging.python.org/guides/" target="_blank" rel="noopener">指南</a></p><h3 id="一些常见的包管理工具"><a href="#一些常见的包管理工具" class="headerlink" title="一些常见的包管理工具"></a>一些常见的包管理工具</h3><ul><li>distutils</li><li>setuptools</li><li>distribute</li><li>disutils2</li><li>distlib</li><li>pip</li></ul><p><strong><em>==创建纯 Python 或者平台 Wheels 的命令是：<code>python setup.py bdist_wheel</code></em></strong>==</p><h2 id="代码打包"><a href="#代码打包" class="headerlink" title="代码打包"></a>代码打包</h2><p>打包你的代码，将它共享出去，让其他的开发者使用。例如，将其打包成一个库分享给其他开发者，以便他们用在自己的应用中，或者共享给开发工具，比如 ‘py.test’。</p><p>这种代码发布方式具备的优势是其成熟的工具生态系统，例如 PyPI 和 pip，这些工具使得其他的开发者很容易下载和安装你的包，无论是用于偶然的实验，还是将其集成到大型专业的系统中。</p><p>Python 代码以这种方式发布共享是一个成熟的惯例。如果你的代码不是在 PyPI 上打包的，那么别的开发者很难找到它，也很难将它集成到他们现有的程序中。他们会严重质疑这些没有在 PyPI 上打包项目的槽糕管理，甚至认为这些项目已停止维护。</p><p>类似于这种发布代码的方式的缺点是，它依赖于开发者了解如何安装它所依赖的 Python 版本，并且能够和愿意使用类似 pip 这样的工具安装你的包所需要的其他依赖。这种做法适合发布代码给其他开发人员，但是不适合发布应用程序给终端用户使用。</p><p><a href="https://python-packaging-user-guide.readthedocs.io/" target="_blank" rel="noopener">Python 打包指南</a> 提供了创建和维护 Pythond 包的一个延伸的指导。</p><h2 id="打包的替代方案"><a href="#打包的替代方案" class="headerlink" title="打包的替代方案"></a>打包的替代方案</h2><p>为了发布应用程序给终端用户使用，你应该 <a href="http://docs.python-guide.org/en/latest/shipping/freezing/#freezing-your-code-ref" target="_blank" rel="noopener">冻结你的应用程序</a>。</p><p>在 Linux 平台，你可以考虑 <a href="http://docs.python-guide.org/en/latest/shipping/packaging/#packaging-for-linux-distributions-ref" target="_blank" rel="noopener">创建一个Linux发行版软件包</a> (例如 Debian or Ubuntu 系统中是一个.deb 文件)</p><h2 id="对于-Python-开发者"><a href="#对于-Python-开发者" class="headerlink" title="对于 Python 开发者"></a>对于 Python 开发者</h2><p>如果你正在写一个开源的 Python 模块，<a href="http://pypi.python.org/" target="_blank" rel="noopener">PyPI</a> 是一个适合它发布的地方，PyPI 的另一个名字 <em>The Cheeseshop</em> 更被人熟知。</p><h3 id="Pip-vs-easy-install"><a href="#Pip-vs-easy-install" class="headerlink" title="Pip vs. easy_install"></a>Pip vs. easy_install</h3><p>使用 <a href="http://pypi.python.org/pypi/pip" target="_blank" rel="noopener">pip</a>。 详情 <a href="http://stackoverflow.com/questions/3220404/why-use-pip-over-easy-install" target="_blank" rel="noopener">点击这里</a></p><h3 id="私人-PyPI"><a href="#私人-PyPI" class="headerlink" title="私人 PyPI"></a>私人 PyPI</h3><p>如果你想要使用源码安装一个 Python 包，而不是使用 PyPI，(即, 你的包<em>不对外公开</em>)，你可以通过托管一个简单的 HTTP 服务器来完成，从那些包的安装路径下运行。</p><p><strong>从一个例子入手是最好的</strong></p><p>比如你想安装一个包，它的名字是 <code>MyPackage.tar.gz</code>，假设你的目录结构使这样：</p><ul><li>archive<ul><li>MyPackage<ul><li>MyPackage.tar.gz</li></ul></li></ul></li></ul><h2 id="代码冻结"><a href="#代码冻结" class="headerlink" title="代码冻结"></a>代码冻结</h2><p>『冻结』你的代码是指创建单个可执行文件，文件里包含所有程序代码以及 Python 解释器。</p><p>像 Dropbox、星战前夜、文明 4 和 BitTorrent 客户端都是如此。</p><p>进行这种分发的好处是你的用户不需要安装所要求的 Python 版本（或其他）即可直接运行你的应用程序。 在 Windows 上，甚至许多 Linux发行版和 OS X，系统自带的 Python 版本总是不尽如人意，此时这种分发方式就会体现其价值。</p><p>此外，终端用户软件应始终是可执行的格式。 以 <code>.py</code> 结尾的文件一般适用于软件工程师和系统管理员。</p><p>冻结的一个缺点是它会增加大约 2-12 MB 的发行大小。另外，如果修补了 Python 的安全漏洞， 你将需要独立负责更新分发的应用程序。</p><h2 id="冻结的替代方案"><a href="#冻结的替代方案" class="headerlink" title="冻结的替代方案"></a>冻结的替代方案</h2><p><a href="http://pythonguidecn.readthedocs.io/zh/latest/shipping/packaging.html#packaging-your-code-ref" target="_blank" rel="noopener">打包你的代码</a> 是指把你的库或工具分发给其他开发者。</p><p>Linux 下一个冻结的替代品是 <a href="http://pythonguidecn.readthedocs.io/zh/latest/shipping/packaging.html#packaging-for-linux-distributions-ref" target="_blank" rel="noopener">Linux 分发包</a> （比如，对于 Debian 或 Ubuntu 是 .deb文件，而对于 Red Hat 与 SuSE 是 .rpm 文件）</p><h2 id="冻结工具的比较"><a href="#冻结工具的比较" class="headerlink" title="冻结工具的比较"></a>冻结工具的比较</h2><p>解决方案还有平台/特性支持性：</p><table><thead><tr><th>Solution</th><th>Windows</th><th>Linux</th><th>OS X</th><th>Python 3</th><th>License</th><th>One-file mode</th><th>Zipfile import</th><th>Eggs</th><th>pkg_resources support</th></tr></thead><tbody><tr><td>bbFreeze</td><td>yes</td><td>yes</td><td>yes</td><td>no</td><td>MIT</td><td>no</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>py2exe</td><td>yes</td><td>no</td><td>no</td><td>yes</td><td>MIT</td><td>yes</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>pyInstaller</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>GPL</td><td>yes</td><td>no</td><td>yes</td><td>no</td></tr><tr><td>cx_Freeze</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>PSF</td><td>no</td><td>yes</td><td>yes</td><td>no</td></tr><tr><td>py2app</td><td>no</td><td>no</td><td>yes</td><td>yes</td><td>MIT</td><td>no</td><td>yes</td><td>yes</td><td>yes</td></tr></tbody></table><blockquote><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在 Linux 下冻结 Windows 安装包，之前只有 PyInstaller 支持，不过后来也是  <a href="http://stackoverflow.com/questions/2950971/cross-compiling-a-python-script-on-linux-into-a-windows-executable#comment11890276_2951046" target="_blank" rel="noopener">停止支持了</a>。</p><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>所有解决方案都需要在 Windows 目标机器上安装了MS Visual C++ dll，除了 py2app 以外。只有 Pyinstaller 支持创建独立运行的绑定了dll 的 exe 文件，你需要在创建时传递参数 <code>--onefile</code> 到 <code>Configure.py</code>。</p></blockquote><h2 id="Windows-下的解决方案"><a href="#Windows-下的解决方案" class="headerlink" title="Windows 下的解决方案"></a>Windows 下的解决方案</h2><h3 id="bbFreeze"><a href="#bbFreeze" class="headerlink" title="bbFreeze"></a>bbFreeze</h3><p>前置要求是安装 <a href="http://pythonguidecn.readthedocs.io/zh/latest/starting/install/win.html#install-windows" target="_blank" rel="noopener">Python, Setuptools 以及 pywin32 的依赖项</a>。</p><ol><li>使用以下命令安装 <code>bbfreeze</code>:</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install bbfreeze</span><br></pre></td></tr></table></figure><ol><li>编写最简单的示例  <code>bb_setup.py</code>：</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from bbfreeze import Freezer</span><br><span class="line"></span><br><span class="line">freezer = Freezer(distdir=<span class="string">'dist'</span>)</span><br><span class="line">freezer.addScript(<span class="string">'foobar.py'</span>, gui_only=<span class="keyword">True</span>)</span><br><span class="line">freezer()</span><br></pre></td></tr></table></figure><blockquote><h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><p>这将适用于最基本的文件脚本。 有时候你需要高级的用法，如包含或者排除某些路径，如下：<br><code>freezer = Freezer(distdir=&#39;dist&#39;, includes=[&#39;my_code&#39;], excludes=[&#39;docs&#39;])</code></p></blockquote><ol><li>(可选) 包含图标</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freezer.setIcon(<span class="string">'my_awesome_icon.ico'</span>)</span><br></pre></td></tr></table></figure><ol><li>为冻结器（freezer）提供 Microsoft Visual C 运行时 DLL，我们有一般有两种方法，第一种是将Microsoft Visual Studio 路径 附加您的 <code>sys.path</code> 中，第二种是在脚本所在同一文件夹中放置 <code>msvcp90.dll</code> 文件。</li><li>开始冻结!</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python bb_setup.py</span><br></pre></td></tr></table></figure><h3 id="py2exe"><a href="#py2exe" class="headerlink" title="py2exe"></a>py2exe</h3><p>前置要求是安装了 <a href="http://pythonguidecn.readthedocs.io/zh/latest/starting/install/win.html#install-windows" target="_blank" rel="noopener">Python on Windows</a>。</p><ol><li>下载并且安装 <a href="http://sourceforge.net/projects/py2exe/files/py2exe/" target="_blank" rel="noopener">http://sourceforge.net/projects/py2exe/files/py2exe/</a></li><li>编写 <code>setup.py</code> (<a href="http://www.py2exe.org/index.cgi/ListOfOptions" target="_blank" rel="noopener">配置选项清单</a>):</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from distutils.core import setup</span><br><span class="line">import py2exe</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    windows=[&#123;<span class="string">'script'</span>: <span class="string">'foobar.py'</span>&#125;],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>(可选) <a href="http://www.py2exe.org/index.cgi/CustomIcons" target="_blank" rel="noopener">包含图标</a></li><li>(可选) <a href="http://stackoverflow.com/questions/112698/py2exe-generate-single-executable-file#113014" target="_blank" rel="noopener">单文件模式</a></li><li>生成 :file: <em>.exe</em> 到 <code>dist</code> 目录:</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python setup.py py2exe</span><br></pre></td></tr></table></figure><ol><li>两种方式来提供 Microsoft Visual C 运行时 DLL。两个选项: <a href="https://www.microsoft.com/en-us/download/details.aspx?id=29" target="_blank" rel="noopener">在目标机器全局安装 dll</a> 或者 <a href="http://www.py2exe.org/index.cgi/Tutorial#Step52" target="_blank" rel="noopener">与 .exe 一起分发 dll</a>。</li></ol><h3 id="PyInstaller"><a href="#PyInstaller" class="headerlink" title="PyInstaller"></a>PyInstaller</h3><p>前置条件是安装 <a href="http://pythonguidecn.readthedocs.io/zh/latest/starting/install/win.html#install-windows" target="_blank" rel="noopener">Python, Setuptools 以及pywin32 依赖项</a>.</p><ul><li><a href="http://bojan-komazec.blogspot.com/2011/08/how-to-create-windows-executable-from.html" target="_blank" rel="noopener">更多的简单教程</a></li><li><a href="https://pyinstaller.readthedocs.io/en/stable/" target="_blank" rel="noopener">官方手册</a></li></ul><h2 id="OS-X"><a href="#OS-X" class="headerlink" title="OS X"></a>OS X</h2><h3 id="py2app"><a href="#py2app" class="headerlink" title="py2app"></a>py2app</h3><h3 id="PyInstaller-1"><a href="#PyInstaller-1" class="headerlink" title="PyInstaller"></a>PyInstaller</h3><p>PyInstaller可用于在 Mac OS X 10.6（Snow Leopard）或更新版本上构建 Unix 可执行文件和窗口应用程序。</p><p>要安装 PyInstaller，使用 pip：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pyinstaller</span><br></pre></td></tr></table></figure><p>要创建标准的 Unix 可执行文件，使用 <code>script.py</code> ：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pyinstaller script.py</span><br></pre></td></tr></table></figure><p>这会创建：</p><ul><li><code>script.spec</code> 文件, 类似于 <code>make</code> 文件</li><li><code>build</code> 文件夹, 存放日志文件</li><li><code>dist</code> 文件夹, 存放主要的可执行文件 <code>script</code> ，和一些依赖的Python库</li></ul><p><code>script.py</code> 会把全部内容放在同一个文件夹中。PyInstaller 将所有 <code>script.py</code> 用到的 Python 库放到 <code>dist</code> 文件夹中。所以在分发可执行文件时，会分发整个 <code>dist</code> 文件夹。</p><p><code>script.spec</code> 文件可以编辑成 <a href="http://pythonhosted.org/PyInstaller/#spec-file-operation" target="_blank" rel="noopener">自定义构建</a> ， 比如可以：</p><ul><li>将数据文件与可执行文件绑定在一起</li><li>包含 PyInstaller 无法自动推断的运行时库（ <code>.dll</code> 或 <code>.so</code> 文件）</li><li>将 Python 运行时选项添加到可执行文件中</li></ul><p>现在：代码 <code>script.spec</code> 可以用 <code>pyinstaller</code> （而不是再次使用 <code>script.py</code> ）运行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pyinstaller script.spec</span><br></pre></td></tr></table></figure><p>要创建独立的 OS X 窗口应用程序，请使用 <code>--windowed</code> 选项：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pyinstaller --windowed script.spec</span><br></pre></td></tr></table></figure><p>这将在 <code>dist</code> 文件夹中创建一个 <code>script.app</code> 。请确保在 Python 代码中 使用 GUI 软件包，例如 <a href="https://riverbankcomputing.com/software/pyqt/intro" target="_blank" rel="noopener">PyQt</a> 或 <a href="http://wiki.qt.io/About-PySide" target="_blank" rel="noopener">PySide</a>来控制应用程序的图形部分。</p><p><code>script.spec</code> 有几个与 Mac OS X 应用程序捆绑有关的 <a href="http://pythonhosted.org/PyInstaller/spec-files.html#spec-file-options-for-a-mac-os-x-bundle" target="_blank" rel="noopener">选项</a> 。 例如，要指定应用程序的图标，请使用 <code>icon=\path\to\icon.icns</code> 选项。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://packaging.python.org/tutorials/packaging-projects/#initial-files" target="_blank" rel="noopener">Python官方文档</a></li><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li><li><a href="https://blog.zengrong.net/post/2169.html" target="_blank" rel="noopener">https://blog.zengrong.net/post/2169.html</a></li><li><a href="http://ju.outofmemory.cn/entry/106479" target="_blank" rel="noopener">http://ju.outofmemory.cn/entry/106479</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;打包Python项目&quot;&gt;&lt;a href=&quot;#打包Python项目&quot; class=&quot;headerlink&quot; title=&quot;打包Python项目&quot;&gt;&lt;/a&gt;打包Python项目&lt;/h1&gt;&lt;p&gt;本教程将指导您如何打包一个简单的Python项目。它将向您展示如何添加必要的
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-关于项目License</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AELicense/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-关于项目License/</id>
    <published>2018-09-15T04:40:43.334Z</published>
    <updated>2018-09-15T09:43:04.196Z</updated>
    
    <content type="html"><![CDATA[<p>您的源码发布 <em>需要</em> 一个许可证。在美国，如果没有指定许可证，用户就没有合法的权利下载、修改或分发。此外，除非你告诉他们要遵循什么规则，否则人们不能对你的代码做出贡献。选择一个许可证是很复杂的，所以这里有一些建议:</p><p>开源许可。 这里有许多可以选择 <a href="http://opensource.org/licenses/alphabetical" target="_blank" rel="noopener"> 开源许可 </a>  。</p><p>通常, 这些许可分为两类：</p><ol><li>一类是让使用者能自由地使用软件 (像这种更加开发的开源许可有 MIT ， BSD &amp; Apache) 。</li><li>另一类是确保代码本身–无论发生任何修改或发布–该软件代码都应该是免费的 (像这种有一定限制的免费开源软件许可有 GPL 和 LGPL) 。</li></ol><p>后者在某种意义上是不那么宽容开放的，因为他们不允许有人向软件中添加代码，并在不包括其更改的源代码的情况下发布代码。</p><p>为了帮助你为自己的项目选择一个许可证，请 <strong>使用</strong> <a href="http://choosealicense.com/" target="_blank" rel="noopener">许可证选择器</a> 。</p><p><strong>更宽容的</strong></p><ul><li>PSFL (Python Software Foundation License) – 用于对 Python 本身作出贡献。</li><li>MIT / BSD / ISC<ul><li>MIT (X11)</li><li>New BSD</li><li>ISC</li></ul></li><li>Apache</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;您的源码发布 &lt;em&gt;需要&lt;/em&gt; 一个许可证。在美国，如果没有指定许可证，用户就没有合法的权利下载、修改或分发。此外，除非你告诉他们要遵循什么规则，否则人们不能对你的代码做出贡献。选择一个许可证是很复杂的，所以这里有一些建议:&lt;/p&gt;
&lt;p&gt;开源许可。 这里有许多可以选
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-常见陷阱</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-常见陷阱/</id>
    <published>2018-09-15T04:40:16.342Z</published>
    <updated>2018-09-15T09:42:52.940Z</updated>
    
    <content type="html"><![CDATA[<p>通常，Python 旨在成为一门简洁一致的语言，避免发生意外。然而，有些情况可能会给新手们造成困惑。</p><p>在这些情况中，有一些虽是有意为之，但还是有潜在风险。还有一些则可以说是语言设计缺陷了。总之，下面列出的这些情况都是些乍一看很不好理解的行为，不过一旦您了解了这些奇怪行为背后的机理，也就基本上能理解了。</p><h2 id="可变默认参数"><a href="#可变默认参数" class="headerlink" title="可变默认参数"></a>可变默认参数</h2><p>似乎每个 Python 新手都会感到惊讶的一点是 Python 在函数定义中对待可变默认参数的方法。</p><h3 id="您所写的"><a href="#您所写的" class="headerlink" title="您所写的"></a>您所写的</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def append_to(element, to=[]):</span><br><span class="line">    to.append(element)</span><br><span class="line">    <span class="keyword">return</span> to</span><br></pre></td></tr></table></figure><h3 id="您可能期待的结果"><a href="#您可能期待的结果" class="headerlink" title="您可能期待的结果"></a>您可能期待的结果</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_list = append_to(<span class="number">12</span>)</span><br><span class="line"><span class="keyword">print</span> my_list</span><br><span class="line"></span><br><span class="line">my_other_list = append_to(<span class="number">42</span>)</span><br><span class="line"><span class="keyword">print</span> my_other_list</span><br></pre></td></tr></table></figure><p>函数每次被调用时，如果不提供第二个参数，就创建一个新的列表。所以结果就应该是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">12</span>]</span><br><span class="line">[<span class="number">42</span>]</span><br></pre></td></tr></table></figure><h3 id="实际上的结果"><a href="#实际上的结果" class="headerlink" title="实际上的结果"></a>实际上的结果</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">12</span>]</span><br><span class="line">[<span class="number">12</span>, <span class="number">42</span>]</span><br></pre></td></tr></table></figure><p><em>一旦</em> 完成了函数定义，一个新的列表就创建出来了，而且在随后的每一次函数调用中被使用的都是这个列表。</p><p><em>一旦</em> 完成了函数定义，Python 的默认参数就被赋值了，而且在随后的每一次函数调用中都不会再被默认值重复赋值（就像是在，嗯，Ruby 里那样）。这就意味着如果您使用了一个可变默认参数，并且改变了它，您也会且 <em>将会</em> 在未来的所有函数调用中改变这同一个参数对象。</p><h3 id="您实际上应该做的"><a href="#您实际上应该做的" class="headerlink" title="您实际上应该做的"></a>您实际上应该做的</h3><p>使用一个默认值来表示我们并不想给这个参数赋值，从而每次在函数被调用时我们都创建一个新的对象。（<a href="http://docs.python.org/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 作为默认值通常是个好选择）。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def append_to(element, to=None):</span><br><span class="line">    <span class="keyword">if</span> to is None:</span><br><span class="line">        to = []</span><br><span class="line">    to.append(element)</span><br><span class="line">    <span class="keyword">return</span> to</span><br></pre></td></tr></table></figure><p>可别忘了，您所传递的第二个参数仍应该是个 <em>列表</em> 对象。</p><h3 id="利用好『缺陷』"><a href="#利用好『缺陷』" class="headerlink" title="利用好『缺陷』"></a>利用好『缺陷』</h3><p>有时你可以专门 <strong>利用</strong>（或者说特地使用）这种行为来维护函数调用间的状态。这通常用于编写缓存函数。</p><h2 id="延迟绑定闭包"><a href="#延迟绑定闭包" class="headerlink" title="延迟绑定闭包"></a>延迟绑定闭包</h2><p>另一个常见的困惑是 Python 在闭包（或在周围全局作用域）中绑定变量的方式。</p><h3 id="当你写下"><a href="#当你写下" class="headerlink" title="当你写下"></a>当你写下</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def create_multipliers():</span><br><span class="line">    <span class="keyword">return</span> [lambda x : i * x <span class="keyword">for</span> i in range(<span class="number">5</span>)]</span><br></pre></td></tr></table></figure><h3 id="你期望发生"><a href="#你期望发生" class="headerlink" title="你期望发生"></a>你期望发生</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> multiplier in create_multipliers():</span><br><span class="line">    <span class="keyword">print</span> multiplier(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>一个包含五个函数的列表，每个函数有它们自己的封闭变量 <code>i</code> 乘以它们的参数，得到:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="而事实是："><a href="#而事实是：" class="headerlink" title="而事实是："></a>而事实是：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>五个函数被创建了，它们全都用 4 乘以 <code>x</code> 。</p><p>Python 的闭包是 <strong>延迟绑定的</strong> 。 这意味着闭包中用到的变量的值，是在内部函数被调用时查询得到的。</p><p>这里，不论 <strong>任何</strong> 返回的函数是如何被调用的， <code>i</code> 取的是调用时周围作用域里的值。 当循环完成时， <code>i</code> 的值最终变成了 4。</p><p>关于这个陷阱有一个普遍严重的误解，它被认为只针对 Python 的 <a href="http://docs.python.org/reference/expressions.html#lambda" target="_blank" rel="noopener">闭包 lambda</a> 定义方式。 事实上，由 <code>lambda</code> 表达式创建的函数并没什么特别，同样的问题也出现在使用普通的 <code>def</code> 上：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def create_multipliers():</span><br><span class="line">    multipliers = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">5</span>):</span><br><span class="line">        def multiplier(x):</span><br><span class="line">            <span class="keyword">return</span> i * x</span><br><span class="line">        multipliers.append(multiplier)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> multipliers</span><br></pre></td></tr></table></figure><h3 id="以上正确的做法应该是："><a href="#以上正确的做法应该是：" class="headerlink" title="以上正确的做法应该是："></a>以上正确的做法应该是：</h3><p>最简单通用的解决方案可以说是有点取巧（hack）。由于 Python 拥有在前文提到的『为函数默认参数赋值』的行为（参见 <a href="http://pythonguidecn.readthedocs.io/zh/latest/writing/gotchas.html#default-args" target="_blank" rel="noopener">可变默认参数</a> ），你可以创建一个立即绑定参数的闭包，像下面这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def create_multipliers():</span><br><span class="line">    <span class="keyword">return</span> [lambda x, i=i : i * x <span class="keyword">for</span> i in range(<span class="number">5</span>)]</span><br></pre></td></tr></table></figure><p>或者，使用 <code>functools.partial</code> 函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from functools import partial</span><br><span class="line">from operator import mul</span><br><span class="line"></span><br><span class="line">def create_multipliers():</span><br><span class="line">    <span class="keyword">return</span> [partial(mul, i) <span class="keyword">for</span> i in range(<span class="number">5</span>)]</span><br></pre></td></tr></table></figure><h3 id="缺陷并不可怕"><a href="#缺陷并不可怕" class="headerlink" title="缺陷并不可怕"></a>缺陷并不可怕</h3><p>有时你就想要闭包有如此表现，延迟绑定在很多情况下是一个很赞的特性。不幸的是，循环创建独立函数是一种会使它们出差错的情况。</p><h2 id="字节码（-pyc）文件无处不在！"><a href="#字节码（-pyc）文件无处不在！" class="headerlink" title="字节码（.pyc）文件无处不在！"></a>字节码（.pyc）文件无处不在！</h2><p>默认情况下，当你直接执行 Python 脚本文件时，Python 解释器会自动将该文件的字节码版本写入同目录下。 比如， <code>module.pyc</code>。</p><p>这些 <code>.pyc</code> 文件不应该被纳入源代码仓库。</p><p>理论上，出于性能原因，此行为默认为开启。 没有这些字节码文件， Python 会在每次加载文件时重新生成字节码文件。</p><h3 id="禁用字节码（-pyc）文件"><a href="#禁用字节码（-pyc）文件" class="headerlink" title="禁用字节码（.pyc）文件"></a>禁用字节码（.pyc）文件</h3><p>幸运的是，生成字节码的过程非常快，在开发代码时不需要担心。</p><p>那些文件很讨厌，所以让我们摆脱他们吧！</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export PYTHONDONTWRITEBYTECODE=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用 <code>$PYTHONDONTWRITEBYTECODE</code> 环境变量来命令 Python 不将这些文件写入磁盘， 开发环境将会保持整洁和干净。</p><p>我建议在你的 <code>~/.profile</code> 里设置这个环境变量。</p><h3 id="删除字节码（-pyc）文件"><a href="#删除字节码（-pyc）文件" class="headerlink" title="删除字节码（.pyc）文件"></a>删除字节码（.pyc）文件</h3><p>以下是删除所有已存在字节码文件的好方法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -type f -name <span class="string">"*.py[co]"</span> -delete -<span class="keyword">or</span> -type d -name <span class="string">"__pycache__"</span> -delete</span><br></pre></td></tr></table></figure><p>从项目根目录运行，所有 <code>.pyc</code> 文件会瞬间消失。</p><h3 id="版本控制忽略"><a href="#版本控制忽略" class="headerlink" title="版本控制忽略"></a>版本控制忽略</h3><p>如果由于性能原因仍然需要 <code>.pyc</code> 文件，你可以随时将它们添加到版本控制存储库的忽略文件中。 流行的版本控制系统能够使用文件中定义的通配符来应用特殊规则。</p><p>一份忽略文件将确保匹配的文件未被检入存储库。 <a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a> 使用 <code>.gitignore</code>，而 <a href="https://www.mercurial-scm.org/" target="_blank" rel="noopener">Mercurial</a> 使用 <code>.hgignore</code>。</p><p>忽略文件里至少应该具备以下内容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syntax:glob   <span class="comment"># This line is not needed for .gitignore files.</span></span><br><span class="line">*.py[cod]     <span class="comment"># Will match .pyc, .pyo and .pyd files.</span></span><br><span class="line">__pycache__/  <span class="comment"># Exclude the whole folder</span></span><br></pre></td></tr></table></figure><p>可按需添加更多文件和目录。下次提交到存储库时，这些文件将不被包括。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常，Python 旨在成为一门简洁一致的语言，避免发生意外。然而，有些情况可能会给新手们造成困惑。&lt;/p&gt;
&lt;p&gt;在这些情况中，有一些虽是有意为之，但还是有潜在风险。还有一些则可以说是语言设计缺陷了。总之，下面列出的这些情况都是些乍一看很不好理解的行为，不过一旦您了解了这
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-日志记录</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-日志记录/</id>
    <published>2018-09-15T04:39:54.022Z</published>
    <updated>2018-09-15T09:43:07.988Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://docs.python.org/library/logging.html#module-logging" target="_blank" rel="noopener"><code>logging</code></a> 模块自 2.3 版以来一直是 Python 标准库的一部分。在 <a href="https://www.python.org/dev/peps/pep-0282" target="_blank" rel="noopener"><strong>PEP 282</strong></a> 中有对它的简洁描述。除了 <a href="http://docs.python.org/howto/logging.html#logging-basic-tutorial" target="_blank" rel="noopener">基础日志教程</a>之外，这些文档是非常难以阅读的。</p><p>日志记录一般有两个目的：</p><ul><li><strong>诊断日志</strong> 记录与应用程序操作相关的日志。例如，当用户遇到程序报错时， 可通过搜索诊断日志以获得上下文信息。</li><li><strong>审计日志</strong> 为商业分析而记录的日志。从审计日志中，可提取用户的交易信息， 并结合其他用户资料构成用户报告，或者用来作为优化商业目标的数据支撑。</li></ul><h2 id="…-或者使用打印（print）"><a href="#…-或者使用打印（print）" class="headerlink" title="… 或者使用打印（print）?"></a>… 或者使用打印（print）?</h2><p>当需要在命令行应用中显示帮助文档时， <code>print</code> 是一个相对于日志更好的选择。 而在其他时候，日志总能优于 <code>print</code> ，理由如下：</p><ul><li>日志事件产生的 <a href="https://docs.python.org/library/logging.html#logrecord-attributes" target="_blank" rel="noopener">日志记录</a> ，包含清晰可用的诊断信息，如文件名称、路径、函数名和行号等。</li><li>包含日志模块的应用，默认可通过根记录器对应用的日志流进行访问，除非你做了日志过滤。</li><li>可通过 <a href="http://docs.python.org/library/logging.html#logging.Logger.setLevel" target="_blank" rel="noopener"><code>logging.Logger.setLevel()</code></a> 方法有选择地记录日志， 或可通过设置 <code>logging.Logger.disabled</code> 属性为 <code>True</code> 来禁用日志记录。</li></ul><h2 id="在库中记录日志"><a href="#在库中记录日志" class="headerlink" title="在库中记录日志"></a>在库中记录日志</h2><p>官方的 <a href="http://docs.python.org/howto/logging.html" target="_blank" rel="noopener">日志指南</a>  里有相关的 <a href="https://docs.python.org/howto/logging.html#configuring-logging-for-a-library" target="_blank" rel="noopener">库日志配置</a> 的说明。由于是 <em>用户</em> ，而非库来指定如何响应日志事件， 因此这里有一个值得反复说明的忠告：</p><blockquote><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>强烈建议不要向您的库日志中加入除 NullHandler 外的其它处理程序。</p></blockquote><p>在库中，声明日志的最佳方式是通过 <code>__name__</code> 全局变量： <a href="http://docs.python.org/library/logging.html#module-logging" target="_blank" rel="noopener"><code>logging</code></a> 模块通过点（<code>.</code>）运算符创建层级排列的日志，因此，用 <code>__name__</code> 可以避免名字冲突。</p><p>以下是一个来自 <a href="https://github.com/kennethreitz/requests" target="_blank" rel="noopener">requests 资源</a> 的最佳实践的例子 —— 请将它放置在 <code>__init__.py</code> 文件中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.getLogger(__name__).addHandler(logging.NullHandler())</span><br></pre></td></tr></table></figure><h2 id="在应用程序中记录日志"><a href="#在应用程序中记录日志" class="headerlink" title="在应用程序中记录日志"></a>在应用程序中记录日志</h2><p>应用程序开发的权威指南  <a href="http://12factor.net/" target="_blank" rel="noopener">《twelve factor app》</a>  也在其中一节描述了 <a href="http://12factor.net/logs" target="_blank" rel="noopener">日志的作用</a> 。它特别强调将日志视为事件流， 并将其发送至取决于应用环境配置的标准输出中。</p><p>至少有以下三种配置日志方式：</p><ul><li>使用 INI 格式文件：<ul><li><strong>优点</strong>：使用 <a href="http://docs.python.org/library/logging.config.html#logging.config.listen" target="_blank" rel="noopener"><code>logging.config.listen()</code></a> 函数监听 socket，可在运行过程中更新配置</li><li><strong>缺点</strong>：相比代码里控制，可控性要弱（ <em>例如</em> 子类化定制的 <code>filters</code> 或 <code>loggers</code>）。</li></ul></li><li>使用字典或 JSON 格式文件：<ul><li><strong>优点</strong>：除了可在运行时动态更新，在 Python 2.6 之后，还可通过 <a href="http://docs.python.org/library/json.html#module-json" target="_blank" rel="noopener"><code>json</code></a> 模块从其它文件中导入配置。</li><li><strong>缺点</strong>：相比代码里控制，可控性要弱</li></ul></li><li>使用代码控制：<ul><li><strong>优点</strong>：相比配置来讲，有绝对的控制。</li><li><strong>缺点</strong>：需要对源码进行修改。</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://docs.python.org/library/logging.html#module-logging&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/a&gt; 模块自 2.3 版以来一
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-代码测试</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-代码测试/</id>
    <published>2018-09-15T04:39:30.430Z</published>
    <updated>2018-09-15T09:42:56.838Z</updated>
    
    <content type="html"><![CDATA[<p>测试你的代码是非常重要的。</p><p>习惯于同时写测试用例和运行代码，现在被视为一个好的习惯。如果使用得当，这种方式将帮助你更加明确自己代码的功能，以及拥有更加可解耦的结构。</p><p>你应对自己编写的函数和类进行测试。这样你就能够更加确定自己所做的工作不会破坏项目的其他部分，你就能够随心所欲地改进既有的代码了。</p><p>如果你在项目中包含了初步测试用例，其他程序猿更敬佩你，更愿意work with you together ，他们将能够更得心应手地尝试使用你编写的代码，也更愿意与你合作开发项目。</p><p>测试的通用规则：</p><ul><li>测试单元应该集中于最小部分功能，并且证明它是正确的。</li><li>每个测试单元必须完全独立。他们都能够单独运行，也可以在测试套件中运行，而不用考虑被调用的顺序。 要想实现这个规则，测试单元应该加载最新的数据集，之后再做一些清理。 这通常用方法 <code>setUp()</code> 和 <code>tearDown()</code> 处理。</li><li>尽量使测试单元快速运行。如果一个单独的测试单元需要较长的时间去运行，开发进度将会延迟， 测试单元将不能如期常态性运行。有时候，因为测试单元需要复杂的数据结构， 并且当它运行时每次都要加载，所以其运行时间较长。请把运行速度较慢的测试单元放在单独的测试组件中， 并且按照需要运行其它测试单元。</li><li>学习使用工具，学习如何运行一个单独的测试或者测试用例。当为某个模块开发了一个新功能时， 我们需要经常运行这个功能的测试用例，理想情况下需配置工具让其在保存代码文件时自动触发运行测试。</li><li>在编码工作开始前后，请运行完整的测试组件。只有这样，你才会坚信现有的代码不会出现错误。</li><li>使用钩子（hook）是一个非常推荐的做法，一旦把代码提交到共享的代码仓库时（译者注：很多时候你会选择 Github）， 即可触发钩子运行所有的测试。</li><li>如果你在开发期间不得不打断自己的工作，请先为你下一步要开发的功能写一个未通过的测试，这样当你回到工作时，将可以很快地回到原先被打断的地方，并且步入正轨。</li><li><p>当你调试代码的时候，首先需要写一个精确定位 Bug 的测试单元。尽管这样做很难， 但是捕捉 Bug 的单元测试在项目中很重要。</p></li><li><p>测试函数需使用长且描述性的名字。测试的编码规范与代码编码规范有点不一样，代码更倾向于使用短的名字， 而测试函数不会直接被调用。在运行代码中，<code>square()</code> 或者甚至 <code>sqr()</code> 这样的命名都是可以的， 但是在测试代码中，您应该这样取名 <code>test_square_of_number_2()</code>，<code>test_square_negative_number()</code>。 当测试单元失败时，函数名会被直接显示出来，此时函数名称的描述性将变得重要。</p></li><li>当业务逻辑不得不变更时，如果代码中有一套不错的测试单元， 维护者将很大一部分依靠测试组件解决问题，或者确保改动不会影响到其他代码。此时测试代码会经常被阅读， 阅读的频率甚至多于业务逻辑代码。目的不明确的测试单元在这种情况下没有多少用处，因此请尽量避免书写目的不明确的测试代码。</li><li>测试代码的另外一个用处是作为新开发人员的入门介绍。当有人需要基于现有的代码库工作时， 运行并且阅读相关的测试代码是最好的做法。他们会或者应该发现业务代码的重点、难点、以及边界场景。 如果他们必须添加一些功能，第一步应该是添加一个测试，以确保新功能开发能保持测试的传统。</li></ul><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="Unittest-单元测试"><a href="#Unittest-单元测试" class="headerlink" title="Unittest 单元测试"></a>Unittest 单元测试</h3><p><a href="http://docs.python.org/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 是 Python 标准库中自带的测试模块。任何一个使用过 Junit，nUnit, 或 CppUnit 工具的人对它的 API 都会比较熟悉。</p><p>我们可以通过继承 <a href="http://docs.python.org/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>unittest.TestCase</code></a> 来创建测试用例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">def fun(x):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">class MyTest(unittest.TestCase):</span><br><span class="line">    def test(<span class="keyword">self</span>):</span><br><span class="line">        <span class="keyword">self</span>.assertEqual(fun(<span class="number">3</span>), <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>Python 2.7 以后，<code>unittest</code> 已支持测试自动发现机制。</p><blockquote><p><a href="http://docs.python.org/library/unittest.html" target="_blank" rel="noopener">关于 unittest 的标准库文档</a></p></blockquote><h3 id="Doctest"><a href="#Doctest" class="headerlink" title="Doctest"></a>Doctest</h3><p><a href="http://docs.python.org/library/doctest.html#module-doctest" target="_blank" rel="noopener"><code>doctest</code></a> 模块会在代码的 Docstrings 中寻找类似于 Python 交互会话的字串（译者注：<code>&gt;&gt;&gt;</code>），并会将其执行，以证实工作正常。</p><p>Doctest 模块的使用场景与单元测试有所不同：它们通常不是很详细，并且不会用特别的用例或者处理复杂的 Bug。Doctest 主要是作为模块和其部件主要用例的表述性文档，因此，Doctest 需在每一次完整测试 套件运行时自动运行。</p><p>函数中的一个简单 Doctest 例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def square(x):</span><br><span class="line">    <span class="string">""</span><span class="string">"Return the square of x.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; square(2)</span></span><br><span class="line"><span class="string">    4</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; square(-2)</span></span><br><span class="line"><span class="string">    4</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    import doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure><p>当使用 <code>python module.py</code> 这样的命令行运行这个模块时，Doctest 将会运行，并会在结果与文档字符串的描述不一致时报错。</p><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><h3 id="py-test"><a href="#py-test" class="headerlink" title="py.test"></a>py.test</h3><p>相比于 Python 标准库里的 unittest 模块，py.test 也是一个没有模板（no-boilerplate）的备选方案：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pytest</span><br></pre></td></tr></table></figure><p>尽管这个测试工具功能完备，并且可扩展，它仍然能保持语法很简单。创建一个测试组件和写一个带有诸多函数的模块一样容易：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># content of test_sample.py</span></span><br><span class="line">def func(x):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">def test_answer():</span><br><span class="line">    assert func(<span class="number">3</span>) == <span class="number">5</span></span><br></pre></td></tr></table></figure><p>运行命令 py.test ：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ py.test</span><br><span class="line">=========================== test session starts ============================</span><br><span class="line">platform darwin -- Python <span class="number">2.7</span><span class="number">.1</span> -- pytest<span class="number">-2.2</span><span class="number">.1</span></span><br><span class="line">collecting ... collected <span class="number">1</span> items</span><br><span class="line"></span><br><span class="line">test_sample.py F</span><br><span class="line"></span><br><span class="line">================================= FAILURES =================================</span><br><span class="line">_______________________________ test_answer ________________________________</span><br><span class="line"></span><br><span class="line">    def test_answer():</span><br><span class="line">&gt;       assert func(<span class="number">3</span>) == <span class="number">5</span></span><br><span class="line">E       assert <span class="number">4</span> == <span class="number">5</span></span><br><span class="line">E        +  where <span class="number">4</span> = func(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">test_sample.py:<span class="number">5</span>: AssertionError</span><br><span class="line">========================= <span class="number">1</span> failed in <span class="number">0.02</span> seconds =========================</span><br></pre></td></tr></table></figure><p>可以看出，这要比 unittest 模块中实现相同功能所要求的工作量少得多。</p><blockquote><p><a href="https://docs.pytest.org/en/latest/" target="_blank" rel="noopener">py.test</a></p></blockquote><h3 id="Hypothesis"><a href="#Hypothesis" class="headerlink" title="Hypothesis"></a>Hypothesis</h3><p>Hypothesis 让你编写被示例源码参数化的测试库。它会生成简单易懂的例子，使你的测试失败， 让你花更少的力气找到更多的错误。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install hypothesis</span><br></pre></td></tr></table></figure><p>例如，测试浮动列表要尝试很多例子，但是会报告每个错误的最小例子（区分异常类型和位置）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@given(lists(floats(allow_nan=<span class="keyword">False</span>, allow_infinity=<span class="keyword">False</span>), min_size=<span class="number">1</span>))</span><br><span class="line">def test_mean(xs):</span><br><span class="line">    mean = sum(xs) / len(xs)</span><br><span class="line">    assert min(xs) &lt;= mean(xs) &lt;= max(xs)</span><br><span class="line">Falsifying example: test_mean(</span><br><span class="line">    xs=[<span class="number">1.7976321109618856e+308</span>, <span class="number">6.102390043022755e+303</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Hypothesis 是实用且强大的工具，很多时候它都会找出被其他测试工具所遗漏的错误。 它能与 py.test 很好地集成，无论是简单亦或者是高级场景中，你都会觉得它很趁手。</p><blockquote><p><a href="https://hypothesis.readthedocs.io/en/latest/" target="_blank" rel="noopener">hypothesis</a></p></blockquote><h3 id="tox"><a href="#tox" class="headerlink" title="tox"></a>tox</h3><p>tox 是一个自动化测试环境管理，并能针对多版本解释器配置进行测试的工具。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install tox</span><br></pre></td></tr></table></figure><p>tox 允许你通过简单的配置文件，来设置复杂的多参数测试矩阵。</p><blockquote><p><a href="https://tox.readthedocs.io/en/latest/" target="_blank" rel="noopener">tox</a></p></blockquote><h3 id="Unittest2"><a href="#Unittest2" class="headerlink" title="Unittest2"></a>Unittest2</h3><p>Unittest2 是 Python 2.7 中 unittest 模块的向后兼容补丁，对比 Python 2.7 之前的版本提供了更好的 API 和断言语法。</p><p>如果使用 Python 2.6 版本或者以下，你可以使用 pip 安装 unittest2：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install unittest2</span><br></pre></td></tr></table></figure><p>推荐你使用 unittest 之名导入模块，目的是更容易地把代码移植到新的版本中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import unittest2 <span class="keyword">as</span> unittest</span><br><span class="line"></span><br><span class="line">class MyTest(unittest.TestCase):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>如果切换到新的 Python 版本，并且不再需要 unittest2 模块，你只需要在测试模块中改变 import 内容，而不必改变其它代码。</p><blockquote><p><a href="http://pypi.python.org/pypi/unittest2" target="_blank" rel="noopener">unittest2</a></p></blockquote><h3 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h3><p><a href="http://docs.python.org/library/unittest.mock.html#module-unittest.mock" target="_blank" rel="noopener"><code>unittest.mock</code></a> 是 Python 中用于测试的一个库。 Python 3.3 版本中，将存在于自带的标准库中 —— <a href="https://docs.python.org/dev/library/unittest.mock" target="_blank" rel="noopener">标准库中的 unittest.mock</a>。</p><p>对于 Python 相对早的版本，如下操作：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install mock</span><br></pre></td></tr></table></figure><p>在测试环境下，使用 mock 对象能够替换部分系统，并且对它们的使用进行断言。</p><p>例如，你可以对一个方法打猴子补丁：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from mock import MagicMock</span><br><span class="line">thing = ProductionClass()</span><br><span class="line">thing.method = MagicMock(return_value=<span class="number">3</span>)</span><br><span class="line">thing.method(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, key=<span class="string">'value'</span>)</span><br><span class="line"></span><br><span class="line">thing.method.assert_called_with(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, key=<span class="string">'value'</span>)</span><br></pre></td></tr></table></figure><p>在测试环境下，你可以使用 <code>patch</code> 修饰器来 mock 某个模块中的类或对象。在下面这个例子中，一直返回相同结果的外部查询系统使用 mock 替换（但仅用在测试期间）。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def mock_search(<span class="keyword">self</span>):</span><br><span class="line">    class MockSearchQuerySet(SearchQuerySet):</span><br><span class="line">        def __iter__(<span class="keyword">self</span>):</span><br><span class="line">            <span class="keyword">return</span> iter([<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>])</span><br><span class="line">    <span class="keyword">return</span> MockSearchQuerySet()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的 SearchForm 指的是 myapp 引入的类,</span></span><br><span class="line"><span class="comment"># 而不是类 SearchForm 本身自己</span></span><br><span class="line">@mock.patch(<span class="string">'myapp.SearchForm.search'</span>, mock_search)</span><br><span class="line">def test_new_watchlist_activities(<span class="keyword">self</span>):</span><br><span class="line">    <span class="comment"># get_search_results 运行一次搜索并对结果进行迭代</span></span><br><span class="line">    <span class="keyword">self</span>.assertEqual(len(myapp.get_search_results(q=<span class="string">"fish"</span>)), <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>Mock 还提供许多其它方法，你可以很轻松地配置和控制它的行为。</p><blockquote><p><a href="http://www.voidspace.org.uk/python/mock/" target="_blank" rel="noopener">Mock 的文档</a></p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;测试你的代码是非常重要的。&lt;/p&gt;
&lt;p&gt;习惯于同时写测试用例和运行代码，现在被视为一个好的习惯。如果使用得当，这种方式将帮助你更加明确自己代码的功能，以及拥有更加可解耦的结构。&lt;/p&gt;
&lt;p&gt;你应对自己编写的函数和类进行测试。这样你就能够更加确定自己所做的工作不会破坏项目
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-项目文档</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-项目文档/</id>
    <published>2018-09-15T04:39:18.634Z</published>
    <updated>2018-09-15T09:43:11.588Z</updated>
    
    <content type="html"><![CDATA[<p>可读性是 Python 开发人员在项目和代码文档中的主要关注点。遵循一些简单的最佳实践可以为您和其他人节省大量时间。</p><h2 id="项目文档"><a href="#项目文档" class="headerlink" title="项目文档"></a>项目文档</h2><p>在根目录下 <code>README</code> 文件应该对用户和项目维护者提供概述信息。它应该是原始文本或非常容易阅读的标记写成，如 <a href="http://docs.python-guide.org/en/latest/writing/documentation/#restructuredtext-ref" target="_blank" rel="noopener">reStructuredText</a> 或 Markdown。 它应该包含几行对项目或库的作用的解释（假设用户不知道项目的任何内容），软件源站点的 URL 和一些基本的信用信息。这个文件应该是代码阅读者的主要入口点。</p><p><code>INSTALL</code> 文件对 Python 来说不是必需的。安装指令通常被简化为一个命令，如 <code>pip install module</code> 或 <code>python setup.py install</code> 并且添加到 <code>README</code> 文件中。</p><p><code>LICENSE</code> 文件应该 <em>始终</em> 存在并且详细说明软件在什么许可证下对公众可用。</p><p><code>TODO</code> 文件或 <code>README</code> 文件中的 <code>TODO</code> 部分应该列出代码的开发计划。</p><p><code>CHANGELOG</code> 文件或在 <code>README</code> 对应的部分应该基于最新版本编写一个代码变更概述。</p><h2 id="其他文档"><a href="#其他文档" class="headerlink" title="其他文档"></a>其他文档</h2><p>根据项目的不同，文档中最好能包含下列部分或所有的内容：</p><ul><li>一份 <strong>简短介绍</strong> ，应该包含几个简化的用例，简要概述该产品能够用来做什么。</li><li>一份 <strong>教程</strong> ，应该展示一些主要的用例以及更多的使用细节。读者能够跟着一步步成功搭建工作原型。</li><li>一份 <strong>API 文档</strong>，通常从代码中产生（参见 <a href="http://pythonguidecn.readthedocs.io/zh/latest/writing/documentation.html#docstring-ref" target="_blank" rel="noopener">docstrings</a>）。它会列出所有的可供公共访问的接口、参数和返回值。</li><li>一份 <strong>贡献文档</strong> 适用于潜在贡献者。这可以包括项目的代码规范和通用设计的策略讲解。</li></ul><h3 id="Sphinx"><a href="#Sphinx" class="headerlink" title="Sphinx"></a>Sphinx</h3><p><a href="http://sphinx.pocoo.org/" target="_blank" rel="noopener">Sphinx</a> 无疑是最流行的 Python 文档工具。<strong>我们推荐在项目中使用 Sphinx。</strong> 它能把 <a href="http://pythonguidecn.readthedocs.io/zh/latest/writing/documentation.html#restructuredtext-ref" target="_blank" rel="noopener">reStructuredText</a> 标记语言转换为流行的输出格式，包括 HTML、LaTeX (可打印 PDF 版本)、手册和纯文本。</p><p><a href="http://readthedocs.org/" target="_blank" rel="noopener">Read The Docs</a> 是一个 <em>超棒的</em> 并且 <em>免费的</em> 文档托管平台，可以托管您的 <a href="http://sphinx.pocoo.org/" target="_blank" rel="noopener">Sphinx</a> 文档。您可以为它配置提交钩子到您的代码库中，这样文档的重新构建即可自动进行。</p><p>运行 <a href="http://sphinx.pocoo.org/" target="_blank" rel="noopener">Sphinx</a> 时首先导入你的代码，它会使用 Python 的内省功能来提取所有函数，方法和类签名，同时提取附带的文档字符串，并将其全部编译成结构良好且易于阅读的文档。</p><blockquote><p>Sphinx 因生成 API 文档而著名，但它也适用于普通的文档。本指南（译者注：原始文档）使用 <a href="http://sphinx.pocoo.org/" target="_blank" rel="noopener">Sphinx</a> 进行构建， 并托管在 <a href="http://readthedocs.org/" target="_blank" rel="noopener">Read The Docs</a> 上。</p></blockquote><h3 id="reStructuredText"><a href="#reStructuredText" class="headerlink" title="reStructuredText"></a>reStructuredText</h3><p>大多数 Python 文档是用 <a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="noopener">reStructuredText</a> 编写的。它是一个内建了所有可选扩展的 Markdown 解析器。</p><p><a href="http://sphinx.pocoo.org/rest.html" target="_blank" rel="noopener">reStructuredText Primer</a> 和 <a href="http://docutils.sourceforge.net/docs/user/rst/quickref.html" target="_blank" rel="noopener">reStructuredText Quick Reference</a> 这两个文档应该能帮助你快速熟悉它的语法。</p><h2 id="源码文档建议"><a href="#源码文档建议" class="headerlink" title="源码文档建议"></a>源码文档建议</h2><p>注释能使代码清晰，将其加入到代码中是为了理解代码起来更容易。注释在 Python 中以一个 hash 开始（数字符号）（”#”）。</p><p>在 Python 中我们使用 <em>文档字符串（docstrings）</em> 用来描述模块、类和函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def square_and_rooter(x):</span><br><span class="line">    <span class="string">""</span><span class="string">"Return the square root of self times self."</span><span class="string">""</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>一般来说，我们要遵循 <a href="https://www.python.org/dev/peps/pep-0008#comments" target="_blank" rel="noopener"><strong>PEP 8#comments</strong></a> （” Python 风格指南”）的注释部分。 更多关于 docstrings 的内容可以在 <a href="https://www.python.org/dev/peps/pep-0257#specification" target="_blank" rel="noopener"><strong>PEP 0257#specification</strong></a> （docstrings 约定指南） 上找到。</p><h3 id="注释代码块"><a href="#注释代码块" class="headerlink" title="注释代码块"></a>注释代码块</h3><p><em>请不要使用三引号去注释代码</em>。 这不是好的实践，因为面向行的命令行处理工具， 比如说 <code>grep</code>，将会很难判断注释掉的代码是否是激活的。对每一个注释行，最好使用带有合适缩进的井号。您的编辑器可能很容易做到这一点，并能使用快捷键就切换 注释 / 取消注释。</p><h3 id="Docstrings-的魔法"><a href="#Docstrings-的魔法" class="headerlink" title="Docstrings 的魔法"></a>Docstrings 的魔法</h3><p>一些工具使用 Docstrings 来嵌入不止是文档的行为， 比如说单元测试逻辑等。接下来会给你讲解 Docstrings 的一些奇特的用法，不过话说回来，如果你只是使用 Docstrings 来做函数文档也是完全合理的。</p><p>像 <a href="http://sphinx.pocoo.org/" target="_blank" rel="noopener">Sphinx</a> 这样的工具会将 Docstrings 解析为 reStructuredText，并以 HTML 格式正确呈现。 这使得将示例代码片段嵌入到项目文档成为可能。</p><p>此外， <a href="https://docs.python.org/3/library/doctest.html" target="_blank" rel="noopener">Doctest</a> 能够读取所有内嵌的看起来像 Python 命令行输入（以 <code>&gt;&gt;&gt;</code> 为前缀）的 Docstrings 并对其进行运行，以检查命令输出是否匹配其下行内容。这允许开发人员在源码中嵌入真实的示例和函数的用法。 此外，它还能确保代码运行过测试并且正常工作。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def my_function(a, b):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; my_function(2, 3)</span></span><br><span class="line"><span class="string">    6</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; my_function('a', 3)</span></span><br><span class="line"><span class="string">    'aaa'</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    <span class="keyword">return</span> a * b</span><br></pre></td></tr></table></figure><h3 id="Docstrings-与块注释的比较"><a href="#Docstrings-与块注释的比较" class="headerlink" title="Docstrings 与块注释的比较"></a>Docstrings 与块注释的比较</h3><p>他们俩是不可互换。对于函数或类，开头的注释区是程序员的注解。而Docstrings 描述了函数或类的 <em>操作性文档</em> ：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 出于某种原因此函数用来减慢程序执行的</span></span><br><span class="line">def square_and_rooter(x):</span><br><span class="line">    <span class="string">""</span><span class="string">"返回自己乘以自己的平方根。"</span><span class="string">""</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>块注释会在脚本执行时被优化掉，与块注释不同，Docstrings 内置于 Python 语言本身。这意味着你可以使用 Python 强大的内省功能以在运行时获得 Docstrings 。对于几乎每个 Python 对象，我们都可以通过其 <strong>*doc*</strong> 属性或使用内置的 <code>help()</code> 函数来访问 Docstrings。</p><p>块注释通常用于解释一段代码是 <em>做什么</em> ，或是算法的细节。而 Docstrings 更适合于向其他用户（或是写完代码 6 个月以后的你）解释代码中的特定功能是 <em>如何</em> 使用， 或是方法、类和模块的作用。</p><h3 id="编写-Docstrings"><a href="#编写-Docstrings" class="headerlink" title="编写 Docstrings"></a>编写 Docstrings</h3><p>取决于函数、方法或类的复杂度，使用单行的 Docstrings 可能十分合适。 以下通常用于非常明显的情况，例如:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def add(a, b):</span><br><span class="line">    <span class="string">""</span><span class="string">"两个数字相加，并返回结果。"</span><span class="string">""</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><p>Docstrings 应该以易于理解的方式来描述函数。另一方面，对于简单的函数和类， 将函数的签名（即 <code>add(a, b) -&gt; result</code> ）嵌入到 Docstrings 中是没有必要的。这是因为使用 Python 的 “inspect” 模块可以很容易地找到这些信息。 此外，这些信息也可以简单地通过阅读源代码来获得。</p><p>在更大或更复杂的项目中，我们建议提供相关函数的更多信息，包括它是做什么的， 所抛的任何异常，返回的内容或参数的相关细节。</p><p>对于更详细的代码文档，用于 Numpy 项目上的 Docstrings 风格会更为流行，通常称为 <a href="http://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_numpy.html" target="_blank" rel="noopener">Numpy style</a> Docstrings。因为可以占用更多的行，所以它允许开发人员写入更多的信息。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def random_number_generator(arg1, arg2):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    摘要行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    扩展功能描述。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    arg1：int</span></span><br><span class="line"><span class="string">        arg1的描述</span></span><br><span class="line"><span class="string">    arg2：str</span></span><br><span class="line"><span class="string">        arg2的描述</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    int</span></span><br><span class="line"><span class="string">        返回值说明</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br></pre></td></tr></table></figure><p>Sphinx 下使用 <a href="https://sphinxcontrib-napoleon.readthedocs.io/" target="_blank" rel="noopener">sphinx.ext.napoleon</a> 插件即可解析这种风格的 Docstrings， 使您可以轻松地将 NumPy 风格文档植入到你的项目中。</p><p>最后，编写 Docstrings 的风格并没那么重要，它们的目的是为任何可能需要阅读或更改代码的人提供文档。 只要它是正确的，可以理解的，切中相关点，那么它就很完美地完成了它的使命。</p><p>要进一步阅读 Docstrings，请随时参见 <a href="https://www.python.org/dev/peps/pep-0257" target="_blank" rel="noopener"><strong>PEP 257</strong></a></p><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><p>你可能在其他场景看到过这些，不过没有特殊情况的话，请尽量使用 <a href="http://pythonguidecn.readthedocs.io/zh/latest/writing/documentation.html#sphinx-ref" target="_blank" rel="noopener">Sphinx</a>。</p><p><a href="https://pycco-docs.github.io/pycco/" target="_blank" rel="noopener">Pycco</a></p><p>Pycco是一个 “文学编程风格的文档生成器”，它是 node.js <a href="http://jashkenas.github.com/docco" target="_blank" rel="noopener">Docco</a> 的移植版本。它将代码生成为一个并排的 HTML 代码区块和对应的文档。</p><p><a href="https://github.com/rtomayko/ronn" target="_blank" rel="noopener">Ronn</a></p><p>Ronn 用来构建 Unix 手册。它将人可读的文本文件转换成用于终端显示的 roff 文件, 以及用于 web 的 HTML 文件。</p><p><a href="http://epydoc.sourceforge.net/" target="_blank" rel="noopener">Epydoc</a></p><p>Epydoc 已经停止维护。请使用 <a href="http://pythonguidecn.readthedocs.io/zh/latest/writing/documentation.html#sphinx-ref" target="_blank" rel="noopener">Sphinx</a> 来替代。</p><p><a href="http://www.mkdocs.org/" target="_blank" rel="noopener">MkDocs</a></p><p>MkDocs 是一个快速简单的静态网站生成器，它适合于构建使用 Markdown 编写的项目文档。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可读性是 Python 开发人员在项目和代码文档中的主要关注点。遵循一些简单的最佳实践可以为您和其他人节省大量时间。&lt;/p&gt;
&lt;h2 id=&quot;项目文档&quot;&gt;&lt;a href=&quot;#项目文档&quot; class=&quot;headerlink&quot; title=&quot;项目文档&quot;&gt;&lt;/a&gt;项目文档&lt;/h2
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-Reading Great Code</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-Reading-Great-Code/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-Reading-Great-Code/</id>
    <published>2018-09-15T04:38:30.150Z</published>
    <updated>2018-09-15T09:43:19.250Z</updated>
    
    <content type="html"><![CDATA[<p>Python 设计背后的核心原则之一就是创建可读的代码。这个设计背后的动机很简单： Python 程序员所做的第一件事就是阅读代码。</p><p>成为一个著名的 Python 程序猿的秘诀之一就是阅读，理解和理解优秀的代码。</p><p>优秀的代码通常遵循 <a href="http://docs.python-guide.org/en/latest/writing/style/#code-style" target="_blank" rel="noopener">Code Style</a> 中概述的指导方针，并想读者表达清晰简洁的意图。</p><p>下面是一些推荐的 Python 项目供读者参阅。这些项目中每一项都是 Python 编码的一个典范。</p><ul><li><a href="https://github.com/gleitz/howdoi" target="_blank" rel="noopener">Howdoi</a> Howdoi 使用 Python 实现的代码搜索工具。</li><li><a href="https://github.com/mitsuhiko/flask" target="_blank" rel="noopener">Flask</a> Flask 是基于 Werkzeug and Jinja2 的 Python 微框架。 它的目的是快速入门并开发实现你头脑中的好主意。</li><li><a href="https://github.com/python-diamond/Diamond" target="_blank" rel="noopener">Diamond</a> Diamond 是使用 python 实现的用于收集监控数据的工具，主要收集 metrics 类型的数据，并将其发布到 Graphite 或其他后台。它能够收集 cpu ， 内存， 网络， i/o ，负载和磁盘 metrics 数据。此外，它还提供 API 用以实现自定义收集器从任意来源中收集指标数据。</li><li><a href="https://github.com/mitsuhiko/werkzeug" target="_blank" rel="noopener">Werkzeug</a> Werkzeug 最初是 WSGI 应用程序的各种实用工具的简单集合，并已成为最先进的 WSGI 实用程序模块之一。它包括强大的调试器、功能齐全的请求和响应对象、处理实体标记的 HTTP 实用程序、缓存控制头、HTTP 日期、cookie 处理、文件上传、强大的 URL 路由系统和一群社区贡献的插件模块。</li><li><a href="https://github.com/kennethreitz/requests" target="_blank" rel="noopener">Requests</a> Requests 是一个用 Python 实现的 Apache2 授权的 HTTP 库供大家使用。</li><li><a href="https://github.com/kennethreitz/tablib" target="_blank" rel="noopener">Tablib</a> Tablib 是用 Python 实现的无格式的表格数据集库。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python 设计背后的核心原则之一就是创建可读的代码。这个设计背后的动机很简单： Python 程序员所做的第一件事就是阅读代码。&lt;/p&gt;
&lt;p&gt;成为一个著名的 Python 程序猿的秘诀之一就是阅读，理解和理解优秀的代码。&lt;/p&gt;
&lt;p&gt;优秀的代码通常遵循 &lt;a hre
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-Code Style</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-Code-Style/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-Code-Style/</id>
    <published>2018-09-15T04:38:05.984Z</published>
    <updated>2018-09-15T09:43:15.538Z</updated>
    
    <content type="html"><![CDATA[<p>如果有人问起 Python 程序员他们最喜欢 Python 哪一点，他们一定会提到 Python 的高可读性。确实，对于 Python 来说，其高可读性一直是 Python 这门语言设计的核心。一个不争的事实是，相对于写代码而言，读代码才是更加平常的事情。</p><p>Python 代码有高可读性的一个原因就是其有着相对而言更加完善的编码风格准则和 「Python化」习语。</p><p>当 Python 老手（Pythonista）认为一段代码不「Python化」，他们通常的意思是这段代码没有遵循一般准则，同时亦没有以最佳的（最具可读性的）方式表达出代码的意图。</p><p>在一些极端的情况下，没有公认最佳的方式来表达 Python 代码的意图，不过这种极端情况非常罕见。</p><h2 id="一般概念"><a href="#一般概念" class="headerlink" title="一般概念"></a>一般概念</h2><h3 id="明确代码意义"><a href="#明确代码意义" class="headerlink" title="明确代码意义"></a>明确代码意义</h3><p>尽管 Python 可以写出从各种意义上来说都像是黑魔法的代码，但最简单直白的表达才是正道。</p><p><strong>不好</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def make_complex(*args):</span><br><span class="line">    x, y = args</span><br><span class="line">    <span class="keyword">return</span> dict(**locals())</span><br></pre></td></tr></table></figure><p><strong>好</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def make_complex(x, y):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'x'</span>: x, <span class="string">'y'</span>: y&#125;</span><br></pre></td></tr></table></figure><p>在上述好的代码中，x 和 y 清晰明了的从参数中获取值，并清晰明了的返回了一个字典。当开发者看到这个函数后就可以明了这个函数的用途，而不好的代码则不行。</p><h3 id="一行一个声明语句"><a href="#一行一个声明语句" class="headerlink" title="一行一个声明语句"></a>一行一个声明语句</h3><p>虽然在 Python 中我们推崇使用形如列表生成式这种简洁明了的复合语句，但是除此以外，我们应该尽量避免将两句独立分割的代码写在同一行。</p><p><strong>不好的风格</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">'one'</span>; <span class="keyword">print</span> <span class="string">'two'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x == <span class="number">1</span>: <span class="keyword">print</span> <span class="string">'one'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> &lt;complex comparison&gt; <span class="keyword">and</span> &lt;other complex comparison&gt;:</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure><p><strong>好的风格</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">'one'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'two'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'one'</span></span><br><span class="line"></span><br><span class="line">cond1 = &lt;complex comparison&gt;</span><br><span class="line">cond2 = &lt;other complex comparison&gt;</span><br><span class="line"><span class="keyword">if</span> cond1 <span class="keyword">and</span> cond2:</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>函数的参数可以使用四种不同的方式传递给函数。</p><ol><li><strong>必选参数</strong> 是没有默认值的必填的参数。 必选参数是最简单的参数构成，用于参数较少的函数的构成，是该函数意义的一部分，使用他们的顺序是按照定义自然排序的。举个例子，对于 <code>send(message, recipient)</code> 和  <code>point(x, y)</code> 这两个函数，使用函数的人需要知道这个函数需要两个参数，并且记住两个参数的顺序。</li></ol><p>在调用函数的时候，我们也可以使用参数的名称调用。使用参数的名称的方式可以调换参数的顺序，就像 <code>send(recipient=&#39;World&#39;,message=&#39;Hello&#39;)</code> 和 <code>point(y=2, x=1)</code> 这样。但这样的做法会降低代码的可读性，并且使代码冗长，因此更建议使用 <code>send(&#39;Hello&#39;, &#39;World&#39;)</code> 和<code>point(1,2)</code> 这样的方式调用。</p><ol><li><strong>关键字参数</strong> 是非强制的，且有默认值。它们经常被用在传递给函数的可选参数中。 当一个函数有超过两个或三个位置参数时，函数签名会变得难以记忆，使用带有默认参数的关键字参数有时候会给你带来便利。比如，一个更完整的 <code>send</code> 函数可以被定义为<code>send(message, to, cc=None, bcc=None)</code>。这里的 <code>cc</code> 和 <code>bcc</code> 是可选的， 当没有传递给它们其他值的时候，它们的值就是 None。</li></ol><p>Python 中有多种方式调用带关键字参数的函数。比如说，我们可以按照定义时的参数顺序而无需明确的命名参数来调用函数，就像 <code>send(&#39;Hello&#39;, &#39;World&#39;, &#39;Cthulhu&#39;, &#39;God&#39;)</code> 是将密件发送给上帝。我们也可以使用命名参数而无需遵循参数顺序来调用函数，就像<code>send(&#39;Hello again&#39;, &#39;World&#39;, bcc=&#39;God&#39;, cc=&#39;Cthulhu&#39;)</code> 。没有特殊情况的话，这两种方式都需要尽力避免，最优的调用方式是与定义方式一致：<code>send(&#39;Hello&#39;, &#39;World&#39;, cc=&#39;Cthulhu&#39;,bcc=&#39;God&#39;)</code> 。</p><p>作为附注，请遵循 <a href="http://en.wikipedia.org/wiki/You_ain&#39;t_gonna_need_it" target="_blank" rel="noopener">YAGNI</a> 原则。 通常，移除一个用作『以防万一』但从未使用的可选参数（以及它在函数中的逻辑），比添加一个所需的新的可选参数和它的逻辑要来的困难。</p><ol><li><strong>任意参数列表</strong> 是第三种给函数传参的方式。如果函数的参数数量是动态的，该函数可以被定义成 <code>*args</code> 的结构。在这个函数体中， <code>args</code> 是一个元组，它包含所有剩余的位置参数。举个例子， 我们可以用任何容器作为参数去调用 <code>send(message, *args)</code> ，比如 <code>send(&#39;Hello&#39;, &#39;God&#39;, &#39;Mom&#39;,&#39;Cthulhu&#39;)</code>。 在此函数体中， <code>args</code> 相当于 <code>(&#39;God&#39;,&#39;Mom&#39;, &#39;Cthulhu&#39;)</code>。</li></ol><p>然而，这种结构有一些缺点，使用时应该特别注意。如果一个函数接受的参数列表具有相同的性质，通常把它定义成一个参数，这个参数是一个列表或者其他任何序列会更清晰。 在这里，如果 <code>send</code> 参数有多个容器（recipients），将之定义成 <code>send(message,recipients)</code> 会更明确，调用它时就使用 <code>send(&#39;Hello&#39;, [&#39;God&#39;, &#39;Mom&#39;, &#39;Cthulhu&#39;])</code>。这样的话， 函数的使用者可以事先将容器列表维护成列表（list）形式，这为传递各种不能被转变成其他序列的序列（包括迭代器）带来了可能。</p><ol><li><strong>任意关键字参数字典</strong> 是最后一种给函数传参的方式。如果函数要求一系列待定的命名参数，我们可以使用 <code>**kwargs</code> 的结构。在函数体中， <code>kwargs</code> 是一个字典，它包含所有传递给函数但没有被其他关键字参数捕捉的命名参数。</li></ol><p>和 <strong>任意参数列表</strong> 中所需注意的一样，相似的原因是：这些强大的技术在非特殊情况下，都要尽量避免使用，因为其缺乏简单和明确的结构来足够表达函数意图。</p><p>编写函数的时候采用何种参数形式，是用位置参数，还是可选关键字参数，是否使用形如任意参数 的高级技术，这些都由程序员自己决定。如果能明智地遵循上述建议，即可轻松写出这样的 Python 函数：</p><ul><li>易读（名字和参数无需解释）</li><li>易改（添加新的关键字参数不会破坏代码的其他部分）</li></ul><h3 id="避免魔法方法"><a href="#避免魔法方法" class="headerlink" title="避免魔法方法"></a>避免魔法方法</h3><p>Python 对骇客来说是一个强有力的工具，它拥有非常丰富的钩子（hook）和工具，允许你施展几乎任何形式的技巧。比如说，它能够做以下：</p><ul><li>改变对象创建和实例化的方式；</li><li>改变 Python 解释器导入模块的方式；</li><li>甚至可能（如果需要的话也是被推荐的）在 Python 中嵌入 C 程序。</li></ul><p>尽管如此，所有的这些选择都有许多缺点。使用最直接的方式来达成目标通常是最好的方法。它们最主要的缺点是可读性不高。许多代码分析工具，比如说 pylint 或者 pyflakes，将无法解析这种『魔法』代码。</p><p>我们认为 Python 开发者应该知道这些近乎无限的可能性，因为它为我们灌输了没有不可能完成的任务的信心。然而，知道何时 <strong>不能</strong> 使用它们也是非常重要的。</p><p>就像一位功夫大师，一个 Pythonista 知道如何用一个手指杀死对方，但从不会那么去做。</p><h3 id="我们都是负责任的用户"><a href="#我们都是负责任的用户" class="headerlink" title="我们都是负责任的用户"></a>我们都是负责任的用户</h3><p>如前所述，Python 允许很多技巧，其中一些具有潜在的危险。一个好的例子是：任何客户端代码能够重写一个对象的属性和方法（Python 中没有 <code>private</code> 关键字）。这种哲学是在说：『我们都是负责任的用户』，它和高度防御性的语言（如 Java，拥有很多机制来预防错误操作）有着非常大的不同。</p><p>这并不意味着，比如说，Python 中没有属性是私有的，也不意味着没有合适的封装方法。 与其依赖在开发者的代码之间树立起的一道道隔墙，Python 社区更愿意依靠一组约定，来表明这些元素不应该被直接访问。</p><p>私有属性的主要约定和实现细节是在所有的 <strong>内部</strong> 变量前加一个下划线。如果客户端代码打破了这条规则并访问了带有下划线的变量，那么因内部代码的改变而出现的任何不当的行为或问题，都是客户端代码的责任。</p><p>鼓励大方地使用此约定：<strong>任何不开放给客户端代码使用的方法或属性，应该有一个下划线前缀</strong>。这将保证更好的职责划分以及更容易对已有代码进行修改。将一个私有属性公开化总是可能的，但是把一个公共属性私有化可能是一个更难的选择。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>当一个函数变得复杂，在函数体中使用多返回值的语句并不少见。然而，为了保持函数的可读性，建议在函数体中避免使用返回多个有意义的值。</p><p>在函数中返回结果主要有两种情况：函数正常运行并返回它的结果，以及错误的情况，要么因为一个错误的输入参数，要么因为其他导致函数无法完成计算或任务的原因。</p><p>如果你在面对第二种情况时不想抛出异常，返回一个值（比如说 None 或 False ）来表明函数无法正确运行，可能是需要的。在这种情况下，越早返回所发现的不正确上下文越好。 这将帮助扁平化函数的结构：我们假定在『因为错误而返回』的语句后的所有代码都能够满足函数主要结果运算。这种类型的多发挥结果，是有必要的。</p><p>然而，当一个函数在其正常运行过程中有多个主要出口点时，它会变得难以调试其返回结果，所以保持单个出口点可能会更好。这也将有助于提取某些代码路径，而且多个出口点很有可能意味着这里需要重构：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def complex_function(a, b, c):</span><br><span class="line">    <span class="keyword">if</span> not a:</span><br><span class="line">        <span class="keyword">return</span> None  <span class="comment"># 抛出一个异常可能会更好</span></span><br><span class="line">    <span class="keyword">if</span> not b:</span><br><span class="line">        <span class="keyword">return</span> None  <span class="comment"># 抛出一个异常可能会更好</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一些复杂的代码试着用 a,b,c 来计算x</span></span><br><span class="line">    <span class="comment"># 如果成功了，抵制住返回 x 的诱惑</span></span><br><span class="line">    <span class="keyword">if</span> not x:</span><br><span class="line">        <span class="comment"># 使用其他的方法来计算出 x</span></span><br><span class="line">    <span class="keyword">return</span> x  <span class="comment"># 返回值 x 只有一个出口点有利于维护代码</span></span><br></pre></td></tr></table></figure><h2 id="习语（Idiom）"><a href="#习语（Idiom）" class="headerlink" title="习语（Idiom）"></a>习语（Idiom）</h2><p>编程习语，说得简单些，就是写代码的 <strong>方式</strong>。编程习语的概念在 <a href="http://c2.com/cgi/wiki?ProgrammingIdiom" target="_blank" rel="noopener">c2</a> 和 <a href="http://stackoverflow.com/questions/302459/what-is-a-programming-idiom" target="_blank" rel="noopener">Stack Overflow</a> 上有详尽的讨论。</p><p>符合习语的 Python 代码通常被称为 <strong>Pythonic</strong>。</p><p>通常只有一种、而且最好只有一种明显的方式去编写代码。对 Python 初学者来说，无意识的情况下很少能写出习语式 Python 代码，所以应该有意识地去获取习语的书写方式。</p><p>如下有一些常见的Python习语：</p><h3 id="解包（Unpacking）"><a href="#解包（Unpacking）" class="headerlink" title="解包（Unpacking）"></a>解包（Unpacking）</h3><p>如果你知道一个列表或者元组的长度，你可以将其解包并为它的元素取名。比如，<code>enumerate()</code> 会对 list 中的每个项提供包含两个元素的元组：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, item in enumerate(some_list):</span><br><span class="line">    <span class="comment"># do something with index and item</span></span><br></pre></td></tr></table></figure><p>你也能通过这种方式交换变量：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure><p>嵌套解包也能工作：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, (b, c) = <span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>Python 3 提供了扩展解包的新方法在 <a href="https://www.python.org/dev/peps/pep-3132" target="_blank" rel="noopener"><strong>PEP 3132</strong></a> 有介绍：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a, *rest = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># a = 1, rest = [2, 3]</span></span><br><span class="line">a, *middle, c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment"># a = 1, middle = [2, 3], c = 4</span></span><br></pre></td></tr></table></figure><h3 id="创建一个被忽略的变量"><a href="#创建一个被忽略的变量" class="headerlink" title="创建一个被忽略的变量"></a>创建一个被忽略的变量</h3><p>如果你需要赋值（比如，在 <a href="http://pythonguidecn.readthedocs.io/zh/latest/writing/style.html#unpacking-ref" target="_blank" rel="noopener">解包（Unpacking）</a> ）但不需要这个变量，请使用 <code>__</code>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'foobar.txt'</span></span><br><span class="line">basename, __, ext = filename.rpartition(<span class="string">'.'</span>)</span><br></pre></td></tr></table></figure><blockquote><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>许多 Python 风格指南建议使用单下划线的 <code>_</code> 而不是这里推荐的双下划线 <code>__</code> 来标记废弃变量。问题是， <code>_</code> 常用在作为 <a href="http://docs.python.org/library/gettext.html#gettext.gettext" target="_blank" rel="noopener"><code>gettext()</code></a> 函数的别名，也被用在交互式命令行中记录最后一次操作的值。相反，使用双下划线 十分清晰和方便，而且能够消除使用其他这些用例所带来的意外干扰的风险。</p></blockquote><h3 id="创建一个含-N-个对象的列表"><a href="#创建一个含-N-个对象的列表" class="headerlink" title="创建一个含 N 个对象的列表"></a>创建一个含 N 个对象的列表</h3><p>使用 Python 列表中的 <code>*</code> 操作符：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">four_nones = [None] * <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="创建一个含-N-个列表的列表"><a href="#创建一个含-N-个列表的列表" class="headerlink" title="创建一个含 N 个列表的列表"></a>创建一个含 N 个列表的列表</h3><p>因为列表是可变的，所以 <code>*</code> 操作符（如上）将会创建一个包含 N 个且指向 <strong>同一个</strong> 列表的列表，这可能不是你想用的。取而代之，请使用列表解析：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">four_lists = [[] <span class="keyword">for</span> __ in xrange(<span class="number">4</span>)]</span><br></pre></td></tr></table></figure><p>注意：在 Python 3 中使用 <code>range()</code> 而不是 <code>xrange()</code>。</p><h3 id="根据列表来创建字符串"><a href="#根据列表来创建字符串" class="headerlink" title="根据列表来创建字符串"></a>根据列表来创建字符串</h3><p>创建字符串的一个常见习语是在空的字符串上使用 <a href="http://docs.python.org/library/stdtypes.html#str.join" target="_blank" rel="noopener"><code>str.join()</code></a> ：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">letters = [<span class="string">'s'</span>, <span class="string">'p'</span>, <span class="string">'a'</span>, <span class="string">'m'</span>]</span><br><span class="line">word = <span class="string">''</span>.join(letters)</span><br></pre></td></tr></table></figure><p>这会将 <strong>word</strong> 变量赋值为 <code>spam</code>。这个习语可以用在列表和元组中。</p><h3 id="在集合体（collection）中查找一个项"><a href="#在集合体（collection）中查找一个项" class="headerlink" title="在集合体（collection）中查找一个项"></a>在集合体（collection）中查找一个项</h3><p>有时我们需要在集合体中查找。让我们看看这两个选择，列表和集合（set），用如下代码举个例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="string">'s'</span>, <span class="string">'p'</span>, <span class="string">'a'</span>, <span class="string">'m'</span>])</span><br><span class="line">l = [<span class="string">'s'</span>, <span class="string">'p'</span>, <span class="string">'a'</span>, <span class="string">'m'</span>]</span><br><span class="line"></span><br><span class="line">def lookup_set(s):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'s'</span> in s</span><br><span class="line"></span><br><span class="line">def lookup_list(l):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'s'</span> in l</span><br></pre></td></tr></table></figure><p>即使两个函数看起来完全一样，但因为 <strong>查找集合</strong> 是利用了 Python 中的『集合是可哈希』的特性，两者的查询性能是非常不同的。为了判断一个项是否在列表中，Python 将会查看每个项直到它找到匹配的项。这是耗时的任务，尤其是对长列表而言。另一方面，在集合中， 项的哈希值将会告诉 Python 在集合的哪里去查找匹配的项。结果是，即使集合很大，查询的速度也很快。在字典中查询也是同样的原理。想了解更多内容，请见 <a href="http://stackoverflow.com/questions/513882/python-list-vs-dict-for-look-up-table" target="_blank" rel="noopener">StackOverflow</a> 。想了解在每种数据结构上的多种常见操作的花费时间的详细内容， 请见 <a href="https://wiki.python.org/moin/TimeComplexity?" target="_blank" rel="noopener">此页面</a>。</p><p>因为这些性能上的差异，在下列场景中，使用集合或者字典而不是列表，通常会是个好主意：</p><ul><li>集合体中包含大量的项；</li><li>你将在集合体中重复地查找项；</li><li>你没有重复的项。</li></ul><p>对于小的集合体、或者你不会频繁查找的集合体，建立哈希带来的额外时间和内存的开销经常会大过改进搜索速度所节省的时间。</p><h2 id="Python之禅"><a href="#Python之禅" class="headerlink" title="Python之禅"></a>Python之禅</h2><p>又名 <a href="https://www.python.org/dev/peps/pep-0020" target="_blank" rel="noopener"><strong>PEP 20</strong></a>, 是 Python 设计的指导原则。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="string">'t special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you'</span>re Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line"><span class="keyword">If</span> the implementation is hard to explain, it<span class="string">'s a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let'</span>s <span class="keyword">do</span> more of those!</span><br><span class="line"></span><br><span class="line">Python之禅 by Tim Peters</span><br><span class="line"></span><br><span class="line">优美胜于丑陋（Python 以编写优美的代码为目标）</span><br><span class="line">明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）</span><br><span class="line">简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）</span><br><span class="line">复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）</span><br><span class="line">扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）</span><br><span class="line">间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）</span><br><span class="line">可读性很重要（优美的代码是具备高可读性的）</span><br><span class="line">即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）</span><br><span class="line">不要包容所有错误，除非您确定需要这样做（精准地捕获异常，不写 `except:pass` 风格的代码）</span><br><span class="line">当存在多种可能，不要尝试去猜测</span><br><span class="line">而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）</span><br><span class="line">虽然这并不容易，因为您不是 Python 之父（这里的 Dutch 是指 Guido ）</span><br><span class="line">做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）</span><br><span class="line">如果您无法向人描述您的方案，那肯定不是一个好方案；反之亦然（方案测评标准）</span><br><span class="line">命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）</span><br></pre></td></tr></table></figure><p>想要了解一些 Python 优雅风格的例子，请见 <a href="http://artifex.org/~hblanks/talks/2011/pep20_by_example.pdf" target="_blank" rel="noopener">这些来自于 Python 用户的幻灯片</a>。</p><h2 id="PEP-8"><a href="#PEP-8" class="headerlink" title="PEP 8"></a>PEP 8</h2><p><a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener"><strong>PEP 8</strong></a> 是 Python 实际意义上的代码风格指南，我们可以在 <a href="http://pep8.org/" target="_blank" rel="noopener">pep8.org</a> 上获得高质量的、可读性更高的 PEP 8 版本。</p><p>强烈推荐阅读这部分。整个 Python 社区都尽力遵循本文档中规定的准则。这其中，一些项目可能受其影响， 而其他项目可能 <a href="http://docs.python-equests.org/en/master/dev/contributing/kenneth-reitz-s-code-style" target="_blank" rel="noopener">修改其建议</a>。</p><p>也就是说，让你的 Python 代码遵循 PEP 8 通常是个好主意，这也有助于在与其他开发人员 一起工作时使代码更加具一致性。命令行程序 pycodestyle <a href="https://github.com/PyCQA/pycodestyle" target="_blank" rel="noopener">https://github.com/PyCQA/pycodestyle</a> （以前叫做<code>pep8</code>），可以检查代码一致性。在你的终端上运行以下命令来安装它：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pycodestyle</span><br></pre></td></tr></table></figure><p>然后，对一个文件或者一系列的文件运行它，来获得任何违规行为的报告：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ pycodestyle optparse.py</span><br><span class="line">optparse.py:<span class="number">69</span>:<span class="number">11</span>: E401 multiple imports on one line</span><br><span class="line">optparse.py:<span class="number">77</span>:<span class="number">1</span>: E302 expected <span class="number">2</span> blank lines, found <span class="number">1</span></span><br><span class="line">optparse.py:<span class="number">88</span>:<span class="number">5</span>: E301 expected <span class="number">1</span> blank line, found <span class="number">0</span></span><br><span class="line">optparse.py:<span class="number">222</span>:<span class="number">34</span>: W602 deprecated form of raising <span class="keyword">exception</span></span><br><span class="line">optparse.py:<span class="number">347</span>:<span class="number">31</span>: E211 whitespace before <span class="string">'('</span></span><br><span class="line">optparse.py:<span class="number">357</span>:<span class="number">17</span>: E201 whitespace after <span class="string">'&#123;'</span></span><br><span class="line">optparse.py:<span class="number">472</span>:<span class="number">29</span>: E221 multiple spaces before operator</span><br><span class="line">optparse.py:<span class="number">544</span>:<span class="number">21</span>: W601 .has_key() is deprecated, <span class="keyword">use</span> '<span class="title">in</span>'</span><br></pre></td></tr></table></figure><p>程序 <a href="https://pypi.python.org/pypi/autopep8/" target="_blank" rel="noopener">autopep8</a> 能自动将代码格式化成 PEP 8 风格。用以下指令安装此程序：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install autopep8</span><br></pre></td></tr></table></figure><p>用以下指令格式化一个文件：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ autopep8 --in-place optparse.py</span><br></pre></td></tr></table></figure><p>不包含 <code>--in-place</code> 标志将会使得程序直接将更改的代码输出到控制台，以供审查。 <code>--aggressive</code> 标志则会执行更多实质性的变化，而且可以多次使用以达到更佳的效果。</p><h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>这里有一些你应该遵循的约定，以让你的代码更加易读。</p><h3 id="检查变量是否等于常量"><a href="#检查变量是否等于常量" class="headerlink" title="检查变量是否等于常量"></a>检查变量是否等于常量</h3><p>你不需要明确地比较一个值是 True，或者 None，或者 0 - 你可以仅仅把它放在 <code>if</code> 语句中。 参阅 <a href="http://docs.python.org/library/stdtypes.html#truth-value-testing" target="_blank" rel="noopener">真值测试</a> 来了解什么被认为是 false：</p><p><strong>糟糕</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> attr == <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'True!'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> attr == None:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'attr is None!'</span></span><br></pre></td></tr></table></figure><p><strong>优雅</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查值</span></span><br><span class="line"><span class="keyword">if</span> attr:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'attr is truthy!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者做相反的检查</span></span><br><span class="line"><span class="keyword">if</span> not attr:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'attr is falsey!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者，None 等于 false，你可以直接相较它进行匹配</span></span><br><span class="line"><span class="keyword">if</span> attr is None:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'attr is None!'</span></span><br></pre></td></tr></table></figure><h3 id="访问字典元素"><a href="#访问字典元素" class="headerlink" title="访问字典元素"></a>访问字典元素</h3><p>不要使用 <code>dict.has_key()</code>方法。 相反，使用 <code>x in d</code> 语法，或者将默认参数传递给 <a href="http://docs.python.org/library/stdtypes.html#dict.get" target="_blank" rel="noopener"><code>dict.get()</code></a> 方法。</p><p><strong>坏的示例</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'hello'</span>: <span class="string">'world'</span>&#125;</span><br><span class="line"><span class="keyword">if</span> d.has_key(<span class="string">'hello'</span>):</span><br><span class="line">    <span class="keyword">print</span> d[<span class="string">'hello'</span>]    <span class="comment"># prints 'world'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'default_value'</span></span><br></pre></td></tr></table></figure><p><strong>推荐的示例</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'hello'</span>: <span class="string">'world'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> d.get(<span class="string">'hello'</span>, <span class="string">'default_value'</span>) <span class="comment"># prints 'world'</span></span><br><span class="line"><span class="keyword">print</span> d.get(<span class="string">'thingy'</span>, <span class="string">'default_value'</span>) <span class="comment"># prints 'default_value'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者:</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'hello'</span> in d:</span><br><span class="line">    <span class="keyword">print</span> d[<span class="string">'hello'</span>]</span><br></pre></td></tr></table></figure><h3 id="操作列表的简便方法"><a href="#操作列表的简便方法" class="headerlink" title="操作列表的简便方法"></a>操作列表的简便方法</h3><p><a href="http://docs.python.org/tutorial/datastructures.html#list-comprehensions" target="_blank" rel="noopener">列表推导式</a> 提供了一个强大并且简洁的方法来对列表价进行操作。除此之外，<a href="http://docs.python.org/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a> 和 <a href="http://docs.python.org/library/functions.html#filter" target="_blank" rel="noopener"><code>filter()</code></a>  函数在列表的操作上也是非常简洁的。</p><p><strong>坏</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Filter elements greater than 4</span></span><br><span class="line">a = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b = []</span><br><span class="line"><span class="keyword">for</span> i in a:</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">4</span>:</span><br><span class="line">        b.append(i)</span><br></pre></td></tr></table></figure><p><strong>好</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b = [i <span class="keyword">for</span> i in a <span class="keyword">if</span> i &gt; <span class="number">4</span>]</span><br><span class="line"><span class="comment"># Or:</span></span><br><span class="line">b = filter(lambda x: x &gt; <span class="number">4</span>, a)</span><br></pre></td></tr></table></figure><p><strong>坏</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add three to all list members.</span></span><br><span class="line">a = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i in range(len(a)):</span><br><span class="line">    a[i] += <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>好</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">a = [i + <span class="number">3</span> <span class="keyword">for</span> i in a]</span><br><span class="line"><span class="comment"># Or:</span></span><br><span class="line">a = map(lambda i: i + <span class="number">3</span>, a)</span><br></pre></td></tr></table></figure><p>使用 <a href="http://docs.python.org/library/functions.html#enumerate" target="_blank" rel="noopener"><code>enumerate()</code></a> 来跟踪正在被处理的元素索引。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i, item in enumerate(a):</span><br><span class="line">    <span class="keyword">print</span> i, item</span><br><span class="line"><span class="comment"># prints</span></span><br><span class="line"><span class="comment"># 0 3</span></span><br><span class="line"><span class="comment"># 1 4</span></span><br><span class="line"><span class="comment"># 2 5</span></span><br></pre></td></tr></table></figure><p>比起手动计数，使用<a href="http://docs.python.org/library/functions.html#enumerate" target="_blank" rel="noopener"><code>enumerate()</code></a> 函数有更好的可读性，而且，他更加适合在迭代器中使用。</p><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>使用 <code>with open</code> 语法来读文件，它能够为你自动关闭文件。</p><p><strong>坏</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'file.txt'</span>)</span><br><span class="line">a = f.read()</span><br><span class="line"><span class="keyword">print</span> a</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p><strong>好</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(<span class="string">'file.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line in f:</span><br><span class="line">        <span class="keyword">print</span> line</span><br></pre></td></tr></table></figure><p>即使在 <code>with</code> 控制块中出现了异常，它也能确保你关闭了文件，因此，使用 <code>with</code> 语法是更加优雅的。</p><h3 id="行的延续"><a href="#行的延续" class="headerlink" title="行的延续"></a>行的延续</h3><p>当一个代码逻辑行的长度超过可接受的限度时，你需要将之分为多个物理行。如果行的结尾是一个反斜杠，Python 解释器会把这些连续行拼接在一起。这在某些情况下很有帮助， 但我们总是应该避免使用，因为它的脆弱性：如果在行的结尾，在反斜杠后加了空格，这会破坏代码，而且可能有意想不到的结果。</p><p>一个更好的解决方案是在元素周围使用括号。左边以一个未闭合的括号开头，Python 解释器会把行的结尾和下一行连接起来直到遇到闭合的括号。同样的行为适用中括号和大括号。</p><p><strong>糟糕</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_very_big_string = <span class="string">"""For a long time I used to go to bed early. Sometimes,\</span></span><br><span class="line"><span class="string">    when I had put out my candle, my eyes would close so quickly that I had not even\</span></span><br><span class="line"><span class="string">    time to say "I'm going to sleep."""</span><span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">from some.deep.module.inside.a.module import a_nice_function, another_nice_function,\</span></span><br><span class="line"><span class="string">    yet_another_nice_function</span></span><br></pre></td></tr></table></figure><p><strong>优雅</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_very_big_string = (</span><br><span class="line">    <span class="string">"For a long time I used to go to bed early. Sometimes, "</span></span><br><span class="line">    <span class="string">"when I had put out my candle, my eyes would close so quickly "</span></span><br><span class="line">    <span class="string">"that I had not even time to say "</span>I<span class="string">'m going to sleep.""</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">from some.deep.module.inside.a.module import (</span></span><br><span class="line"><span class="string">    a_nice_function, another_nice_function, yet_another_nice_function)</span></span><br></pre></td></tr></table></figure><p>尽管如此，通常情况下，必须去分割一个长逻辑行意味着你同时想做太多的事，这可能影响可读性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果有人问起 Python 程序员他们最喜欢 Python 哪一点，他们一定会提到 Python 的高可读性。确实，对于 Python 来说，其高可读性一直是 Python 这门语言设计的核心。一个不争的事实是，相对于写代码而言，读代码才是更加平常的事情。&lt;/p&gt;
&lt;p&gt;P
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-代码结构</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-代码结构/</id>
    <published>2018-09-15T04:28:12.303Z</published>
    <updated>2018-09-15T09:43:00.539Z</updated>
    
    <content type="html"><![CDATA[<p>这里我们所说的「结构」就是关于如何让项目达到预期的目标。我们需要考虑的是如何更好的利用 Python 的特性创造出干净、有效的代码。实际上，「结构」意味着代码的结构、依赖非常的清晰，像文件系统中的文件和文件夹一样。</p><p>哪些函数应该放在哪个模块中？项目中的数据流是怎样的？哪些函数应该组织在一起或者分离开？从广义上讲，通过回答这些问题，你就可以开始规划你的项目长什么样子。</p><p>在本节中，我们将深入研究 Python 的模块和导入系统，因为它们是项目结构中的核心元素。然后我们将探讨如何构建可扩展易测试的代码结构的各种观点。</p><h2 id="仓库结构"><a href="#仓库结构" class="headerlink" title="仓库结构"></a>仓库结构</h2><h3 id="That-is-important"><a href="#That-is-important" class="headerlink" title="That is important!"></a>That is important!</h3><p>就像代码风格，API 设计和自动化对于健康的开发周期是必不可少的，仓库结构也是项目<a href="http://www.amazon.com/gp/product/1257638017/ref=as_li_ss_tl?ie=UTF8&amp;tag=bookforkind-20&amp;linkCode=as2&amp;camp=1789&amp;creative=39095&amp;creativeASIN=1257638017" target="_blank" rel="noopener">体系结构</a>中的重要组成部分。</p><p>当一个潜在用户或贡献者打开你的仓库页面，他们将看到：</p><ul><li>项目名称</li><li>项目描述</li><li>大堆的文件</li></ul><p>只有当他们在下滑滚动时，才能看到项目里的自述文档。</p><p>如果你的仓库包含了大量的垃圾文件或者混乱嵌套的目录结构，即使有漂亮的自述文档，用户也可能尚未看到就前往查看其他项目了。</p><blockquote><p>为你想要的工作而装扮，而不是你现在做的工作而装扮。</p></blockquote><p>当然，第一印象并不代表全部。你和你的同事可能花费数个小时在这个仓库中，最终对每个细节都非常熟悉。它的布局很重要。</p><h3 id="简单的仓库"><a href="#简单的仓库" class="headerlink" title="简单的仓库"></a>简单的仓库</h3><p><strong>简述</strong>: 这个仓库是  <a href="http://kennethreitz.org/" target="_blank" rel="noopener">Kenneth Reitz</a>  的建议。</p><p>可以在 <a href="https://github.com/kennethreitz/samplemod" target="_blank" rel="noopener">GitHub</a> 上看到。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">README.rst</span><br><span class="line">LICENSE</span><br><span class="line">setup.py</span><br><span class="line">requirements.txt</span><br><span class="line">sample/__init__.py</span><br><span class="line">sample/core.py</span><br><span class="line">sample/helpers.py</span><br><span class="line">docs/conf.py</span><br><span class="line">docs/index.rst</span><br><span class="line">tests/test_basic.py</span><br><span class="line">tests/test_advanced.py</span><br></pre></td></tr></table></figure><p>让我们深入了解一些细节。</p><h3 id="具体模块"><a href="#具体模块" class="headerlink" title="具体模块"></a>具体模块</h3><table><thead><tr><th>位置</th><th><code>./sample/</code> 或 <code>./sample.py</code></th></tr></thead><tbody><tr><td>目的</td><td>具体代码</td></tr></tbody></table><p>模块包是仓库的核心。它不应该被藏起来：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sample/</span><br></pre></td></tr></table></figure><p>如果你的模块内只有一个文件，你可以直接把这个文件放在仓库的根目录下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sample.py</span><br></pre></td></tr></table></figure><p>你的模块不应属于一个模糊的 src 目录或 python 的子目录。</p><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><table><thead><tr><th>位置</th><th><code>./LICENSE</code></th></tr></thead><tbody><tr><td>目的</td><td>法律相关</td></tr></tbody></table><p>除了源码本身外，这可以说是仓库中最重要的部分。在这个文件中应该包含完整的许可证文本和版权声明。</p><p>如果你不确定项目中应该使用哪种授权，请参考 <a href="http://choosealicense.com/" target="_blank" rel="noopener">choosealicense.com</a> 。</p><p>当然，你也可以发布不包含授权的代码，但这可能会让很多人不去使用你的代码。</p><h3 id="Setup-py"><a href="#Setup-py" class="headerlink" title="Setup.py"></a>Setup.py</h3><table><thead><tr><th>位置</th><th><code>./setup.py</code></th></tr></thead><tbody><tr><td>目的</td><td>包安装和分发管理</td></tr></tbody></table><p>如果你的模块包在仓库的根目录下，这个文件也应该位于根目录。</p><h3 id="依赖文件"><a href="#依赖文件" class="headerlink" title="依赖文件"></a>依赖文件</h3><table><thead><tr><th>位置</th><th><code>./requirements.txt</code></th></tr></thead><tbody><tr><td>目的</td><td>开发中的依赖</td></tr></tbody></table><p> <a href="https://pip.pypa.io/en/stable/user_guide/#requirements-files" target="_blank" rel="noopener">pip requirements file</a>  应该放置在仓库的根目录下。它应指出项目所需的依赖关系，包括测试、构建和生成文档过程中的。</p><p>如果该项目开发不需要依赖，或者你喜欢通过  <code>setup.py</code> 安装开发环境，这个文件可能不是必须的。</p><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><table><thead><tr><th>位置</th><th><code>./docs/</code></th></tr></thead><tbody><tr><td>目的</td><td>项目的参考文档</td></tr></tbody></table><p>没有理由把它放在其他地方。</p><h3 id="测试套件"><a href="#测试套件" class="headerlink" title="测试套件"></a>测试套件</h3><p><em>有关编写测试的建议，请参考</em>  <a href="http://docs.python-guide.org/en/latest/writing/tests/" target="_blank" rel="noopener"><em>Testing Your Code</em></a> 。</p><table><thead><tr><th>位置</th><th><code>./test_sample.py</code> 或 <code>./tests</code></th></tr></thead><tbody><tr><td>目的</td><td>软件包集成和单元测试</td></tr></tbody></table><p>开始时，一个小的测试套件经常在一个文件中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test_sample.py</span><br></pre></td></tr></table></figure><p>一旦测试套件多起来时，可以像这样把各套件放在一个文件夹中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tests/test_basic.py</span><br><span class="line">tests/test_advanced.py</span><br></pre></td></tr></table></figure><p>显然，这些测试套件需要你导入包模块才能运行测试。你可以通过这些方法来做：</p><ul><li>将包安装在 site-packages 中。</li><li>使用一个简单（但是<em>明确</em>）的路径去修正解决它。</li></ul><p>我强烈推荐后者。需要开发者在修改代码后主动运行 <code>setup.py develop</code> 去测试，也需要为每个代码库实例设置独立的运行环境。</p><p>要给单个测试导入上下文，请创建一个 tests/context.py 文件：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, os.path.abspath(os.path.join(os.path.dirname(<span class="keyword">__file__</span>), <span class="string">'..'</span>)))</span><br><span class="line"></span><br><span class="line">import sample</span><br></pre></td></tr></table></figure><p>然后，在各个测试模块中导入这个上下文模块：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from .context import sample</span><br></pre></td></tr></table></figure><p>无论安装方式如何，这通常都会像预期那样工作。</p><p>有的人会建议你应该把测试放在你自己的代码模块内，我不同意这个观点。这通常会增加用户的复杂性，而且许多的测试套件往往需要额外的依赖和运行时上下文。</p><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><table><thead><tr><th>位置</th><th><code>./Makefile</code></th></tr></thead><tbody><tr><td>目的</td><td>通用的管理任务。</td></tr></tbody></table><p>如果你看过我的大部分项目或任何 Pocoo 项目，你都会注意到有一个 Makefile 文件。 为什么？ 这些项目不是用 C 语言编写的… 简而言之， make 是一个定义项目通用任务的非常有用的工具。</p><p><strong>一个简单的 Makefile：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">init:</span><br><span class="line">    pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">    py.test tests</span><br><span class="line"></span><br><span class="line">.PHONY: init test</span><br></pre></td></tr></table></figure><p>其他通用的管理脚本（例如 <code>manage.py</code> 或 <code>fabfile.py</code> ）也应放在仓库的根目录。</p><h3 id="关于-Django-应用程序"><a href="#关于-Django-应用程序" class="headerlink" title="关于 Django 应用程序"></a>关于 Django 应用程序</h3><p>自从 Django 1.4发布以来，我注意到了 Django 应用程序的一个新趋势。 由于新的捆绑应用程序模板，许多开发人员构建其仓库的效果很差。</p><p>怎样做的呢？他们总是在一个新的仓库中运行以下内容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ django-admin.py startproject samplesite</span><br></pre></td></tr></table></figure><p>这样生成的仓库结构如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">README.rst</span><br><span class="line">samplesite/manage.py</span><br><span class="line">samplesite/samplesite/settings.py</span><br><span class="line">samplesite/samplesite/wsgi.py</span><br><span class="line">samplesite/samplesite/sampleapp/models.py</span><br></pre></td></tr></table></figure><p>不要这样做。</p><p>重复的路径会让你的工具和开发人员感到困惑。不必要的嵌套对任何人都没有帮助（除非他们怀念单一的 SVN 仓库）。</p><p>让我们正确的做到这一点：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ django-admin.py startproject samplesite .</span><br></pre></td></tr></table></figure><p>注意那个 <code>.</code> 。</p><p>由此生成的仓库结构如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">README.rst</span><br><span class="line">manage.py</span><br><span class="line">samplesite/settings.py</span><br><span class="line">samplesite/wsgi.py</span><br><span class="line">samplesite/sampleapp/models.py</span><br></pre></td></tr></table></figure><h2 id="代码结构是关键"><a href="#代码结构是关键" class="headerlink" title="代码结构是关键"></a>代码结构是关键</h2><p>Python 处理了导入和模块，因此构建 Python 项目相对容易。容易是指没有太多的约束，并且模块导入模型很容易掌握。因此，您所剩的是纯架构方面的任务，比如设计项目的不同点及其交互。</p><p>一个项目的结构简单意味着它也很容易做得不好。结构不佳的项目包括以下一些特征：</p><ul><li>多个杂乱的循环依赖关系：假如 <code>furn.py</code> 中 Table (桌子) 和 Chair （椅子）类需要从 <code>workers.py</code> 导入 Carpenter （木匠） 来回答诸如 <code>table.isdoneby()</code> 的问题；相反地，假如 Carpenter 类需要导入 Table 和 Chair 来回答诸如 <code>carpenter.whatdo()</code> 的问题。这样，就产生了一个循环依赖关系。在这种情况下，你不得不凭借脆弱的技巧，例如在方法或函数内使用导入语句。</li><li>隐藏的耦合关系： Table 实现中的每一次更改会在不相关的测试用例中中断20次测试，因为它破坏了 Carpenter 的代码，需要非常仔细的处理来适应此次更改。这意味着在 Carpenter 中有较多关于 Table 的假设，或在 Table 中有较多关于 Carpenter 的假设。</li><li>对全局状态或上下文的大量使用： Table 和 Carpenter 依赖于可修改的全局变量（可由不同的代理进行修改），而不是显式传递 <code>(高度、宽度、类型、木材)</code> 。你需要检查对这些全局变量的所有访问，以了解为什么长方形桌子变成了正方形，然后发现远程模板代码也在修改此上下文，从而弄乱了桌子的尺寸。</li><li>“意大利面条”式代码: 代码有多页嵌套 if 子句、 for 循环，有大量的复制粘贴程序代码，并没有适当的分块称为“意大利面条”式代码。 Python 的有意义的缩进 (最具争议性的特征之一) 使得维护这种代码变得非常困难。好消息是你可能看不到太多这种情况。</li><li>在 Python 中更有可能看到的是“意大利饺子”式代码：它由数百个类似的小逻辑片段组成，通常是类或对象，没有适当的结构。如果你不记得是否应该使用 FurnitureTable 、 AssetTable ，还是 TableNew 来完成手头上的任务，那么你可能会在“意大利饺子”式代码中漫无目的地游着。</li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>Python 模块是可用的主要抽象层之一，也是最自然的一个。抽象层允许将代码分成包含相关数据和功能的多个部分。</p><p>例如，项目的一层可以处理用户操作的接口，而另一层可以处理数据的底层操作。将这两层分离最自然的方法是：将所有接口功能组合在一个文件中，而在另一个文件中组合数据底层操作。在这种情况下，接口文件需要导入数据底层操作文件，这是通过 <code>import</code> 和 <code>from... import</code> 语句完成的。</p><p>一旦使用 <em>import</em> 语句，就会使用模块。这些模块可以是内置的模块，如 <em>os</em> 和 <em>sys</em>、环境中安装的第三方模块，或项目中的内部模块。</p><p>要与样式指南保持一致，需保持模块名称简短、小写，并确保避免使用特殊符号，如点（.）或问号（？）。所以应该避免像 <code>my.spam.py</code> 这样的文件名！以这种方式命名会影响 Python 查找模块的方式。</p><p>在这个 <em>my.spam.py</em> 情况下， Python 希望在名为 <code>my</code> 的文件夹中找到一个 <code>spam.py</code> 文件，但不应该这样命名。在 Python 文档中有一个应该如何使用点表示法的 <a href="http://docs.python.org/tutorial/modules.html#packages" target="_blank" rel="noopener">例子</a> 。</p><p>如果你希望将模块命名为 <code>my_spam.py</code> ，但其实下划线也不应该在模块名称中经常出现。在模块名称中使用其他字符（空格或连字符）将会阻止导入（- 是减操作符），因此请尽量保持模块名称的简短，这样就不需要将单词分开了。而且，最重要的是，不要使用带下划线的名称空间，应该使用子模块。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以</span></span><br><span class="line">import library.plugin.foo</span><br><span class="line"><span class="comment"># 不行</span></span><br><span class="line">import library.foo_plugin</span><br></pre></td></tr></table></figure><p>除了一些命名限制之外， Python 文件并不是一个特殊的模块，但你需要了解导入机制才能正确使用这个概念并避免一些问题。</p><p>具体地说， <code>import modu</code> 语句会去查找正确的文件，首先会在调用者所在的目录中查找 <code>modu.py</code> 。如果找不到，Python 解释器将递归搜索 “path” 中的 <code>modu.py</code> 。如果未找到，则引发 ImportError 异常。</p><p>一旦找到 <code>modu.py</code> ，Python 解释器将在一个隔离的空间内执行该模块。 <code>modu.py</code> 中的任何顶级语句都将被执行，包括其他导入（如果有的话）。 函数和类的定义存储在模块的字典中。</p><p>然后，模块的变量，函数和类将通过模块的名称空间提供给调用者，这是编程中的一个核心理念，在 Python 中特别有用而且功能强大。</p><p>在许多语言中，预处理器使用 <code>include file</code> 指令来获取文件中的所有代码，并将其复制到调用者的代码中。 这在 Python 中有所不同：导入的代码会被隔离在模块的命名空间内，这意味着你通常不必担心导入代码可能会产生不需要的效果，例如导入模块中有用相同的名称不会覆盖已有的函数。</p><p>通过使用 import 语句的特殊语法可以模拟更标准的行为：<code>from modu import *</code>。 这通常被认为是不好的做法。 <strong>使用</strong> <code>import *</code> <strong>会使代码更难阅读，并使得依赖更少的分块</strong>。</p><p>使用 <code>from modu import func</code> 是一种精确定位您想要导入的函数并将其放入全局命名空间的方法。 它比 <code>import *</code> 危害更小，因为它显式地显示了在全局命名空间中要导入的内容，它比简单的 <code>import modu</code> 的唯一优点是它可以节省一些输入。</p><p><strong>非常槽糕</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">from modu import *</span><br><span class="line">[...]</span><br><span class="line">x = sqrt(<span class="number">4</span>)  <span class="comment">#  sqrt是modu的一部分吗? 内置的? 上面定义了?</span></span><br></pre></td></tr></table></figure><p><strong>好一点的</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from modu import sqrt</span><br><span class="line">[...]</span><br><span class="line">x = sqrt(<span class="number">4</span>)  <span class="comment"># sqrt 可能是modu的一部分, 如果不在之间重新定义的话</span></span><br></pre></td></tr></table></figure><p><strong>最佳</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import modu</span><br><span class="line">[...]</span><br><span class="line">x = modu.sqrt(<span class="number">4</span>)  <span class="comment"># sqrt显然是modu的命名空间的一部分</span></span><br></pre></td></tr></table></figure><p>如 <a href="http://docs.python-guide.org/en/latest/writing/style/#code-style" target="_blank" rel="noopener">Code Style</a> 部分所述, 可读性是 Python 的主要特性之一。可读性意味着避免无用的样板文字和混乱，因此有必要花费一些努力来达到一定程度的简洁性上。但简洁不是简短和晦涩难懂。如 <code>modu.func</code> 的习惯用法，就能够立即判断类或函数来自何处。 除了最简单的单个文件项目之外，这样写可以大大提高了代码的可读性和可理解性。</p><h2 id="包系统"><a href="#包系统" class="headerlink" title="包系统"></a>包系统</h2><p>Python 提供了一个非常简单的封装系统，它只是模块机制到目录的扩展。</p><p>任何一个带有 <code>__init__.py</code> 文件的目录都被认为是 Python 包。包中的不同模块以类似于普通模块的方式导入，但 <code>__init__.py</code> 文件具有特殊的行为，该文件用于收集所有包范围的定义。</p><p>一个在目录 <code>pack/</code> 中的 <code>modu.py</code> 文件通过语句 <code>import pack.modu</code> 来导入。这个语句将在 <code>pack</code> 目录中查找 <code>__init__.py</code> 文件，并执行其所有顶级语句。接着它将查找一个叫 <code>pack/modu.py</code> 的文件并执行其所有顶级语句。在这些操作时候定义在 <code>modu.py</code> 中的任何变量，函数或类都在 pack.modu 命名空间中可用。</p><p>一个常见的问题是添加太多的代码到 <code>__init__.py</code> 文件中。当项目的复杂度增长时，在深层目录结构中可能由子包和子子包。在这种情况下，从子子包中导入单个项时遍历目录树时将需要执行所有 <code>__init__.py</code> 文件。</p><p>如果一个包的模块和子包不需要共享任何代码，那么让 <code>__init__.py</code> 文件保持为空是正常的，甚至是一个好的实践。</p><p>最后，一个简便的语法可以用来导入深度嵌套的包：<code>import very.deep.module as mod</code> 这允许你使用 <em>mod</em> 来代替冗长罗嗦的 <code>very.deep.module</code>。</p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>Python 有时被描述为一种面向对象的编程语言。这可能对大家有些误导，需要加以澄清。</p><p>在 Python 中，所有东西都视为一个对象，并且可以按对象处理。当我们说，函数是“一级”对象，就是将函数视为对象的意思。函数、类、字符串，甚至类型都是 Python 中的对象：像任何对象一样，它们有一个类型，可以作为函数参数传递，并且它们可能有方法和属性。按这种理解， Python 是一种面向对象的语言。</p><p>但是，与 Java 不同， Python 并没有将面向对象的编程作为主要的编程范例来实施。 Python 项目不采用面向对象的方式是完全可行的，即不使用或很少使用类定义、类继承或特定于面向对象编程的任何其他机制。</p><p>此外，从 <a href="http://docs.python-guide.org/en/latest/writing/structure/#modules" target="_blank" rel="noopener">模块</a> 部分可以看出， Python 处理模块和名称空间的方式为开发人员提供了一种自然的方法来确保抽象层的封装和分离，这两者都是使用面向对象的最常见原因。因此，当业务模型不需要面向对象时， Python 程序员有更大的自由来不使用面向对象编程。</p><p>基于一些因素的考虑，我们应避免不必要的面向对象编程。当我们想将一些状态和功能粘合在一起时，定义自定义类是很有用的。在函数编程的讨论中，我们指出，“不必要的面向对象编程”这个问题出自方程的“状态”部分。</p><p>在某些体系结构中，例如典型的 web 应用程序，会生成多个 Python 进程实例，以响应可能同时发生的外部请求。在这种情况下，将一些状态保存到实例对象中，意味着保留一些关于世界的静态信息，这很容易出现并发或竞争问题。有时，在对象的初始化（通常用 <code>__init__()</code> 方法来完成）状态和实际使用对象方法的状态之间，世界信息可能已经改变，保持的状态可能已经过时。例如，一个请求加载了内存中的某一项，并将其标记为由用户读取。而另一个请求同时要求删除该项，这可能发生在第一个进程加载该项之后，然后我们必须将其标记为已删除对象。</p><p>上述以及其他问题引出了这样的想法：使用无状态函数是一种更好的编程范例。</p><p>另一种说法是建议尽可能少的使用具有隐式上下文和副作用的函数和程序。函数的隐式上下文由全局变量和持久层中的数据项（使用方法访问）组成。副作用是指函数对其隐式上下文所做的更改。如果函数会保存或删除全局变量或持久层中的数据，则称它有副作用。</p><p>将有上下文和副作用的函数与逻辑函数（称为纯函数）隔离开来，可以获得以下好处：</p><ul><li>纯函数是确定性的：给定一个固定的输入，输出始终是相同的。</li><li>纯函数需要重构或优化时，更容易更改或替换。</li><li>纯函数更易于使用单元测试进行测试：对于复杂的上下文设置和事后的数据清理的需求更少。</li><li>纯函数更容易操作、修饰和传递。</li></ul><p>总之，针对某些体系结构，由于没有上下文或副作用，纯函数是比类和对象更有效的构建块。</p><p>显然，面向对象编程在许多情况下是有用的，甚至是必要的，例如在开发图形化桌面应用程序或游戏时，被操作的东西（窗口、按钮、化身、车辆）在计算机内存中具有相对较长的寿命。</p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>Python 语言提供了一种简单而强大的语法，称为“装饰器”。装饰器是一个函数或类，它包装（或装饰）了函数或方法。装饰器函数或方法将替换原来“未装饰”的函数或方法。因为函数是 Python 中的一级对象，所以可以“手动”完成（参见下述示例），但是使用 @decorator 语法则更清晰，也更受青睐。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    <span class="comment"># 一些操作</span></span><br><span class="line"></span><br><span class="line">def decorator(func):</span><br><span class="line">    <span class="comment"># 处理 func</span></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">foo = decorator(foo)  <span class="comment"># 手动装饰</span></span><br><span class="line"></span><br><span class="line">@decorator</span><br><span class="line">def bar():</span><br><span class="line">    <span class="comment"># 一些操作</span></span><br><span class="line"><span class="comment"># bar() 被装饰了</span></span><br></pre></td></tr></table></figure><p>此机制对于分离关注点和避免外部非相关逻辑“污染”函数或方法的核心逻辑很有用。最好采用装饰器来处理的一个功能示例是 <a href="https://en.wikipedia.org/wiki/Memoization#Overview" target="_blank" rel="noopener">备注</a> 或缓存：你希望将计算非常耗时/耗空间的函数的结果存储在表中，并直接使用这些结果，而不是在已经计算过以后重新调用并计算。这显然不是函数逻辑的一部分。</p><h2 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h2><p>上下文管理器是一个 Python 对象，为操作提供了额外的上下文信息。 这种额外的信息， 在使用 <code>with</code> 语句初始化上下文，以及完成 <code>with</code> 块中的所有代码时，采用可调用的形式。 这里展示了使用上下文管理器的为人熟知的示例，打开文件：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(<span class="string">'file.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    contents = f.read()</span><br></pre></td></tr></table></figure><p>任何熟悉这种模式的人都知道以这种形式调用 <code>open</code> 能确保 <code>f</code> 的 <code>close</code> 方法会在某个时候被调用。 这样可以减少开发人员的认知负担，并使代码更容易阅读。</p><p>实现这个功能有两种简单的方法：使用类或使用生成器。 让我们自己实现上面的功能，以使用类方式开始：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class CustomOpen(object):</span><br><span class="line">    def __init__(<span class="keyword">self</span>, filename):</span><br><span class="line">        <span class="keyword">self</span>.file = open(filename)</span><br><span class="line"></span><br><span class="line">    def __enter__(<span class="keyword">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.file</span><br><span class="line"></span><br><span class="line">    def __exit__(<span class="keyword">self</span>, ctx_type, ctx_value, ctx_traceback):</span><br><span class="line">        <span class="keyword">self</span>.file.close()</span><br><span class="line"></span><br><span class="line">with CustomOpen(<span class="string">'file'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    contents = f.read()</span><br></pre></td></tr></table></figure><p>这只是一个常规的 Python 对象，它有两个由 <code>with</code> 语句使用的额外方法。 CustomOpen 首先被实例化，然后调用它的 <code>__enter__</code> 方法，而且 <code>__enter__</code> 的返回值在 <code>as f</code> 语句中被赋给 <code>f</code> 。 当 <code>with</code> 块中的内容执行完后，会调用 <code>__exit__</code> 方法。</p><p>现在我们演示生成器方式，我们将使用了 Python 自带的 <a href="https://docs.python.org/2/library/contextlib.html" target="_blank" rel="noopener">contextlib</a>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from contextlib import contextmanager</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def custom_open(filename):</span><br><span class="line">    f = open(filename)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> f</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">with custom_open(<span class="string">'file'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    contents = f.read()</span><br></pre></td></tr></table></figure><p>这与上面的类示例道理相通，尽管它更简洁。<code>custom_open</code> 函数一直运行到 <code>yield</code> 语句。 然后它将控制权返回给 <code>with</code> 语句，然后在 <code>as f</code> 部分将 yield 的 <code>f</code> 赋值给 <code>f</code>。 <code>finally</code> 确保不论 <code>with</code> 中是否发生异常， <code>close()</code> 都会被调用。</p><p>由于这两种方法都是一样的，所以我们应该遵循 Python 之禅来决定何时使用哪种。 如果封装的逻辑量很大，则类的方法可能会更好。 而对于处理简单操作的情况，函数方法可能会更好。</p><h2 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h2><p>Python 是动态类型语言，这意味着变量并没有固定的类型。实际上，Python 中的变量和其他语言有很大的不同，特别是静态类型语言。变量并不是计算机内存中被写入的某个值，它们只是指向内存的『标签』或『名称』。因此可能存在这样的情况，变量 <code>a</code> 先代表值 1，然后变成 字符串 <code>a string</code> , 然后又变为指向一个函数。</p><p>Python 的动态类型常被认为是它的缺点，的确这个特性会导致复杂度提升和难以调试的代码。 命名为 <code>a</code> 的变量可能是各种类型，开发人员或维护人员需要在代码中追踪命名，以保证它 没有被设置到毫不相关的对象上。</p><p>这里有些避免发生类似问题的参考方法：</p><ul><li>避免对不同类型的对象使用同一个变量名</li></ul><p><strong>不推荐</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">a = <span class="string">'a string'</span></span><br><span class="line">def a():</span><br><span class="line">    pass  <span class="comment"># Do something</span></span><br></pre></td></tr></table></figure><p><strong>推荐</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">1</span></span><br><span class="line">msg = <span class="string">'a string'</span></span><br><span class="line">def func():</span><br><span class="line">    pass  <span class="comment"># Do something</span></span><br></pre></td></tr></table></figure><p>使用简短的函数或方法能降低对不相关对象使用同一个名称的风险。</p><p>即使是相关的不同 类型的对象，也更建议使用不同命名：</p><p><strong>不推荐</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items = <span class="string">'a b c d'</span>  <span class="comment"># This is a string...</span></span><br><span class="line">items = items.split(<span class="string">' '</span>)  <span class="comment"># ...becoming a list</span></span><br><span class="line">items = set(items)  <span class="comment"># ...and then a set</span></span><br></pre></td></tr></table></figure><p>重复使用命名对效率并没有提升：赋值时无论如何都要创建新的对象。然而随着复杂度的提升，赋值语句被其他代码包括 <code>if</code> 分支和循环分开，使得更难查明指定变量的类型。</p><p>在某些代码的做法中，例如函数编程，推荐的是从不重复对同一个变量命名赋值。Java 内的实现方式是使用 <code>final</code> 关键字。Python 并没有 <code>final</code> 关键字而且这与它的哲学 相悖。尽管如此，避免给同一个变量命名重复赋值仍是是个好的做法，并且有助于掌握 可变与不可变类型的概念。</p><h2 id="可变和不可变类型"><a href="#可变和不可变类型" class="headerlink" title="可变和不可变类型"></a>可变和不可变类型</h2><p>Python提供两种内置或用户定义的类型。</p><p>可变类型允许内容的内部修改。典型的动态类型 包括列表与字典：列表都有可变方法，如 <code>list.append()</code> 和 <code>list.pop()</code>， 并且能就地修改。字典也是一样。</p><p>不可变类型没有修改自身内容的方法。比如，赋值为整数 6 的变量 x 并没有 “自增” 方法，如果需要计算 x + 1，必须创建另一个整数变量并给其命名。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_list[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line"><span class="keyword">print</span> my_list  <span class="comment"># [4, 2, 3] &lt;- The same list has changed</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">6</span></span><br><span class="line">x = x + <span class="number">1</span>  <span class="comment"># The new x is another object</span></span><br></pre></td></tr></table></figure><p>这种差异导致的一个后果就是，可变类型是不 ‘稳定 ‘的，因而不能作为字典的键使用。</p><p>合理地使用可变类型与不可变类型有助于阐明代码的意图。</p><p>例如与列表相似的不可变类型是元组， 创建方式为 <code>(1, 2)</code>。元组是不可修改的，并能作为字典的键使用。</p><p>Python 中一个可能会让初学者惊讶的特性是：字符串是不可变类型。这意味着当需要组合一个 字符串时，将每一部分放到一个可变列表里，使用字符串时再组合 (<code>join</code>) 起来的做法更高效。 值得注意的是，使用列表推导的构造方式比在循环中调用 <code>append()</code> 来构造列表更好也更快。</p><p>还有一个选项是使用 <code>map</code> 函数，它可以 <code>map</code> 一个函数 <code>str</code> 到可序列化对象上 ( 例如 <code>range(20)</code>)。 结果会产生一个集合，你可以对结果进行 <code>join</code> 在一起，就如其他的例子一样。<code>map</code> 函数在一些场景下速度会更快。</p><p><strong>差</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 0 到 19 创建一个连续的字符串（例如「012..1819」）</span></span><br><span class="line">nums = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> n in range(<span class="number">20</span>):</span><br><span class="line">    nums += str(n)   <span class="comment"># slow and inefficient</span></span><br><span class="line"><span class="keyword">print</span> nums</span><br></pre></td></tr></table></figure><p><strong>好</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 0 到 19 创建一个连续的字符串（例如「012..1819」）</span></span><br><span class="line">nums = []</span><br><span class="line"><span class="keyword">for</span> n in range(<span class="number">20</span>):</span><br><span class="line">    nums.append(str(n))</span><br><span class="line"><span class="keyword">print</span> <span class="string">""</span>.join(nums)  <span class="comment"># much more efficient</span></span><br></pre></td></tr></table></figure><p><strong>较好</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 0 到 19 创建一个连续的字符串（例如「012..1819」）</span></span><br><span class="line">nums = [str(n) <span class="keyword">for</span> n in range(<span class="number">20</span>)]</span><br><span class="line"><span class="keyword">print</span> <span class="string">""</span>.join(nums)</span><br></pre></td></tr></table></figure><p><strong>最好</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 0 到 19 创建一个连续的字符串（例如「012..1819」）</span></span><br><span class="line">nums = map(str, range(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">""</span>.join(nums)</span><br></pre></td></tr></table></figure><p>最后关于字符串的说明的一点是，使用 <code>join()</code> 并不总是最好的选择。比如当用预先确定数量的字符串创建一个新的字符串时，使用加法操作符确实更快，但在上文提到的情况 下或添加到已存在字符串的情况下，使用 <code>join()</code> 是更好的选择。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="string">'foo'</span></span><br><span class="line">bar = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line">foobar = foo + bar  <span class="comment"># This is good</span></span><br><span class="line">foo += <span class="string">'ooo'</span>  <span class="comment"># This is bad, instead you should do:</span></span><br><span class="line">foo = <span class="string">''</span>.join([foo, <span class="string">'ooo'</span>])</span><br></pre></td></tr></table></figure><blockquote><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>除了 <a href="http://docs.python.org/library/stdtypes.html#str.join" target="_blank" rel="noopener"><code>str.join()</code></a> 和 <code>+</code>，您也可以使用 <a href="http://docs.python.org/library/string.html#string-formatting" target="_blank" rel="noopener">%</a> 格式运算符来连接确定数量的字符串，但 <a href="https://www.python.org/dev/peps/pep-3101" target="_blank" rel="noopener">PEP 3101</a> 建议使用 <a href="http://docs.python.org/library/stdtypes.html#str.format" target="_blank" rel="noopener"><code>str.format()</code></a> 替代 <code>%</code> 操作符。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="string">'foo'</span></span><br><span class="line">bar = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line">foobar = <span class="string">'%s%s'</span> % (foo, bar) <span class="comment"># It is OK</span></span><br><span class="line">foobar = <span class="string">'&#123;0&#125;&#123;1&#125;'</span>.format(foo, bar) <span class="comment"># It is better</span></span><br><span class="line">foobar = <span class="string">'&#123;foo&#125;&#123;bar&#125;'</span>.format(foo=foo, bar=bar) <span class="comment"># It is best</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/writing/structure/#structure-of-the-repository" target="_blank" rel="noopener">Python漫游指南</a></li><li><a href="http://www.diveintopython.net/toc/index.html" target="_blank" rel="noopener">http://www.diveintopython.net/toc/index.html</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里我们所说的「结构」就是关于如何让项目达到预期的目标。我们需要考虑的是如何更好的利用 Python 的特性创造出干净、有效的代码。实际上，「结构」意味着代码的结构、依赖非常的清晰，像文件系统中的文件和文件夹一样。&lt;/p&gt;
&lt;p&gt;哪些函数应该放在哪个模块中？项目中的数据流是
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>部署postgresql</title>
    <link href="https://yo42.github.io/2018/09/11/%E9%83%A8%E7%BD%B2postgresql/"/>
    <id>https://yo42.github.io/2018/09/11/部署postgresql/</id>
    <published>2018-09-11T06:55:29.804Z</published>
    <updated>2018-09-15T03:22:00.637Z</updated>
    
    <content type="html"><![CDATA[<h3 id="部署postgres数据库-Docker"><a href="#部署postgres数据库-Docker" class="headerlink" title="部署postgres数据库(Docker)"></a>部署postgres数据库(Docker)</h3><h4 id="使用sameersbn-postgresql"><a href="#使用sameersbn-postgresql" class="headerlink" title="使用sameersbn/postgresql"></a>使用sameersbn/postgresql</h4><h4 id="工作目录-home-postgres"><a href="#工作目录-home-postgres" class="headerlink" title="工作目录:/home/postgres"></a>工作目录:/home/postgres</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">postgresql:</span><br><span class="line">  restart: always</span><br><span class="line">  image: sameersbn/postgresql:9.6-2</span><br><span class="line">  volumes:</span><br><span class="line">    - $PWD:/var/lib/postgresql</span><br><span class="line">    - /var/run/postgresql/:/var/run/postgresql/</span><br><span class="line">    - /home/nucleus-d1/rsyncd/data/:/home/nucleus-d1/rsyncd/data/</span><br><span class="line">    - /home/postgres/zhangxiaohao/:/home/postgres/zhangxiaohao/</span><br><span class="line">  environment:</span><br><span class="line">    - DB_USER=postgres</span><br><span class="line">    - DB_PASS=xxxxx</span><br><span class="line">    - DB_EXTENSION=</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;0.0.0.0:5432:5432&quot;</span><br></pre></td></tr></table></figure><h4 id="9-6-main-pg-hba-conf-权限配置"><a href="#9-6-main-pg-hba-conf-权限配置" class="headerlink" title="9.6/main/pg_hba.conf # 权限配置"></a>9.6/main/pg_hba.conf # 权限配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># &quot;local&quot; is for Unix domain socket connections only</span><br><span class="line">local   all             all                                  trust</span><br><span class="line">host    all             all             112.94.5.240/28      md5</span><br><span class="line">host    all             all             192.168.0.0/16       md5</span><br><span class="line">host    all             all             0.0.0.0/0            md5</span><br><span class="line"># IPv4 local connections:</span><br><span class="line">host    all             all             127.0.0.1/32         trust</span><br><span class="line">host    all             all             112.94.5.240/28      md5</span><br><span class="line">host    all             all             192.168.0.0/16       md5</span><br><span class="line">host    all             all             0.0.0.0/0            md5</span><br></pre></td></tr></table></figure><p>开放办公室ssh通道连接pgsql数据库</p><h4 id="centos-安装postgresql-client"><a href="#centos-安装postgresql-client" class="headerlink" title="centos 安装postgresql-client"></a>centos 安装postgresql-client</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install postgresql</span><br></pre></td></tr></table></figure><h4 id="修改默认密码"><a href="#修改默认密码" class="headerlink" title="修改默认密码"></a>修改默认密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user postgres  with password xxx</span><br></pre></td></tr></table></figure><h4 id="配置java应用连接pgsql数据库"><a href="#配置java应用连接pgsql数据库" class="headerlink" title="配置java应用连接pgsql数据库"></a>配置java应用连接pgsql数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- data_center_jdbc_url=jdbc:postgresql://192.168.8.143:5432/d1_statistics?autoReconnect=true&amp;useUnicode=true&amp;rewriteBatchedStatements=true&amp;useSSL=false</span><br><span class="line">- data_center_jdbc_username=postgres</span><br><span class="line">- data_center_jdbc_password=xxx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;部署postgres数据库-Docker&quot;&gt;&lt;a href=&quot;#部署postgres数据库-Docker&quot; class=&quot;headerlink&quot; title=&quot;部署postgres数据库(Docker)&quot;&gt;&lt;/a&gt;部署postgres数据库(Docker)&lt;/h3
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>游戏服内外网穿透</title>
    <link href="https://yo42.github.io/2018/09/11/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%86%85%E5%A4%96%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>https://yo42.github.io/2018/09/11/游戏服内外网穿透/</id>
    <published>2018-09-11T06:14:35.348Z</published>
    <updated>2018-09-11T06:42:22.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于游戏服内外网穿透"><a href="#关于游戏服内外网穿透" class="headerlink" title="关于游戏服内外网穿透"></a>关于游戏服内外网穿透</h2><p>大致一个场景:公司网络区分了内外网，游戏服务器架设在内网，而手机连接wifi是属于外网，需要满足个需求，外网环境(公司wifi、或个人办工电脑机器)实现正常访问内网游戏服。</p><p>涉及HTTP七层的转发以及TCP四层的转发</p><p>大致原理:部署转发代理服(包含外网网卡)，通过NGinx代理转发请求，内外网DNS劫持，实现。因为Nginx从1.9版本开始支持了TCP四层的转发，故使用Nginx的Stream模块进行实现，此外使用开源的HAproxy也是一个解决方案。</p><p>逻辑图:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="内外网穿透.png" alt="内外网穿透" title="">                </div>                <div class="image-caption">内外网穿透</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="内外网穿透2.png" alt="内外网穿透" title="">                </div>                <div class="image-caption">内外网穿透</div>            </figure><p>Nginx配置nginx.conf:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line"></span><br><span class="line"> include /etc/nginx/vhost.d/01-proxy.conf;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TCP转发:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> server &#123;</span><br><span class="line">    listen        7011;</span><br><span class="line">    proxy_pass    192.168.8.137:7011;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> server &#123;</span><br><span class="line">     listen        7012;</span><br><span class="line">     proxy_pass    192.168.8.137:7012;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen        27011;</span><br><span class="line">     proxy_pass    192.168.8.137:27011;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen       27012;</span><br><span class="line">     proxy_pass    192.168.8.137:27012;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> server &#123;</span><br><span class="line">     listen        27013;</span><br><span class="line">     proxy_pass    192.168.8.137:27013;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen        10004;</span><br><span class="line">     proxy_pass    192.168.8.137:10004;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen        10005;</span><br><span class="line">     proxy_pass    192.168.8.137:10005;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen        10006;</span><br><span class="line">     proxy_pass    192.168.8.137:10006;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen        10007;</span><br><span class="line">     proxy_pass    192.168.8.137:10007;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen        10008;</span><br><span class="line">     proxy_pass    192.168.8.137:10008;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen        10009;</span><br><span class="line">     proxy_pass    192.168.8.137:10009;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen         8111;</span><br><span class="line">     proxy_pass    192.168.8.137:8111;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> HTTP转发:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8080;</span><br><span class="line">    listen       8443 ssl;</span><br><span class="line">    server_name  proxydevh7d.demigame.com;</span><br><span class="line"></span><br><span class="line">    proxy_set_header Host             $host;</span><br><span class="line">    proxy_set_header X-Real-IP        $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-Forwarded-For2 $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">    server_name_in_redirect off;</span><br><span class="line"></span><br><span class="line">    include /home/nucleus-h7/global/nginx-137/conf/ssl.cfg;</span><br><span class="line">    include /home/nucleus-h7/global/nginx-137/conf/vhost.d/games-out.cfg;</span><br><span class="line"></span><br><span class="line">    error_log  /home/nucleus-h7/global/nginx-137/logs/games_errors_log   notice;</span><br><span class="line">    access_log /home/nucleus-h7/global/nginx-137/logs/games_access_log combined;</span><br><span class="line"></span><br><span class="line">    location ~* ^/ &#123;</span><br><span class="line">         proxy_pass http://192.168.8.137;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    location ~* ^/h7d/download/ &#123;</span><br><span class="line">    autoindex on;</span><br><span class="line">    autoindex_localtime on;</span><br><span class="line">    rewrite /h7d/(.*) /$1 break;</span><br><span class="line">        proxy_pass http://192.168.8.137;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:在内外网网关机器使用的是centos7 dnsmasq</p><p>1、在内网网关机器添加hosts劫持DNS，指向内网服务器的ip地址</p><p>2、在外网网关机器添加hosts劫持DNS，指向外网服务器的ip地址</p><p>3、测试解析</p><p>TODO:</p><p>1、目前H7的代理服h7-proxy-s189只有一个外网接口，所以采用新增虚接口的形式实现多网卡。</p><p>2、缺点:机器一重启虚拟接口就消失，需要手动执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip a a 192.168.1.54/22 dev eth1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于游戏服内外网穿透&quot;&gt;&lt;a href=&quot;#关于游戏服内外网穿透&quot; class=&quot;headerlink&quot; title=&quot;关于游戏服内外网穿透&quot;&gt;&lt;/a&gt;关于游戏服内外网穿透&lt;/h2&gt;&lt;p&gt;大致一个场景:公司网络区分了内外网，游戏服务器架设在内网，而手机连接wifi
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Docker 远程API调用启用TLS加密</title>
    <link href="https://yo42.github.io/2018/09/11/Docker-%E8%BF%9C%E7%A8%8BAPI%E8%B0%83%E7%94%A8%E5%90%AF%E7%94%A8TLS%E5%8A%A0%E5%AF%86/"/>
    <id>https://yo42.github.io/2018/09/11/Docker-远程API调用启用TLS加密/</id>
    <published>2018-09-11T05:06:02.930Z</published>
    <updated>2018-09-11T06:14:50.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="普通的HTTP模式（非常不安全）："><a href="#普通的HTTP模式（非常不安全）：" class="headerlink" title="普通的HTTP模式（非常不安全）："></a>普通的HTTP模式（非常不安全）：</h1><h2 id="服务端（CentOS-7，IP地址192-168-9-7）："><a href="#服务端（CentOS-7，IP地址192-168-9-7）：" class="headerlink" title="服务端（CentOS 7，IP地址192.168.9.7）："></a>服务端（CentOS 7，IP地址192.168.9.7）：</h2><pre>sed -i 's/\(OPTIONS="\)/\1-H 0.0.0.0:1699 /' /etc/sysconfig/docker# 也就是加入 -H 0.0.0.0:1699参数</pre>## 重启docker。## 客户端配置：<pre>echo 'export DOCKER_HOST="tcp://192.168.9.7:1699"' >> ~/.bashrcsource ~/.bashrc</pre>## 测试：<pre>docker version</pre>### 生成脚本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># vim:set et ts=4 sw=4:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到当前目录</span></span><br><span class="line">current_dir=`dirname <span class="variable">$0</span>`</span><br><span class="line">current_dir=`readlink -f <span class="variable">$current_dir</span>`</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;current_dir&#125;</span> &amp;&amp; <span class="built_in">export</span> current_dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># header</span></span><br><span class="line"><span class="built_in">exec</span> 6&gt;&amp;1</span><br><span class="line"><span class="built_in">exec</span>  &gt; <span class="variable">$&#123;0&#125;</span>.stdout</span><br><span class="line"><span class="built_in">exec</span> 2&gt; <span class="variable">$&#123;0&#125;</span>.stderr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">_usage</span></span>() &#123;</span><br><span class="line">    <span class="built_in">exec</span> 1&gt;&amp;6 6&gt;&amp;-</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'&#123; "Action": "GenerateDockerTLSKey", "RetCode": 1, "Message": "Usage: ./docker-server-tlskey.sh IP1 IP2 PW" &#125;'</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IP1=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">IP2=<span class="string">"<span class="variable">$2</span>"</span></span><br><span class="line">PW=<span class="string">"<span class="variable">$3</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># check input</span></span><br><span class="line">[ <span class="string">"x<span class="variable">$IP1</span>"</span> == <span class="string">"x"</span> ] || [ <span class="string">"x<span class="variable">$IP2</span>"</span> == <span class="string">"x"</span> ] || [ <span class="string">"x<span class="variable">$PW</span>"</span> == <span class="string">"x"</span> ] &amp;&amp; _usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># check IP1 or IP2</span></span><br><span class="line"><span class="keyword">if</span> ! /sbin/ip a | egrep -q <span class="string">"<span class="variable">$&#123;IP1&#125;</span>|<span class="variable">$&#123;IP2&#125;</span>"</span> ;<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exec</span> 1&gt;&amp;6 6&gt;&amp;-</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'&#123; "Action": "GenerateDockerTLSKey", "RetCode": 2, "Message": "Error: IP1 or IP2 not fount" &#125;'</span></span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># check ca pem file</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f ./ca.pem ] || [ ! -f ./ca-key.pem ] ;<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exec</span> 1&gt;&amp;6 6&gt;&amp;-</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'&#123; "Action": "GenerateDockerTLSKey", "RetCode": 3, "Message": "ca.pem or ca-key.pem not fount" &#125;'</span></span><br><span class="line">    <span class="built_in">exit</span> 3</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/docker/cert.pem ] ;<span class="keyword">then</span></span><br><span class="line">    ips=$(openssl x509 \</span><br><span class="line">        -certopt no_subject,no_header,no_version,no_serial,no_signame,no_validity,no_subject,no_issuer,no_pubkey,no_sigdump,no_aux \</span><br><span class="line">        -noout -text -<span class="keyword">in</span> /etc/docker/cert.pem )</span><br><span class="line"></span><br><span class="line">    i=0</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">echo</span> <span class="variable">$ips</span> | grep -q <span class="variable">$IP1</span> ;<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">let</span> i+=1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">echo</span> <span class="variable">$ips</span> | grep -q <span class="variable">$IP2</span> ;<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">let</span> i+=1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$i</span> -eq 2 ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">exec</span> 1&gt;&amp;6 6&gt;&amp;-</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'&#123; "Action": "GenerateDockerTLSKey", "RetCode": 0, "Message": "NotChange" &#125;'</span></span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">[ -d /etc/docker ] || mkdir -pv /etc/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成</span></span><br><span class="line">openssl genrsa -out server-key.pem 4096 \</span><br><span class="line">    &amp;&amp; openssl req -subj <span class="string">"/CN=<span class="variable">$&#123;IP1&#125;</span>"</span> -sha256 -new -key server-key.pem -out ./server.csr \</span><br><span class="line">    &amp;&amp; <span class="built_in">echo</span> subjectAltName = IP:<span class="variable">$&#123;IP1&#125;</span>,IP:<span class="variable">$&#123;IP2&#125;</span>,IP:127.0.0.1 &gt; ./extfile.cnf \</span><br><span class="line">    &amp;&amp; openssl x509 -req -days 3650 -sha256 -passin pass:<span class="variable">$PW</span> \</span><br><span class="line">                    -<span class="keyword">in</span> ./server.csr -CA ./ca.pem -CAkey ./ca-key.pem \</span><br><span class="line">                    -CAcreateserial -extfile ./extfile.cnf \</span><br><span class="line">                    -out /etc/docker/cert.pem \</span><br><span class="line">    &amp;&amp; chmod 0444 /etc/docker/cert.pem       \</span><br><span class="line">    &amp;&amp; rm -f server.csr extfile.cnf ca.srl   \</span><br><span class="line">    &amp;&amp; cp ca.pem         /etc/docker/ca.pem  \</span><br><span class="line">    &amp;&amp; cp server-key.pem /etc/docker/key.pem \</span><br><span class="line">    &amp;&amp; systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line">retvar=$?</span><br><span class="line"></span><br><span class="line"><span class="comment">## 有时会遇到如下报错:</span></span><br><span class="line"><span class="comment">#Warning! D-Bus connection terminated.</span></span><br><span class="line"><span class="comment">#Failed to wait for response: Connection reset by peer</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># footer</span></span><br><span class="line"><span class="built_in">exec</span> 1&gt;&amp;6 6&gt;&amp;-</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$retvar</span> -eq 0 ] ;<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'&#123; "Action": "GenerateDockerTLSKey", "RetCode": 0 &#125;'</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'&#123; "Action": "GenerateDockerTLSKey", "RetCode": 1, "Message": "openssl error" &#125;'</span></span><br><span class="line">   <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>### 手动生成脚本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># vim:set et ts=2 sw=2:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到当前目录</span></span><br><span class="line">current_dir=`dirname <span class="variable">$0</span>`</span><br><span class="line">current_dir=`readlink -f <span class="variable">$current_dir</span>`</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;current_dir&#125;</span> &amp;&amp; <span class="built_in">export</span> current_dir</span><br><span class="line"></span><br><span class="line">IP1=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">IP2=<span class="string">"<span class="variable">$2</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">_usage</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Usage: <span class="variable">$0</span> IP1 IP2"</span></span><br><span class="line">  <span class="built_in">exit</span> 127</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># check input</span></span><br><span class="line">[ <span class="string">"x<span class="variable">$IP1</span>"</span> == <span class="string">"x"</span> ] || [ <span class="string">"x<span class="variable">$IP2</span>"</span> == <span class="string">"x"</span> ] &amp;&amp; _usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># check IP1 or IP2</span></span><br><span class="line"><span class="keyword">if</span> ! /sbin/ip a | egrep -q <span class="string">"<span class="variable">$&#123;IP1&#125;</span>|<span class="variable">$&#123;IP2&#125;</span>"</span> ;<span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"ERROR: <span class="variable">$&#123;IP1&#125;</span> or <span class="variable">$&#123;IP2&#125;</span> not fount"</span></span><br><span class="line">  <span class="built_in">exit</span> 126</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/docker/cert.pem ] ;<span class="keyword">then</span></span><br><span class="line">  ips=$(openssl x509 \</span><br><span class="line">    -certopt no_subject,no_header,no_version,no_serial,no_signame,no_validity,no_subject,no_issuer,no_pubkey,no_sigdump,no_aux \</span><br><span class="line">    -noout -text -<span class="keyword">in</span> /etc/docker/cert.pem )</span><br><span class="line"></span><br><span class="line">  i=0</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">echo</span> <span class="variable">$ips</span> | grep -q <span class="variable">$IP1</span> ;<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">let</span> i+=1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">echo</span> <span class="variable">$ips</span> | grep -q <span class="variable">$IP2</span> ;<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">let</span> i+=1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$i</span> -eq 2 ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"not change, skip"</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"ip change"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">openssl req -subj <span class="string">"/CN=<span class="variable">$&#123;IP1&#125;</span>"</span> -sha256 -new -key server-key.pem -out ./server.csr</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> subjectAltName = IP:<span class="variable">$&#123;IP1&#125;</span>,IP:<span class="variable">$&#123;IP2&#125;</span>,IP:127.0.0.1 &gt; ./extfile.cnf</span><br><span class="line"></span><br><span class="line">openssl x509 -req -days 3650 -sha256 \</span><br><span class="line">  -<span class="keyword">in</span> ./server.csr -CA ./ca.pem -CAkey ./ca-key.pem \</span><br><span class="line">  -CAcreateserial -extfile ./extfile.cnf \</span><br><span class="line">  -out /etc/docker/cert.pem &amp;&amp; <span class="built_in">echo</span> <span class="string">"OK"</span></span><br><span class="line"></span><br><span class="line">chmod 0444 /etc/docker/cert.pem</span><br><span class="line">rm -f server.csr extfile.cnf ca.srl</span><br><span class="line"></span><br><span class="line">cp ca.pem         /etc/docker/ca.pem</span><br><span class="line">cp server-key.pem /etc/docker/key.pem</span><br></pre></td></tr></table></figure># 启用HTTPS模式：## 文档： https://docs.docker.com/engine/articles/https/## CA证书### 私钥（使用xlands做为密码）：<pre>openssl genrsa -aes256 -out ca-key.pem 4096 chmod 0400 ca-key.pem</pre>### 签发申请（10年）：<pre>openssl req -new -x509 -days 3650 \            -subj "/C=CN/ST=GD/L=GZ/O=baoyugame/OU=baoyugame/CN=*.baoyugame.com" \            -sha256 -key ca-key.pem -out ca.pemchmod 0444 ca.pem </pre>## 服务端证书：### 私钥：<pre>openssl genrsa -out server-key.pem 4096chmod 0400 server-key.pem</pre>### 请求证书（设置HOST为不同IP地址就可以给其他主机签发证书）：<pre>HOST=192.168.9.7openssl req -subj "/CN=$HOST" -sha256 -new -key server-key.pem -out server-$HOST.csr</pre>### 需允许服务器的网卡IP地址：<pre>echo subjectAltName = IP:$HOST,IP:127.0.0.1 > extfile.cnf</pre>### 签署 -（不带-extfile extfile.cnf参数）- ：<pre>openssl x509 -req -days 3650 -sha256 \             -in server-$HOST.csr -CA ca.pem -CAkey ca-key.pem \             -CAcreateserial -extfile extfile.cnf \             -out server-cert-$HOST.pem</pre><pre>chmod 0444 server-cert-$HOST.pem</pre><h3 id="删除请求证书："><a href="#删除请求证书：" class="headerlink" title="删除请求证书："></a>删除请求证书：</h3><pre>rm server-$HOST.csr</pre>### 部署证书（复制到各自主机上）：<pre>#echo 'DOCKER_CERT_PATH=/etc/docker' | sudo tee -a /etc/sysconfig/docker#sed -i 's/\(OPTIONS="\)/\1 --tlsverify '  /etc/sysconfig/docker</pre><pre>cat<<eof> /etc/sysconfig/dockerDOCKER_CERT_PATH=/etc/dockerOPTIONS="-g /home/docker --tlsverify --ip=172.17.42.1 --userland-proxy=false -H 0.0.0.0:1699 -H unix:///var/run/docker.sock "EOF</eof></pre><pre>sudo cp ca.pem          /etc/docker/ca.pemsudo cp server-key.pem  /etc/docker/key.pemsudo cp server-cert-$HOST.pem /etc/docker/cert.pem</pre><h3 id="开启："><a href="#开启：" class="headerlink" title="开启："></a>开启：</h3><pre>sudo systemctl start docker</pre>## 客户端证书：### 独立目录：<pre>mkdir client && cd client</pre>### 私钥：<pre>openssl genrsa -out key.pem 4096chmod 0400 key.pem</pre>### 请求证书：<pre>openssl req -subj '/CN=client' -new -key key.pem -out client.csr</pre>### 附件属性：<pre>echo extendedKeyUsage = clientAuth > extfile.cnf</pre>### 签署：<pre>openssl x509 -req -days 3650 -sha256 -in client.csr -CA ../ca.pem -CAkey ../ca-key.pem \  -CAcreateserial -extfile extfile.cnf \  -out cert.pem chmod 0444 cert.pemcp ../ca.pem .### 删除请求证书：<pre>rm client.csr extfile.cnf .srl</pre>### 部署证书：<pre>mkdir     ~/.docker/cp ca.pem ~/.docker/cp client-key.pem  ~/.docker/key.pemcp client-cert.pem ~/.docker/cert.pem</pre><h3 id="客户端配置（默认启用TLS）："><a href="#客户端配置（默认启用TLS）：" class="headerlink" title="客户端配置（默认启用TLS）："></a>客户端配置（默认启用TLS）：</h3><pre>cat<<eof>> ~/.bashrcexport DOCKER_HOST="tcp://192.168.9.7:1699" export DOCKER_TLS_VERIFY=1export DOCKER_CERT_PATH=/path/to/dir/tls-key/clientEOF</eof></pre><pre>source ~/.bashrc</pre><h3 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h3><pre>docker version</pre> </pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;普通的HTTP模式（非常不安全）：&quot;&gt;&lt;a href=&quot;#普通的HTTP模式（非常不安全）：&quot; class=&quot;headerlink&quot; title=&quot;普通的HTTP模式（非常不安全）：&quot;&gt;&lt;/a&gt;普通的HTTP模式（非常不安全）：&lt;/h1&gt;&lt;h2 id=&quot;服务端（C
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker 学习笔记</title>
    <link href="https://yo42.github.io/2018/09/09/Docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://yo42.github.io/2018/09/09/Docker-学习笔记/</id>
    <published>2018-09-09T09:52:13.149Z</published>
    <updated>2018-09-09T10:03:45.823Z</updated>
    
    <content type="html"><![CDATA[<p>Docker有两个概念需要搞清楚,镜像与容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">镜像是从网上docker pub上拉取下来的镜像，拉取下来后可以使用docker run命令进行运行。</span><br><span class="line"># dockerhub 是官方构建的一个镜像仓库,类似github一样,上面累积了许多人上传制作的镜像,有官方,有的是用户上传的,任何人都可自由下载。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器是将镜像运行在一个容器中</span><br></pre></td></tr></table></figure><p>Registry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用户可以在自己的数据中心搭建私有的registry,也可以从官方使用docker官方的registry也就是docker hub.</span><br><span class="line">它是一个公共的镜像仓库，供用户下载和使用，dockerhub中有两种库。</span><br><span class="line">用户仓库和顶层库，用户仓库是有私人创建的，顶层使用docker公司负责维护的。</span><br></pre></td></tr></table></figure><p>常用操作命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker images #查看从docker hub上下载到本地的镜像</span><br><span class="line">docker search #镜像名#从docker hub上搜索镜像</span><br><span class="line">docker pull #从docker registry中拉取镜像</span><br><span class="line">docker push #将本地制作好的镜像推送到docker hub</span><br><span class="line">docker rm 容器id #删除容器命令</span><br><span class="line">docker rmi 镜像id #删除镜像 </span><br><span class="line">docker stop $(docker ps -a) #批量停止容器</span><br><span class="line">docker rm $(docker ps -a) # 批量删除容器</span><br><span class="line">docker rm $(docker ps -a|awk &apos;&#123;print $1&#125;&apos;|cut -f 1 -d &quot;C&quot;) # 批量删除容器</span><br><span class="line">docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq) #both</span><br><span class="line">###ps:docker rm 与docker rmi 都可以加 -f强制删除,需要注意的是如果删除镜像报错,如果基于镜像启动的容器存在,则无法直接删除,需要先删除容器再删除镜像。</span><br><span class="line">docker inspect # 查看镜像和容器的详细信息</span><br><span class="line">docker ps # 查看容器相关的信息，状态 选项 -a 列出所有容器的的状态 -l 列出最新的状态</span><br><span class="line">docker commit &lt;container_id&gt; &lt;some_name&gt; # 可以将一个容器固化为一个新的镜像,通过commit将镜像保存起来，也就是可以将一个环境配配置好的容器，保存，以后用到在拿出来使用。</span><br><span class="line">docker run -it -v --volumes-from --name --rm --privileged 镜像名字 # 以交互式运行容器 --name 只是一个名称，可以不加 --rm docker容器退出时将自动删除，注意如果容器运行在后台模式是不能带--rm的.需要映射多个端口使用多个-p 选项</span><br><span class="line">docker run 镜像名字 echo “hello world” # 在容器的shell中输出helloworld</span><br><span class="line">docker logs 容器id #显示容器的标准输出</span><br><span class="line">docker attach 容器id #重新进入关闭的容器</span><br><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure><p>docker命令结构:</p><p>首先有两个方面，一个是docker镜像制作端，一个是用户使用端类似C/S 架构。</p><p>使用docker build命令结合dockerfile可以创建管理镜像,创建完后可以push到docker hub。</p><p>用户可以通过从网上拉取制作好的镜像,拉取到本地,运行容器。</p><p>使用docker pull时,可以从官方docker hub中的官方镜像库,其他公共库,私人仓库,拉取镜像资源,同时也可以拉取私有服务器中获取镜像资源，只需指定特定的库名,或服务器地址即可。</p><p>如何临时退出一个正在交互的容器，而不是终止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按ctrl-p+ctrl-q   #ctrl -c 是终止停止进程</span><br></pre></td></tr></table></figure><p>构建docker镜像应该遵循的原则,请参考官方文档，dockerfile最佳实践:</p><p>尽量选取满足需求但较小的基础系统镜像，例如大部分时候可以选择 debian:wheezy 或 debian:jessie 镜像，仅有不足百兆大小; </p><p>清理编译生成文件、安装包的缓存等临时文件; 安装各个软件时候要指定准确的版本号，并避免引入不需要的依赖; </p><p>从安全角度考虑，应用要尽量使用系统的库和依赖; 如果安装应用时候需要配置一些特殊的环境变量，</p><p>在安装后要还原不需要保持 的变量值; </p><p>使用 Dockerfile 创建镜像时候要添加 .dockerignore 文件或使用干净的工作目 录。</p><p>在构建docker容器时可以控制容器占用系统资源，调整系统硬件资源，例如cpu，内存，io等。</p><p>查看容器映射出来的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -f name=nginx</span><br></pre></td></tr></table></figure><p>查看容器内应用监听的端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -ti global_nginx_1 ss -lntp</span><br></pre></td></tr></table></figure><p>制作镜像</p><pre><code>两种办法:1.使用Dockerfile,使用docker commit 将容器提交保存为镜像.##最好使用Dockerfile来构建镜像,不推荐docker commit方法。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">首先编辑一个空白的文本文件命名为DockerfIle，每一个指令的前缀都必须是大写的。</span><br><span class="line">FROM centos    #从centos 这个镜像文件中构建,from字段必须是第一个，可以有多个from</span><br><span class="line">在文件中可以写入运行命令使其在docker容器中运行</span><br><span class="line">RUN echo ’hello world‘ ##在容器中运行的指令</span><br><span class="line">CMD ##</span><br><span class="line">ENV ##后续的指令可以调用变量 $&#123;variable_name&#125;</span><br><span class="line">WORKDIR ##</span><br><span class="line">MAINTAINER ## dockerfile会根据上下文执行的命令，使用缓存，如果修改了使用者名称，将刷新缓存</span><br><span class="line">EXPOSE ## 端口宣告</span><br><span class="line">ADD ##</span><br><span class="line">COPY ##</span><br><span class="line">docker build -t 给镜像一个名称 . #注意，最后有个点，这条命令会读取当前目录下的所有文件以及目录和Dockerfile文件，建议创建新目录来build</span><br><span class="line"></span><br><span class="line">之后使用 docker images 就可以看到自己建立的镜像了，使用docker history 镜像id 就可以查看到刚刚容器的输出结果了。注意这个创建的镜像是不可以开启新的容器的 官方的解释 &quot;Notice the new changed-ubuntu image does not have its own copies of every layer. As can be seen in the diagram below, the new image is sharing its four underlying layers with the ubuntu:15.04 image.&quot;</span><br><span class="line">并且使用 docker history 可以看到刚刚通过文件输出镜像的大小只有11b，这种只是个共享图像层。</span><br><span class="line">一旦你构建或创建了一个新的镜像，你可以使用 docker push 命令将镜像推送到 Docker Hub 。这样你就可以分享你的镜像了，镜像可以是公开的，或者你可以把镜像添加到你的私有仓库中。</span><br></pre></td></tr></table></figure><p>Docker Volumes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">docker volumes 是一个存储卷,它可以使宿主机与容器里面共享数据,这个数据卷可以是系统文件上的任何一个目录,你可以挂在任意个Volumes 到容器里,多个容器也可以共享一个或多个数据量。</span><br><span class="line">docker run --volumes-from </span><br><span class="line">如果你有一些持久化的数据， 并且想在不同的container之间共享这些数据， 或者想在一些没有持久化的container中使用， </span><br><span class="line">最好的方法就是使用 Data Volumn Container, </span><br><span class="line">在把数据mount到你的container里.(译者：如开篇译者提到的docker的container是无状态的， </span><br><span class="line">也就是说标记状态的数据，例如：数据库数据， 应用程序的log 等等， 是不应该放到container里的， 而是放到 Data Volume </span><br><span class="line">Container里, 这点和funcational programming很像， 所以我喜欢把一般的docker container 叫做 </span><br><span class="line">functional container用来区分 data volume container ）</span><br><span class="line">这里的意思相当于有个最简洁的容器来专门跑存储容器，之后的启动的容器都可以使用 docker run --volumes-from 从存储数据容器中来实现数据的共享。</span><br><span class="line">$ docker run -d -v /dbdata --name dbdata training/postgres</span><br><span class="line"> </span><br><span class="line">这样做之后就可以通过 --volumes-from 把 /dbdata mount到其他的container里了</span><br><span class="line"></span><br><span class="line">$ docker run -d --volumes-from dbdata --name db1 training/postgres</span><br><span class="line"> </span><br><span class="line">还可以继续共享到另外一个container里</span><br><span class="line"></span><br><span class="line">$ docker run -d --volumes-from dbdata --name db2 training/postgres</span><br><span class="line"> </span><br><span class="line">-volumes-from 可以多次使用来 mount 多个conatainer里的多个volumes。</span><br><span class="line"></span><br><span class="line">这个操作是链式的， 我们在db1 中通过 --volumes-from mount进来的 volume可以继续被其他container使用</span><br><span class="line"></span><br><span class="line">$ docker run -d --name db3 --volumes-from db1 training/postgres</span><br><span class="line"> </span><br><span class="line">(译者:</span><br><span class="line"> 这里我们不是直接使用 volume container， 而是使用db1 这个functional container 把volume </span><br><span class="line">挂载到另外一个 funcational container上的，所谓的链式就是 dbdata -&gt; db1 -&gt; db3)</span><br><span class="line"></span><br><span class="line">如果你把所有mount volumes的container都移除掉， 包括初始化的那个 dbdata container， volume才会被移除掉。通过这个属性可以方便的升级升级数据或者在不同container间migrate数据.</span><br><span class="line"></span><br><span class="line">备份、恢复和移植数据卷</span><br><span class="line"></span><br><span class="line">Volume的另外一个用处就是备份、恢复和migrate数据。 具体的做法如下，使用 --volumes-from 来创建一个新的container mount这个volume</span><br><span class="line"></span><br><span class="line">$ sudo docker run --volumes-from dbdata -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata</span><br><span class="line"> </span><br><span class="line">&gt;</span><br><span class="line">    这里我们启动了一个新的container， </span><br><span class="line">从 dbdata 挂载了一个volume。同时挂载了一个本地目录到这个container里。最后我们通过一个 tar命令把 dbdata 里的数据备份到了 /backup 里。命令结束并且停止这个container后我们就在本地得到了一个备份的数据.</span><br><span class="line"></span><br><span class="line">(译者: 这里使用的 ubuntu container， 就是为了把volume中的数据打包备份到host的某一个目录里。)</span><br><span class="line"></span><br><span class="line">备份的数据可以恢复到这个container， 或者其他使用这个volume的container。首先创建一个container</span><br><span class="line"></span><br><span class="line">$ sudo docker run -v /dbdata --name dbdata2 ubuntu</span><br><span class="line"> </span><br><span class="line">&gt;    之后un-tar备份文件到 data volume 里</span><br><span class="line"></span><br><span class="line">$ sudo docker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar</span><br><span class="line"> </span><br><span class="line">你可以使用你喜欢的工具加上上面的技术来自动备份，迁移和恢复数据</span><br></pre></td></tr></table></figure><p>实践:在Docker容器中运行web应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先docker pull nginx 或者制作好web应用的镜像.</span><br><span class="line">docker run -idt -p 80:80 -v /docker/download/:/data/ download:1 #以后台进程运行</span><br><span class="line">docker exec 容器id nginx #使用docker exec执行nginx 启动命令</span><br><span class="line">docker top #查看容器内的进程运行状态</span><br></pre></td></tr></table></figure><p>开启动一个长时间运行的后台进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=$(docker run -d centos /bin/bash -c &quot;while true; do echo hello world; sleep 1; done&quot;)</span><br><span class="line"></span><br><span class="line">docker logs $a ##将会看到有hello world</span><br></pre></td></tr></table></figure><h4 id="删除Docker镜像"><a href="#删除Docker镜像" class="headerlink" title="删除Docker镜像"></a>删除Docker镜像</h4><p>首先要保证有权限对Docker镜像或者容器进行操作，具体做法参见进入前文安装部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 停止所有容器</span><br><span class="line">$ docker stop $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line"># 删除指定镜像</span><br><span class="line">$ docker rmi $image</span><br><span class="line"></span><br><span class="line"># 删除无标示镜像，即id为&lt;None&gt;的镜像</span><br><span class="line">$ docker rmi $(docker images | grep &quot;^&lt;none&gt;&quot; | awk &quot;&#123;print $3&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 删除所有镜像</span><br><span class="line">$ docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><h3 id="在Docker构建nginx容器-在构建Dockerfile时应在空目录下构建"><a href="#在Docker构建nginx容器-在构建Dockerfile时应在空目录下构建" class="headerlink" title="在Docker构建nginx容器 #在构建Dockerfile时应在空目录下构建"></a>在Docker构建nginx容器 #在构建Dockerfile时应在空目录下构建</h3><h4 id="构建dockerfile"><a href="#构建dockerfile" class="headerlink" title="构建dockerfile"></a>构建dockerfile</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat&lt;&lt;\EOF &gt; Dockerfile </span><br><span class="line"># Nginx</span><br><span class="line">#</span><br><span class="line"># Version 1.0</span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER djluo &lt;dj.luo@baoyugame.com&gt;</span><br><span class="line">RUN rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="line">RUN yum -y install nginx; yum clean all</span><br><span class="line">EOF</span><br><span class="line">#通过Dockerfile在容器中安装nginx</span><br><span class="line">docker build -t nginx:1.0 . #-t 只是个版本名称</span><br></pre></td></tr></table></figure><h4 id="进入容器修改配置文件"><a href="#进入容器修改配置文件" class="headerlink" title="进入容器修改配置文件:"></a>进入容器修改配置文件:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bash-4.2# </span><br><span class="line">bash-4.2# rm conf.d/&#123;default.conf,example_ssl.conf&#125;</span><br><span class="line">bash-4.2# rm -f /etc/nginx/&#123;koi-utf,koi-win,scgi_params,uwsgi_params,win-utf&#125;</span><br><span class="line">bash-4.2# cat&lt;&lt;\EOF &gt; /etc/nginx/conf.d/download.conf </span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    root       /data/html;</span><br><span class="line">    access_log /data/logs/download.log;</span><br><span class="line">    location / &#123;</span><br><span class="line">        autoindex on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">bash-4.2# mkdir -p /data/&#123;html,logs&#125;</span><br><span class="line">bash-4.2# /usr/sbin/nginx -t </span><br><span class="line">bash-4.2# exit</span><br></pre></td></tr></table></figure><h4 id="制作成镜像commit"><a href="#制作成镜像commit" class="headerlink" title="制作成镜像commit:"></a>制作成镜像commit:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps -l # 获取最新的一个容器信息，通常就是上面操作的了。</span><br><span class="line">docker commit -a &quot;djluo &lt;dj.luo@baoyugame.com&gt;&quot; -m &quot;用于docker build的下载环境&quot; 07d7a871cf32 download:1</span><br><span class="line">docker rm 07d7a871cf32 # 删除容器</span><br></pre></td></tr></table></figure><h4 id="构建Nginx的主目录和日志目录"><a href="#构建Nginx的主目录和日志目录" class="headerlink" title="构建Nginx的主目录和日志目录:"></a>构建Nginx的主目录和日志目录:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/docker/download/&#123;html,logs&#125;</span><br><span class="line">echo &quot;Hi&quot; &gt; ~/docker/download/html/index.html</span><br></pre></td></tr></table></figure><h4 id="正式运行下载环境的容器：需要映射端口，公网访问"><a href="#正式运行下载环境的容器：需要映射端口，公网访问" class="headerlink" title="正式运行下载环境的容器：需要映射端口，公网访问"></a>正式运行下载环境的容器：需要映射端口，公网访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 --name download -v /docker/download/:/data/ download:1 /usr/sbin/nginx</span><br><span class="line">#将docker容器里的80端口映射到宿主机的80，好让外网访问，-v共享存储卷，将宿主机的目录数据挂载到容器里  并且启动nginx</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正确的用法：应该是分为2个容器，应用容器和管理容器。</span><br><span class="line">应用容器：跑具体的应用，如nginx、java、php等。将应用数据放到VOULME中。</span><br><span class="line">管理容器：跑SSHD，并挂载上应用容器的数据VOULME。随心所欲的操作吧。</span><br><span class="line">不过有些应用的重启、重新导入配置等，可能需要到容器外操作</span><br><span class="line">docker守护进进程(服务端)默认以unixsocket方式启动，如果需要用到远程调用需要使用remoteapi</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">以下是一个RUN格式正确的指导，显示所有apt-get 建议。</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">    aufs-tools \</span><br><span class="line">    automake \</span><br><span class="line">    build-essential \</span><br><span class="line">    curl \</span><br><span class="line">    dpkg-sig \</span><br><span class="line">    libcap-dev \</span><br><span class="line">    libsqlite3-dev \</span><br><span class="line">    mercurial \</span><br><span class="line">    reprepro \</span><br><span class="line">    ruby1.9.1 \</span><br><span class="line">    ruby1.9.1-dev \</span><br><span class="line">    s3cmd=1.1.* \</span><br><span class="line"> &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line">####################ENTRYPOINT###############################</span><br><span class="line">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] （exec表格，首选）</span><br></pre></td></tr></table></figure><p>docker 默认本地的仓库目录，存储着push的镜像。</p><p>这个目录默认是100g，超过了将会push失败，所以建议定时清理。</p><h3 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp &lt;containerId&gt;:/file/path/within/container /host/path/target</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker 镜像导入和导出</span><br><span class="line">导出镜像</span><br><span class="line">docker save -o centos7.tar centos</span><br><span class="line">导入本地镜像</span><br><span class="line">sudo docker load --input centos7.tar</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker有两个概念需要搞清楚,镜像与容器。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
</feed>

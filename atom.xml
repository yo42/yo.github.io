<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yo42</title>
  
  <subtitle>Dont&#39;t Panic,Do not go gentle into that good night~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yo42.github.io/"/>
  <updated>2019-02-13T02:08:04.528Z</updated>
  <id>https://yo42.github.io/</id>
  
  <author>
    <name>Yo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手动搭建k8s集群</title>
    <link href="https://yo42.github.io/2019/01/29/%E6%90%AD%E5%BB%BAk8s%E9%9B%86%E7%BE%A4/"/>
    <id>https://yo42.github.io/2019/01/29/搭建k8s集群/</id>
    <published>2019-01-29T02:34:08.394Z</published>
    <updated>2019-02-13T02:08:04.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集群节点-初始化"><a href="#集群节点-初始化" class="headerlink" title="集群节点 初始化"></a>集群节点 初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure><h3 id="集群环境变量-amp-节点分发"><a href="#集群环境变量-amp-节点分发" class="headerlink" title="集群环境变量&amp;节点分发"></a>集群环境变量&amp;节点分发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"># TLS Bootstrapping 使用的Token，可以使用命令 head -c 16 /dev/urandom | od -An -t x | tr -d &apos; &apos; 生成</span><br><span class="line">BOOTSTRAP_TOKEN=&quot;a4b521597f9938eaf36a82177c7c6f3a&quot;</span><br><span class="line"></span><br><span class="line"># 最好使用 当前未用的网段 来定义服务网段和 Pod 网段</span><br><span class="line"></span><br><span class="line"># 服务网段，部署前路由不可达，部署后集群内路由可达(kube-proxy 和 ipvs 保证)</span><br><span class="line">export SERVICE_CIDR=&quot;10.100.0.0/16&quot;</span><br><span class="line"></span><br><span class="line"># Pod 网段，建议 /16 段地址，部署前路由不可达，部署后集群内路由可达(flanneld 保证)</span><br><span class="line">export CLUSTER_CIDR=&quot;10.200.0.0/16&quot;</span><br><span class="line"></span><br><span class="line"># 服务端口范围 (NodePort Range)</span><br><span class="line">export NODE_PORT_RANGE=&quot;30000-32766&quot;</span><br><span class="line"></span><br><span class="line"># 集群各机器 IP 数组</span><br><span class="line">export NODE_IPS=&quot;10.1.2.30 10.1.2.1 10.1.2.2&quot;</span><br><span class="line">export NODE_IP=&quot;10.1.2.30&quot;</span><br><span class="line"></span><br><span class="line"># 集群各 IP 对应的 主机名数组</span><br><span class="line">export NODE_NAME=kube-master1</span><br><span class="line"></span><br><span class="line"># kube-apiserver 的 VIP（HA 组件 keepalived 发布的 IP）</span><br><span class="line">#export MASTER_VIP=172.27.129.253</span><br><span class="line"># MASTER API Server 地址</span><br><span class="line">MASTER_URL=&quot;hhht-k8s-api.virtual.local&quot;</span><br><span class="line"></span><br><span class="line"># kube-apiserver VIP 地址（HA 组件 haproxy 监听 6443 端口）</span><br><span class="line">export KUBE_APISERVER=&quot;https://$&#123;MASTER_URL&#125;:6443&quot;</span><br><span class="line"></span><br><span class="line"># HA 节点，配置 VIP 的网络接口名称</span><br><span class="line">#export VIP_IF=&quot;eth0&quot;</span><br><span class="line"></span><br><span class="line"># etcd 集群服务地址列表</span><br><span class="line">export ETCD_ENDPOINTS=&quot;https://10.1.2.30:2379,https://10.1.2.1:2379,https://10.1.2.2:2379&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># etcd 集群间通信的 IP 和端口</span><br><span class="line">export ETCD_NODES=&quot;kube-master1=https://10.1.2.30:2380,kube-master2=https://10.1.2.1:2380,kube-master3=https://10.1.2.2:2380&quot;</span><br><span class="line"></span><br><span class="line"># flanneld 网络配置前缀</span><br><span class="line">export FLANNEL_ETCD_PREFIX=&quot;/kubernetes/network&quot;</span><br><span class="line"></span><br><span class="line"># kubernetes 服务IP(预先分配，一般为SERVICE_CIDR中的第一个IP)</span><br><span class="line">export CLUSTER_KUBERNETES_SVC_IP=&quot;10.100.0.1&quot;</span><br><span class="line"></span><br><span class="line"># 集群 DNS 服务IP(从SERVICE_CIDR 中预先分配)</span><br><span class="line">export CLUSTER_DNS_SVC_IP=&quot;10.100.0.2&quot;</span><br><span class="line"></span><br><span class="line"># 集群 DNS 域名</span><br><span class="line">export CLUSTER_DNS_DOMAIN=&quot;hhhtcluster.local.&quot;</span><br><span class="line"></span><br><span class="line"># 将二进制目录 /opt/k8s/bin 加到 PATH 中</span><br><span class="line">PATH=/usr/k8s/bin:$PATH</span><br><span class="line"></span><br><span class="line">PATH=/apps/svr/k8s/bin:$PATH</span><br></pre></td></tr></table></figure><p>复制到所有服务器上给以上文件执行权限然后修改系统变量</p><p>echo ‘source /apps/sh/env.sh’ &gt;&gt; ~/.bash_profile</p><p>将上面变量保存为: env.sh，然后将脚本拷贝到所有机器的/apps/sh/目录。</p><p>为方便后面迁移，我们在集群内定义一个域名用于访问apiserver，在每个节点的/etc/hosts文件中添加记录：10.1.2.30 hhht-k8s-api.virtual.local</p><p>其中10.1.2.30为master01 的IP，暂时使用该IP 来做apiserver 的负载地址</p><h3 id="创建CA证书和密钥-amp-节点分发"><a href="#创建CA证书和密钥-amp-节点分发" class="headerlink" title="创建CA证书和密钥&amp;节点分发"></a>创建CA证书和密钥&amp;节点分发</h3><h4 id="安装CFSSL工具集"><a href="#安装CFSSL工具集" class="headerlink" title="安装CFSSL工具集"></a>安装CFSSL工具集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">chmod +x cfssl_linux-amd64</span><br><span class="line">mv cfssl_linux-amd64 /usr/local/bin/cfssl</span><br><span class="line"></span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">chmod +x cfssljson_linux-amd64</span><br><span class="line">mv cfssljson_linux-amd64 /usr/local/bin/cfssljson</span><br><span class="line"></span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</span><br><span class="line">chmod +x cfssl-certinfo_linux-amd64</span><br><span class="line">mv cfssl-certinfo_linux-amd64 /usr/local/bin/cfssl-certinfo</span><br><span class="line"></span><br><span class="line">export PATH=/usr/local/bin:$PATH</span><br></pre></td></tr></table></figure><p>创建目录 mkdir -p /apps/conf/kubernetes/ssl</p><p>进入/apps/conf/kubernetes/ssl 目录新建以下2个文件</p><p>ca-config.json、ca-csr.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;signing&quot;: &#123;</span><br><span class="line">        &quot;default&quot;: &#123;</span><br><span class="line">            &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;profiles&quot;: &#123;</span><br><span class="line">            &quot;kubernetes&quot;: &#123;</span><br><span class="line">                &quot;expiry&quot;: &quot;87600h&quot;,</span><br><span class="line">                &quot;usages&quot;: [</span><br><span class="line">                    &quot;signing&quot;,</span><br><span class="line">                    &quot;key encipherment&quot;,</span><br><span class="line">                    &quot;server auth&quot;,</span><br><span class="line">                    &quot;client auth&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>config.json</code>：可以定义多个profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个profile；</li><li><code>signing</code>: 表示该证书可用于签名其它证书；生成的ca.pem 证书中<code>CA=TRUE</code>；</li><li><code>server auth</code>: 表示client 可以用该CA 对server 提供的证书进行校验；</li><li><code>client auth</code>: 表示server 可以用该CA 对client 提供的证书进行验证。</li></ul><p>ca-csr.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;BeiJing&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>CN</code>: <code>Common Name</code>，kube-apiserver 从证书中提取该字段作为请求的用户名(User Name)；浏览器使用该字段验证网站是否合法；</li><li><code>O</code>: <code>Organization</code>，kube-apiserver 从证书中提取该字段作为请求用户所属的组(Group)；</li></ul><h4 id="生成CA-证书和私钥："><a href="#生成CA-证书和私钥：" class="headerlink" title="生成CA 证书和私钥："></a>生成CA 证书和私钥：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br><span class="line">ls` `ca*</span><br><span class="line">ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem</span><br></pre></td></tr></table></figure><p>创建完成后把/apps/conf/kubernetes/ssl这个目录复制到所有master节点上</p><h3 id="部署etcd集群-节点x3"><a href="#部署etcd集群-节点x3" class="headerlink" title="部署etcd集群 (节点x3)"></a>部署etcd集群 (节点x3)</h3><p>kubernetes 系统使用etcd存储所有的数据，我们这里部署3个节点的etcd 集群，这3个节点直接复用kubernetes master的3个节点，分别命名为etcd01、etcd02、etcd03:</p><p>etcd01：10.1.2.30<br>etcd02：10.1.2.1<br>etcd03：10.1.2.2</p><p>修改3台master服务器的/apps/sh/env.sh文件的第31行左右</p><p>把以下内容修改为本机信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">####OTHER</span><br><span class="line">NODE_NAME=etcd01</span><br><span class="line">NODE_IP=10.1.2.30</span><br></pre></td></tr></table></figure><p>名字可以任意只要能区分就可以</p><p>IP填写本机IP</p><p>修改以下配置填入所有正确的ETCD地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NODE_IPS=&quot;172.18.49.242 172.18.49.243 172.18.49.244&quot;</span><br><span class="line"></span><br><span class="line">ETCD_NODES=etcd01=https://172.18.49.242:2380,etcd02=https://172.18.49.243:2380,etcd03=https://172.18.49.244:2380</span><br><span class="line"></span><br><span class="line">KUBE_APISERVER=&quot;https://$&#123;MASTER_URL&#125;:6443&quot;</span><br></pre></td></tr></table></figure><p>修改完毕后执行 source /apps/sh/env.sh 命令</p><p>echo $NODE_NAME</p><p>echo $NODE_IP</p><p>echo $ETCD_NODES</p><p>输出内容是你修改的内容即正确。</p><h3 id="创建TLS-密钥和证书"><a href="#创建TLS-密钥和证书" class="headerlink" title="创建TLS 密钥和证书"></a>创建TLS 密钥和证书</h3><p>为了保证通信安全，客户端(如etcdctl)与etcd 集群、etcd 集群之间的通信需要使用TLS 加密。</p><p>创建etcd 证书签名请求：</p><p>对应路径：/apps/conf/etcd/ssl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; etcd-csr.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;etcd&quot;,</span><br><span class="line">  &quot;hosts&quot;: [</span><br><span class="line">    &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;$&#123;NODE_IP&#125;&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>生成证书</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=/apps/conf/kubernetes/ssl/ca.pem   -ca-key=/apps/conf/kubernetes/ssl/ca-key.pem   -config=/apps/conf/kubernetes/ssl/ca-config.json   -profile=kubernetes etcd-csr.json | cfssljson -bare etcd</span><br></pre></td></tr></table></figure><h3 id="创建etcd-的systemd-unit-文件"><a href="#创建etcd-的systemd-unit-文件" class="headerlink" title="创建etcd 的systemd unit 文件"></a>创建etcd 的systemd unit 文件</h3><p>需要新建目录 /apps/lib/etcd/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; etcd.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Etcd Server</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Documentation=https://github.com/coreos</span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">WorkingDirectory=/apps/lib/etcd/</span><br><span class="line">ExecStart=/apps/svr/k8s/bin/etcd \\</span><br><span class="line">  --name=$&#123;NODE_NAME&#125; \\</span><br><span class="line">  --cert-file=/apps/conf/etcd/ssl/etcd.pem \\</span><br><span class="line">  --key-file=/apps/conf/etcd/ssl/etcd-key.pem \\</span><br><span class="line">  --peer-cert-file=/apps/conf/etcd/ssl/etcd.pem \\</span><br><span class="line">  --peer-key-file=/apps/conf/etcd/ssl/etcd-key.pem \\</span><br><span class="line">  --trusted-ca-file=/apps/conf/kubernetes/ssl/ca.pem \\</span><br><span class="line">  --peer-trusted-ca-file=/apps/conf/kubernetes/ssl/ca.pem \\</span><br><span class="line">  --initial-advertise-peer-urls=https://$&#123;NODE_IP&#125;:2380 \\</span><br><span class="line">  --listen-peer-urls=https://$&#123;NODE_IP&#125;:2380 \\</span><br><span class="line">  --listen-client-urls=https://$&#123;NODE_IP&#125;:2379,http://127.0.0.1:2379 \\</span><br><span class="line">  --advertise-client-urls=https://$&#123;NODE_IP&#125;:2379 \\</span><br><span class="line">  --initial-cluster-token=etcd-cluster-0 \\</span><br><span class="line">  --initial-cluster=$&#123;ETCD_NODES&#125; \\</span><br><span class="line">  --initial-cluster-state=new \\</span><br><span class="line">  --data-dir=/apps/lib/etcd</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>指定<code>etcd</code>的工作目录和数据目录为 /apps/lib/etcd/，需要在启动服务前创建这个目录；</li><li>为了保证通信安全，需要指定etcd 的公私钥(cert-file和key-file)、Peers通信的公私钥和CA 证书(peer-cert-file、peer-key-file、peer-trusted-ca-file)、客户端的CA 证书(trusted-ca-file)；</li><li><code>--initial-cluster-state</code>值为<code>new</code>时，<code>--name</code>的参数值必须位于<code>--initial-cluster</code>列表中；</li></ul><h3 id="启动etcd-服务"><a href="#启动etcd-服务" class="headerlink" title="启动etcd 服务"></a>启动etcd 服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp etcd.service /etc/systemd/system/</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable etcd</span><br><span class="line">systemctl start etcd</span><br><span class="line">systemctl status etcd</span><br></pre></td></tr></table></figure><p>最先启动的etcd 进程会卡住一段时间，等待其他节点启动加入集群，在所有的etcd 节点重复上面的步骤，直到所有的机器etcd 服务都已经启动。</p><h4 id="验证服务"><a href="#验证服务" class="headerlink" title="验证服务"></a>验证服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for ip in $&#123;NODE_IPS&#125;; do</span><br><span class="line">  ETCDCTL_API=3 /apps/svr/k8s/bin/etcdctl \</span><br><span class="line">  --endpoints=https://$&#123;ip&#125;:2379  \</span><br><span class="line">  --cacert=/apps/conf/kubernetes/ssl/ca.pem \</span><br><span class="line">  --cert=/apps/conf/etcd/ssl/etcd.pem \</span><br><span class="line">  --key=/apps/conf/etcd/ssl/etcd-key.pem \</span><br><span class="line">  endpoint health; done</span><br></pre></td></tr></table></figure><p><a href="https://10.1.2.30:2379" target="_blank" rel="noopener">https://10.1.2.30:2379</a> is healthy: successfully committed proposal: took = 2.436477ms<br><a href="https://10.1.2.1:2379" target="_blank" rel="noopener">https://10.1.2.1:2379</a> is healthy: successfully committed proposal: took = 2.893396ms<br><a href="https://10.1.2.2:2379" target="_blank" rel="noopener">https://10.1.2.2:2379</a> is healthy: successfully committed proposal: took = 2.621429ms</p><h4 id="配置kubectl-命令行工具"><a href="#配置kubectl-命令行工具" class="headerlink" title="配置kubectl 命令行工具"></a>配置kubectl 命令行工具</h4><p>在master服务器上安装</p><p>kubectl默认从~/.kube/config配置文件中获取访问kube-apiserver 地址、证书、用户名等信息，需要正确配置该文件才能正常使用kubectl命令。</p><p>需要将下载的kubectl 二进制文件和生产的~/.kube/config配置文件拷贝到需要使用kubectl 命令的机器上。</p><h4 id="创建admin-证书"><a href="#创建admin-证书" class="headerlink" title="创建admin 证书"></a>创建admin 证书</h4><p>kubectl 与kube-apiserver 的安全端口通信，需要为安全通信提供TLS 证书和密钥。创建admin 证书签名请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; admin-csr.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;admin&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;O&quot;: &quot;system:masters&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>后续kube-apiserver使用RBAC 对客户端(如kubelet、kube-proxy、Pod)请求进行授权<br>kube-apiserver 预定义了一些RBAC 使用的RoleBindings，如cluster-admin 将Group system:masters与Role cluster-admin绑定，该Role 授予了调用kube-apiserver所有API 的权限<br>O 指定了该证书的Group 为system:masters，kubectl使用该证书访问kube-apiserver时，由于证书被CA 签名，所以认证通过，同时由于证书用户组为经过预授权的system:masters，所以被授予访问所有API 的劝降<br>hosts 属性值为空列表</p><p>新建目录/apps/conf/kubectl/ssl 在目录中生成admin 证书和私钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=/apps/conf/kubernetes/ssl/ca.pem   -ca-key=/apps/conf/kubernetes/ssl/ca-key.pem   -config=/apps/conf/kubernetes/ssl/ca-config.json   -profile=kubernetes admin-csr.json | cfssljson -bare admin</span><br></pre></td></tr></table></figure><h4 id="创建kubectl-kubeconfig-文件"><a href="#创建kubectl-kubeconfig-文件" class="headerlink" title="创建kubectl kubeconfig 文件"></a>创建kubectl kubeconfig 文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl config set-cluster kubernetes   --certificate-authority=/apps/conf/kubernetes/ssl/ca.pem   --embed-certs=true   --server=$&#123;KUBE_APISERVER&#125;</span><br><span class="line">kubectl config set-credentials admin   --client-certificate=/apps/conf/kubectl/ssl/admin.pem   --embed-certs=true   --client-key=/apps/conf/kubectl/ssl/admin-key.pem   --token=$&#123;BOOTSTRAP_TOKEN&#125;</span><br><span class="line">kubectl config set-context kubernetes   --cluster=kubernetes   --user=admin</span><br><span class="line">kubectl config use-context kubernetes</span><br></pre></td></tr></table></figure><p>admin.pem证书O 字段值为system:masters，kube-apiserver 预定义的 RoleBinding cluster-admin 将 Group system:masters 与 Role cluster-admin 绑定，该 Role 授予了调用kube-apiserver 相关 API 的权限<br>生成的kubeconfig 被保存到 ~/.kube/config 文件</p><p>注意这里是配置连接信息的。如果发现连接不通可以到 ~/.kube/config 这里查看服务器配置是否都正确</p><h4 id="分发kubeconfig-文件"><a href="#分发kubeconfig-文件" class="headerlink" title="分发kubeconfig 文件"></a>分发kubeconfig 文件</h4><p>将~/.kube/config文件拷贝到运行kubectl命令的机器的~/.kube/目录下去。</p><h3 id="部署K8s-Master节点"><a href="#部署K8s-Master节点" class="headerlink" title="部署K8s Master节点"></a>部署K8s Master节点</h3><p>kubernetes master 节点包含的组件有：</p><p>kube-apiserver<br>kube-scheduler<br>kube-controller-manager</p><p>目前这3个组件需要部署到同一台机器上：（后面再部署高可用的master）</p><p>kube-scheduler、kube-controller-manager 和 kube-apiserver 三者的功能紧密相关；<br>同时只能有一个 kube-scheduler、kube-controller-manager 进程处于工作状态，如果运行多个，则需要通过选举产生一个 leader；</p><p>master 节点与node 节点上的Pods 通过Pod 网络通信，所以需要在master 节点上部署Flannel 网络。</p><h4 id="创建kubernetes-证书"><a href="#创建kubernetes-证书" class="headerlink" title="创建kubernetes 证书"></a>创建kubernetes 证书</h4><p>创建kubernetes 证书签名请求：</p><p>进入目录  /apps/conf/kubernetes/ssl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kubernetes-csr.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="line">  &quot;hosts&quot;: [</span><br><span class="line">    &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;$&#123;NODE_IP&#125;&quot;,</span><br><span class="line">    &quot;$&#123;MASTER_URL&#125;&quot;,</span><br><span class="line">    &quot;$&#123;CLUSTER_KUBERNETES_SVC_IP&#125;&quot;,</span><br><span class="line">    &quot;kubernetes&quot;,</span><br><span class="line">    &quot;kubernetes.default&quot;,</span><br><span class="line">    &quot;kubernetes.default.svc&quot;,</span><br><span class="line">    &quot;kubernetes.default.svc.cluster&quot;,</span><br><span class="line">    &quot;kubernetes.default.svc.cluster.local&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>如果 hosts 字段不为空则需要指定授权使用该证书的 <strong>IP 或域名列表</strong>，所以上面分别指定了当前部署的 master 节点主机 IP 以及apiserver 负载的内部域名</li><li>还需要添加 kube-apiserver 注册的名为 <code>kubernetes</code> 的服务 IP (Service Cluster IP)，一般是 kube-apiserver <code>--service-cluster-ip-range</code> 选项值指定的网段的<strong>第一个IP</strong></li></ul><h4 id="生成kubernetes-证书和私钥："><a href="#生成kubernetes-证书和私钥：" class="headerlink" title="生成kubernetes 证书和私钥："></a>生成kubernetes 证书和私钥：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=/apps/conf/kubernetes/ssl/ca.pem   -ca-key=/apps/conf/kubernetes/ssl/ca-key.pem   -config=/apps/conf/kubernetes/ssl/ca-config.json   -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes</span><br></pre></td></tr></table></figure><h4 id="配置和启动kube-apiserver"><a href="#配置和启动kube-apiserver" class="headerlink" title="配置和启动kube-apiserver"></a>配置和启动kube-apiserver</h4><h4 id="创建kube-apiserver-使用的客户端token-文件"><a href="#创建kube-apiserver-使用的客户端token-文件" class="headerlink" title="创建kube-apiserver 使用的客户端token 文件"></a>创建kube-apiserver 使用的客户端token 文件</h4><p>kubelet 首次启动时向kube-apiserver 发送TLS Bootstrapping 请求，kube-apiserver 验证请求中的token 是否与它配置的token.csv 一致，如果一致则自动为kubelet 生成证书和密钥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /apps/conf/kubernetes/</span><br><span class="line">cat &gt; token.csv &lt;&lt;EOF</span><br><span class="line">$&#123;BOOTSTRAP_TOKEN&#125;,kubelet-bootstrap,10001,&quot;system:kubelet-bootstrap&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="创建kube-apiserver-的systemd-unit文件"><a href="#创建kube-apiserver-的systemd-unit文件" class="headerlink" title="创建kube-apiserver 的systemd unit文件"></a>创建kube-apiserver 的systemd unit文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">cd /apps/sh</span><br><span class="line">cat  &gt; kube-apiserver.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes API Server</span><br><span class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/apps/svr/k8s/bin/kube-apiserver \\</span><br><span class="line">  --admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota \\</span><br><span class="line">  --advertise-address=$&#123;NODE_IP&#125; \\</span><br><span class="line">  --bind-address=0.0.0.0 \\</span><br><span class="line">  --insecure-bind-address=$&#123;NODE_IP&#125; \\</span><br><span class="line">  --authorization-mode=Node,RBAC \\</span><br><span class="line">  --runtime-config=rbac.authorization.k8s.io/v1alpha1 \\</span><br><span class="line">  --kubelet-https=true \\</span><br><span class="line">  --enable-bootstrap-token-auth \\</span><br><span class="line">  --token-auth-file=/apps/conf/kubernetes/token.csv \\</span><br><span class="line">  --service-cluster-ip-range=$&#123;SERVICE_CIDR&#125; \\</span><br><span class="line">  --service-node-port-range=$&#123;NODE_PORT_RANGE&#125; \\</span><br><span class="line">  --tls-cert-file=/apps/conf/kubernetes/ssl/kubernetes.pem \\</span><br><span class="line">  --tls-private-key-file=/apps/conf/kubernetes/ssl/kubernetes-key.pem \\</span><br><span class="line">  --client-ca-file=/apps/conf/kubernetes/ssl/ca.pem \\</span><br><span class="line">  --service-account-key-file=/apps/conf/kubernetes/ssl/ca-key.pem \\</span><br><span class="line">  --etcd-cafile=/apps/conf/kubernetes/ssl/ca.pem \\</span><br><span class="line">  --etcd-certfile=/apps/conf/kubernetes/ssl/kubernetes.pem \\</span><br><span class="line">  --etcd-keyfile=/apps/conf/kubernetes/ssl/kubernetes-key.pem \\</span><br><span class="line">  --etcd-servers=$&#123;ETCD_ENDPOINTS&#125; \\</span><br><span class="line">  --enable-swagger-ui=true \\</span><br><span class="line">  --allow-privileged=true \\</span><br><span class="line">  --apiserver-count=2 \\</span><br><span class="line">  --audit-log-maxage=30 \\</span><br><span class="line">  --audit-log-maxbackup=3 \\</span><br><span class="line">  --audit-log-maxsize=100 \\</span><br><span class="line">  --audit-log-path=/apps/logs/kubernetes/audit.log \\</span><br><span class="line">  --audit-policy-file=/apps/conf/kubernetes/audit-policy.yaml \\</span><br><span class="line">  --event-ttl=1h \\</span><br><span class="line">  --logtostderr=true \\</span><br><span class="line">  --v=6</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">Type=notify</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li><strong>1.9.x</strong>版本的，一定要注意上面的参数<code>experimental-bootstrap-token-auth</code>，需要替换成<code>enable-bootstrap-token-auth</code>，因为这个参数在<strong>1.9.x</strong>里面已经废弃掉了</li><li>kube-apiserver 1.6 版本开始使用 etcd v3 API 和存储格式</li><li><code>--authorization-mode=RBAC</code> 指定在安全端口使用RBAC 授权模式，拒绝未通过授权的请求</li><li>kube-scheduler、kube-controller-manager 一般和 kube-apiserver 部署在同一台机器上，它们使用<strong>非安全端口</strong>和 kube-apiserver通信</li><li>kubelet、kube-proxy、kubectl 部署在其它 Node 节点上，如果通过<strong>安全端口</strong>访问 kube-apiserver，则必须先通过 TLS 证书认证，再通过 RBAC 授权</li><li>kube-proxy、kubectl 通过使用证书里指定相关的 User、Group 来达到通过 RBAC 授权的目的</li><li>如果使用了 kubelet TLS Boostrap 机制，则不能再指定 <code>--kubelet-certificate-authority</code>、<code>--kubelet-client-certificate</code> 和 <code>--kubelet-client-key</code> 选项，否则后续 kube-apiserver 校验 kubelet 证书时出现 ”x509: certificate signed by unknown authority“ 错误</li><li><code>--admission-control</code> 值必须包含 <code>ServiceAccount</code>，否则部署集群插件时会失败</li><li><code>--bind-address</code> 不能为 <code>127.0.0.1</code></li><li><code>--service-cluster-ip-range</code> 指定 Service Cluster IP 地址段，该地址段不能路由可达</li><li><code>--service-node-port-range=${NODE_PORT_RANGE}</code> 指定 NodePort 的端口范围</li><li>缺省情况下 kubernetes 对象保存在<code>etcd/registry</code> 路径下，可以通过 <code>--etcd-prefix</code> 参数进行调整</li><li>kube-apiserver 1.8版本后需要在<code>--authorization-mode</code>参数中添加<code>Node</code>，即：<code>--authorization-mode=Node,RBAC</code>，否则Node 节点无法注册</li><li>注意要开启审查日志功能，指定<code>--audit-log-path</code>参数是不够的，这只是指定了日志的路径，还需要指定一个审查日志策略文件：<code>--audit-policy-file</code>，我们也可以使用日志收集工具收集相关的日志进行分析</li></ul><p>新建文件 audit-policy.yaml</p><p>在目录/apps/conf/kubernetes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: audit.k8s.io/v1beta1 # This is required.</span><br><span class="line">kind: Policy</span><br><span class="line"># Don&apos;t generate audit events for all requests in RequestReceived stage.</span><br><span class="line">omitStages:</span><br><span class="line">  - &quot;RequestReceived&quot;</span><br><span class="line">rules:</span><br><span class="line">  # Log pod changes at RequestResponse level</span><br><span class="line">  - level: RequestResponse</span><br><span class="line">    resources:</span><br><span class="line">    - group: &quot;&quot;</span><br><span class="line">      # Resource &quot;pods&quot; doesn&apos;t match requests to any subresource of pods,</span><br><span class="line">      # which is consistent with the RBAC policy.</span><br><span class="line">      resources: [&quot;pods&quot;]</span><br><span class="line">  # Log &quot;pods/log&quot;, &quot;pods/status&quot; at Metadata level</span><br><span class="line">  - level: Metadata</span><br><span class="line">    resources:</span><br><span class="line">    - group: &quot;&quot;</span><br><span class="line">      resources: [&quot;pods/log&quot;, &quot;pods/status&quot;]</span><br><span class="line"> </span><br><span class="line">  # Don&apos;t log requests to a configmap called &quot;controller-leader&quot;</span><br><span class="line">  - level: None</span><br><span class="line">    resources:</span><br><span class="line">    - group: &quot;&quot;</span><br><span class="line">      resources: [&quot;configmaps&quot;]</span><br><span class="line">      resourceNames: [&quot;controller-leader&quot;]</span><br><span class="line"> </span><br><span class="line">  # Don&apos;t log watch requests by the &quot;system:kube-proxy&quot; on endpoints or services</span><br><span class="line">  - level: None</span><br><span class="line">    users: [&quot;system:kube-proxy&quot;]</span><br><span class="line">    verbs: [&quot;watch&quot;]</span><br><span class="line">    resources:</span><br><span class="line">    - group: &quot;&quot; # core API group</span><br><span class="line">      resources: [&quot;endpoints&quot;, &quot;services&quot;]</span><br><span class="line"> </span><br><span class="line">  # Don&apos;t log authenticated requests to certain non-resource URL paths.</span><br><span class="line">  - level: None</span><br><span class="line">    userGroups: [&quot;system:authenticated&quot;]</span><br><span class="line">    nonResourceURLs:</span><br><span class="line">    - &quot;/api*&quot; # Wildcard matching.</span><br><span class="line">    - &quot;/version&quot;</span><br><span class="line"> </span><br><span class="line">  # Log the request body of configmap changes in kube-system.</span><br><span class="line">  - level: Request</span><br><span class="line">    resources:</span><br><span class="line">    - group: &quot;&quot; # core API group</span><br><span class="line">      resources: [&quot;configmaps&quot;]</span><br><span class="line">    # This rule only applies to resources in the &quot;kube-system&quot; namespace.</span><br><span class="line">    # The empty string &quot;&quot; can be used to select non-namespaced resources.</span><br><span class="line">    namespaces: [&quot;kube-system&quot;]</span><br><span class="line"> </span><br><span class="line">  # Log configmap and secret changes in all other namespaces at the Metadata level.</span><br><span class="line">  - level: Metadata</span><br><span class="line">    resources:</span><br><span class="line">    - group: &quot;&quot; # core API group</span><br><span class="line">      resources: [&quot;secrets&quot;, &quot;configmaps&quot;]</span><br><span class="line"> </span><br><span class="line">  # Log all other resources in core and extensions at the Request level.</span><br><span class="line">  - level: Request</span><br><span class="line">    resources:</span><br><span class="line">    - group: &quot;&quot; # core API group</span><br><span class="line">    - group: &quot;extensions&quot; # Version of group should NOT be included.</span><br><span class="line"> </span><br><span class="line">  # A catch-all rule to log all other requests at the Metadata level.</span><br><span class="line">  - level: Metadata</span><br><span class="line">    # Long-running requests like watches that fall under this rule will not</span><br><span class="line">    # generate an audit event in RequestReceived.</span><br><span class="line">    omitStages:</span><br><span class="line">      - &quot;RequestReceived&quot;</span><br></pre></td></tr></table></figure><p>审查日志的相关配置可以查看文档了解：<a href="https://kubernetes.io/docs/tasks/debug-application-cluster/audit/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/debug-application-cluster/audit/</a></p><h4 id="启动kube-apiserver"><a href="#启动kube-apiserver" class="headerlink" title="启动kube-apiserver"></a>启动kube-apiserver</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp kube-apiserver.service /etc/systemd/system/</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable kube-apiserver</span><br><span class="line">systemctl start kube-apiserver</span><br><span class="line">systemctl status kube-apiserver</span><br></pre></td></tr></table></figure><h4 id="配置和启动kube-controller-manager"><a href="#配置和启动kube-controller-manager" class="headerlink" title="配置和启动kube-controller-manager"></a>配置和启动kube-controller-manager</h4><h4 id="启动kube-controller-manager"><a href="#启动kube-controller-manager" class="headerlink" title="启动kube-controller-manager"></a>启动kube-controller-manager</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp kube-apiserver.service /etc/systemd/system/</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable kube-apiserver</span><br><span class="line">systemctl start kube-apiserver</span><br><span class="line">systemctl status kube-apiserver</span><br></pre></td></tr></table></figure><h4 id="配置和启动kube-scheduler"><a href="#配置和启动kube-scheduler" class="headerlink" title="配置和启动kube-scheduler"></a>配置和启动kube-scheduler</h4><h4 id="创建kube-scheduler-的systemd-unit文件"><a href="#创建kube-scheduler-的systemd-unit文件" class="headerlink" title="创建kube-scheduler 的systemd unit文件"></a>创建kube-scheduler 的systemd unit文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kube-controller-manager.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Controller Manager</span><br><span class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/apps/svr/k8s/bin/kube-controller-manager \\</span><br><span class="line">  --address=127.0.0.1 \\</span><br><span class="line">  --master=http://$&#123;MASTER_URL&#125;:8080 \\</span><br><span class="line">  --allocate-node-cidrs=true \\</span><br><span class="line">  --service-cluster-ip-range=$&#123;SERVICE_CIDR&#125; \\</span><br><span class="line">  --cluster-cidr=$&#123;CLUSTER_CIDR&#125; \\</span><br><span class="line">  --cluster-name=kubernetes \\</span><br><span class="line">  --cluster-signing-cert-file=/apps/conf/kubernetes/ssl/ca.pem \\</span><br><span class="line">  --cluster-signing-key-file=/apps/conf/kubernetes/ssl/ca-key.pem \\</span><br><span class="line">  --service-account-private-key-file=/apps/conf/kubernetes/ssl/ca-key.pem \\</span><br><span class="line">  --root-ca-file=/apps/conf/kubernetes/ssl/ca.pem \\</span><br><span class="line">  --leader-elect=true \\</span><br><span class="line">  --v=2</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li><code>--address</code> 值必须为 <code>127.0.0.1</code>，因为当前 kube-apiserver 期望 scheduler 和 controller-manager 在同一台机器</li><li><code>--master=http://${MASTER_URL}:8080</code>：使用<code>http</code>(非安全端口)与 kube-apiserver 通信，需要下面的<code>haproxy</code>启动成功后才能去掉8080端口</li><li><code>--leader-elect=true</code> 部署多台机器组成的 master 集群时选举产生一处于工作状态的 <code>kube-controller-manager</code> 进程</li></ul><h3 id="启动kube-scheduler"><a href="#启动kube-scheduler" class="headerlink" title="启动kube-scheduler"></a>启动kube-scheduler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp kube-scheduler.service /etc/systemd/system/</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable kube-scheduler</span><br><span class="line">systemctl start kube-scheduler</span><br><span class="line">systemctl status kube-scheduler</span><br></pre></td></tr></table></figure><h2 id="6-4-验证master-节点"><a href="#6-4-验证master-节点" class="headerlink" title="6.4 验证master 节点"></a>6.4 验证master 节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get componentstatuses</span><br></pre></td></tr></table></figure><p>NAME STATUS MESSAGE ERROR<br>controller-manager Healthy ok<br>scheduler Healthy ok<br>etcd-1 Healthy {“health”: “true”}<br>etcd-2 Healthy {“health”: “true”}<br>etcd-0 Healthy {“health”: “true”}</p><h3 id="关于k8s-master节点高可用"><a href="#关于k8s-master节点高可用" class="headerlink" title="关于k8s master节点高可用"></a>关于k8s master节点高可用</h3><p>目前所谓的 Kubernetes HA 其实主要的就是 API Server 的 HA，master 上其他组件比如 controller-manager 等都是可以通过 Etcd 做选举；而 API Server 只是提供一个请求接收服务，所以对于 API Server 一般有两种方式做 HA；一种是对多个 API Server 做 vip，另一种使用 nginx 反向代理，本文采用 nginx 方式</p><p><strong>master 之间除 api server 以外其他组件通过 etcd 选举，api server 默认不作处理；在每个 node 上启动一个 nginx，每个 nginx 反向代理所有 api server，node 上 kubelet、kube-proxy 连接本地的 nginx 代理端口，当 nginx 发现无法连接后端时会自动踢掉出问题的 api server，从而实现 api server 的 HA</strong></p><p>实际上是通过keepalived + haproxy实现的，其中keepalived是提供一个VIP，通过VIP关联所有的Master节点；然后haproxy提供端口转发功能。由于VIP还是存在Master的机器上的，默认配置API Server的端口是6443，所以我们需要将另外一个端口关联到这个VIP上，一般用8443。</p><p><code>haproxy</code>的确可以代理我们的两个master 上的apiserver 了，但是还不是高可用的，如果master01 这个节点down 掉了，那么我们haproxy 就不能正常提供服务了。这里我们可以使用两种方法来实现高可用</p><h4 id="方式1：使用阿里云SLB"><a href="#方式1：使用阿里云SLB" class="headerlink" title="方式1：使用阿里云SLB"></a>方式1：使用阿里云SLB</h4><p>这种方式实际上是最省心的，在阿里云上建一个内网的SLB，将master01 与master02 添加到SLB 机器组中，转发80(http)和443(https)端口即可（注意下面的提示）</p><blockquote><p>注意：阿里云的负载均衡是四层TCP负责，不支持后端ECS实例既作为Real Server又作为客户端向所在的负载均衡实例发送请求。因为返回的数据包只在云服务器内部转发，不经过负载均衡，所以在后端ECS实例上去访问负载均衡的服务地址是不通的。什么意思？就是如果你要使用阿里云的SLB的话，那么你不能在<code>apiserver</code>节点上使用SLB（比如在apiserver 上安装kubectl，然后将apiserver的地址设置为SLB的负载地址使用），因为这样的话就可能造成回环了，所以简单的做法是另外用两个新的节点做<code>HA</code>实例，然后将这两个实例添加到<code>SLB</code> 机器组中。</p></blockquote><h4 id="方式2：使用keepalived"><a href="#方式2：使用keepalived" class="headerlink" title="方式2：使用keepalived"></a>方式2：使用keepalived</h4><p><code>KeepAlived</code> 是一个高可用方案，通过 VIP（即虚拟 IP）和心跳检测来实现高可用。其原理是存在一组（两台）服务器，分别赋予 Master、Backup 两个角色，默认情况下Master 会绑定VIP 到自己的网卡上，对外提供服务。Master、Backup 会在一定的时间间隔向对方发送心跳数据包来检测对方的状态，这个时间间隔一般为 2 秒钟，如果Backup 发现Master 宕机，那么Backup 会发送ARP 包到网关，把VIP 绑定到自己的网卡，此时Backup 对外提供服务，实现自动化的故障转移，当Master 恢复的时候会重新接管服务。非常类似于路由器中的虚拟路由器冗余协议（VRRP）</p><h4 id="安装haproxy、keepalived"><a href="#安装haproxy、keepalived" class="headerlink" title="安装haproxy、keepalived"></a>安装haproxy、keepalived</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y haproxy keepalived</span><br></pre></td></tr></table></figure><h4 id="配置haproxy"><a href="#配置haproxy" class="headerlink" title="配置haproxy"></a>配置haproxy</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">frontend k8s-api</span><br><span class="line">    bind 192.168.1.137:443</span><br><span class="line">    mode tcp</span><br><span class="line">    option tcplog</span><br><span class="line">    tcp-request inspect-delay 5s</span><br><span class="line">    tcp-request content accept if &#123; req.ssl_hello_type 1 &#125;</span><br><span class="line">    default_backend k8s-api</span><br><span class="line"></span><br><span class="line">backend k8s-api</span><br><span class="line">    mode tcp</span><br><span class="line">    option tcplog</span><br><span class="line">    option tcp-check</span><br><span class="line">    balance roundrobin</span><br><span class="line">    default-server inter 10s downinter 5s rise 2 fall 2 slowstart 60s maxconn 250 maxqueue 256 weight 100</span><br><span class="line">    server k8s-api-1 192.168.1.137:6443 check</span><br><span class="line">    server k8s-api-2 192.168.1.138:6443 check</span><br><span class="line"></span><br><span class="line">frontend k8s-http-api</span><br><span class="line">    bind 192.168.1.137:80</span><br><span class="line">    mode tcp</span><br><span class="line">    option tcplog</span><br><span class="line">    default_backend k8s-http-api</span><br><span class="line"></span><br><span class="line">backend k8s-http-api</span><br><span class="line">    mode tcp</span><br><span class="line">    option tcplog</span><br><span class="line">    option tcp-check</span><br><span class="line">    balance roundrobin</span><br><span class="line">    default-server inter 10s downinter 5s rise 2 fall 2 slowstart 60s maxconn 250 maxqueue 256 weight 100</span><br><span class="line">    server k8s-http-api-1 192.168.1.137:8080 check</span><br><span class="line">    server k8s-http-api-2 192.168.1.138:8080 check</span><br></pre></td></tr></table></figure><p>通过上面的配置文件我们可以看出通过<code>https</code>的访问将请求转发给apiserver 的6443端口了，http的请求转发到了apiserver 的8080端口。</p><h4 id="启动haproxy"><a href="#启动haproxy" class="headerlink" title="启动haproxy"></a>启动haproxy</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start haproxy</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> haproxy</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl status haproxy</span></span><br></pre></td></tr></table></figure><p>然后我们可以通过上面<code>9000</code>端口监控我们的<code>haproxy</code>的运行状态</p><p>上面我们的<code>haproxy</code>的确可以代理我们的两个master 上的apiserver 了，但是还不是高可用的，如果master01 这个节点down 掉了，那么我们haproxy 就不能正常提供服务了。这里我们可以使用两种方法来实现高可用</p><p><code>KeepAlived</code> 是一个高可用方案，通过 VIP（即虚拟 IP）和心跳检测来实现高可用。其原理是存在一组（两台）服务器，分别赋予 Master、Backup 两个角色，默认情况下Master 会绑定VIP 到自己的网卡上，对外提供服务。Master、Backup 会在一定的时间间隔向对方发送心跳数据包来检测对方的状态，这个时间间隔一般为 2 秒钟，如果Backup 发现Master 宕机，那么Backup 会发送ARP 包到网关，把VIP 绑定到自己的网卡，此时Backup 对外提供服务，实现自动化的故障转移，当Master 恢复的时候会重新接管服务。非常类似于路由器中的虚拟路由器冗余协议（VRRP）</p><p>我们这里将master01 设置为Master，master02 设置为Backup，修改配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi /etc/keepalived/keepalived.conf</span></span><br><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   router_id kube_api</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script check_haproxy &#123;</span><br><span class="line">    # 自身状态检测</span><br><span class="line">    script "killall -0 haproxy"</span><br><span class="line">    interval 3</span><br><span class="line">    weight 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance haproxy-vip &#123;</span><br><span class="line">    # 使用单播通信，默认是组播通信</span><br><span class="line">    unicast_src_ip 192.168.1.137</span><br><span class="line">    unicast_peer &#123;</span><br><span class="line">        192.168.1.138</span><br><span class="line">    &#125;</span><br><span class="line">    # 初始化状态</span><br><span class="line">    state MASTER</span><br><span class="line">    # 虚拟ip 绑定的网卡 （这里根据你自己的实际情况选择网卡）</span><br><span class="line">    interface eth0</span><br><span class="line">    # 此ID 要与Backup 配置一致</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    # 默认启动优先级，要比Backup 大点，但要控制量，保证自身状态检测生效</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        # 虚拟ip 地址</span><br><span class="line">        192.168.1.139</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_haproxy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.1.139 80 &#123;</span><br><span class="line">  delay_loop 5</span><br><span class="line">  lvs_sched wlc</span><br><span class="line">  lvs_method NAT</span><br><span class="line">  persistence_timeout 1800</span><br><span class="line">  protocol TCP</span><br><span class="line"></span><br><span class="line">  real_server 192.168.1.137 80 &#123;</span><br><span class="line">    weight 1</span><br><span class="line">    TCP_CHECK &#123;</span><br><span class="line">      connect_port 80</span><br><span class="line">      connect_timeout 3</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.1.139 443 &#123;</span><br><span class="line">  delay_loop 5</span><br><span class="line">  lvs_sched wlc</span><br><span class="line">  lvs_method NAT</span><br><span class="line">  persistence_timeout 1800</span><br><span class="line">  protocol TCP</span><br><span class="line"></span><br><span class="line">  real_server 192.168.1.137 443 &#123;</span><br><span class="line">    weight 1</span><br><span class="line">    TCP_CHECK &#123;</span><br><span class="line">      connect_port 443</span><br><span class="line">      connect_timeout 3</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>统一的方式在master02 节点上安装keepalived，修改配置，只需要将state 更改成BACKUP，priority更改成99，unicast_src_ip 与unicast_peer 地址修改即可。</p><p>启动keepalived:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl start keepalived</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">enable</span> keepalived</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看日志</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> journalctl -f -u keepalived</span></span><br></pre></td></tr></table></figure><p>验证虚拟IP:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用ifconfig -a 命令查看不到，要使用ip addr</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 00:16:3e:00:55:c1 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.1.137/24 brd 192.168.1.255 scope global dynamic eth0</span><br><span class="line">       valid_lft 31447746sec preferred_lft 31447746sec</span><br><span class="line">    inet 192.168.1.139/24 brd 192.168.1.255 scope global secondary eth0-vip</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><blockquote><p>到这里，我们就可以将上面的6443端口和8080端口去掉了，可以手动将<code>kubectl</code>生成的<code>config</code>文件(<code>~/.kube/config</code>)中的server 地址6443端口去掉，另外<code>kube-controller-manager</code>和<code>kube-scheduler</code>的<strong>–master</strong>参数中的8080端口去掉了，然后分别重启这两个组件即可。</p></blockquote><p>验证apiserver：关闭master01 节点上的kube-apiserver 进程，然后查看虚拟ip是否漂移到了master02 节点。</p><p>然后我们就可以将第一步在<code>/etc/hosts</code>里面设置的域名对应的IP 更改为我们的虚拟IP了</p><blockquote><p>master01 与master 02 节点都需要安装keepalived 和haproxy，实际上我们虚拟IP的自身检测应该是检测haproxy，脚本大家可以自行更改</p></blockquote><p>这样我们就实现了接入层apiserver 的高可用了，一个部分是多活的apiserver 服务，另一个部分是一主一备的haproxy 服务。</p><h4 id="kube-controller-manager-和kube-scheduler-的高可用"><a href="#kube-controller-manager-和kube-scheduler-的高可用" class="headerlink" title="kube-controller-manager 和kube-scheduler 的高可用"></a>kube-controller-manager 和kube-scheduler 的高可用</h4><p>Kubernetes 的管理层服务包括<code>kube-scheduler</code>和<code>kube-controller-manager</code>。kube-scheduler和kube-controller-manager使用一主多从的高可用方案，在<strong>同一时刻只允许一个服务</strong>处以具体的任务。Kubernetes中实现了一套简单的选主逻辑，依赖Etcd实现scheduler和controller-manager的选主功能。如果scheduler和controller-manager在启动的时候设置了<code>leader-elect</code>参数，它们在启动后会先尝试获取leader节点身份，只有在获取leader节点身份后才可以执行具体的业务逻辑。它们分别会在Etcd中创建kube-scheduler和kube-controller-manager的endpoint，endpoint的信息中记录了当前的leader节点信息，以及记录的上次更新时间。leader节点会定期更新endpoint的信息，维护自己的leader身份。每个从节点的服务都会定期检查endpoint的信息，如果endpoint的信息在时间范围内没有更新，它们会尝试更新自己为leader节点。scheduler服务以及controller-manager服务之间不会进行通信，利用Etcd的强一致性，能够保证在分布式高并发情况下leader节点的全局唯一性。整体方案如下图所示：</p><p>当集群中的leader节点服务异常后，其它节点的服务会尝试更新自身为leader节点，当有多个节点同时更新endpoint时，由Etcd保证只有一个服务的更新请求能够成功。通过这种机制sheduler和controller-manager可以保证在leader节点宕机后其它的节点可以顺利选主，保证服务故障后快速恢复。当集群中的网络出现故障时对服务的选主影响不是很大，因为scheduler和controller-manager是依赖Etcd进行选主的，在网络故障后，可以和Etcd通信的主机依然可以按照之前的逻辑进行选主，就算集群被切分，Etcd也可以保证同一时刻只有一个节点的服务处于leader状态。</p><h3 id="k8s-Node节点安装flannel网络"><a href="#k8s-Node节点安装flannel网络" class="headerlink" title="k8s Node节点安装flannel网络"></a>k8s Node节点安装flannel网络</h3><p>kubernetes 要求集群内各节点能通过Pod 网段互联互通，下面我们来使用Flannel 在所有节点上创建互联互通的Pod 网段的步骤。</p><h4 id="创建TLS-密钥和证书-1"><a href="#创建TLS-密钥和证书-1" class="headerlink" title="创建TLS 密钥和证书"></a>创建TLS 密钥和证书</h4><p>etcd 集群启用了双向TLS 认证，所以需要为flanneld 指定与etcd 集群通信的CA 和密钥。</p><p>创建flanneld 证书签名请求：</p><p>新建目录/apps/conf/flanneld/ssl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; flanneld-csr.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;flanneld&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>生成flanneld 证书和私钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=/apps/conf/kubernetes/ssl/ca.pem   -ca-key=/apps/conf/kubernetes/ssl/ca-key.pem   -config=/apps/conf/kubernetes/ssl/ca-config.json   -profile=kubernetes flanneld-csr.json | cfssljson -bare flanneld</span><br></pre></td></tr></table></figure><h4 id="向etcd-写入集群Pod-网段信息"><a href="#向etcd-写入集群Pod-网段信息" class="headerlink" title="向etcd 写入集群Pod 网段信息"></a>向etcd 写入集群Pod 网段信息</h4><p>该步骤只需在第一次部署Flannel 网络时执行，后续在其他节点上部署Flanneld 时无需再写入该信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl   --endpoints=$&#123;ETCD_ENDPOINTS&#125;   --ca-file=/apps/conf/kubernetes/ssl/ca.pem   --cert-file=/apps/conf/flanneld/ssl/flanneld.pem   --key-file=/apps/conf/flanneld/ssl/flanneld-key.pem   set $&#123;FLANNEL_ETCD_PREFIX&#125;/config &apos;&#123;&quot;Network&quot;:&quot;&apos;$&#123;CLUSTER_CIDR&#125;&apos;&quot;, &quot;SubnetLen&quot;: 24, &quot;Backend&quot;: &#123;&quot;Type&quot;: &quot;vxlan&quot;&#125;&#125;&apos;</span><br></pre></td></tr></table></figure><p>写入的 Pod 网段(${CLUSTER_CIDR}，10.200.0.0/16) 必须与<code>kube-controller-manager</code> 的 <code>--cluster-cidr</code> 选项值一致；</p><p>创建flanneld的systemd unit 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cd /apps/sh</span><br><span class="line">cat &gt; flanneld.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Flanneld overlay address etcd agent</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line">After=etcd.service</span><br><span class="line">Before=docker.service</span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/apps/svr/k8s/bin/flanneld \\</span><br><span class="line">  -etcd-cafile=/apps/conf/kubernetes/ssl/ca.pem \\</span><br><span class="line">  -etcd-certfile=/apps/conf/flanneld/ssl/flanneld.pem \\</span><br><span class="line">  -etcd-keyfile=/apps/conf/flanneld/ssl/flanneld-key.pem \\</span><br><span class="line">  -etcd-endpoints=$&#123;ETCD_ENDPOINTS&#125; \\</span><br><span class="line">  -etcd-prefix=$&#123;FLANNEL_ETCD_PREFIX&#125;</span><br><span class="line">ExecStartPost=/apps/svr/k8s/bin/mk-docker-opts.sh -k DOCKER_NETWORK_OPTIONS -d /run/flannel/docker</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">RequiredBy=docker.service</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li><code>mk-docker-opts.sh</code>脚本将分配给flanneld 的Pod 子网网段信息写入到<code>/run/flannel/docker</code> 文件中，后续docker 启动时使用这个文件中的参数值为 docker0 网桥</li><li>flanneld 使用系统缺省路由所在的接口和其他节点通信，对于有多个网络接口的机器(内网和公网)，可以用 <code>--iface</code> 选项值指定通信接口(上面的 systemd unit 文件没指定这个选项)</li></ul><h4 id="启动flanneld"><a href="#启动flanneld" class="headerlink" title="启动flanneld"></a>启动flanneld</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp flanneld.service /etc/systemd/system/</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable flanneld</span><br><span class="line">systemctl start flanneld</span><br></pre></td></tr></table></figure><h4 id="检查flanneld-服务"><a href="#检查flanneld-服务" class="headerlink" title="检查flanneld 服务"></a>检查flanneld 服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig flannel.1</span><br></pre></td></tr></table></figure><h4 id="检查分配给各flanneld-的Pod-网段信息"><a href="#检查分配给各flanneld-的Pod-网段信息" class="headerlink" title="检查分配给各flanneld 的Pod 网段信息"></a>检查分配给各flanneld 的Pod 网段信息</h4><p>查看集群 Pod 网段(/16)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">etcdctl \</span><br><span class="line"> --endpoints=$&#123;ETCD_ENDPOINTS&#125; \</span><br><span class="line"> --ca-file=/apps/conf/kubernetes/ssl/ca.pem \</span><br><span class="line"> --cert-file=/apps/conf/flanneld/ssl/flanneld.pem \</span><br><span class="line"> --key-file=/apps/conf/flanneld/ssl/flanneld-key.pem \</span><br><span class="line"> get $&#123;FLANNEL_ETCD_PREFIX&#125;/config</span><br></pre></td></tr></table></figure><p>{“Network”:”10.200.0.0/16”, “SubnetLen”: 24, “Backend”: {“Type”: “vxlan”}}</p><h3 id="部署-K8s-Node节点"><a href="#部署-K8s-Node节点" class="headerlink" title="部署 K8s Node节点"></a>部署 K8s Node节点</h3><p>kubernetes Node 节点包含如下组件：</p><ul><li>flanneld</li><li>docker</li><li>kubelet</li><li>kube-proxy</li></ul><h4 id="安装Docker基础环境"><a href="#安装Docker基础环境" class="headerlink" title="安装Docker基础环境"></a>安装Docker基础环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line">yum install docker-ce -y</span><br><span class="line">systemctl start docker &amp;&amp; systemctl enable docker</span><br></pre></td></tr></table></figure><h4 id="配置docker"><a href="#配置docker" class="headerlink" title="配置docker"></a>配置docker</h4><p>你可以用二进制或yum install 的方式来安装docker，然后修改docker 的systemd unit 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /usr/lib/systemd/system/docker.service  <span class="comment"># 用systemctl status docker 命令可查看unit 文件路径</span></span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">After=network-online.target firewalld.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line"><span class="meta">#</span><span class="bash"> the default is not to use systemd <span class="keyword">for</span> cgroups because the delegate issues still</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> exists and systemd currently does not support the cgroup feature <span class="built_in">set</span> required</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> containers run by docker</span></span><br><span class="line">EnvironmentFile=-/run/flannel/docker</span><br><span class="line">ExecStart=/usr/bin/dockerd --log-level=info $DOCKER_NETWORK_OPTIONS</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line"><span class="meta">#</span><span class="bash"> Having non-zero Limit*s causes performance problems due to accounting overhead</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> the kernel. We recommend using cgroups to <span class="keyword">do</span> container-local accounting.</span></span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line"><span class="meta">#</span><span class="bash"> Uncomment TasksMax <span class="keyword">if</span> your systemd version supports it.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Only systemd 226 and above support this version.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">TasksMax=infinity</span></span><br><span class="line">TimeoutStartSec=0</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> delegate yes so that systemd does not reset the cgroups of docker containers</span></span><br><span class="line">Delegate=yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">kill</span> only the docker process, not all processes <span class="keyword">in</span> the cgroup</span></span><br><span class="line">KillMode=process</span><br><span class="line"><span class="meta">#</span><span class="bash"> restart the docker process <span class="keyword">if</span> it exits prematurely</span></span><br><span class="line">Restart=on-failure</span><br><span class="line">StartLimitBurst=3</span><br><span class="line">StartLimitInterval=60s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>dockerd 运行时会调用其它 docker 命令，如 docker-proxy，所以需要将 docker 命令所在的目录加到 PATH 环境变量中</li><li>flanneld 启动时将网络配置写入到 <code>/run/flannel/docker</code> 文件中的变量 <code>DOCKER_NETWORK_OPTIONS</code>，dockerd 命令行上指定该变量值来设置 docker0 网桥参数</li><li>如果指定了多个 <code>EnvironmentFile</code> 选项，则必须将 <code>/run/flannel/docker</code> 放在最后(确保 docker0 使用 flanneld 生成的 bip 参数)</li><li>不能关闭默认开启的 <code>--iptables</code> 和 <code>--ip-masq</code> 选项</li><li>如果内核版本比较新，建议使用 <code>overlay</code> 存储驱动</li><li>docker 从 1.13 版本开始，可能将 <strong>iptables FORWARD chain的默认策略设置为DROP</strong>，从而导致 ping 其它 Node 上的 Pod IP 失败，遇到这种情况时，需要手动设置策略为 <code>ACCEPT</code>：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo iptables -P FORWARD ACCEPT</span></span><br></pre></td></tr></table></figure><p>如果没有开启上面的路由转发(<code>net.ipv4.ip_forward=1</code>)，则需要把以下命令写入<code>/etc/rc.local</code>文件中，防止节点重启<strong>iptables FORWARD chain的默认策略又还原为DROP</strong>（下面的开机脚本我测试了几次都没生效，不知道是不是方法有误，所以最好的方式还是开启上面的路由转发功能，一劳永逸）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep 60 &amp;&amp; /sbin/iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure><ul><li>为了加快 pull image 的速度，可以使用国内的仓库镜像服务器，同时增加下载的并发数。(如果 dockerd 已经运行，则需要重启 dockerd 生效。)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">  "max-concurrent-downloads": 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl stop firewalld</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">disable</span> firewalld</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo iptables -F &amp;&amp; sudo iptables -X &amp;&amp; sudo iptables -F -t nat &amp;&amp; sudo iptables -X -t nat</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker</span></span><br></pre></td></tr></table></figure><ul><li>需要关闭 firewalld(centos7)/ufw(ubuntu16.04)，否则可能会重复创建 iptables 规则</li><li>最好清理旧的 iptables rules 和 chains 规则</li><li>执行命令：docker version，检查docker服务是否正常</li></ul><h3 id="安装和配置kubelet"><a href="#安装和配置kubelet" class="headerlink" title="安装和配置kubelet"></a>安装和配置kubelet</h3><p>kubelet 启动时向kube-apiserver 发送TLS bootstrapping 请求，需要先将bootstrap token 文件中的kubelet-bootstrap 用户赋予system:node-bootstrapper 角色，然后kubelet 才有权限创建认证请求(certificatesigningrequests)：</p><blockquote><p>kubelet就是运行在Node节点上的，所以这一步安装是在所有的Node节点上，如果你想把你的Master也当做Node节点的话，当然也可以在Master节点上安装的。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create clusterrolebinding kubelet-bootstrap --clusterrole=system:node-bootstrapper --user=kubelet-bootstrap</span></span><br></pre></td></tr></table></figure><ul><li><code>--user=kubelet-bootstrap</code> 是文件 <code>/etc/kubernetes/token.csv</code> 中指定的用户名，同时也写入了文件 <code>/etc/kubernetes/bootstrap.kubeconfig</code></li></ul><p>另外1.8 版本中还需要为Node 请求创建一个RBAC 授权规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create clusterrolebinding kubelet-nodes --clusterrole=system:node --group=system:nodes</span></span><br></pre></td></tr></table></figure><p>然后下载最新的kubelet 和kube-proxy 二进制文件（前面下载kubernetes 目录下面其实也有）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://dl.k8s.io/v1.8.2/kubernetes-server-linux-amd64.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar -xzvf kubernetes-server-linux-amd64.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> kubernetes</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar -xzvf  kubernetes-src.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cp -r ./server/bin/&#123;kube-proxy,kubelet&#125; /usr/k8s/bin/</span></span><br></pre></td></tr></table></figure><h3 id="创建kubelet-bootstapping-kubeconfig-文件"><a href="#创建kubelet-bootstapping-kubeconfig-文件" class="headerlink" title="创建kubelet bootstapping kubeconfig 文件"></a>创建kubelet bootstapping kubeconfig 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置集群参数</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl config <span class="built_in">set</span>-cluster kubernetes \</span></span><br><span class="line">  --certificate-authority=/etc/kubernetes/ssl/ca.pem \</span><br><span class="line">  --embed-certs=true \</span><br><span class="line">  --server=$&#123;KUBE_APISERVER&#125; \</span><br><span class="line">  --kubeconfig=bootstrap.kubeconfig</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置客户端认证参数</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl config <span class="built_in">set</span>-credentials kubelet-bootstrap \</span></span><br><span class="line">  --token=$&#123;BOOTSTRAP_TOKEN&#125; \</span><br><span class="line">  --kubeconfig=bootstrap.kubeconfig</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置上下文参数</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl config <span class="built_in">set</span>-context default \</span></span><br><span class="line">  --cluster=kubernetes \</span><br><span class="line">  --user=kubelet-bootstrap \</span><br><span class="line">  --kubeconfig=bootstrap.kubeconfig</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置默认上下文</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl config use-context default --kubeconfig=bootstrap.kubeconfig</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv bootstrap.kubeconfig /etc/kubernetes/</span></span><br></pre></td></tr></table></figure><ul><li><code>--embed-certs</code> 为 <code>true</code> 时表示将 <code>certificate-authority</code> 证书写入到生成的 <code>bootstrap.kubeconfig</code> 文件中；</li><li>设置 kubelet 客户端认证参数时<strong>没有</strong>指定秘钥和证书，后续由 <code>kube-apiserver</code> 自动生成；</li></ul><h3 id="创建kubelet-的systemd-unit-文件"><a href="#创建kubelet-的systemd-unit-文件" class="headerlink" title="创建kubelet 的systemd unit 文件"></a>创建kubelet 的systemd unit 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir /var/lib/kubelet <span class="comment"># 必须先创建工作目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &gt; kubelet.service &lt;&lt;EOF</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Kubelet</span><br><span class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</span><br><span class="line">After=docker.service</span><br><span class="line">Requires=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">WorkingDirectory=/var/lib/kubelet</span><br><span class="line">ExecStart=/usr/k8s/bin/kubelet \\</span><br><span class="line">  --fail-swap-on=false \\</span><br><span class="line">  --cgroup-driver=cgroupfs \\</span><br><span class="line">  --address=$&#123;NODE_IP&#125; \\</span><br><span class="line">  --hostname-override=$&#123;NODE_IP&#125; \\</span><br><span class="line">  --experimental-bootstrap-kubeconfig=/etc/kubernetes/bootstrap.kubeconfig \\</span><br><span class="line">  --kubeconfig=/etc/kubernetes/kubelet.kubeconfig \\</span><br><span class="line">  --require-kubeconfig \\</span><br><span class="line">  --cert-dir=/etc/kubernetes/ssl \\</span><br><span class="line">  --cluster-dns=$&#123;CLUSTER_DNS_SVC_IP&#125; \\</span><br><span class="line">  --cluster-domain=$&#123;CLUSTER_DNS_DOMAIN&#125; \\</span><br><span class="line">  --hairpin-mode promiscuous-bridge \\</span><br><span class="line">  --allow-privileged=true \\</span><br><span class="line">  --serialize-image-pulls=false \\</span><br><span class="line">  --logtostderr=true \\</span><br><span class="line">  --v=2</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><blockquote><p><strong>请仔细阅读下面的注意事项，不然可能会启动失败</strong>。</p></blockquote><ul><li><code>--fail-swap-on</code>参数，这个一定要注意，<strong>Kubernetes 1.8开始要求关闭系统的Swap</strong>，如果不关闭，默认配置下kubelet将无法启动，也可以通过kubelet的启动参数<code>–fail-swap-on=false</code>来避免该问题</li><li><code>--cgroup-driver</code>参数，kubelet 用来维护主机的的 cgroups 的，默认是<code>cgroupfs</code>，但是这个地方的值需要你根据docker 的配置来确定（<code>docker info |grep cgroup</code>）</li><li><code>-address</code> 不能设置为 <code>127.0.0.1</code>，否则后续 Pods 访问 kubelet 的 API 接口时会失败，因为 Pods 访问的 <code>127.0.0.1</code>指向自己而不是 kubelet</li><li>如果设置了 <code>--hostname-override</code> 选项，则 <code>kube-proxy</code> 也需要设置该选项，否则会出现找不到 Node 的情况</li><li><code>--experimental-bootstrap-kubeconfig</code> 指向 bootstrap kubeconfig 文件，kubelet 使用该文件中的用户名和 token 向 kube-apiserver 发送 TLS Bootstrapping 请求</li><li>管理员通过了 CSR 请求后，kubelet 自动在 <code>--cert-dir</code> 目录创建证书和私钥文件(<code>kubelet-client.crt</code> 和 <code>kubelet-client.key</code>)，然后写入 <code>--kubeconfig</code> 文件(自动创建 <code>--kubeconfig</code> 指定的文件)</li><li>建议在 <code>--kubeconfig</code> 配置文件中指定 <code>kube-apiserver</code> 地址，如果未指定 <code>--api-servers</code> 选项，则必须指定 <code>--require-kubeconfig</code> 选项后才从配置文件中读取 kue-apiserver 的地址，否则 kubelet 启动后将找不到 kube-apiserver (日志中提示未找到 API Server），<code>kubectl get nodes</code> 不会返回对应的 Node 信息</li><li><code>--cluster-dns</code> 指定 kubedns 的 Service IP(可以先分配，后续创建 kubedns 服务时指定该 IP)，<code>--cluster-domain</code> 指定域名后缀，这两个参数同时指定后才会生效</li></ul><h3 id="启动kubelet"><a href="#启动kubelet" class="headerlink" title="启动kubelet"></a>启动kubelet</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cp kubelet.service /etc/systemd/system/kubelet.service</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> kubelet</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start kubelet</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl status kubelet</span></span><br></pre></td></tr></table></figure><h3 id="通过kubelet-的TLS-证书请求"><a href="#通过kubelet-的TLS-证书请求" class="headerlink" title="通过kubelet 的TLS 证书请求"></a>通过kubelet 的TLS 证书请求</h3><p>kubelet 首次启动时向kube-apiserver 发送证书签名请求，必须通过后kubernetes 系统才会将该 Node 加入到集群。查看未授权的CSR 请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get csr</span></span><br><span class="line">NAME                                                   AGE       REQUESTOR           CONDITION</span><br><span class="line">node-csr--k3G2G1EoM4h9w1FuJRjJjfbIPNxa551A8TZfW9dG-g   2m        kubelet-bootstrap   Pending</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes</span></span><br><span class="line">No resources found.</span><br></pre></td></tr></table></figure><p>通过CSR 请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl certificate approve node-csr--k3G2G1EoM4h9w1FuJRjJjfbIPNxa551A8TZfW9dG-g</span></span><br><span class="line">certificatesigningrequest "node-csr--k3G2G1EoM4h9w1FuJRjJjfbIPNxa551A8TZfW9dG-g" approved</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes</span></span><br><span class="line">NAME            STATUS    ROLES     AGE       VERSION</span><br><span class="line">192.168.1.170   Ready     &lt;none&gt;    48s       v1.8.1</span><br></pre></td></tr></table></figure><p>自动生成了kubelet kubeconfig 文件和公私钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l /etc/kubernetes/kubelet.kubeconfig</span></span><br><span class="line">-rw------- 1 root root 2280 Nov  7 10:26 /etc/kubernetes/kubelet.kubeconfig</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l /etc/kubernetes/ssl/kubelet*</span></span><br><span class="line">-rw-r--r-- 1 root root 1046 Nov  7 10:26 /etc/kubernetes/ssl/kubelet-client.crt</span><br><span class="line">-rw------- 1 root root  227 Nov  7 10:22 /etc/kubernetes/ssl/kubelet-client.key</span><br><span class="line">-rw-r--r-- 1 root root 1115 Nov  7 10:16 /etc/kubernetes/ssl/kubelet.crt</span><br><span class="line">-rw------- 1 root root 1675 Nov  7 10:16 /etc/kubernetes/ssl/kubelet.key</span><br></pre></td></tr></table></figure><h3 id="配置kube-proxy"><a href="#配置kube-proxy" class="headerlink" title="配置kube-proxy"></a>配置kube-proxy</h3><h4 id="创建kube-proxy-证书签名请求："><a href="#创建kube-proxy-证书签名请求：" class="headerlink" title="创建kube-proxy 证书签名请求："></a>创建kube-proxy 证书签名请求：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &gt; kube-proxy-csr.json &lt;&lt;EOF</span></span><br><span class="line">&#123;</span><br><span class="line">  "CN": "system:kube-proxy",</span><br><span class="line">  "hosts": [],</span><br><span class="line">  "key": &#123;</span><br><span class="line">    "algo": "rsa",</span><br><span class="line">    "size": 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  "names": [</span><br><span class="line">    &#123;</span><br><span class="line">      "C": "CN",</span><br><span class="line">      "ST": "BeiJing",</span><br><span class="line">      "L": "BeiJing",</span><br><span class="line">      "O": "k8s",</span><br><span class="line">      "OU": "System"</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>CN 指定该证书的 User 为 <code>system:kube-proxy</code></li><li><code>kube-apiserver</code> 预定义的 RoleBinding <code>system:node-proxier</code> 将User <code>system:kube-proxy</code> 与 Role <code>system:node-proxier</code>绑定，该 Role 授予了调用 <code>kube-apiserver</code> Proxy 相关 API 的权限</li><li>hosts 属性值为空列表</li></ul><h4 id="生成kube-proxy-客户端证书和私钥"><a href="#生成kube-proxy-客户端证书和私钥" class="headerlink" title="生成kube-proxy 客户端证书和私钥"></a>生成kube-proxy 客户端证书和私钥</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cfssl gencert -ca=/etc/kubernetes/ssl/ca.pem \</span></span><br><span class="line">  -ca-key=/etc/kubernetes/ssl/ca-key.pem \</span><br><span class="line">  -config=/etc/kubernetes/ssl/ca-config.json \</span><br><span class="line">  -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls kube-proxy*</span></span><br><span class="line">kube-proxy.csr  kube-proxy-csr.json  kube-proxy-key.pem  kube-proxy.pem</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mv kube-proxy*.pem /etc/kubernetes/ssl/</span></span><br></pre></td></tr></table></figure><h4 id="创建kube-proxy-kubeconfig-文件"><a href="#创建kube-proxy-kubeconfig-文件" class="headerlink" title="创建kube-proxy kubeconfig 文件"></a>创建kube-proxy kubeconfig 文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置集群参数</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl config <span class="built_in">set</span>-cluster kubernetes \</span></span><br><span class="line">  --certificate-authority=/etc/kubernetes/ssl/ca.pem \</span><br><span class="line">  --embed-certs=true \</span><br><span class="line">  --server=$&#123;KUBE_APISERVER&#125; \</span><br><span class="line">  --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置客户端认证参数</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl config <span class="built_in">set</span>-credentials kube-proxy \</span></span><br><span class="line">  --client-certificate=/etc/kubernetes/ssl/kube-proxy.pem \</span><br><span class="line">  --client-key=/etc/kubernetes/ssl/kube-proxy-key.pem \</span><br><span class="line">  --embed-certs=true \</span><br><span class="line">  --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置上下文参数</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl config <span class="built_in">set</span>-context default \</span></span><br><span class="line">  --cluster=kubernetes \</span><br><span class="line">  --user=kube-proxy \</span><br><span class="line">  --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置默认上下文</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv kube-proxy.kubeconfig /etc/kubernetes/</span></span><br></pre></td></tr></table></figure><ul><li>设置集群参数和客户端认证参数时 <code>--embed-certs</code> 都为 <code>true</code>，这会将 <code>certificate-authority</code>、<code>client-certificate</code> 和 <code>client-key</code> 指向的证书文件内容写入到生成的 <code>kube-proxy.kubeconfig</code> 文件中</li><li><code>kube-proxy.pem</code> 证书中 CN 为 <code>system:kube-proxy</code>，<code>kube-apiserver</code> 预定义的 RoleBinding <code>cluster-admin</code> 将User <code>system:kube-proxy</code> 与 Role <code>system:node-proxier</code> 绑定，该 Role 授予了调用 <code>kube-apiserver</code> Proxy 相关 API 的权限</li></ul><h4 id="创建kube-proxy-的systemd-unit-文件"><a href="#创建kube-proxy-的systemd-unit-文件" class="headerlink" title="创建kube-proxy 的systemd unit 文件"></a>创建kube-proxy 的systemd unit 文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir -p /var/lib/kube-proxy <span class="comment"># 必须先创建工作目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &gt; kube-proxy.service &lt;&lt;EOF</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Kube-Proxy Server</span><br><span class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">WorkingDirectory=/var/lib/kube-proxy</span><br><span class="line">ExecStart=/usr/k8s/bin/kube-proxy \\</span><br><span class="line">  --bind-address=$&#123;NODE_IP&#125; \\</span><br><span class="line">  --hostname-override=$&#123;NODE_IP&#125; \\</span><br><span class="line">  --cluster-cidr=$&#123;SERVICE_CIDR&#125; \\</span><br><span class="line">  --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig \\</span><br><span class="line">  --logtostderr=true \\</span><br><span class="line">  --v=2</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li><code>--hostname-override</code> 参数值必须与 kubelet 的值一致，否则 kube-proxy 启动后会找不到该 Node，从而不会创建任何 iptables 规则</li><li><code>--cluster-cidr</code> 必须与 kube-apiserver 的 <code>--service-cluster-ip-range</code> 选项值一致</li><li>kube-proxy 根据 <code>--cluster-cidr</code> 判断集群内部和外部流量，指定 <code>--cluster-cidr</code> 或 <code>--masquerade-all</code> 选项后 kube-proxy 才会对访问 Service IP 的请求做 SNAT</li><li><code>--kubeconfig</code> 指定的配置文件嵌入了 kube-apiserver 的地址、用户名、证书、秘钥等请求和认证信息</li><li>预定义的 RoleBinding <code>cluster-admin</code> 将User <code>system:kube-proxy</code> 与 Role <code>system:node-proxier</code> 绑定，该 Role 授予了调用 <code>kube-apiserver</code> Proxy 相关 API 的权限</li></ul><h4 id="启动kube-proxy"><a href="#启动kube-proxy" class="headerlink" title="启动kube-proxy"></a>启动kube-proxy</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cp kube-proxy.service /etc/systemd/system/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> kube-proxy</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start kube-proxy</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl status kube-proxy</span></span><br></pre></td></tr></table></figure><h3 id="验证集群功能"><a href="#验证集群功能" class="headerlink" title="验证集群功能"></a>验证集群功能</h3><p>定义yaml 文件：（将下面内容保存为：nginx-ds.yaml）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-ds</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx-ds</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx-ds</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-ds</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="string">addonmanager.kubernetes.io/mode:</span> <span class="string">Reconcile</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx-ds</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>创建 Pod 和服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f nginx-ds.yml</span></span><br><span class="line">service "nginx-ds" created</span><br><span class="line">daemonset "nginx-ds" created</span><br></pre></td></tr></table></figure><p>执行下面的命令查看Pod 和SVC：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -o wide</span></span><br><span class="line">NAME             READY     STATUS    RESTARTS   AGE       IP           NODE</span><br><span class="line">nginx-ds-f29zt   1/1       Running   0          23m       172.17.0.2   192.168.1.170</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc</span></span><br><span class="line">NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">nginx-ds     NodePort    10.254.6.249   &lt;none&gt;        80:30813/TCP   24m</span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li>服务IP：10.254.6.249</li><li>服务端口：80</li><li>NodePort端口：30813</li></ul><p>在所有 Node 上执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl 10.254.6.249</span><br><span class="line">$ curl 192.168.1.170:30813</span><br></pre></td></tr></table></figure><p>执行上面的命令预期都会输出nginx 欢迎页面内容，表示我们的Node 节点正常运行了。</p><h3 id="解决从k8s-gcr-io拉取镜像失败问题"><a href="#解决从k8s-gcr-io拉取镜像失败问题" class="headerlink" title="解决从k8s.gcr.io拉取镜像失败问题"></a>解决从k8s.gcr.io拉取镜像失败问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker pull mirrorgooglecontainers/kube-apiserver-amd64:v1.11.3</span><br><span class="line">docker pull mirrorgooglecontainers/kube-controller-manager-amd64:v1.11.3</span><br><span class="line">docker pull mirrorgooglecontainers/kube-scheduler-amd64:v1.11.3</span><br><span class="line">docker pull mirrorgooglecontainers/kube-proxy-amd64:v1.11.3</span><br><span class="line">docker pull mirrorgooglecontainers/pause:3.1</span><br><span class="line">docker pull mirrorgooglecontainers/etcd-amd64:3.2.18</span><br><span class="line">docker pull coredns/coredns:1.1.3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker tag docker.io/mirrorgooglecontainers/kube-proxy-amd64:v1.11.3 k8s.gcr.io/kube-proxy-amd64:v1.11.3</span><br><span class="line">docker tag docker.io/mirrorgooglecontainers/kube-scheduler-amd64:v1.11.3 k8s.gcr.io/kube-scheduler-amd64:v1.11.3</span><br><span class="line">docker tag docker.io/mirrorgooglecontainers/kube-apiserver-amd64:v1.11.3 k8s.gcr.io/kube-apiserver-amd64:v1.11.3</span><br><span class="line">docker tag docker.io/mirrorgooglecontainers/kube-controller-manager-amd64:v1.11.3 k8s.gcr.io/kube-controller-manager-amd64:v1.11.3</span><br><span class="line">docker tag docker.io/mirrorgooglecontainers/etcd-amd64:3.2.18  k8s.gcr.io/etcd-amd64:3.2.18</span><br><span class="line">docker tag docker.io/mirrorgooglecontainers/pause:3.1  k8s.gcr.io/pause:3.1</span><br><span class="line">docker tag docker.io/coredns/coredns:1.1.3  k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.qikqiak.com/post/manual-install-high-available-kubernetes-cluster/" target="_blank" rel="noopener">https://www.qikqiak.com/post/manual-install-high-available-kubernetes-cluster/</a></li><li><a href="https://github.com/mendickxiao/kubeasz/blob/master/docs/00-%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A.md" target="_blank" rel="noopener">https://github.com/mendickxiao/kubeasz/blob/master/docs/00-%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A.md</a></li><li><a href="https://jimmysong.io/kubernetes-handbook/practice/master-ha.html" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/practice/master-ha.html#</a></li><li><a href="https://www.kubernetes.org.cn/5025.html" target="_blank" rel="noopener">https://www.kubernetes.org.cn/5025.html</a></li><li><a href="https://www.kubernetes.org.cn/4963.html" target="_blank" rel="noopener">https://www.kubernetes.org.cn/4963.html</a></li><li><a href="https://k8s-install.opsnull.com/01.%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.html" target="_blank" rel="noopener">https://k8s-install.opsnull.com/01.%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.html</a></li><li><a href="https://kubernetes.feisky.xyz/bu-shu-pei-zhi/index" target="_blank" rel="noopener">https://kubernetes.feisky.xyz/bu-shu-pei-zhi/index</a></li><li><a href="https://mritd.me/2017/07/21/set-up-kubernetes-ha-cluster-by-binary/" target="_blank" rel="noopener">https://mritd.me/2017/07/21/set-up-kubernetes-ha-cluster-by-binary/</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;集群节点-初始化&quot;&gt;&lt;a href=&quot;#集群节点-初始化&quot; class=&quot;headerlink&quot; title=&quot;集群节点 初始化&quot;&gt;&lt;/a&gt;集群节点 初始化&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DevOps &amp; SRE 必备技能清单</title>
    <link href="https://yo42.github.io/2018/10/28/DevOps-SRE-%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E6%B8%85%E5%8D%95/"/>
    <id>https://yo42.github.io/2018/10/28/DevOps-SRE-必备技能清单/</id>
    <published>2018-10-28T03:45:57.769Z</published>
    <updated>2018-10-28T06:52:44.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul><li>这个列表并非详尽无遗，只是列举了技术基础、必须知道的技能和一些随机的想法。可以用它们作为一个清单来评估你自己或其他人，或者为下一次面试DevOps/SRE（Site Reliability Engineers，网站可靠性工程师）工作做准备。补充下，这个清单是比较个人的想法。</li></ul><p><strong>下一步是什么？更了解DevOps生态系统：</strong></p><ul><li>首先，一定要了解文化要点的重要性：在这里（<a href="http://w.san.wccnw.top/browse.php?u=Gp/XsLMboegkekS/h/8BHXb0sTOQAoHmBSzaAaweVgZL9wvn3ZkrIAh8m848ZkDJvewBfBudLtEkKJwX5q6rCTiNJyF6QA==&amp;b=13" target="_blank" rel="noopener">15点DevOps检查表</a> ）可以读到更多信息。</li><li>您应该掌握类Unix系统并且很好地理解Linux发行版的工作原理。</li><li>为产品设置选择一个操作系统。不需要掌握每一个操作系统，这会让你的工作陷入困境，选择其中一个并掌握它。</li><li>能轻松使用终端，可能有一些GUI来管理服务器，但是无论如何，必须热爱终端，它更快、更安全，坦白说，一旦掌握了用起来会更容易。</li><li>如何获取CPU/系统信息（cat /proc/version，/proc/cpuinfo，uptime，等。）</li><li>cron作业如何运作。在特定日期/时间/月设置cron作业。</li><li>了解在机器上运行的操作系统是什么（cat /etc/lsb-release）</li><li>了解不同的Linux操作系统之间的区别，以及了解在机器上运行的操作系统（例如cat /etc/lsb-release）</li><li>shell之间的区别：sh/dash/bash/ash/zsh</li><li>如何设置和取消设置ENV变量。导出的ENV变量是临时的，如何导出永久的变量？</li><li>什么是shell配置文件：〜/.bashrc，.bash_profile，.environment .. 如何为程序初始化文件“添加”设置？</li><li>了解Vim，其配置（.vimrc）及其一些基本提示是必须的。</li><li>日志如何在*nix系统中运行，什么是日志记录级别以及如何使用日志管理工具（rsyslog，logstash，fluentd，logwatch，awslogs ..）</li><li>swapping如何工作。swappiness是什么。（swapon -s，/proc/sys/vm/swappiness，sysctl vm.swappiness ..）</li><li>能轻松使用脚本语言轻松自如。Bash是必须了解的（其他脚本语言也是非常有用的，如Python，Perl ..）。</li><li>掌握有用的命令，例如进程监控命令（ps，top，htop，atop ..），系统性能命令（nmon，iostat，sar，vmstat..）和网络故障排除和分析（nmap，tcpdump，ping，traceroute，airmon，airodump ..）。</li><li>你的备份策略是什么？如何测试备份的可靠性？</li><li>你知道ext4，ntfs，fat？知道联合文件系统（Union FS）吗？</li><li>如何在系统上查看/设置网络配置？</li><li>如何在具有不同子网的计算机上设置静态/动态IP地址？（提示：CIDR）</li><li>使用网络数据包分析来分析和了解网络的工作原理：tcpdump，Wireshark ..</li><li>你熟悉OSI模型和TCP/IP模型的规范吗？TCP和UDP有什么区别？你知道vxlan吗？</li><li>如何设置防火墙（iptables，至少知道ufw）：设置规则，列出规则，路由流量，阻止协议/端口 ..</li><li>如何查看/设置/备份路由器设置？</li><li>DNS如何工作？如何设置DNS服务器（Bind，Unbound，PowerDNS，Dnsmasq ..）？递归（recursive）和权威（authoritative）DNS有什么区别？如何排除DNS故障（nslookup，dig ..）</li><li>熟悉DNS和A，AAAA，C，CNAME，TXT记录</li><li>当你在浏览器中点击google.com时会发生什么？从浏览器的缓存、本地DNS缓存、本地网络配置（hosts文件）、路由、DNS、网络、Web协议中，缓存系统到Web服务器（如果深入分析，最基本的问题也很难回答）。</li><li>熟悉CDN提供商（fastly，Akamai等）</li><li>熟悉SSL/TLS的工作原理以及数字证书的工作原理（https）</li><li>了解SSL证书（需要加密）</li><li>熟悉更安全的协议和工具：TLS，STARTTLS，SCP，SSH，<br>SFTP，FTPS ..</li><li>了解PPTP，OpenVPN，L2TP/IPSec之间的区别</li><li>学习为域设置记录集（可以使用Route53或CloudFlare等托管云服务）</li><li>SSH如何工作，如何调试它，如何生成ssh密钥以及无密码登录到其他计算机</li><li>什么是init系统？你知道Systemd（自15.04以来由Ubuntu使<br>用），Upstart（由Ubuntu开发），SysV ..</li><li>用任何软件的源代码编译它（gcc，make和其他相关内容）</li><li>如何通过终端用不同的格式压缩/解压缩文件（主要是：tar/tar.gz）</li><li>如何设置Web服务器（Apache，Nginx ..）</li><li>学习使用“awk，sed，sort，uniq”操作Nginx/Apache日志文件</li><li>Nginx和Apache有什么区别？什么时候使用Nginx？什么时候使用Apache？在同一个Web应用程序中，何时以及如何同时使用它们？</li><li>如何设置反向代理（Nginx ..）</li><li>如何设置缓存服务器（Squid，Nginx，Varnish ..）</li><li>如何设置负载均衡器（HAproxy，Nginx ..）</li><li>如何为您的微服务建立API网关（Ambassador，Kong，Traefik，Nginx ..）</li><li>熟悉Systemd以及如何使用systemctl和journalctl等命令分析和管理服务</li><li>熟悉OAuth、SAML、Auth0集成</li><li>熟悉RESTful API，Webhooks，GraphQL，gRPC</li><li>确保ES集群安全（XPack（商业），OpenSource：ReadOnlyREST，Search Guard）</li><li>使用snapshot API或esdump进行ES备份（快照和增量）（注意：需要nodejs/npm）</li><li>使用DB备份</li><li>学习Python（pip + setup.py）和BASH。您是否开始使用Golang作为脚本语言？尝试一下吧。</li><li>发展云计算技能。从选择云基础架构提供商开始：Amazon Web Services，Google Cloud Platform，Digitalocean，Microsoft Azure。或者使用OpenStack创建自己的私有云。</li><li>staging服务器怎么样？单元测试的测试策略是什么？端到端？真的需要staging服务器吗？Google下“staging servers must die”。</li><li>阅读有关PaaS/Iaas/Saas/CaaS/FaaS/DaaS和无服务器架构的信息</li><li>了解如何通过CLI中的Cloud Shell，或你的程序中的Cloud SDK，来使用和配置云资源</li><li>了解如何使用至少一个配置管理和远程执行工具（Ansible，Puppet，SaltStack，Chef 等）。您的选择应基于以下标准：语法，性能，模板语言，推拉模型，性能，架构，与其他工具的集成，可伸缩性，可用性等等。</li><li>用于image构建的Packer</li><li>将Jenkins集成到CI/CD中</li><li>设置Consul（用于服务发现）</li><li>开始研究“基础架构即代码”（infrastructure as code），以及基础架构配置自动化工具，如Terraform和Packer</li><li>开始研究容器和Docker。容器是底层架构（cgroups和namespaces），它是如何工作的？</li><li>开始熟悉基本的Docker命令（logs/inspect/top/ps/rm）。另外得研究docker hub（push/pull image）</li><li>开始研究容器编排工具：Docker Swarm，Kubernetes，Mesosphere DC/OS，AWS ECS</li><li>阅读有关无状态和有状态应用程序的知识</li><li>学习为您的应用程序构建小型的docker image（alpine比较合适）。仅安装所需的包就够了。</li><li>了解默认运行服务的最常用端口号（如：SSH（22），Web（80），HTTP/S（443）等）</li><li>从分布式角度学习网络（在容器世界中建立网络）。利用分布式系统中的8个谬论，让自己轻松应对。</li><li>了解L4/L7负载均衡器。</li><li>了解如何确保代理服务器和反向代理服务器的安全（Nginx，Traefik，Ambassador ..），并了解它们的网络系统是如何工作的。</li><li>熟悉帮助创建可分发和可移植开发环境的工具（例如：Vagrant和Docker）。</li><li>部署应用程序时，管理私密信息。Hashicorp Vault会帮助你。</li><li>了解AWS SQS，Google PubSub或其它替代方案。</li><li>熟悉Kafka，AWS Kinesis或其它替代方案。</li><li>了解AWS RDS，大多数时候Ops发现很容易将普通任务委派给服务提供商以避免额外的工作，但这会带来一些费用。</li><li>如果你在使用Kubernetes，那么了解它的所有组件和工作。</li><li>学习如何首先处理K8s内置功能，然后学习Helm/Istio。</li><li>了解监控的方式和内容（从操作系统和应用程序的角度来看）。</li><li>一旦到了合适的阶段，接着会需要追踪（Tracing）来帮助理解和挖掘，并且应用程序需要直接支持它</li><li>如果您正在处理（大）数据工程相关应用程序，那么得熟悉Hadoop，HBase，Zookeeper，Spark以及如何设置相关集群</li><li>学习如何根据应用需求设置和调整Redis，如何添加身份验证。</li><li>了解应用程序的性质：CPU密集型，内存密集型，I/O密集型，然后了解如何相应地进行处理。</li><li>学习根据需要在不同类型的数据库之间进行选择：SQL，NoSQL，TSDB，图形数据库 ..</li><li>学习管理IAM角色/权限以及如何管理不同用户的密钥（AWS IAM，GCP IAM ..）。</li><li>如果您喜欢分享并帮助其他人解决遇到过的问题，请将代码发布到GitHub。</li><li>学习对基础架构和应用程序进行基准测试以填补空白。</li><li>不要直接去执行。先可视化最终目标、画图、与开发人员详细讨论、毫不犹豫地提问、让问题彻底变得愚蠢。</li><li>不时做小型演示或PoC以便更好地理解。</li><li>你熟悉IDE（Sublime Text，Atom，Eclipse ..）吗？</li><li>深入了解DB（MySQL或任何其它你喜欢的数据库）。</li><li>了解Redis/Memcache以及类似工具。</li><li>了解微服务架构的优缺点，并开始构建类似的架构。</li><li>了解如何配置和使用持续集成和持续交付工具，如Jenkins，Travis CI，Buildbot，GoCd。将这些工具与其它工具（如Selenium，构建工具，配置管理软件，Docker，云供应商的SDK等）集成是非常有帮助的。</li><li>学习分布式版本控制系统Git及其基本命令（pull/push/commit/clone/branch/merge/logs等）。了解git工作流程。你知道如何将Git存储库恢复到以前的提交吗？</li><li>如何使用SSH密钥。尝试使用Github，Bitbucket或Gitlab .. 来配置对repo/account的无密码访问。</li><li>熟悉内核版本的混乱以及如何修补它们。</li><li>了解如何生成校验（md5，SHA ..）以验证任何文件的完整性。</li><li>了解单体（Monolithic）和微服务（Microservices）架构之间的区别。</li><li>如何实现零宕机部署？制定回滚、自修复、自动扩展的策略是什么？</li><li>了解可扩展性和高度分布式系统，如何让它们一直保持运行状态？</li><li>熟悉API和服务：RESTfull，RESTful-like，API网关，Lambda函数，serverless计算，SOA，SOAP，JMS，CRUD ..</li><li>如何确保基础架构、网络和运行的应用程序的安全？</li><li>你知道什么是ChatOps吗？是否尝试过使用一个已知框架？ Hubot，Lita，Cog？</li><li>了解如何设置、配置和使用某些监控系统（Nagios，Zabix，Sensu，Prometheus ..）</li><li>无论你做什么都“记录下来”，无论多么粗糙，做吧。稍后，你会感谢自己的。</li><li>制作小的代码脚本以方便使用，记下命令或片段（通过StackOverflow，Github Gists或其它在线记事板），它会帮助你得到想要的东西。</li><li>让Google，StackExchange，Quora和其它专业论坛成为您的朋友。</li><li>读，读，读。在Twitter/StackOverflow上提问。</li><li>参加会议。可以加入我们当地的聚会，如<a href="http://w.yi.wccnw.top/browse.php?u=3%2bEbCNhA3ow7CQsuY03Ew%2b9bUDOiA8frvqmO0moiy16kn9PAhr7AbzM1BBi%2bWSf0tTYVufBAGhmEHqFP&amp;b=5" target="_blank" rel="noopener">DevOpsLinks Community会议（班加罗尔）</a>，<a href="http://w.yi.wccnw.top/browse.php?u=3%2bEbCNhA3ow7CQsuY03Ew%2b9bUDOiA8frvqmO0moiy36kn9PAhr7AbzMVBBi%2bWSf0tTQ=&amp;b=5" target="_blank" rel="noopener">DevOpsLinks Community会议（伦敦）</a>和<a href="http://w.yi.wccnw.top/browse.php?u=3%2bEbCNhA3ow7CQsuY03Ew%2b9bUDOiA8frvqmO0moiy1Cul8rchrDHO04ZExS5Hw==&amp;b=5" target="_blank" rel="noopener">DevOpsLinks Community会议（巴黎）</a>。如果想组织当地的聚会，请联系我们，我们将为您提供帮助！</li><li>与同一领域的研究员交谈并讨论您的问题。通过<a href="http://w.yi.wccnw.top/browse.php?u=lvQbQ8pBxtIlAAc0fU7Ew%2b9b&amp;b=5" target="_blank" rel="noopener">社区</a>学习。</li><li>加入我们的<a href="http://w.yi.wccnw.top/browse.php?u=lvQbQ8pBxtIlAAc0fU7Ew%2b9b&amp;b=5" target="_blank" rel="noopener">Slack频道</a>并询问您的所有（菜鸟级）问题，都没问题！我们都是从开始起步的。</li><li>不要试图解决所有问题。永远记住一件事：没有人是一座孤岛。你不能做、学习、实现一切。要了解对于手头的任务最重要的是什么。</li><li>阅读DevOps词汇表（请Google它）</li><li>关注开源项目（Kubernetes/Docker等）或者让您感到兴奋的东西。</li><li>关注来自<a href="http://w.yi.wccnw.top/browse.php?u=lvQbQ8pBxtIlAAc0fU7Ew%2b9b&amp;b=5" target="_blank" rel="noopener">社区</a>的志同道合的人，并了解最新的科技趋势。</li><li>尝试搭建良好的开发实践以及坚实的架构。</li><li>了解如何在生产级别进行扩展。</li><li>了解如何在生产服务器中实时调试和跟踪运行的应用程序。</li><li>关注一些合适的科技公司的技术博客（我们跟随：Google/Uber/Quora/Github/Netflix）。这是您可以直接从专家那里学习的地方，并有机会看到他们解决任何问题的方法。</li><li>浏览一些新闻聚合器，如Reddit，hackernews，medium等。</li><li>在twitter上关注志同道合的开发人员和技术公司。 （我总是阅读文章和观看谈话/会议，事后剖析（post-mortems）是我最喜欢的内容。我也关注一些github库看看我使用的技术发生了什么。）</li><li>加入<a href="http://w.yi.wccnw.top/browse.php?u=lvQbQ8pBxtIlAAc0fU7Ew%2b9b&amp;b=5" target="_blank" rel="noopener">DevOpsLinks</a>、<a href="http://w.yi.wccnw.top/browse.php?u=lvQbTM5H3cM/AkAib0c=&amp;b=5" target="_blank" rel="noopener">Kaptain</a>和<a href="http://w.yi.wccnw.top/browse.php?u=lvQbTcBex9E%2bBR4qc1nEw%2b9b&amp;b=5" target="_blank" rel="noopener">Shipped</a>！我们相信你会学到很多东西，即使你是专家，你仍然不得不更多地学习。</li><li>阅读各种与技术相关的博客并订阅DevOps Newsletters。顺便说一句，我们有一份<a href="http://w.yi.wccnw.top/browse.php?u=3%2bEbCMJSzcsjAUA5eVDFxOVAEAe0GeH1ppY=&amp;b=5" target="_blank" rel="noopener">出版物</a>，您可以提交您的文章并与社区分享。</li><li>了解开源以及<a href="http://w.yi.wccnw.top/browse.php?u=lvQbTdlZ2ow1DUE4elKNj7IGTkHoRLi0/9PI3Sw3g2rmg8vQm6PdeXALTByoXzzn63QnvfAKCBqeHqcF5g==&amp;b=5" target="_blank" rel="noopener">如何</a>为开源项目做出贡献。</li><li>如果系统出现问题，您应该能够进行事后剖析。详细记录出现了什么问题，以及如何防止它再次发生。</li><li>尝试学习StackOverflow的专家如何解决问题。永远记住，方法是不断变化的，不像基础知识总是保持不变。</li><li>读书。</li><li>最后这点也很重要……不要假设任何事情，永远不要把现实视为理所当然，总是去尝试并享受旅程。</li></ul><p>如果您拥有以上大部分技能，则可以确保您具备DevOps、SRE和系统工程知识的先决条件。</p><p>你无法一次性学习所有这些，但是具备这样一个思维模式是主要的。 即使去熟悉所有这些也肯定需要时间，但俗话说旅程很有趣。 你会失败很多次，并从错误中吸取教训，不要重蹈覆辙。</p><p><strong>永远记住，我们都是学生。我们通过碰撞和试验来学习。不要羞于失败，因为这就是学习的方式。</strong></p><p><strong>DevOpsLinks</strong>，一个来自世界各地的DevOps专业人士和从业者的社区。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://res.infoq.com/articles/the-must-know-checklist-for-devops-and-sre/zh/resources/4924-1539417307400.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure></p><p><strong>Shipped</strong>，一个专注于无服务计算、FaaS和其他有趣主题的技术的社区。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://res.infoq.com/articles/the-must-know-checklist-for-devops-and-sre/zh/resources/4225-1539417307128.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure></p><p><strong>Kaptain</strong>：一个Kubernetes社区中心，主要包括手工策划的时事通讯、团队聊天、培训和更多（即将推出）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://res.infoq.com/articles/the-must-know-checklist-for-devops-and-sre/zh/resources/3626-1539417306768.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="http://www.infoq.com/cn/articles/the-must-know-checklist-for-devops-and-sre" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/the-must-know-checklist-for-devops-and-sre</a></li><li><a href="https://hackernoon.com/the-must-know-checklist-for-devops-site-reliability-engineers-update-8ba44dbc824" target="_blank" rel="noopener">https://hackernoon.com/the-must-know-checklist-for-devops-site-reliability-engineers-update-8ba44dbc824</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;这个列表并非详尽无遗，只是列举了技术基础、必须知道的技能和一些随机的想法。可以用它们作为一个清单来评估你自己或其他人，或者为下一
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>初尝Node.js</title>
    <link href="https://yo42.github.io/2018/10/01/%E5%88%9D%E5%B0%9DNode-js/"/>
    <id>https://yo42.github.io/2018/10/01/初尝Node-js/</id>
    <published>2018-10-01T09:16:58.959Z</published>
    <updated>2018-10-14T09:38:36.025Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js® 是一个基于 <a href="https://developers.google.com/v8/" target="_blank" rel="noopener">Chrome V8 引擎</a> 的 JavaScript 运行时。</p><p><strong>Node.js</strong>是一个能够在服务器端运行<a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a>的<a href="https://zh.wikipedia.org/wiki/%E9%96%8B%E6%94%BE%E5%8E%9F%E5%A7%8B%E7%A2%BC" target="_blank" rel="noopener">开放源代码</a>、<a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E5%B9%B3%E5%8F%B0" target="_blank" rel="noopener">跨平台</a>JavaScript <a href="https://zh.wikipedia.org/wiki/%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener">运行环境</a>。</p><p><strong>Node.js采用了<a href="https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95" target="_blank" rel="noopener">事件驱动</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E9%9D%9E%E9%98%BB%E5%A1%9E&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">非阻塞</a>和 <a href="https://zh.wikipedia.org/w/index.php?title=%E9%9D%9E%E5%90%8C%E6%AD%A5%E8%BC%B8%E5%85%A5%E8%BC%B8%E5%87%BA&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">异步输入输出</a>模型等技术来提高性能</strong>，可优化应用程序的传输量和规模。这些技术通常用于数据密集的实时应用程序。</p><p><strong>Node.js以单线程运行，使用非阻塞I/O调用，这样既可以支持数以万计的并发连线，又不会因多线程本身的特点而带来麻烦。众多请求只使用单线程的设计意味着可以用于创建高并发应用程序。</strong>Node.js应用程序的设计目标是任何需要操作I/O的函数都使用<a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">回调函数</a>。</p><p>这种设计的缺点是，如果不使用<a href="https://nodejs.org/api/cluster.html" target="_blank" rel="noopener">cluster</a>、<a href="http://strong-pm.io/" target="_blank" rel="noopener">StrongLoop Process Manager</a>或<a href="https://github.com/Unitech/pm2" target="_blank" rel="noopener">pm2</a>等模块，Node.js就难以处理多核或多线程等情况。</p><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>nvm:Node.js版本控制器，用于切换多版本的Node.js环境。</p><p>npm:（全称 Node Package Manager，即“node包管理器”）是<a href="https://zh.wikipedia.org/wiki/Node.js" target="_blank" rel="noopener">Node.js</a>默认的、以<a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a>编写的<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94%E5%A5%97%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1" target="_blank" rel="noopener">软件包管理系统</a>。</p><p>Node.js Express 框架: 相当于Python的Flask框架</p><p>Node.js多进程:<a href="https://nodejs.org/api/cluster.html" target="_blank" rel="noopener">cluster</a>、<a href="https://github.com/Unitech/pm2" target="_blank" rel="noopener">pm2</a></p><p>Node.js核心内置模块:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http：提供HTTP服务器功能。</span><br><span class="line">url：解析URL。</span><br><span class="line">fs：与文件系统交互。</span><br><span class="line">querystring：解析URL的查询字符串。</span><br><span class="line">child_process：新建子进程。</span><br><span class="line">util：提供一系列实用小工具。</span><br><span class="line">path：处理文件路径。</span><br><span class="line">crypto：提供加密和解密功能，基本上是对OpenSSL的包装。</span><br></pre></td></tr></table></figure><h1 id="阻塞对比非阻塞一览"><a href="#阻塞对比非阻塞一览" class="headerlink" title="阻塞对比非阻塞一览"></a>阻塞对比非阻塞一览</h1><p>本概论涵盖了在 Node.js 中 <strong>阻塞</strong> and <strong>非阻塞</strong> 的区别，同时也会牵涉到时间轮询和 libuv 方面，不需要先行了解这些方面的知识也可以继续阅读。我们假定读者对于 JavaScript 语言和 Node.js 的回调机制有一个基本的了解。</p><blockquote><p>“I/O” 指的是系统磁盘和由 <a href="http://libuv.org/" target="_blank" rel="noopener">libuv</a> 支持的网络之间的交互。</p></blockquote><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p><strong>阻塞</strong> 是说 Node.js 中其它的 JavaScript 命令必须等到一个非 JavaScript 操作完成之后才可以执行。这是因为当 <strong>阻塞</strong> 发生时，事件机制无法继续运行JavaScript。</p><p>在 Node.js 中，JavaScript由于 CPU 密集操作而表现不佳。而不是等待非 JavaScript操作 （例如I/O）。这被称为 <strong>阻塞</strong>。在 Node.js 基本类库中，使用 libuv 的同步方法大多数都是 <strong>阻塞</strong> 的。原生方法也可能是 <strong>阻塞</strong> 的。</p><p>所有在 Node.js 中提供的 I/O 方法也包括异步版本，它们都是 <strong>非阻塞</strong> 的，接受回调函数。一些方法同时也具备 <strong>阻塞</strong> 功能，它们的名字结尾都以 <code>Sync</code> 结尾。</p><h2 id="代码比较"><a href="#代码比较" class="headerlink" title="代码比较"></a>代码比较</h2><p><strong>阻塞</strong> 方法执行起来是 <strong>同步地</strong>，但是 <strong>非阻塞</strong> 方法执行起来是 <strong>异步地</strong>。 如果你使用文件系统模块读取一个文件，同步方法看上去如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> data = fs.readFileSync(<span class="string">'/file.md'</span>); <span class="comment">// blocks here until file is read</span></span><br></pre></td></tr></table></figure><p>这是一个与之功能等同的 <strong>异步</strong> 版本示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'/file.md'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第一个示例看上去比第二个似乎简单些，但是有一个缺陷：第二行语句会 <strong>阻塞</strong> 其它 JavaScript 语句的执行直到整个文件全部读取完毕。注意在同步版本的代码中，任何异常都会抛出，会导致整个程序崩溃。在异步版本示例代码中，它由作者来决定是否抛出异常。</p><p>让我们扩展一点我们的同步代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> data = fs.readFileSync(<span class="string">'/file.md'</span>); <span class="comment">// blocks here until file is read</span></span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line"><span class="comment">// moreWork(); will run after console.log</span></span><br></pre></td></tr></table></figure><p>这是一个类似的，但是功能上不等同的异步代码示例版本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'/file.md'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// moreWork(); will run before console.log</span></span><br></pre></td></tr></table></figure><p>第一个示例代码中， <code>console.log</code> 将在 <code>moreWork()</code> 之前被调用。在第二个例子中， <code>fs.readFile()</code> 因为是 <strong>非阻塞</strong> 的，所以 JavaScript 会继续执行， <code>moreWork()</code> 将被首先调用。<code>moreWork()</code> 无需等待文件读完而先行执行完毕，这对于高效吞吐来说是一个绝佳的设计。</p><h2 id="并行和吞吐"><a href="#并行和吞吐" class="headerlink" title="并行和吞吐"></a>并行和吞吐</h2><p>在 Node.js 中 JavaScript 的执行是单线程的，所以并行与事件轮询能力（即在完成其它任务之后处理 JavaScript 回调函数的能力）有关。任何一个企图以并行的方式运行的代码必须让事件轮询机制以非 JavaScript 操作来运行，像 I/O 操作。</p><p>举个例子，让我们思考一个案例：案例中每个对服务器的请求消耗 50 毫秒完成，其中的 45 毫秒又是可以通过异步操作而完成的数据库操作。选择 <strong>非阻塞</strong> 操作可以释放那 45 毫秒用以处理其它的请求操作。这是在选择 <strong>阻塞</strong> 和 <strong>非阻塞</strong> 方法上的重大区别。</p><p>Node.js 中的事件轮询机制和其它语言相比而言有区别，其它语言需要创建线程来处理并行任务。</p><h2 id="把阻塞和非阻塞代码混在一起写的危险"><a href="#把阻塞和非阻塞代码混在一起写的危险" class="headerlink" title="把阻塞和非阻塞代码混在一起写的危险"></a>把阻塞和非阻塞代码混在一起写的危险</h2><p>在处理 I/O 问题时，有些东西必须避免。下面让我们看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'/file.md'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">fs.unlinkSync(<span class="string">'/file.md'</span>);</span><br></pre></td></tr></table></figure><p>在以上的例子中， <code>fs.unlinkSync()</code> 极有可能在 <code>fs.readFile()</code> 之前执行，所以在真正准备开始读取文件前此文件就已经被删除了。一个更好的处理方法就是彻底让使它变得 <strong>非阻塞化</strong>，并且保证按照正确顺序执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'/file.md'</span>, (readFileErr, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (readFileErr) <span class="keyword">throw</span> readFileErr;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  fs.unlink(<span class="string">'/file.md'</span>, (unlinkErr) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (unlinkErr) <span class="keyword">throw</span> unlinkErr;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上代码在 <code>fs.readFile()</code> 用异步方式调用 <code>fs.unlink()</code>，这就保证了执行顺序的正确。</p><h2 id="第一个应用"><a href="#第一个应用" class="headerlink" title="第一个应用"></a>第一个应用</h2><p>app.js # require命令用于指定加载模块，加载时可以省略脚本文件的后缀名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">'127.0.0.1'</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.statusCode = <span class="number">200</span>;</span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(port, hostname, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后使用 <code>node app.js</code> 运行程序，访问 <a href="http://localhost:3000%EF%BC%8C%E4%BD%A0%E5%B0%B1%E4%BC%9A%E7%9C%8B%E5%88%B0%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%EF%BC%8C%E5%86%99%E7%9D%80%E2%80%9CHello/" target="_blank" rel="noopener">http://localhost:3000，你就会看到一个消息，写着“Hello</a> World”。</p><h3 id="Run-Node-js-in-Docker"><a href="#Run-Node-js-in-Docker" class="headerlink" title="Run Node.js in Docker"></a>Run Node.js in Docker</h3><h4 id="创建-Node-js-应用"><a href="#创建-Node-js-应用" class="headerlink" title="创建 Node.js 应用"></a>创建 Node.js 应用</h4><p>首先，创建一个新文件夹以便于容纳需要的所有文件，并且在此其中创建一个 <code>package.json</code> 文件，描述你应用程序以及需要的依赖：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"docker_web_app"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Node.js on Docker"</span>,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"Neo  &lt;Neo42@mail.com&gt;"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"server.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node app2mongo.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"express"</span>: <span class="string">"^4.16.3"</span>,</span><br><span class="line">    <span class="attr">"mongodb"</span>: <span class="string">"^3.1.6"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配合着你的 <code>package.json</code> 请运行 <code>npm install</code>。如果你使用的 <code>npm</code> 是版本 5 或者之后的版本，这会自动生成一个 <code>package-lock.json</code> 文件，它将一起被拷贝进入你的 Docker 镜像中。</p><h4 id="安装-MongoDB-driver-for-Node-js"><a href="#安装-MongoDB-driver-for-Node-js" class="headerlink" title="安装 MongoDB driver for Node.js."></a>安装 <a href="https://www.mongodb.com/" target="_blank" rel="noopener">MongoDB</a> driver for Node.js.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mongodb --save</span><br></pre></td></tr></table></figure><p>App2mongo.js # 操作测试Mongodb</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertDocuments = <span class="function"><span class="keyword">function</span>(<span class="params">db, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Get the documents collection</span></span><br><span class="line">  <span class="keyword">const</span> collection = db.collection(<span class="string">'documents'</span>);</span><br><span class="line">  <span class="comment">// Insert some documents</span></span><br><span class="line">  collection.insertMany([</span><br><span class="line">    &#123;<span class="attr">Neo</span> : <span class="number">42</span>&#125;, &#123;<span class="attr">a</span> : <span class="number">2</span>&#125;, &#123;<span class="attr">a</span> : <span class="number">3</span>&#125;</span><br><span class="line">  ], <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    assert.equal(err, <span class="literal">null</span>);</span><br><span class="line">    assert.equal(<span class="number">3</span>, result.result.n);</span><br><span class="line">    assert.equal(<span class="number">3</span>, result.ops.length);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Inserted 3 documents into the collection Neo"</span>);</span><br><span class="line">    callback(result);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findDocuments = <span class="function"><span class="keyword">function</span>(<span class="params">db, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Get the documents collection</span></span><br><span class="line">  <span class="keyword">const</span> collection = db.collection(<span class="string">'documents'</span>);</span><br><span class="line">  <span class="comment">// Find some documents</span></span><br><span class="line">  collection.find(&#123;&#125;).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, docs</span>) </span>&#123;</span><br><span class="line">    assert.equal(err, <span class="literal">null</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Found the following records"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(docs)</span><br><span class="line">    callback(docs);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connection URL</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">'mongodb://192.168.0.103:27017'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Database Name</span></span><br><span class="line"><span class="keyword">const</span> dbName = <span class="string">'Neo42'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use connect method to connect to the server</span></span><br><span class="line">MongoClient.connect(url, <span class="function"><span class="keyword">function</span>(<span class="params">err, client</span>) </span>&#123;</span><br><span class="line">  assert.equal(<span class="literal">null</span>, err);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Connected correctly to server Neo42"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> db = client.db(dbName);</span><br><span class="line"></span><br><span class="line">  insertDocuments(db, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    findDocuments(db, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      client.close();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="创建Dockerfile"><a href="#创建Dockerfile" class="headerlink" title="创建Dockerfile"></a>创建Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create app directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Install app dependencies</span></span></span><br><span class="line"><span class="bash"><span class="comment"># A wildcard is used to ensure both package.json AND package-lock.json are copied</span></span></span><br><span class="line"><span class="bash"><span class="comment"># where available (npm@5+)</span></span></span><br><span class="line"><span class="bash">COPY package*.json ./</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN npm install</span></span><br><span class="line"><span class="bash"><span class="comment"># If you are building your code for production</span></span></span><br><span class="line"><span class="bash"><span class="comment"># RUN npm install --only=production</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Bundle app source</span></span></span><br><span class="line"><span class="bash">COPY . .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 8080</span></span><br><span class="line"><span class="bash">CMD [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure><h4 id="构建DockerImage"><a href="#构建DockerImage" class="headerlink" title="构建DockerImage"></a>构建DockerImage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t Neo:42/node-web-app .</span><br></pre></td></tr></table></figure><h4 id="Run-Docker"><a href="#Run-Docker" class="headerlink" title="Run Docker"></a>Run Docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -d Neo:42/node-web-app</span><br></pre></td></tr></table></figure><h4 id="运行输出"><a href="#运行输出" class="headerlink" title="运行输出"></a>运行输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Connected correctly to server Neo42 # 连接数据库</span><br><span class="line">Inserted 3 documents into the collection Neo # 插入doc</span><br><span class="line">Found the following records # 查询</span><br><span class="line">[ &#123; _id: 5bb1e06dc2bf97000f0e1886, Neo: 42 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e06dc2bf97000f0e1887, a: 2 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e06dc2bf97000f0e1888, a: 3 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e2bb0c25dc000fa94345, Neo: 42 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e2bb0c25dc000fa94346, a: 2 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e2bb0c25dc000fa94347, a: 3 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e30bb78d09000f1ff341, Neo: 42 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e30bb78d09000f1ff342, a: 2 &#125;,</span><br><span class="line">  &#123; _id: 5bb1e30bb78d09000f1ff343, a: 3 &#125; ]</span><br></pre></td></tr></table></figure><h2 id="Node-js-PM2-Runtime"><a href="#Node-js-PM2-Runtime" class="headerlink" title="Node.js PM2 Runtime"></a>Node.js PM2 Runtime</h2><p>PM2 is a Production Runtime and Process Manager for Node.js applications with a built-in Load Balancer. It allows you to keep applications alive forever, to reload them without downtime and facilitate common Devops tasks.</p><p><strong>Advanced, production process manager for Node.js</strong></p><p><strong>PM2 Features:高效管理多进程、日志分析记录简单的监控、集群扩展、部署方便等…..</strong></p><p><strong>PM2群集模式和重新加载操作可以避免停机时间。</strong></p><h3 id="Using-PM2-with-Docker"><a href="#Using-PM2-with-Docker" class="headerlink" title="Using PM2 with Docker"></a>Using PM2 with Docker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">neo_42</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── ecosystem.config.js</span><br><span class="line">├── package.json</span><br><span class="line">└── src</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br></pre></td></tr></table></figure><p>生成ecosystem.config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 init</span><br></pre></td></tr></table></figure><p>app.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line"></span><br><span class="line">// Constants</span><br><span class="line">const PORT = 8080;</span><br><span class="line">const HOST = &apos;0.0.0.0&apos;;</span><br><span class="line"></span><br><span class="line">// App</span><br><span class="line">const app = express();</span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&apos;Hello world\n&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(PORT, HOST);</span><br><span class="line">console.log(`Running on http://$&#123;HOST&#125;:$&#123;PORT&#125;`);</span><br></pre></td></tr></table></figure><p>Dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FROM keymetrics/pm2:latest-alpine</span><br><span class="line"></span><br><span class="line">WORKDIR src/</span><br><span class="line"># Bundle APP files</span><br><span class="line">COPY src src/</span><br><span class="line">COPY package.json .</span><br><span class="line">COPY ecosystem.config.js .</span><br><span class="line"></span><br><span class="line"># Install app dependencies</span><br><span class="line">ENV NPM_CONFIG_LOGLEVEL warn</span><br><span class="line">RUN npm install --production</span><br><span class="line"></span><br><span class="line"># Expose the listening port of your app</span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line"># Show current folder structure in logs</span><br><span class="line">#RUN ls -al -R</span><br><span class="line"></span><br><span class="line">CMD [ &quot;pm2-runtime&quot;, &quot;start&quot;, &quot;ecosystem.config.js&quot; ]</span><br><span class="line">#CMD [&quot;pm2-runtime&quot;, &quot;ecosystem.config.js&quot;, &quot;--web&quot;]</span><br></pre></td></tr></table></figure><p>构建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &apos;neo/pm2:v1&apos; .</span><br></pre></td></tr></table></figure><p>Run</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:8080 -d neo/pm2:v1</span><br></pre></td></tr></table></figure><p>Pm2 Commands</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 051 pm2  ls</span><br><span class="line">docker exec -it 051 pm2 monit</span><br></pre></td></tr></table></figure><p>Pm2 Commands参考<a href="http://pm2.keymetrics.io/docs/usage/quick-start/" target="_blank" rel="noopener">http://pm2.keymetrics.io/docs/usage/quick-start/</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://nodejs.org/zh-cn/docs/guides/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/docs/guides/</a></li><li><a href="https://zh.wikipedia.org/zh-cn/Node.js" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-cn/Node.js</a></li><li><a href="https://github.com/nodejs/docker-node/tree/526c6e618300bdda0da4b3159df682cae83e14aa#dockerfile" target="_blank" rel="noopener">https://github.com/nodejs/docker-node/tree/526c6e618300bdda0da4b3159df682cae83e14aa#dockerfile</a></li><li><a href="https://github.com/Unitech/PM2/" target="_blank" rel="noopener">https://github.com/Unitech/PM2/</a></li><li><a href="https://pm2.io/doc/en/runtime/integration/docker/" target="_blank" rel="noopener">https://pm2.io/doc/en/runtime/integration/docker/</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Node.js® 是一个基于 &lt;a href=&quot;https://developers.google.com/v8/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chrome V8 引擎&lt;/a&gt; 的 JavaScript 运行时。&lt;/p&gt;
&lt;p&gt;&lt;stro
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>DevOps最全术语汇总</title>
    <link href="https://yo42.github.io/2018/09/24/DevOps%E6%9C%80%E5%85%A8%E6%9C%AF%E8%AF%AD%E6%B1%87%E6%80%BB/"/>
    <id>https://yo42.github.io/2018/09/24/DevOps最全术语汇总/</id>
    <published>2018-09-24T06:46:15.204Z</published>
    <updated>2018-09-24T06:51:59.900Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>A/B Testing</p><p><a href="https://xebialabs.com/glossary/a/b-testing/" target="_blank" rel="noopener">A/B测试</a></p><p>使用A/B测试的技术将新功能或某项功能的不同变体推向不同组别的用户，这些功能可通过比较指标和用户行为进行评估。</p><p>Acceptance Testing</p><p><a href="https://xebialabs.com/glossary/acceptance-testing/" target="_blank" rel="noopener">验收测试</a></p><p>通常对整个系统进行高级测试，以确定新功能和现有功能的整体质量是否足以让系统投入生产。</p><p>Agent</p><p><a href="https://xebialabs.com/glossary/agent/" target="_blank" rel="noopener">代理程序</a></p><p>代理程序是安装在特定物理服务器上的程序，用于在该服务器上处理不同进程的执行。</p><p>Agile</p><p><a href="https://xebialabs.com/glossary/agile/" target="_blank" rel="noopener">敏捷</a></p><p>是DevOps的前身；敏捷是一种软件开发方法，更广泛来说，是一种业务方法。敏捷强调短期迭代的规划和开发周期以提供更好的控制以及可预测性，并支持随着项目的发展而不断变化的需求。</p><p>ARA (Application Release Automation)</p><p><a href="https://xebialabs.com/glossary/ara-(application-release-automation" target="_blank" rel="noopener">ARA （应用程序发布自动化）</a>/)</p><p>可以在目标环境中自动安装和正确配置给定应用程序版本并随时可用的工具、脚本或产品。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>Behavior-Driven Development (BDD)</p><p><a href="https://xebialabs.com/glossary/behavior-driven-development-(bdd" target="_blank" rel="noopener">行为驱动开发（BDD）</a>/)</p><p>一种开发方法，强调软件应该根据应用程序的期望行为并以业务管理人员可读的语法来指定。</p><p>Black Box Testing</p><p><a href="https://xebialabs.com/glossary/black-box-testing/" target="_blank" rel="noopener">黑盒测试</a></p><p>一种测试或质量保证实践，它假设不知道被测系统内部的工作原理，因此尝试验证外部而不是内部行为或状态。</p><p>Build Agent</p><p>Build Agent</p><p>一种用于持续集成的代理程序，可以本地或远程安装，跟持续集成服务器有关。它发送和接收跟处理软件构建有关的消息。</p><p>Build Artifact Repository</p><p><a href="https://xebialabs.com/glossary/build-artifact-repository/" target="_blank" rel="noopener">构建工件存储库</a></p><p>用于组织具有元数据构造的工件，并允许自动发布和使用这些工件的工具。</p><p>Build Automation</p><p><a href="https://xebialabs.com/glossary/build-automation/" target="_blank" rel="noopener">构建自动化</a></p><p>允许将源代码自动编译为可发布的二进制代码的工具或框架。通常包括代码级的单元测试，以确保代码的各个部分按预期运行。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>Canary Release</p><p><a href="https://xebialabs.com/glossary/canary-release/" target="_blank" rel="noopener">灰度发布</a>（金丝雀发布）</p><p>一种上线策略，在该策略中，把新的应用程序版本发布到生产服务器的一小部分上，并严格监控以确定其是否按预期运行。如果一切看起来稳定，那么新版本将推广到整个生产环境。</p><p>Configuration Drift</p><p><a href="https://xebialabs.com/glossary/configuration-drift/" target="_blank" rel="noopener">配置漂移</a></p><p>由于手工的特殊更改（如热修复）没有引入到系统模版中而引起软件和硬件配置与系统模版版本漂移或不一致。</p><p>Configuration Management</p><p><a href="https://xebialabs.com/glossary/configuration-management/" target="_blank" rel="noopener">配置管理</a></p><p>用于建立和维护系统一致的设置和功能属性的术语。它包括用于IT基础设施自动化等系统管理任务的工具。</p><p>Continuous Delivery</p><p><a href="https://xebialabs.com/glossary/continuous-delivery/" target="_blank" rel="noopener">持续交付</a>（CD)</p><p>持续交付是一套流程和实践，从根本上清除软件生产过程中的浪费，能更快地交付高质量的功能，并在业务和用户之间建立快速有效的反馈环。</p><p>Continuous Integration (CI)</p><p><a href="https://xebialabs.com/glossary/continuous-integration-(ci" target="_blank" rel="noopener">持续集成（CI）</a>/)</p><p>持续集成（CI）是一种开发实践，它要求开发人员每天多次把代码集成到共享存储库中。然后通过自动构建验证每次签入，使得团队能尽早发现问题。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>Dark Launch</p><p><a href="https://xebialabs.com/glossary/dark-launch/" target="_blank" rel="noopener">灰度上线</a></p><p>一种上线策略，其中实现新功能的代码被发布到生产环境的子集，但是不可见或只是部分激活。然而，该代码是在生产环境中运行，用户并不知晓。</p><p>Delivery Pipeline</p><p><a href="https://xebialabs.com/glossary/delivery-pipeline/" target="_blank" rel="noopener">交付管道</a></p><p>一系列为新应用程序版本实施软件交付过程的编排的、自动化的任务。该管道中的每个步骤旨在提高新版本的置信度，使其能够做出合格/不合格的决策。交付管道可以被看作是组织发布流程的优化结果。</p><p>DevOps</p><p>DevOps</p><p>DevOps（开发和运维）是一个软件开发短语，用于描述开发和IT运维之间的敏捷关系。DevOps的目标是改善在软件开发周期中不同角色之间的沟通、协作和流程，以改善和加速软件交付。</p><p>DevOps Intelligence</p><p><a href="https://xebialabs.com/glossary/devops-intelligence/" target="_blank" rel="noopener">DevOps</a>智能</p><p>提供公司所需的洞察力，以更高效、更低风险和更好结果的方式交付软件，</p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>Functional Testing</p><p><a href="https://xebialabs.com/glossary/functional-testing/" target="_blank" rel="noopener">功能测试</a></p><p>进行端到端系统的测试以验证（新）功能。使用可执行规范，通过运行针对应用程序的规范来进行功能测试。</p><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>Infrastructure as a Service (IaaS)</p><p><a href="https://xebialabs.com/glossary/infrastructure-as-a-service-(iaas" target="_blank" rel="noopener">基础</a>/)<a href="https://xebialabs.com/glossary/infrastructure-as-a-service-(iaas" target="_blank" rel="noopener">设施</a>/)<a href="https://xebialabs.com/glossary/infrastructure-as-a-service-(iaas" target="_blank" rel="noopener">即服务（IaaS）</a>/)</p><p>云托管的虚拟机器通常根据“按需付费”收费。用户对机器有完全的控制，但是需要自己安装和配置所需的中间件和应用程序。</p><p>Infrastructure as Code</p><p><a href="https://xebialabs.com/glossary/infrastructure-as-code/" target="_blank" rel="noopener">基础</a><a href="https://xebialabs.com/glossary/infrastructure-as-code/" target="_blank" rel="noopener">设施</a><a href="https://xebialabs.com/glossary/infrastructure-as-code/" target="_blank" rel="noopener">即代码</a>（IaC)</p><p>一种系统配置管理技术，其中以完全自动化的形式指定机器、网络设备、操作系统、中间件等。规范或“蓝图”被认为是代码，由供应工具执行，保存在版本控制中，通常遵循用于应用程序代码开发的相同实践。</p><h3 id="L"><a href="#L" class="headerlink" title="L"></a>L</h3><p>Lean</p><p><a href="https://xebialabs.com/glossary/lean/" target="_blank" rel="noopener">精益</a></p><p>“精益制造”或“精益生产”是一种方式或方法，旨在通过专注于保护价值来减少生产过程中的浪费。它很大程度上来源于丰田公司在汽车制造业中开发的实践，精益概念已经作为敏捷方法的部分被应用于软件开发。价值流程图（VSM）试图直观地识别有价值和有浪费的流程步骤，是个关键的精益工具。</p><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>Microservices</p><p><a href="https://xebialabs.com/glossary/microservices/" target="_blank" rel="noopener">微服务</a></p><p>微服务是一种软件架构设计模式，其中复杂的应用程序由独立的小型进程构成，这些进程使用与语言无关的API进行通信。这些服务规模小，高度分离，专注于完成一个小任务。</p><h3 id="N"><a href="#N" class="headerlink" title="N"></a>N</h3><p>Non-functional Requirements (NFRs)</p><p><a href="https://xebialabs.com/glossary/non-functional-requirements-(nfrs" target="_blank" rel="noopener">非功能性需求（NFRs）</a>/)</p><p>系统质量的规范，诸如易用性，设计清晰度，延迟，速度，处理大量用户的能力等，描述了如何轻松或高效地使用某个功能，而不只是它是否存在。这些特性可以使用持续交付反馈环来解决和改善。</p><p>NoOps</p><p>NoOps</p><p>在一个公司中，应用程序运行的系统管理要么是完全由外部一方（如PaaS 供应商）来处理，要么就是全自动化的。使用NoOps旨在尽量减少或不使用内部运维能力和员工。</p><h3 id="O"><a href="#O" class="headerlink" title="O"></a>O</h3><p>Orchestration Pipeline</p><p><a href="https://xebialabs.com/glossary/orchestration-pipeline/" target="_blank" rel="noopener">编排管道</a></p><p>在适当的时间调用形成持续交付管道的不同自动化任务的工具或产品。它们通常也记录每个任务的状态和输出，并通过管道可视化特征流。</p><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>Platform as a Service (PaaS)</p><p><a href="https://xebialabs.com/glossary/platform-as-a-service-(paas" target="_blank" rel="noopener">平台即服务（PaaS）</a>/)</p><p>云托管的应用程序运行时间通常根据“按需支付”的原则计费。用户提供应用程序代码和有限的配置设置，中间件、数据库等都是提供的运行时的一部分。</p><p>Product Owner</p><p><a href="https://xebialabs.com/glossary/product-owner/" target="_blank" rel="noopener">产品负责人</a></p><p>开发团队中负责定义、确定优先级和维护未完成功能及其他工作的人或角色。产品负责人在敏捷软件开发方法中很常见，通常代表业务或客户组织。相比在更传统的软件开发过程中的同行，产品负责人需要在敏捷开发流程中扮演更积极的日常角色。</p><p>Provisioning</p><p><a href="https://xebialabs.com/glossary/provisioning/" target="_blank" rel="noopener">服务开通</a></p><p>为用户（在持续交付的场景下，通常是开发或测试团队）准备新系统的过程。该系统通常根据需要进行虚拟化和实例化。配置机器以安装操作系统、中间件等操作是由自动化的系统配置管理工具来处理，这些自动化工具还验证所需要的配置是否得到维护。</p><h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><p>Regression Testing</p><p><a href="https://xebialabs.com/glossary/regression-testing/" target="_blank" rel="noopener">回归测试</a></p><p>对端到端系统的测试，以验证应用程序的更改没有对现有功能产生负面影响。</p><p>Release Coordination</p><p><a href="https://xebialabs.com/glossary/release-coordination/" target="_blank" rel="noopener">发布协调</a></p><p>定义和执行从代码签入到生效的新功能（或功能集）所需的所有操作。在持续交付环境中，这在很大程度上是完全自动化的，并由管道执行。</p><p>Release Management</p><p><a href="https://xebialabs.com/glossary/release-management/" target="_blank" rel="noopener">发布管理</a></p><p>发布管理是管理软件发布从开发阶段到实际软件发布阶段的流程。</p><p>Release Orchestration</p><p><a href="https://xebialabs.com/glossary/release-orchestration/" target="_blank" rel="noopener">发布编排</a></p><p>发布编排是使用诸如XL发布等工具管理软件发布（从开发阶段到实际软件发布阶段）。</p><h3 id="T"><a href="#T" class="headerlink" title="T"></a>T</h3><p>Test-Driven Development (TDD)</p><p><a href="https://xebialabs.com/glossary/test-driven-development-(tdd" target="_blank" rel="noopener">测试驱动开发（TDD）</a>/)</p><p>一种开发实践，在该实践过程中，用于验证代码片段表现的小测试在编写代码前就已经写就。这些测试最初是失败的，但开发人员的目标是接着添加代码使这些测试成功。</p><h3 id="U"><a href="#U" class="headerlink" title="U"></a>U</h3><p>Unit Testing</p><p><a href="https://xebialabs.com/glossary/unit-testing/" target="_blank" rel="noopener">单元测试</a></p><p>代码级（即无需安装完整的端到端系统以运行）测试以验证各个代码段的行为。TDD广泛使用单元测试以描述和验证预期的行为。</p><h3 id="V"><a href="#V" class="headerlink" title="V"></a>V</h3><p>Value Stream Mapping</p><p><a href="https://xebialabs.com/glossary/value-stream-mapping/" target="_blank" rel="noopener">价值</a><a href="https://xebialabs.com/glossary/value-stream-mapping/" target="_blank" rel="noopener">流程</a><a href="https://xebialabs.com/glossary/value-stream-mapping/" target="_blank" rel="noopener">图</a></p><p>一种过程可视化和改善技术，大量用于精益生产和工程方法中。价值流图用于识别必要的处理步骤，而不是逐渐清除流程中的“浪费”。</p><p>Virtualization</p><p><a href="https://xebialabs.com/glossary/virtualization/" target="_blank" rel="noopener">虚拟化</a></p><p>一种系统管理方法，用户和应用程序不需要使用物理机器，而是在实际的“真实”硬件上运行的模拟系统。这样的“虚拟机”能够在几秒钟内自动生成、启动、停运、克隆和丢弃，给操作带来了巨大的便利。</p><h3 id="W"><a href="#W" class="headerlink" title="W"></a>W</h3><p>Waterfall</p><p><a href="https://xebialabs.com/glossary/waterfall/" target="_blank" rel="noopener">瀑布式（开发）</a></p><p>一种基于分阶段项目方法的软件开发方法，从“需求收集”到“开发”，再到“发布”。如果项目中前面的阶段有延迟，整个过程中靠后的阶段（通常和测试及QA相关）会因此在时间上受到挤压。</p><p>White Box Testing</p><p><a href="https://xebialabs.com/glossary/white-box-testing/" target="_blank" rel="noopener">白盒测试</a></p><p>一种测试或质量保证实践，它通过系统运行时检查系统（内部）表现和状态以验证系统内部功能是否正确。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;A&quot;&gt;&lt;a href=&quot;#A&quot; class=&quot;headerlink&quot; title=&quot;A&quot;&gt;&lt;/a&gt;A&lt;/h3&gt;&lt;p&gt;A/B Testing&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://xebialabs.com/glossary/a/b-testing/&quot; t
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>持续集成CI/CD</title>
    <link href="https://yo42.github.io/2018/09/24/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90CI-CD/"/>
    <id>https://yo42.github.io/2018/09/24/持续集成CI-CD/</id>
    <published>2018-09-24T06:08:38.669Z</published>
    <updated>2018-09-24T14:24:56.742Z</updated>
    
    <content type="html"><![CDATA[<p><strong>持续集成（Continuous Integration）</strong>指的是，频繁地（一天多次）将代码集成到主干。 </p><p>在保证质量的前提，通过持续集成使产品进行快速的迭代。</p><p>它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p><p>互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称CI）。</p><p><strong>持续交付</strong>（Continuous delivery）<em>**</em>在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（<em>production-like environments</em>）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。</p><p>持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p><p><strong>持续部署</strong>则是在持续交付的基础上，把部署到生产环境的过程自动化。</p><p>持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。</p><p>持续部署的前提是能自动化完成测试、构建、部署等步骤。</p><p>持续集成CI/CD工具:Jenkins、Travis CI、Drone、Wercker、Circle CI等等….</p><p>工具上的话，jenkins使用的较多，插件多、社区文化活跃。</p><p>常见组合:jenkins+svn+maven+ant、jenkins+GitLab</p><p>持续集成的核心价值在于：</p><ol><li>持续集成中的任何一个环节都是自动完成的，无需太多的人工干预，有利于减少重复过程以节省时间、费用和工作量；</li><li>持续集成保障了每个时间点上团队成员提交的代码是能成功集成的。换言之，任何时间点都能第一时间发现软件的集成问题，使任意时间发布可部署的软件成为了可能；</li><li>持续集成还能利于软件本身的发展趋势，这点在需求不明确或是频繁性变更的情景中尤其重要，持续集成的质量能帮助团队进行有效决策，同时建立团队对开发产品的信心。</li></ol><h3 id="为啥需要持续集成CI-CD？"><a href="#为啥需要持续集成CI-CD？" class="headerlink" title="为啥需要持续集成CI/CD？"></a>为啥需要持续集成CI/CD？</h3><p>敏捷开发、快速交付是互联网行业的标准。一个产品、一个项目团队，通过高效的敏捷开发，以及快速交付产品的流程使其能从软件行业中脱颖而出。说白了就是为了应对快速变化需求的一个解决方案或者手段。</p><p>解放运维劳动力，提高效率，减少因发布、部署、交付更新带来的失误。</p><p>随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile） 在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。</p><p>持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。</p><h3 id="持续集成CI-CD的好处"><a href="#持续集成CI-CD的好处" class="headerlink" title="持续集成CI/CD的好处"></a>持续集成CI/CD的好处</h3><p><strong>快速发现错误。</strong>每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。</p><p><strong>防止分支大幅偏离主干。</strong>如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</p><p>持续集成的大致流程:</p><blockquote><p>编码 -&gt; 构建 -&gt; 集成 -&gt; 测试 -&gt; 交付 -&gt; 部署</p></blockquote><h2 id="持续集成的原则"><a href="#持续集成的原则" class="headerlink" title="持续集成的原则"></a>持续集成的原则</h2><p>业界普遍认同的持续集成的原则包括：</p><ul><li>需要版本控制软件保障团队成员提交的代码不会导致集成失败。常用的版本控制软件有 git、svn 等；</li><li>开发人员必须及时向版本控制库中提交代码，也必须经常性地从版本控制库中更新代码到本地；</li><li>需要有专门的集成服务器来执行集成构建。根据项目的具体实际，集成构建可以被软件的修改来直接触发，也可以定时启动，如每半个小时构建一次；</li><li>必须保证构建的成功。如果构建失败，修复构建过程中的错误是优先级最高的工作。一旦修复，需要手动启动一次构建。</li></ul><h2 id="持续集成系统的组成"><a href="#持续集成系统的组成" class="headerlink" title="持续集成系统的组成"></a>持续集成系统的组成</h2><p>由此可见，一个完整的构建系统必须包括：</p><ul><li>一个自动构建过程，包括自动编译、分发、部署和测试等。</li><li>一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库。</li><li>一个持续集成服务器。</li></ul><h3 id="在实施CI-CD对整个团队文化的影响"><a href="#在实施CI-CD对整个团队文化的影响" class="headerlink" title="在实施CI/CD对整个团队文化的影响"></a>在实施CI/CD对整个团队文化的影响</h3><p>CICD是一个流程上的实践，我们把代码开发、到代码部署、到最后的交付，进行持续地迭代和交付，在这个过程中对原来的团队产生的影响是这样的：开发不再只关注他在开发这部分的实现，他需要保证从代码开发实现、到单测、到测试、到构建部署，到最后的分发发布，这样整个流程的覆盖。按照我的理解，CICD对整个团队文化的影响是，每个人对产品研发的整个流程都要全部参与进去，不再是只局限在自己的角色上。比如我是一个开发，我只做实现，我不再关注部署和测试；或者我是一个测试，我不关注开发实现，不关注部署，我只关注执行；或者我是一个运维，我对前面的所有流程都不了解，我只执行最后的运维步骤，而CICD就是把整个团队有效地集成在一起，通过一个流程持续地迭代发布验证，这样的话，整个团队就能更高效地展开合作。</p><h3 id="多分支、多版本实施CI-CD的建议"><a href="#多分支、多版本实施CI-CD的建议" class="headerlink" title="多分支、多版本实施CI/CD的建议"></a>多分支、多版本实施CI/CD的建议</h3><p>我们目前的确也遇到了多分支并行的情况，也就是说我们需要对不同的业务场景做不同的版本管理。在这种情况下，我们依然可以做CI的实施，但是要经过专门的设计，在每个分支所运行的软件，它的版本管理需要做统一的管理，比如需要规划每个分支的依赖是什么样的，要把整个路径都管理起来。如果没有这样的管理，从构建到部署到测试都是混乱的。在版本管理的基础上，我们还要把代码和测试有效地集成起来，也就是说，不光是代码到测试，是代码到配置、到测试、到部署，都要有效地集成起来。一份代码在这个分支上，它对应的配置在哪里，是什么版本，在这个分支上测试的版本在哪里，都需要管理起来；在这个分支上，代码部署的版本依赖也需要统一的管理。如果我们没有做好这些基础设施，是没有办法做CICD实施的。当我们把这些整理清楚之后，再针对每个分支做整体的实施，通过版本管理去理清楚我们实施的部署构建，到底依赖圈是什么样的，这样就可以做一个正确的实施。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;持续集成（Continuous Integration）&lt;/strong&gt;指的是，频繁地（一天多次）将代码集成到主干。 &lt;/p&gt;
&lt;p&gt;在保证质量的前提，通过持续集成使产品进行快速的迭代。&lt;/p&gt;
&lt;p&gt;它的核心措施是，代码集成到主干之前，必须通过自动化测试
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>关于游戏客户端资源热更方式&amp;流程</title>
    <link href="https://yo42.github.io/2018/09/16/%E5%85%B3%E4%BA%8E%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B5%84%E6%BA%90%E7%83%AD%E6%9B%B4%E6%96%B9%E5%BC%8F-%E6%B5%81%E7%A8%8B/"/>
    <id>https://yo42.github.io/2018/09/16/关于游戏客户端资源热更方式-流程/</id>
    <published>2018-09-16T06:41:19.561Z</published>
    <updated>2018-09-16T06:59:58.011Z</updated>
    
    <content type="html"><![CDATA[<p>应用场景:客户端人员上传更新资源至内网FTP，运维人员操作将客户端资源外放至外网CDN源站。</p><p>实现技术方案:源站架设Nginx，通过GIT远程仓库模式进行资源的更新。</p><p>改进优化的方向:目前，还是通过手动外放资源的方式进行操作，可以优化为开放HTTP Web API接口实现调用GIT命令，进行资源更新的流程。</p><p>逻辑图:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="client.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="client2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="架设部署gitolite"><a href="#架设部署gitolite" class="headerlink" title="架设部署gitolite"></a>架设部署gitolite</h3><h3 id="克隆管理库"><a href="#克隆管理库" class="headerlink" title="克隆管理库"></a>克隆管理库</h3><h3 id="修改-git2-gitolite-conf-gitolite-conf-配置客户端更新库，并提交即可完成创建操作。"><a href="#修改-git2-gitolite-conf-gitolite-conf-配置客户端更新库，并提交即可完成创建操作。" class="headerlink" title="修改 ./git2-gitolite/conf/gitolite.conf 配置客户端更新库，并提交即可完成创建操作。"></a>修改 ./git2-gitolite/conf/gitolite.conf 配置客户端更新库，并提交即可完成创建操作。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repo cilugame/h5-client</span><br><span class="line">    RW      =   @oc_users</span><br></pre></td></tr></table></figure><h3 id="创建本地库"><a href="#创建本地库" class="headerlink" title="创建本地库"></a>创建本地库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/nucleus/client/data/h5</span><br><span class="line">git init ./</span><br></pre></td></tr></table></figure><h3 id="忽略无关配置"><a href="#忽略无关配置" class="headerlink" title="忽略无关配置"></a>忽略无关配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat&lt;&lt;EOF &gt; .gitignore</span><br><span class="line">/*</span><br><span class="line">!/release</span><br><span class="line">!/release/*</span><br><span class="line">!/.gitignore</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="上传客户端资源"><a href="#上传客户端资源" class="headerlink" title="上传客户端资源"></a>上传客户端资源</h3><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git ci -minit</span><br></pre></td></tr></table></figure><h3 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@git2.cilugame.com:cilugame/h5-client.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="登录CDN源站"><a href="#登录CDN源站" class="headerlink" title="登录CDN源站"></a>登录CDN源站</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/nucleus-h5/global/client/html</span><br></pre></td></tr></table></figure><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@git2.cilugame.com:cilugame/h5-client.git ./h5/</span><br></pre></td></tr></table></figure><h3 id="安全加固"><a href="#安全加固" class="headerlink" title="安全加固"></a>安全加固</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 ./h5/.git/</span><br><span class="line">chmod 600 ./h5/.gitignore</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;应用场景:客户端人员上传更新资源至内网FTP，运维人员操作将客户端资源外放至外网CDN源站。&lt;/p&gt;
&lt;p&gt;实现技术方案:源站架设Nginx，通过GIT远程仓库模式进行资源的更新。&lt;/p&gt;
&lt;p&gt;改进优化的方向:目前，还是通过手动外放资源的方式进行操作，可以优化为开放HTT
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>关于Gitolite &amp; SSH-Config联动</title>
    <link href="https://yo42.github.io/2018/09/16/%E5%85%B3%E4%BA%8EGitolite-SSH-Config%E8%81%94%E5%8A%A8/"/>
    <id>https://yo42.github.io/2018/09/16/关于Gitolite-SSH-Config联动/</id>
    <published>2018-09-16T03:58:25.689Z</published>
    <updated>2018-09-16T07:04:42.634Z</updated>
    
    <content type="html"><![CDATA[<p>Gitolite是一款Perl语言开发的Git服务管理工具，通过公钥对用户进行认证，并能够通过配置文件对写操作进行基于分支和路径的精细授权。<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">仓库地址</a></p><p>SSH-Config:OpenSSH SSH Client config files;SSH config是SSH客户端的一个参数配置方案，可以将一些关于SSH命令的参数放到配置文件中去，执行ssh命令的时候从文件中读取，简化命令行的操作。</p><p>应用场景:开发团队，个人客户端本地通过GIT团队协作模式，实时更新服务器信息。通过配置个人ssh-config(～/.ssh/config)，结合ZSH 补全，可以实现方便、快捷的登录服务器。</p><p>效果图如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="ssh.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="服务端部署gitolite"><a href="#服务端部署gitolite" class="headerlink" title="服务端部署gitolite:"></a>服务端部署gitolite:</h3><h3 id="steps-to-install"><a href="#steps-to-install" class="headerlink" title="steps to install"></a>steps to install</h3><p>First, prepare the ssh key:</p><ul><li>login to “git” on the server</li><li>make sure <code>~/.ssh/authorized_keys</code> is empty or non-existent</li><li>make sure your ssh public key from your workstation has been copied as $HOME/YourName.pub</li></ul><p>Next, install gitolite by running these commands:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/sitaramc/gitolite</span><br><span class="line">mkdir -p $HOME/bin</span><br><span class="line">gitolite/install -to $HOME/bin</span><br></pre></td></tr></table></figure><p>Finally, setup gitolite with yourself as the administrator:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitolite setup -pk YourName.pub</span><br></pre></td></tr></table></figure><p>If the last command doesn’t run perhaps “bin” is not in your “PATH”. You can either add it, or just run:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME/bin/gitolite setup -pk YourName.pub</span><br></pre></td></tr></table></figure><p>If you get any other errors please refer to the online documentation whose URL was given at the top of this file.</p><h3 id="个人本地克隆管理库，实现维护git仓库"><a href="#个人本地克隆管理库，实现维护git仓库" class="headerlink" title="个人本地克隆管理库，实现维护git仓库"></a>个人本地克隆管理库，实现维护git仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@host:gitolite-admin</span><br></pre></td></tr></table></figure><h3 id="新增仓库、以及日常修改权限配置文件"><a href="#新增仓库、以及日常修改权限配置文件" class="headerlink" title="新增仓库、以及日常修改权限配置文件"></a>新增仓库、以及日常修改权限配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conf/gitolite.conf</span><br></pre></td></tr></table></figure><h3 id="新增个人公钥"><a href="#新增个人公钥" class="headerlink" title="新增个人公钥"></a>新增个人公钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在key/目录下新增个人公钥</span><br></pre></td></tr></table></figure><h3 id="Example："><a href="#Example：" class="headerlink" title="Example："></a>Example：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ops_users = mike jake</span><br><span class="line">@dev_users = tom jerry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">repo cilu-h5</span><br><span class="line">    RW      =   @ops_users</span><br><span class="line">    RW      =   get_host xxx</span><br><span class="line">    R       =   tom</span><br><span class="line">    R       =   jerry</span><br></pre></td></tr></table></figure><p>新增仓库只需新增一个repo配置项</p><p>按需使用仓库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@git2.cilugame.com:cilu-h5.git ~/ssh-config/cilu-h5/</span><br></pre></td></tr></table></figure><p>合并本地.ssh/config脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># vim:set et ts=2 sw=2:</span></span><br><span class="line"><span class="comment">#set -x</span></span><br><span class="line"></span><br><span class="line">current_dir=$(dirname <span class="variable">$0</span>)</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;current_dir&#125;</span> &amp;&amp; <span class="built_in">export</span> current_dir</span><br><span class="line"></span><br><span class="line">old_ssh=~/.ssh/config</span><br><span class="line">new_ssh=~/.ssh/config.new</span><br><span class="line">bak_dir=~/.ssh/backup</span><br><span class="line">bak_ssh=<span class="string">"<span class="variable">$&#123;bak_dir&#125;</span>/<span class="variable">$(date +'%F_%H%M%S')</span>"</span></span><br><span class="line">hostname=$(hostname)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="variable">$&#123;old_ssh&#125;</span> ] ;<span class="keyword">then</span></span><br><span class="line">  touch <span class="variable">$&#123;old_ssh&#125;</span></span><br><span class="line">  chmod 0644 <span class="variable">$&#123;old_ssh&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">[ -d ~/.ssh/ControlPath ] || mkdir -pv ~/.ssh/ControlPath</span><br><span class="line"></span><br><span class="line"><span class="comment"># header</span></span><br><span class="line">cat&lt;&lt;\EOF &gt; <span class="variable">$&#123;new_ssh&#125;</span></span><br><span class="line">Host github.com</span><br><span class="line">  Port 22</span><br><span class="line"></span><br><span class="line">Host cnc.cilugame.com</span><br><span class="line">  Port 11932</span><br><span class="line"></span><br><span class="line">Host git2.cilugame.com</span><br><span class="line">    ProxyCommand ssh -q h5@jump.cilugame.com socat - TCP:%h:%p</span><br><span class="line"></span><br><span class="line">Host *</span><br><span class="line">   Port 932</span><br><span class="line">   SendEnv LANG LC_*</span><br><span class="line">   SendEnv GIT_*</span><br><span class="line">   ForwardAgent yes</span><br><span class="line">   ServerAliveInterval 10</span><br><span class="line">   XAuthLocation /opt/X11/bin/xauth</span><br><span class="line">   UseRoaming no</span><br><span class="line">   ControlPersist 1h</span><br><span class="line">   ControlMaster auto</span><br><span class="line">   ControlPath ~/.ssh/ControlPath/%r@%h:%p</span><br><span class="line">   Compression yes</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># openssh 在7.2版本新增了AddKeysToAgent参数并废弃了AskPassGUI参数</span></span><br><span class="line"><span class="keyword">if</span> ssh -V 2&gt;&amp;1 | grep -q <span class="string">"OpenSSH_7.[2-9]"</span>;<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"   AddKeysToAgent yes"</span> &gt;&gt; <span class="variable">$&#123;new_ssh&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># merge</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> ../*/[0-9]*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  file_name=$(basename <span class="variable">$file</span>)</span><br><span class="line">  dir_name=$(dirname  <span class="variable">$file</span>)</span><br><span class="line">  dir_name=$(basename  <span class="variable">$dir_name</span>)</span><br><span class="line">  src_file=<span class="string">"~/ssh-config/<span class="variable">$&#123;dir_name&#125;</span>/<span class="variable">$&#123;file_name&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#echo "#========== $src_file" &gt;&amp;2</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"#========== <span class="variable">$src_file</span> ==========#"</span></span><br><span class="line"></span><br><span class="line">  cat <span class="variable">$file</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line"><span class="keyword">done</span> &gt;&gt; <span class="variable">$&#123;new_ssh&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compare and backup</span></span><br><span class="line">system=$(uname)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$system</span>"</span> == <span class="string">"xDarwin"</span> ] ;<span class="keyword">then</span></span><br><span class="line">  old_md5=$(md5 <span class="variable">$old_ssh</span> | awk <span class="string">'&#123;print $4&#125;'</span>)</span><br><span class="line">  new_md5=$(md5 <span class="variable">$new_ssh</span> | awk <span class="string">'&#123;print $4&#125;'</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  old_md5=$(md5sum <span class="variable">$old_ssh</span> | awk <span class="string">'&#123;print $1&#125;'</span>)</span><br><span class="line">  new_md5=$(md5sum <span class="variable">$new_ssh</span> | awk <span class="string">'&#123;print $1&#125;'</span>)</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo "merge to ~/.ssh/config" &gt;&amp;2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$&#123;old_md5&#125;</span>"</span> = <span class="string">"x<span class="variable">$&#123;new_md5&#125;</span>"</span> ] ;<span class="keyword">then</span></span><br><span class="line">  <span class="comment">#echo "Already up-to-date." &gt;&amp;2</span></span><br><span class="line">  rm -f <span class="variable">$new_ssh</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment">#echo "Updating..." &gt;&amp;2</span></span><br><span class="line">  [ -d <span class="string">"<span class="variable">$bak_dir</span>"</span> ] || mkdir <span class="string">"<span class="variable">$bak_dir</span>"</span></span><br><span class="line">  cp <span class="variable">$old_ssh</span> <span class="variable">$bak_ssh</span></span><br><span class="line">  mv <span class="variable">$new_ssh</span> <span class="variable">$old_ssh</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">chmod 0644 <span class="variable">$&#123;old_ssh&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释ControlPersist</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$hostname</span>"</span> == <span class="string">'oc-dev-s73'</span> ];<span class="keyword">then</span></span><br><span class="line">  sed -i <span class="string">'s/ControlPersist 1h/#ControlPersist 1h/g'</span> <span class="variable">$&#123;old_ssh&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="配置GIT钩子，实现自动触发，更新配置文件"><a href="#配置GIT钩子，实现自动触发，更新配置文件" class="headerlink" title="配置GIT钩子，实现自动触发，更新配置文件"></a>配置GIT钩子，实现自动触发，更新配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/ssh-config/</span><br><span class="line"><span class="keyword">for</span> dir <span class="keyword">in</span> *</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="variable">$dir</span> ] ;<span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">pushd</span> <span class="variable">$dir</span> &gt; /dev/null</span><br><span class="line">    [ -d <span class="string">"./.git/hooks"</span> ] || <span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'#!/bin/sh'</span>                        &gt; .git/hooks/post-merge</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'[ -x ./merge.sh ] &amp;&amp; ./merge.sh'</span> &gt;&gt; .git/hooks/post-merge</span><br><span class="line"></span><br><span class="line">    chmod +x .git/hooks/post-merge</span><br><span class="line">    <span class="built_in">popd</span> &gt; /dev/null</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>后续有更新时（成功后会自动调用勾子进行合并操作）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/ssh-config/cilu-h5/</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>通过使用Gitolite可以大大提高团队的协助效率，有时如果是需要提供第三方技术支持，也可以使用Gitolite进行一些简单的配置文件更新、及交付。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Gitolite是一款Perl语言开发的Git服务管理工具，通过公钥对用户进行认证，并能够通过配置文件对写操作进行基于分支和路径的精细授权。&lt;a href=&quot;https://github.com/sitaramc/gitolite&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-学习资料&amp;社区资讯</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker-s-Guide-to-Python-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99-%E7%A4%BE%E5%8C%BA%E8%B5%84%E8%AE%AF/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker-s-Guide-to-Python-学习资料-社区资讯/</id>
    <published>2018-09-15T10:21:59.298Z</published>
    <updated>2018-09-16T00:27:22.940Z</updated>
    
    <content type="html"><![CDATA[<h3 id="The-Python-Tutorial"><a href="#The-Python-Tutorial" class="headerlink" title="The Python Tutorial"></a>The Python Tutorial</h3><p>这个是官方教程。它包含了所有的基础，并提供了一个关于语言和标准库的教程。推荐给那些需要一份关于这门语言的快速开始指南的人们。</p><blockquote><p><a href="http://docs.python.org/tutorial/index.html" target="_blank" rel="noopener">The Python Tutorial</a></p></blockquote><h3 id="Python-for-Beginners"><a href="#Python-for-Beginners" class="headerlink" title="Python for Beginners"></a>Python for Beginners</h3><p>thepythonguru.com 是一个专注于新手程序员的教程网站。它涵盖了许多深度的 Python 概念。它也会教你一些像 lambda 表达式，正则表达式等 Python 的高级结构。 最后，它以『如何使用 Python 访问 MySQL 数据库』这篇教程结束。</p><blockquote><p><a href="http://thepythonguru.com/" target="_blank" rel="noopener">Python for beginners</a></p></blockquote><h3 id="学习-Python-交互式数据科学"><a href="#学习-Python-交互式数据科学" class="headerlink" title="学习 Python 交互式数据科学"></a>学习 Python 交互式数据科学</h3><p>如果你热衷于在线交互式环境来学习 Python 数据科学， <a href="https://www.datacamp.com/courses/intro-to-python-for-data-science?tap_a=5644-dce66f&amp;tap_s=116411-750171" target="_blank" rel="noopener">this free python tutorial by DataCamp</a> 是一个比较好的开始。如果你已经是一位对机器学习有提前了解和兴趣，并使用scikit-learn的核心开发人员，查看 <a href="https://www.datacamp.com/courses/supervised-learning-with-scikit-learn?tap_a=5644-dce66f&amp;tap_s=116411-750171" target="_blank" rel="noopener">course on Supervised Learning with scikit-learn</a> 。</p><p><a href="http://datacamp.com/?tap_a=5644-dce66f&amp;tap_s=116411-750171" target="_blank" rel="noopener">Python 数据科学</a></p><h3 id="学习交互式-Python-教程"><a href="#学习交互式-Python-教程" class="headerlink" title="学习交互式 Python 教程"></a>学习交互式 Python 教程</h3><p>Learnpython.org 是一个简单自由获取 Python 介绍的方式。这个网站采用与流行站点 <a href="http://tryruby.org/" target="_blank" rel="noopener">Try Ruby</a> 相同的方式，站点自带交互式 Python 解释器，这样你可以不用在本地安装 Python 就可以进行学习。</p><blockquote><p><a href="http://www.learnpython.org/" target="_blank" rel="noopener">Learn Python</a></p></blockquote><p>如果你想拥有传统纸质书籍，<em>Python For You and Me</em>  是一个学习这门语言各个方面的极佳资源。</p><blockquote><p><a href="https://pymbook.readthedocs.io/" target="_blank" rel="noopener">Python for You and Me</a> <a href="https://www.datacamp.com/" target="_blank" rel="noopener">Learn Python Interactively with DataCamp!</a></p></blockquote><h3 id="渐进式学习-Python"><a href="#渐进式学习-Python" class="headerlink" title="渐进式学习 Python"></a>渐进式学习 Python</h3><p>Techbeamers.com 提供渐进式教程进行 Python 教学。每一个主题的教程都添加了逻辑性的代码片段，并设置了随堂测验。这里是一份关于 <a href="http://www.techbeamers.com/python-interview-questions-programmers" target="_blank" rel="noopener">Python 面试问题</a> 的章节来帮助求职者。你也可以阅读要点 <a href="http://www.techbeamers.com/essential-python-tips-tricks-programmers" target="_blank" rel="noopener">Python tips</a> 和学习 <a href="http://www.techbeamers.com/python-code-optimization-tips-tricks" target="_blank" rel="noopener">best coding practices</a> 来撰写高质量的代码。通过下面这个链接，你将获得正确的平台来快速学习 Python 。</p><p><a href="http://www.techbeamers.com/python-tutorial-step-by-step" target="_blank" rel="noopener">Python 从入门到高级</a></p><h3 id="在线-Python-助教"><a href="#在线-Python-助教" class="headerlink" title="在线 Python 助教"></a>在线 Python 助教</h3><p>在线 Python 助教给你一个可视化的渐进步骤，来说明你的程序是如何运行的。Python 助教帮助人们理解电脑执行程序源代码每一行的方式来克服基础障碍。</p><blockquote><p><a href="http://pythontutor.com/" target="_blank" rel="noopener">在线 Python 助教</a></p></blockquote><h3 id="用-Python-创作一个属于你自己的电脑游戏"><a href="#用-Python-创作一个属于你自己的电脑游戏" class="headerlink" title="用 Python 创作一个属于你自己的电脑游戏"></a>用 Python 创作一个属于你自己的电脑游戏</h3><p>这本书，正适合编程零经验的初学者。每一个章节都有一个小游戏的源代码，利用这些例证程序来解释程序设计概念，给读者一个「感性」的程序思想。</p><blockquote><p><a href="http://inventwithpython.com/" target="_blank" rel="noopener">Invent Your Own Computer Games with Python</a></p></blockquote><h3 id="Hacking-Secret-Ciphers-with-Python"><a href="#Hacking-Secret-Ciphers-with-Python" class="headerlink" title="Hacking Secret Ciphers with Python"></a>Hacking Secret Ciphers with Python</h3><p>这本书教授完全初学者 Python 程序设计和基础密码学。章节提供各式各样的密码源代码，同时提供程序是如何破解它们的方法。</p><blockquote><p><a href="http://inventwithpython.com/hacking/" target="_blank" rel="noopener">Hacking Secret Ciphers with Python</a></p></blockquote><h3 id="Learn-Python-the-Hard-Way"><a href="#Learn-Python-the-Hard-Way" class="headerlink" title="Learn Python the Hard Way"></a>Learn Python the Hard Way</h3><p>这是一份绝佳的 Python 初级程序员指南。包含了从 console 到 web 的「 hello world 」。</p><blockquote><p><a href="http://learnpythonthehardway.org/book/" target="_blank" rel="noopener">Learn Python the Hard Way</a></p></blockquote><h3 id="Python速成"><a href="#Python速成" class="headerlink" title="Python速成"></a>Python速成</h3><p>这份指南和 <em>Python for Programmers with 3 Hours</em> 一样出名，它为使用其他开发语言的有经验的程序员提供了 Python 速成课。</p><blockquote><p><a href="http://stephensugden.com/crash_into_python/" target="_blank" rel="noopener">Python 速成</a></p></blockquote><h3 id="Dive-Into-Python-3"><a href="#Dive-Into-Python-3" class="headerlink" title="Dive Into Python 3"></a>Dive Into Python 3</h3><p>Dive Into Python 3 对于那些准备转投 Python 3 的程序员是一本好书。如果你正准备从 Python 2 过渡到 3 ，亦或者你已经具有其他语言的开发经验，这本书对你来说非常适合阅读。</p><blockquote><p><a href="http://www.diveintopython3.net/" target="_blank" rel="noopener">Dive Into Python 3</a></p></blockquote><h3 id="Think-Python-How-to-Think-Like-a-Computer-Scientist"><a href="#Think-Python-How-to-Think-Like-a-Computer-Scientist" class="headerlink" title="Think Python: How to Think Like a Computer Scientist"></a>Think Python: How to Think Like a Computer Scientist</h3><p>Think Python 尝试在使用 Python 语言时介绍一个基础的计算机科学的概念。它的目的是创造一本拥有大量练习、通俗易懂并且每个章节的每个片段都致力于解决项目问题的书。</p><p>在探索 Python 语言大量特性的可行性时，作者穿插了各式各样的设计模式和最优范例。</p><p>这本书也包含了几个案例研究，让读者将书本中讨论的主题应用到实际问题中来更好的学习。案例研究包含关于 GUI 和 Markov Analysis 的作业。</p><blockquote><p><a href="http://greenteapress.com/thinkpython/html/index.html" target="_blank" rel="noopener">Think Python</a></p></blockquote><h3 id="Python-Koans"><a href="#Python-Koans" class="headerlink" title="Python Koans"></a>Python Koans</h3><p>Python Koans 是 Edgecase’s Ruby Koans 的一个端口。它使用测试驱动的方法，参阅 TEST DRIVEN DESIGN SECTION 来提供一个交互式教程来教学基础 Python 概念。通过修复在测试脚本中失败的断言语句，这提供了一个连续的步骤来学习 Python。</p><p>对于那些习惯于使用语言并自己搞清楚问题的人来说，将是一个富有欢乐和吸引力的选择。对于那些 Python 和程序设计初学者来说，拥有额外的资源和参考将非常有帮助。</p><blockquote><p><a href="http://bitbucket.org/gregmalcolm/python_koans" target="_blank" rel="noopener">Python Koans</a></p></blockquote><p>更多关于测试驱动开发的资源请关注：</p><blockquote><p><a href="http://en.wikipedia.org/wiki/Test-driven_development" target="_blank" rel="noopener">Test Driven Development</a></p></blockquote><h3 id="A-Byte-of-Python"><a href="#A-Byte-of-Python" class="headerlink" title="A Byte of Python"></a>A Byte of Python</h3><p>A Byte of Python 是一本学习 Python 的免费入门书籍，非常适合没有编程基础的人学习。</p><blockquote><p><a href="http://www.ibiblio.org/swaroopch/byteofpython/read/" target="_blank" rel="noopener">A Byte of Python for Python 2.x</a> <a href="https://python.swaroopch.com/" target="_blank" rel="noopener">A Byte of Python for Python 3.x</a></p></blockquote><h3 id="Learn-to-Program-in-Python-with-Codeacademy"><a href="#Learn-to-Program-in-Python-with-Codeacademy" class="headerlink" title="Learn to Program in Python with Codeacademy"></a>Learn to Program in Python with Codeacademy</h3><p>这是一个适合绝大多数 Python 初学者的 Codeacademy 课程。这个免费的交互式课程主要教授 Python 编程中基础和部分深入的知识，同时会有测试来检验学者对知识的掌握程度。 这门课程也包含很多功能可以反馈你学习的情况，帮助你更好的学习。</p><blockquote><p><a href="http://www.codecademy.com/en/tracks/python" target="_blank" rel="noopener">Learn to Program in Python with Codeacademy</a></p></blockquote><h3 id="Code-the-blocks"><a href="#Code-the-blocks" class="headerlink" title="Code the blocks"></a>Code the blocks</h3><p><em>Code the blocks</em> 为初学者提供免费交互式的 Python 教程。它将 Python 程序设计和 3D 环境下「 搭砖块 」建造建筑相互结合。此教程教授你如何使用 Python 一步步创造一个精细的 3D 建筑，让你学习 Python 的过程充满欢乐。</p><blockquote><p><a href="https://codetheblocks.com/tutorials/introduction" target="_blank" rel="noopener">Code the blocks</a></p></blockquote><h2 id="Intermediate"><a href="#Intermediate" class="headerlink" title="Intermediate"></a>Intermediate</h2><h3 id="Effective-Python"><a href="#Effective-Python" class="headerlink" title="Effective Python"></a>Effective Python</h3><p>这本书包含了 59 种特定方法来提高编写 Pythonic 代码。总长度只有 227 页，列举了大量的晋升中等水平 Python 工程师必备的知识技能。</p><blockquote><p><a href="http://www.effectivepython.com/" target="_blank" rel="noopener">Effective Python</a></p></blockquote><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="Pro-Python"><a href="#Pro-Python" class="headerlink" title="Pro Python"></a>Pro Python</h3><p>这本书适用于中级到高级 Python 程序员，他们希望理解 Python 的工作原理以及怎样提升自己的代码水平。</p><blockquote><p><a href="http://propython.com/" target="_blank" rel="noopener">Pro Python</a></p></blockquote><h3 id="《Expert-Python-Programming》"><a href="#《Expert-Python-Programming》" class="headerlink" title="《Expert Python Programming》"></a>《Expert Python Programming》</h3><p>《Expert Python Programming》专注于为高级工程师提供 Python 的最佳实践的建议。</p><p>它的话题包括装饰器（伴随缓存、代理、上下文管理器、案例研究）、方法解析顺序，使用 <code>super()</code> 和元编程，还有通用的 <a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener">PEP 8</a> 最佳实践。</p><p>它花了多个章节，详细地介绍了如何编写和发布一个扩展包甚至最终发布一个应用，包含了一个使用 zc.buildout 的章节。后面的章节详细讲述了最佳实践，比如编写文档、测试驱动开发、 版本控制、优化和分析。</p><blockquote><p><a href="http://www.packtpub.com/expert-python-programming/book" target="_blank" rel="noopener">Expert Python Programming</a></p></blockquote><h3 id="《A-Guide-to-Python’s-Magic-Methods》"><a href="#《A-Guide-to-Python’s-Magic-Methods》" class="headerlink" title="《A Guide to Python’s Magic Methods》"></a>《A Guide to Python’s Magic Methods》</h3><p>这 是Rafe Kettler 发表博文的集合，解释了 Python 中的 “魔法方法”。魔法方法由双下划线包围 （比如 <strong>init</strong>），能够使类和对象表现出不同的、魔法的行为。</p><blockquote><p><a href="http://www.rafekettler.com/magicmethods.html" target="_blank" rel="noopener">A Guide to Python’s Magic Methods</a></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>Rafekettler.com 目前已关闭，您可以直接访问他们的 Github 版本。 在这里您可以找到一个 PDF 版本:  <a href="https://github.com/RafeKettler/magicmethods/blob/master/magicmethods.pdf" target="_blank" rel="noopener">A Guide to Python’s Magic Methods (repo on GitHub)</a></p></blockquote><h2 id="工程师和科学家"><a href="#工程师和科学家" class="headerlink" title="工程师和科学家"></a>工程师和科学家</h2><h3 id="A-Primer-on-Scientific-Programming-with-Python"><a href="#A-Primer-on-Scientific-Programming-with-Python" class="headerlink" title="A Primer on Scientific Programming with Python"></a>A Primer on Scientific Programming with Python</h3><p>《A Primer on Scientific Programming with Python》由 Hans Petter Langtangen 编写， 主要涵盖了 Python 在科学领域的使用。在这本书中，例子是从数学和自然科学中选出的。</p><blockquote><p><a href="http://www.springer.com/mathematics/computational+science+%26+engineering/book/978-3-642-30292-3" target="_blank" rel="noopener">A Primer on Scientific Programming with Python</a></p></blockquote><h3 id="Numerical-Methods-in-Engineering-with-Python"><a href="#Numerical-Methods-in-Engineering-with-Python" class="headerlink" title="Numerical Methods in Engineering with Python"></a>Numerical Methods in Engineering with Python</h3><p>《Numerical Methods in Engineering with Python》由 Jaan Kiusalaas 编写， 其重点是数值方法以及如何用 Python 来实现他们。</p><blockquote><p><a href="http://www.cambridge.org/us/academic/subjects/engineering/engineering-mathematics-and-programming/numerical-methods-engineering-python-2nd-edition" target="_blank" rel="noopener">Numerical Methods in Engineering with Python</a></p></blockquote><h2 id="其他话题"><a href="#其他话题" class="headerlink" title="其他话题"></a>其他话题</h2><h3 id="Problem-Solving-with-Algorithms-and-Data-Structures"><a href="#Problem-Solving-with-Algorithms-and-Data-Structures" class="headerlink" title="Problem Solving with Algorithms and Data Structures"></a>Problem Solving with Algorithms and Data Structures</h3><p>《Problem Solving with Algorithms and Data Structures》涵盖了一系列数据结构和算法。 所有概念都用 Python 代码说明，提供了可在浏览器中直接运行的交互式样例。</p><blockquote><p><a href="http://www.interactivepython.org/courselib/static/pythonds/index.html" target="_blank" rel="noopener">Problem Solving with Algorithms and Data Structures</a></p></blockquote><h3 id="Programming-Collective-Intelligence"><a href="#Programming-Collective-Intelligence" class="headerlink" title="Programming Collective Intelligence"></a>Programming Collective Intelligence</h3><p>《Programming Collective Intelligence》介绍了大量基础的机器学习和数据挖掘方法。 本书不会侧重于数据挖掘的数学原理，而是更侧重于解释底层的理论算法，以及展示如何使用 Python 来实现这些算法。</p><blockquote><p><a href="http://shop.oreilly.com/product/9780596529321.do" target="_blank" rel="noopener">Programming Collective Intelligence</a></p></blockquote><h3 id="Transforming-Code-into-Beautiful-Idiomatic-Python"><a href="#Transforming-Code-into-Beautiful-Idiomatic-Python" class="headerlink" title="Transforming Code into Beautiful, Idiomatic Python"></a>Transforming Code into Beautiful, Idiomatic Python</h3><p>《Transforming Code into Beautiful, Idiomatic Python》 是由 Raymond Hettinger 制作的视频。 通过它可以学习到如何更好地利用 Python 最好的特性和如何通过代码转换来改进现有代码。</p><blockquote><p><a href="https://www.youtube.com/watch?v=OSGv2VnC0go" target="_blank" rel="noopener">Transforming Code into Beautiful, Idiomatic Python</a></p></blockquote><h3 id="Fullstack-Python"><a href="#Fullstack-Python" class="headerlink" title="Fullstack Python"></a>Fullstack Python</h3><p>《Fullstack Python》为使用 Python 进行 Web 开发提供了完整的自上向下的资源。</p><p>技术话题范围涵盖从设置 Web 服务器到设计前端、选择数据库、优化/缩放等。</p><p>顾名思义，它涵盖了从头开始构建和运行完整的 Web 应用程序所需的所有内容。</p><blockquote><p><a href="https://www.fullstackpython.com/" target="_blank" rel="noopener">Fullstack Python</a></p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="Python-in-a-Nutshell"><a href="#Python-in-a-Nutshell" class="headerlink" title="Python in a Nutshell"></a>Python in a Nutshell</h3><p>《Python in a Nutshell》 由 Alex Martelli编写，涵盖了 Python 跨平台的多数用法， 从它的语法到内建库，再到比如说编写 C 扩展的高级主题。</p><blockquote><p><a href="http://shop.oreilly.com/product/9780596001889.do" target="_blank" rel="noopener">Python in a Nutshell</a></p></blockquote><h3 id="The-Python-Language-Reference"><a href="#The-Python-Language-Reference" class="headerlink" title="The Python Language Reference"></a>The Python Language Reference</h3><p>这是 Python 的参考手册，它涵盖了这门语言的语法和核心语义。</p><blockquote><p><a href="http://docs.python.org/reference/index.html" target="_blank" rel="noopener">The Python Language Reference</a></p></blockquote><h3 id="Python-Essential-Reference"><a href="#Python-Essential-Reference" class="headerlink" title="Python Essential Reference"></a>Python Essential Reference</h3><p>《Python Essential Reference》，由 David Beazley 撰写，是 Python 的最终参考指南。 它简明扼要地解释了标准库的核心语言和最重要的部分。 它涵盖了 Python 3 和 2.6 版本。</p><blockquote><p><a href="http://www.dabeaz.com/per.html" target="_blank" rel="noopener">Python Essential Reference</a></p></blockquote><h3 id="Python-Pocket-Reference"><a href="#Python-Pocket-Reference" class="headerlink" title="Python Pocket Reference"></a>Python Pocket Reference</h3><p>《Python Pocket Reference》由 Mark Lutz 编写，是一个了解核心语言的易于使用的参考， 介绍了常用的模块和工具集。它涵盖了 Python 3 和 Python 2。</p><blockquote><p><a href="http://shop.oreilly.com/product/9780596158095.do" target="_blank" rel="noopener">Python Pocket Reference</a></p></blockquote><h3 id="Python-Cookbook"><a href="#Python-Cookbook" class="headerlink" title="Python Cookbook"></a>Python Cookbook</h3><p>Python Cookbook 由 David Beazley 和 Brian K. Jones 编写，打包了许多具有实践意义的”食谱”。 这本书涵盖了核心 Python 语言，也涵盖了诸多不同应用的常见任务。</p><blockquote><p><a href="http://shop.oreilly.com/product/0636920027072.do" target="_blank" rel="noopener">Python Cookbook</a></p></blockquote><h3 id="Writing-Idiomatic-Python"><a href="#Writing-Idiomatic-Python" class="headerlink" title="Writing Idiomatic Python"></a>Writing Idiomatic Python</h3><p>《Writing Idiomatic Python》由 Jeff Knupp 编写，包含了最常见和最重要的 Python 习语， 其形式尽可能地有辨识度和易于理解。每个习语都是编写一些常用代码片段的推荐方式， 其后会解释为什么这个习语是重要的。每个习语均有两个代码样例：”有害的” 方式和 “理想的” 方式。</p><blockquote><p><a href="http://www.amazon.com/Writing-Idiomatic-Python-2-7-3-Knupp/dp/1482372177/" target="_blank" rel="noopener">For Python 2.7.3+</a></p><p><a href="http://www.amazon.com/Writing-Idiomatic-Python-Jeff-Knupp-ebook/dp/B00B5VXMRG/" target="_blank" rel="noopener">For Python 3.3+</a></p></blockquote><h2 id="Planet-Python"><a href="#Planet-Python" class="headerlink" title="Planet Python"></a>Planet Python</h2><p>这是一个来自日益增长的开发者提供的 Python 资讯汇总。</p><blockquote><p><a href="http://planet.python.org/" target="_blank" rel="noopener">Planet Python</a></p></blockquote><h2 id="r-python"><a href="#r-python" class="headerlink" title="/r/python"></a>/r/python</h2><p>/r/python 是 Reddit Python 社区，在这里，用户对 Python 相关的资讯进行投稿和投票。</p><blockquote><p><a href="http://reddit.com/r/python" target="_blank" rel="noopener">/r/python</a></p></blockquote><h2 id="Talk-Python-Podcast"><a href="#Talk-Python-Podcast" class="headerlink" title="Talk Python Podcast"></a>Talk Python Podcast</h2><p>头号以 Python 为重点的播客，涵盖了 Python 相关的人员和想法。</p><blockquote><p><a href="https://talkpython.fm/" target="_blank" rel="noopener">Talk Python To Me</a></p></blockquote><h2 id="Python-Bytes-Podcast"><a href="#Python-Bytes-Podcast" class="headerlink" title="Python Bytes Podcast"></a>Python Bytes Podcast</h2><p>一个涵盖最近开发人员头条的简短形式的 Python 播客。</p><blockquote><p><a href="https://pythonbytes.fm/" target="_blank" rel="noopener">Python Bytes</a></p></blockquote><h2 id="Pycoder’s-Weekly"><a href="#Pycoder’s-Weekly" class="headerlink" title="Pycoder’s Weekly"></a>Pycoder’s Weekly</h2><p>Pycoder’s Weekly 是 Python开发者为 Python开发者们准备的免费的 Python 新闻周刊（包括项目，文章，资讯，工作）。</p><blockquote><p><a href="http://www.pycoders.com/" target="_blank" rel="noopener">Pycoder’s Weekly</a></p></blockquote><h2 id="Python-Weekly"><a href="#Python-Weekly" class="headerlink" title="Python Weekly"></a>Python Weekly</h2><p>Python Weekly 是一个以策划 Python 相关的新闻，文章，新版发布，工作等为特色的周刊。</p><blockquote><p><a href="http://www.pythonweekly.com/" target="_blank" rel="noopener">Python Weekly</a></p></blockquote><h2 id="Python-News"><a href="#Python-News" class="headerlink" title="Python News"></a>Python News</h2><p>Python News 是 <a href="https://pythoncaff.com/docs/python-guide/2018/intro-news/www.python.org" target="_blank" rel="noopener">Python 官网</a> 的新闻板块。它简要地强调了 Python 社区的新闻。</p><blockquote><p><a href="http://www.python.org/news/" target="_blank" rel="noopener">Python News</a></p></blockquote><h2 id="Import-Python-Weekly"><a href="#Import-Python-Weekly" class="headerlink" title="Import Python Weekly"></a>Import Python Weekly</h2><p>Weekly Python Newsletter 包含 Python 的文章，项目，视频和你邮箱中的推文。让你的 Python 编程技巧处于更新状态。</p><blockquote><p><a href="http://www.importpython.com/newsletter/" target="_blank" rel="noopener">Import Python Weekly Newsletter</a></p></blockquote><h2 id="Awesome-Python-Newsletter"><a href="#Awesome-Python-Newsletter" class="headerlink" title="Awesome Python Newsletter"></a>Awesome Python Newsletter</h2><p>每周对最受欢迎的 Python 新闻，文章和软件包进行总结。</p><blockquote><p><a href="https://python.libhunt.com/newsletter" target="_blank" rel="noopener">Awesome Python Newsletter</a></p></blockquote><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;The-Python-Tutorial&quot;&gt;&lt;a href=&quot;#The-Python-Tutorial&quot; class=&quot;headerlink&quot; title=&quot;The Python Tutorial&quot;&gt;&lt;/a&gt;The Python Tutorial&lt;/h3&gt;&lt;p&gt;这个
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Docker Harbor镜像仓库</title>
    <link href="https://yo42.github.io/2018/09/15/Docker-Harbor%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/"/>
    <id>https://yo42.github.io/2018/09/15/Docker-Harbor镜像仓库/</id>
    <published>2018-09-15T10:08:02.715Z</published>
    <updated>2018-09-16T07:07:51.713Z</updated>
    
    <content type="html"><![CDATA[<p>场景架构:属于分布式集群的方式部署Dokcer镜像仓库，每个项目部署一个从仓库，所有从仓库共用连接一个主仓库，每次对镜像构建集成时将PUSH至主仓库，主仓库再分发至各项目的从仓库。</p><h2 id="部署Harbor"><a href="#部署Harbor" class="headerlink" title="部署Harbor"></a>部署Harbor</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构:"></a>目录结构:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /home/nucleus-oc/</span><br><span class="line">sudo mkdir /home/nucleus-oc/harbor/  # 数据目录</span><br><span class="line">sudo mkdir /home/nucleus-oc/2231/    # 控制目录</span><br></pre></td></tr></table></figure><h3 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/nucleus-oc/harbor/ssl-key/chained.pem #证书</span><br><span class="line">/home/nucleus-oc/harbor/ssl-key/server.key     # 密钥</span><br></pre></td></tr></table></figure><h3 id="下载并解压缩离线安装包："><a href="#下载并解压缩离线安装包：" class="headerlink" title="下载并解压缩离线安装包："></a>下载并解压缩离线安装包：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home/nucleus-oc/2231/</span><br><span class="line">wget https://github.com/vmware/harbor/releases/download/v1.1.2/harbor-offline-installer-v1.1.2.tgz</span><br><span class="line">tar xf harbor-offline-installer-v1.1.2.tgz</span><br></pre></td></tr></table></figure><h3 id="修改配置文件docker-compose-yml"><a href="#修改配置文件docker-compose-yml" class="headerlink" title="修改配置文件docker-compose.yml"></a>修改配置文件docker-compose.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /home/nucleus-oc/2231/harbor/</span><br><span class="line">sed -e &apos;s@ /data/@ /home/nucleus-oc/harbor/@&apos; \</span><br><span class="line">    -e &apos;s@ /var/log/harbor/@ /home/nucleus-oc/harbor/logs/@&apos; \</span><br><span class="line">    -i docker-compose.yml</span><br></pre></td></tr></table></figure><h3 id="修改harbor-cfg"><a href="#修改harbor-cfg" class="headerlink" title="修改harbor.cfg"></a>修改harbor.cfg</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5 hostname = oc-control-h9tc.mtiancity.com      #仓库域名 </span><br><span class="line">9 ui_url_protocol = https</span><br><span class="line">12 db_password = wV6QRnTkX8SQNqxu</span><br><span class="line">24 ssl_cert = /home/nucleus-oc/harbor/ssl-key/chained.pem  </span><br><span class="line">25 ssl_cert_key = /home/nucleus-oc/harbor/ssl-key/server.key</span><br><span class="line">28 secretkey_path = /home/nucleus-oc/harbor</span><br><span class="line">55 harbor_admin_password = GLcvN2Ezrh5XT3Hx</span><br><span class="line">87 self_registration = off</span><br><span class="line">95 project_creation_restriction = adminonly</span><br></pre></td></tr></table></figure><h3 id="正式安装"><a href="#正式安装" class="headerlink" title="正式安装"></a>正式安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/nucleus-oc/2231/harbor/</span><br><span class="line"> ./install.sh</span><br></pre></td></tr></table></figure><h3 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">https://github.com/goharbor/harbor</a></li><li><a href="http://www.vmtocloud.com/remote-site-replicated-docker-registries-with-vmware-harbor/" target="_blank" rel="noopener">http://www.vmtocloud.com/remote-site-replicated-docker-registries-with-vmware-harbor/</a></li><li><a href="http://www.cnblogs.com/jicki/p/5737369.html" target="_blank" rel="noopener">http://www.cnblogs.com/jicki/p/5737369.html</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;场景架构:属于分布式集群的方式部署Dokcer镜像仓库，每个项目部署一个从仓库，所有从仓库共用连接一个主仓库，每次对镜像构建集成时将PUSH至主仓库，主仓库再分发至各项目的从仓库。&lt;/p&gt;
&lt;h2 id=&quot;部署Harbor&quot;&gt;&lt;a href=&quot;#部署Harbor&quot; clas
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-优雅的包管理</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker-s-Guide-to-Python-%E4%BC%98%E9%9B%85%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker-s-Guide-to-Python-优雅的包管理/</id>
    <published>2018-09-15T09:45:48.832Z</published>
    <updated>2018-09-15T10:07:37.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打包Python项目"><a href="#打包Python项目" class="headerlink" title="打包Python项目"></a>打包Python项目</h1><p>本教程将指导您如何打包一个简单的Python项目。它将向您展示如何添加必要的文件和结构来创建包，如何构建包以及如何将其上载到Python包索引。</p><h2 id="一个简单的项目"><a href="#一个简单的项目" class="headerlink" title="一个简单的项目"></a>一个简单的项目</h2><p>本教程使用一个名为的简单项目<code>example_pkg</code>。如果您不熟悉Python的模块和<a href="https://packaging.python.org/glossary/#term-import-package" target="_blank" rel="noopener">导入包</a>，请花几分钟时间阅读包含<a href="https://docs.python.org/3/tutorial/modules.html#packages" target="_blank" rel="noopener">文件包和模块</a>的<a href="https://docs.python.org/3/tutorial/modules.html#packages" target="_blank" rel="noopener">Python文档</a>。</p><p>要在本地创建此项目，请创建以下文件结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/example_pkg</span><br><span class="line">  /example_pkg</span><br><span class="line">    __init__.py</span><br></pre></td></tr></table></figure><p>创建此结构后，您将需要在顶级文件夹中运行本教程中的所有命令 - 所以一定要确保。<code>cd example_pkg</code></p><p>您还应该编辑<code>example_pkg/__init__.py</code>并在其中放入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;example_pkg&quot;</span><br></pre></td></tr></table></figure><p>这只是为了您可以在本教程后面验证它是否正确安装。</p><h2 id="创建包文件"><a href="#创建包文件" class="headerlink" title="创建包文件"></a>创建包文件</h2><p>现在，您将创建一些文件来打包此项目并准备分发。创建下面列出的新文件 - 您将在以下步骤中向其添加内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/example_pkg</span><br><span class="line">  /example_pkg</span><br><span class="line">    __init__.py</span><br><span class="line">  setup.py</span><br><span class="line">  LICENSE</span><br><span class="line">  README.md</span><br></pre></td></tr></table></figure><h2 id="创建的setup-py"><a href="#创建的setup-py" class="headerlink" title="创建的setup.py"></a>创建的setup.py</h2><p><code>setup.py</code>是<a href="https://packaging.python.org/key_projects/#setuptools" target="_blank" rel="noopener">setuptools</a>的构建脚本。它告诉setuptools你的包（例如名称和版本）以及要包含的代码文件。</p><p>打开<code>setup.py</code>并输入以下内容，您可以根据需要个性化值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import setuptools</span><br><span class="line"></span><br><span class="line">with open(&quot;README.md&quot;, &quot;r&quot;) as fh:</span><br><span class="line">    long_description = fh.read()</span><br><span class="line"></span><br><span class="line">setuptools.setup(</span><br><span class="line">    name=&quot;example_pkg&quot;,</span><br><span class="line">    version=&quot;0.0.1&quot;,</span><br><span class="line">    author=&quot;Example Author&quot;,</span><br><span class="line">    author_email=&quot;author@example.com&quot;,</span><br><span class="line">    description=&quot;A small example package&quot;,</span><br><span class="line">    long_description=long_description,</span><br><span class="line">    long_description_content_type=&quot;text/markdown&quot;,</span><br><span class="line">    url=&quot;https://github.com/pypa/sampleproject&quot;,</span><br><span class="line">    packages=setuptools.find_packages(),</span><br><span class="line">    classifiers=[</span><br><span class="line">        &quot;Programming Language :: Python :: 3&quot;,</span><br><span class="line">        &quot;License :: OSI Approved :: MIT License&quot;,</span><br><span class="line">        &quot;Operating System :: OS Independent&quot;,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>setup()</code>有几个论点。此示例包使用相对最小的集：</p><ul><li><code>name</code>是您的包的名称。只要包含字母，数字<code>_</code>和，就可以是任何名称<code>-</code>。它也不能在pypi.org上使用。</li><li><code>version</code> 是包版本看 <a href="https://www.python.org/dev/peps/pep-0440" target="_blank" rel="noopener"><strong>PEP 440</strong></a>有关版本的更多详细信息。</li><li><code>author</code>并<code>author_email</code>用于识别包的作者。</li><li><code>description</code> 是一个简短的，一句话的包的总结。</li><li><code>long_description</code>是包的详细说明。这显示在Python Package Index的包详细信息包中。在这种情况下，加载长描述<code>README.md</code>是一种常见模式。</li><li><code>long_description_content_type</code>告诉索引什么类型的标记用于长描述。在这种情况下，它是Markdown。</li><li><code>url</code>是项目主页的URL。对于许多项目，这只是一个指向GitHub，GitLab，Bitbucket或类似代码托管服务的链接。</li><li><code>packages</code>是应包含在<a href="https://packaging.python.org/glossary/#term-distribution-package" target="_blank" rel="noopener">分发包</a>中的所有Python <a href="https://packaging.python.org/glossary/#term-import-package" target="_blank" rel="noopener">导入包</a>的列表。我们可以使用 自动发现所有包和子包，而不是手动列出每个包。在这种情况下，包列表将是example_pkg，因为它是唯一存在的包。<code>find_packages()</code></li><li><code>classifiers</code>告诉索引并<a href="https://packaging.python.org/key_projects/#pip" target="_blank" rel="noopener">点</a>一些关于你的包的其他元数据。在这种情况下，该软件包仅与Python 3兼容，根据MIT许可证进行许可，并且与操作系统无关。您应始终至少包含您的软件包所使用的Python版本，软件包可用的许可证以及您的软件包将使用的操作系统。有关分类器的完整列表，请参阅<a href="https://pypi.org/classifiers/" target="_blank" rel="noopener">https://pypi.org/classifiers/</a>。</li></ul><p>除了这里提到的还有很多。有关详细信息，请参阅 <a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/" target="_blank" rel="noopener">打包和分发项目</a>。</p><h2 id="创建README-md"><a href="#创建README-md" class="headerlink" title="创建README.md"></a>创建README.md</h2><p>打开<code>README.md</code>并输入以下内容。如果您愿意，可以自定义此项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Example Package</span><br><span class="line"></span><br><span class="line">This is a simple example package. You can use</span><br><span class="line">[Github-flavored Markdown](https://guides.github.com/features/mastering-markdown/)</span><br><span class="line">to write your content.</span><br></pre></td></tr></table></figure><h2 id="创建许可证"><a href="#创建许可证" class="headerlink" title="创建许可证"></a>创建许可证</h2><p>上传到Python Package Index的每个包都包含许可证，这一点很重要。这告诉用户安装您的软件包可以使用您的软件包的条款。有关选择许可证的帮助，请参阅 <a href="https://choosealicense.com/" target="_blank" rel="noopener">https://choosealicense.com/</a>。选择许可证后，打开 <code>LICENSE</code>并输入许可证文本。例如，如果您选择了MIT许可证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Copyright (c) 2018 The Python Packaging Authority</span><br><span class="line"></span><br><span class="line">Permission is hereby granted, free of charge, to any person obtaining a copy</span><br><span class="line">of this software and associated documentation files (the &quot;Software&quot;), to deal</span><br><span class="line">in the Software without restriction, including without limitation the rights</span><br><span class="line">to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span><br><span class="line">copies of the Software, and to permit persons to whom the Software is</span><br><span class="line">furnished to do so, subject to the following conditions:</span><br><span class="line"></span><br><span class="line">The above copyright notice and this permission notice shall be included in all</span><br><span class="line">copies or substantial portions of the Software.</span><br><span class="line"></span><br><span class="line">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span><br><span class="line">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span><br><span class="line">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span><br><span class="line">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span><br><span class="line">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span><br><span class="line">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span><br><span class="line">SOFTWARE.</span><br></pre></td></tr></table></figure><h2 id="生成分发档案"><a href="#生成分发档案" class="headerlink" title="生成分发档案"></a>生成分发档案</h2><p>下一步是为<a href="https://packaging.python.org/glossary/#term-distribution-package" target="_blank" rel="noopener">包</a>生<a href="https://packaging.python.org/glossary/#term-distribution-package" target="_blank" rel="noopener">成分发包</a>。这些是上传到包索引的档案，可以通过<a href="https://packaging.python.org/key_projects/#pip" target="_blank" rel="noopener">pip</a>安装。</p><p>确保您拥有<code>setuptools</code>并<code>wheel</code> 安装了最新版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --user --upgrade setuptools wheel</span><br></pre></td></tr></table></figure><p>小费</p><p>如果您在安装这些软件时遇到问题，请参阅 <a href="https://packaging.python.org/tutorials/installing-packages/" target="_blank" rel="noopener">安装软件包</a>教程</p><p>现在从<code>setup.py</code>位于的同一目录运行此命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 setup.py sdist bdist_wheel</span><br></pre></td></tr></table></figure><p>此命令应输出大量文本，一旦完成，应在<code>dist</code>目录中生成两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dist/</span><br><span class="line">  example_pkg-0.0.1-py3-none-any.whl</span><br><span class="line">  example_pkg-0.0.1.tar.gz</span><br></pre></td></tr></table></figure><p>注意</p><p>如果您遇到麻烦，请复制输出并提出有关<a href="https://github.com/pypa/packaging-problems/issues/new?title=Trouble+following+packaging+libraries+tutorial" target="_blank" rel="noopener">包装问题的问题</a>，我们会尽力为您提供帮助！</p><p>该<code>tar.gz</code>文件是<a href="https://packaging.python.org/glossary/#term-source-archive" target="_blank" rel="noopener">源存档，</a>而该<code>.whl</code>文件是 <a href="https://packaging.python.org/glossary/#term-built-distribution" target="_blank" rel="noopener">构建的分发</a>。较新的<a href="https://packaging.python.org/key_projects/#pip" target="_blank" rel="noopener">pip</a>版本优先安装构建的发行版，但如果需要，将回退到源代码存档。您应该始终上传源存档并为项目兼容的平台提供构建的存档。在这种情况下，我们的示例包在任何平台上都与Python兼容，因此只需要一个构建的发行版。</p><h2 id="上传分发档案"><a href="#上传分发档案" class="headerlink" title="上传分发档案"></a>上传分发档案</h2><p>最后，是时候将您的包上传到Python Package Index了！</p><p>您需要做的第一件事是在Test PyPI上注册一个帐户。Test PyPI是用于测试和实验的包索引的单独实例。这对于像我们不一定想要上传到真实索引的本教程那样很棒。要注册帐户，请访问<a href="https://test.pypi.org/account/register/" target="_blank" rel="noopener">https://test.pypi.org/account/register/</a>并完成该页面上的步骤。在您上传任何软件包之前，您还需要验证您的电子邮件地址。有关Test PyPI的更多详细信息，请参阅 <a href="https://packaging.python.org/guides/using-testpypi/" target="_blank" rel="noopener">使用TestPyPI</a>。</p><p>现在您已注册，您可以使用<a href="https://packaging.python.org/key_projects/#twine" target="_blank" rel="noopener">twine</a>上传分发包。你需要安装Twine：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --user --upgrade twine</span><br></pre></td></tr></table></figure><p>安装完成后，运行Twine上传所有存档<code>dist</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">twine upload --repository-url https://test.pypi.org/legacy/ dist/*</span><br></pre></td></tr></table></figure><p>系统将提示您输入使用Test PyPI注册的用户名和密码。命令完成后，您应该看到与此类似的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Uploading distributions to https://test.pypi.org/legacy/</span><br><span class="line">Enter your username: [your username]</span><br><span class="line">Enter your password:</span><br><span class="line">Uploading example_pkg-0.0.1-py3-none-any.whl</span><br><span class="line">100%|█████████████████████| 4.65k/4.65k [00:01&lt;00:00, 2.88kB/s]</span><br><span class="line">Uploading example_pkg-0.0.1.tar.gz</span><br><span class="line">100%|█████████████████████| 4.25k/4.25k [00:01&lt;00:00, 3.05kB/s]</span><br></pre></td></tr></table></figure><p>注意</p><p>如果您收到错误消息，则需要为您的包选择一个唯一的名称。一个不错的选择 。更新参数 ，删除文件夹，然后 <a href="https://packaging.python.org/tutorials/packaging-projects/#generating-archives" target="_blank" rel="noopener">重新生成存档</a>。<code>The user &#39;[your username]&#39; isn&#39;t allowed to upload to project&#39;example-pkg&#39;`</code>example_pkg_your_username<code>name</code>setup.py<code></code>dist`</p><p>上传后，您的包应该可以在TestPyPI上查看，例如，<a href="https://test.pypi.org/project/example-pkg" target="_blank" rel="noopener">https：</a> //test.pypi.org/project/example-pkg</p><h2 id="安装新上传的软件包"><a href="#安装新上传的软件包" class="headerlink" title="安装新上传的软件包"></a>安装新上传的软件包</h2><p>您可以使用<a href="https://packaging.python.org/key_projects/#pip" target="_blank" rel="noopener">pip</a>来安装包并验证它是否有效。创建一个新的<a href="https://packaging.python.org/key_projects/#virtualenv" target="_blank" rel="noopener">virtualenv</a>（请参阅<a href="https://packaging.python.org/tutorials/installing-packages/" target="_blank" rel="noopener">安装包</a>以获取详细说明）并从TestPyPI安装包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --index-url https://test.pypi.org/simple/ example_pkg</span><br></pre></td></tr></table></figure><p>注意</p><p>如果在预览步骤中使用了不同的包名称，请<code>example_pkg</code>在上面的命令中使用您的包名称替换 。</p><p>pip应该从Test PyPI安装包，输出应该如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collecting example_pkg</span><br><span class="line">  Downloading https://test-files.pythonhosted.org/packages/.../example_pkg-0.0.1-py3-none-any.whl</span><br><span class="line">Installing collected packages: example-pkg</span><br><span class="line">Successfully installed example-pkg-0.0.1</span><br></pre></td></tr></table></figure><p>您可以通过导入模块并引用先前<code>name</code>放置的属性来测试它是否已正确安装<code>__init__.py</code>。</p><p>运行Python解释器（确保你仍然在你的virtualenv中）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python</span><br></pre></td></tr></table></figure><p>然后导入模块并打印出<code>name</code>属性。无论您给出的<a href="https://packaging.python.org/glossary/#term-distribution-package" target="_blank" rel="noopener">分发包</a>名称是什么，这都应该是相同的 ，<code>setup.py</code>因为您的<a href="https://packaging.python.org/glossary/#term-import-package" target="_blank" rel="noopener">导入包</a>是<code>example_pkg</code>。</p><p>>&gt;&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import example_pkg</span><br><span class="line">&gt;&gt;&gt; example_pkg.name</span><br><span class="line">&apos;example_pkg&apos;</span><br></pre></td></tr></table></figure><h2 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h2><p><strong>恭喜，您已经打包并分发了一个Python项目！</strong> ✨🍰✨</p><p>请记住，本教程向您展示了如何将软件包上传到Test PyPI，而测试PyPI是短暂的。偶尔删除包和帐户并不罕见。如果您想将软件包上传到真正的Python软件包索引，可以通过在<a href="https://pypi.org/" target="_blank" rel="noopener">https://pypi.org</a>上注册帐户并按照相同的说明进行上传，但是，使用上传软件包并输入您的帐户凭据在真正的PyPI上注册。您可以使用真正的PyPI安装包 。<code>twine upload dist/*`</code>pip install your-package`</p><p>在这一点上，如果你想阅读更多关于包装的Python库，你可以做一些事情：</p><ul><li>阅读有关使用<a href="https://packaging.python.org/key_projects/#setuptools" target="_blank" rel="noopener">setuptools</a>在<a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/" target="_blank" rel="noopener">打包和分发项目中</a>打包库的 更多信息。</li><li>阅读<a href="https://packaging.python.org/guides/packaging-binary-extensions/" target="_blank" rel="noopener">包装二进制扩展</a>。</li><li>考虑诸如<a href="https://packaging.python.org/key_projects/#flit" target="_blank" rel="noopener">flit</a>，<a href="https://github.com/ofek/hatch" target="_blank" rel="noopener">hatch</a>和<a href="https://github.com/sdispater/poetry" target="_blank" rel="noopener">poetry之类的</a><a href="https://packaging.python.org/key_projects/#setuptools" target="_blank" rel="noopener">setuptools的</a>替代方案。</li></ul><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a><a href="https://packaging.python.org/" target="_blank" rel="noopener">目录</a></h3><ul><li><a href="https://packaging.python.org/overview/" target="_blank" rel="noopener">Python的打包概述</a></li><li>教程<ul><li><a href="https://packaging.python.org/tutorials/installing-packages/" target="_blank" rel="noopener">安装包</a></li><li><a href="https://packaging.python.org/tutorials/managing-dependencies/" target="_blank" rel="noopener">管理应用程序依赖项</a></li><li><a href="https://packaging.python.org/tutorials/packaging-projects/#" target="_blank" rel="noopener">打包Python项目</a></li></ul></li><li><a href="https://packaging.python.org/guides/" target="_blank" rel="noopener">指南</a></li><li><a href="https://packaging.python.org/discussions/" target="_blank" rel="noopener">讨论</a></li><li><a href="https://packaging.python.org/specifications/" target="_blank" rel="noopener">PyPA规格</a></li><li><a href="https://packaging.python.org/key_projects/" target="_blank" rel="noopener">项目摘要</a></li><li><a href="https://packaging.python.org/glossary/" target="_blank" rel="noopener">词汇表</a></li><li><a href="https://packaging.python.org/support/" target="_blank" rel="noopener">如何获得支持</a></li><li><a href="https://packaging.python.org/contribute/" target="_blank" rel="noopener">有助于本指南</a></li><li><a href="https://packaging.python.org/news/" target="_blank" rel="noopener">新闻</a></li></ul><h4 id="上一主题"><a href="#上一主题" class="headerlink" title="上一主题"></a>上一主题</h4><p><a href="https://packaging.python.org/tutorials/managing-dependencies/" target="_blank" rel="noopener">管理应用程序依赖项</a></p><h4 id="下一个主题"><a href="#下一个主题" class="headerlink" title="下一个主题"></a>下一个主题</h4><p><a href="https://packaging.python.org/guides/" target="_blank" rel="noopener">指南</a></p><h3 id="一些常见的包管理工具"><a href="#一些常见的包管理工具" class="headerlink" title="一些常见的包管理工具"></a>一些常见的包管理工具</h3><ul><li>distutils</li><li>setuptools</li><li>distribute</li><li>disutils2</li><li>distlib</li><li>pip</li></ul><p><strong><em>==创建纯 Python 或者平台 Wheels 的命令是：<code>python setup.py bdist_wheel</code></em></strong>==</p><h2 id="代码打包"><a href="#代码打包" class="headerlink" title="代码打包"></a>代码打包</h2><p>打包你的代码，将它共享出去，让其他的开发者使用。例如，将其打包成一个库分享给其他开发者，以便他们用在自己的应用中，或者共享给开发工具，比如 ‘py.test’。</p><p>这种代码发布方式具备的优势是其成熟的工具生态系统，例如 PyPI 和 pip，这些工具使得其他的开发者很容易下载和安装你的包，无论是用于偶然的实验，还是将其集成到大型专业的系统中。</p><p>Python 代码以这种方式发布共享是一个成熟的惯例。如果你的代码不是在 PyPI 上打包的，那么别的开发者很难找到它，也很难将它集成到他们现有的程序中。他们会严重质疑这些没有在 PyPI 上打包项目的槽糕管理，甚至认为这些项目已停止维护。</p><p>类似于这种发布代码的方式的缺点是，它依赖于开发者了解如何安装它所依赖的 Python 版本，并且能够和愿意使用类似 pip 这样的工具安装你的包所需要的其他依赖。这种做法适合发布代码给其他开发人员，但是不适合发布应用程序给终端用户使用。</p><p><a href="https://python-packaging-user-guide.readthedocs.io/" target="_blank" rel="noopener">Python 打包指南</a> 提供了创建和维护 Pythond 包的一个延伸的指导。</p><h2 id="打包的替代方案"><a href="#打包的替代方案" class="headerlink" title="打包的替代方案"></a>打包的替代方案</h2><p>为了发布应用程序给终端用户使用，你应该 <a href="http://docs.python-guide.org/en/latest/shipping/freezing/#freezing-your-code-ref" target="_blank" rel="noopener">冻结你的应用程序</a>。</p><p>在 Linux 平台，你可以考虑 <a href="http://docs.python-guide.org/en/latest/shipping/packaging/#packaging-for-linux-distributions-ref" target="_blank" rel="noopener">创建一个Linux发行版软件包</a> (例如 Debian or Ubuntu 系统中是一个.deb 文件)</p><h2 id="对于-Python-开发者"><a href="#对于-Python-开发者" class="headerlink" title="对于 Python 开发者"></a>对于 Python 开发者</h2><p>如果你正在写一个开源的 Python 模块，<a href="http://pypi.python.org/" target="_blank" rel="noopener">PyPI</a> 是一个适合它发布的地方，PyPI 的另一个名字 <em>The Cheeseshop</em> 更被人熟知。</p><h3 id="Pip-vs-easy-install"><a href="#Pip-vs-easy-install" class="headerlink" title="Pip vs. easy_install"></a>Pip vs. easy_install</h3><p>使用 <a href="http://pypi.python.org/pypi/pip" target="_blank" rel="noopener">pip</a>。 详情 <a href="http://stackoverflow.com/questions/3220404/why-use-pip-over-easy-install" target="_blank" rel="noopener">点击这里</a></p><h3 id="私人-PyPI"><a href="#私人-PyPI" class="headerlink" title="私人 PyPI"></a>私人 PyPI</h3><p>如果你想要使用源码安装一个 Python 包，而不是使用 PyPI，(即, 你的包<em>不对外公开</em>)，你可以通过托管一个简单的 HTTP 服务器来完成，从那些包的安装路径下运行。</p><p><strong>从一个例子入手是最好的</strong></p><p>比如你想安装一个包，它的名字是 <code>MyPackage.tar.gz</code>，假设你的目录结构使这样：</p><ul><li>archive<ul><li>MyPackage<ul><li>MyPackage.tar.gz</li></ul></li></ul></li></ul><h2 id="代码冻结"><a href="#代码冻结" class="headerlink" title="代码冻结"></a>代码冻结</h2><p>『冻结』你的代码是指创建单个可执行文件，文件里包含所有程序代码以及 Python 解释器。</p><p>像 Dropbox、星战前夜、文明 4 和 BitTorrent 客户端都是如此。</p><p>进行这种分发的好处是你的用户不需要安装所要求的 Python 版本（或其他）即可直接运行你的应用程序。 在 Windows 上，甚至许多 Linux发行版和 OS X，系统自带的 Python 版本总是不尽如人意，此时这种分发方式就会体现其价值。</p><p>此外，终端用户软件应始终是可执行的格式。 以 <code>.py</code> 结尾的文件一般适用于软件工程师和系统管理员。</p><p>冻结的一个缺点是它会增加大约 2-12 MB 的发行大小。另外，如果修补了 Python 的安全漏洞， 你将需要独立负责更新分发的应用程序。</p><h2 id="冻结的替代方案"><a href="#冻结的替代方案" class="headerlink" title="冻结的替代方案"></a>冻结的替代方案</h2><p><a href="http://pythonguidecn.readthedocs.io/zh/latest/shipping/packaging.html#packaging-your-code-ref" target="_blank" rel="noopener">打包你的代码</a> 是指把你的库或工具分发给其他开发者。</p><p>Linux 下一个冻结的替代品是 <a href="http://pythonguidecn.readthedocs.io/zh/latest/shipping/packaging.html#packaging-for-linux-distributions-ref" target="_blank" rel="noopener">Linux 分发包</a> （比如，对于 Debian 或 Ubuntu 是 .deb文件，而对于 Red Hat 与 SuSE 是 .rpm 文件）</p><h2 id="冻结工具的比较"><a href="#冻结工具的比较" class="headerlink" title="冻结工具的比较"></a>冻结工具的比较</h2><p>解决方案还有平台/特性支持性：</p><table><thead><tr><th>Solution</th><th>Windows</th><th>Linux</th><th>OS X</th><th>Python 3</th><th>License</th><th>One-file mode</th><th>Zipfile import</th><th>Eggs</th><th>pkg_resources support</th></tr></thead><tbody><tr><td>bbFreeze</td><td>yes</td><td>yes</td><td>yes</td><td>no</td><td>MIT</td><td>no</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>py2exe</td><td>yes</td><td>no</td><td>no</td><td>yes</td><td>MIT</td><td>yes</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>pyInstaller</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>GPL</td><td>yes</td><td>no</td><td>yes</td><td>no</td></tr><tr><td>cx_Freeze</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>PSF</td><td>no</td><td>yes</td><td>yes</td><td>no</td></tr><tr><td>py2app</td><td>no</td><td>no</td><td>yes</td><td>yes</td><td>MIT</td><td>no</td><td>yes</td><td>yes</td><td>yes</td></tr></tbody></table><blockquote><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在 Linux 下冻结 Windows 安装包，之前只有 PyInstaller 支持，不过后来也是  <a href="http://stackoverflow.com/questions/2950971/cross-compiling-a-python-script-on-linux-into-a-windows-executable#comment11890276_2951046" target="_blank" rel="noopener">停止支持了</a>。</p><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>所有解决方案都需要在 Windows 目标机器上安装了MS Visual C++ dll，除了 py2app 以外。只有 Pyinstaller 支持创建独立运行的绑定了dll 的 exe 文件，你需要在创建时传递参数 <code>--onefile</code> 到 <code>Configure.py</code>。</p></blockquote><h2 id="Windows-下的解决方案"><a href="#Windows-下的解决方案" class="headerlink" title="Windows 下的解决方案"></a>Windows 下的解决方案</h2><h3 id="bbFreeze"><a href="#bbFreeze" class="headerlink" title="bbFreeze"></a>bbFreeze</h3><p>前置要求是安装 <a href="http://pythonguidecn.readthedocs.io/zh/latest/starting/install/win.html#install-windows" target="_blank" rel="noopener">Python, Setuptools 以及 pywin32 的依赖项</a>。</p><ol><li>使用以下命令安装 <code>bbfreeze</code>:</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install bbfreeze</span><br></pre></td></tr></table></figure><ol><li>编写最简单的示例  <code>bb_setup.py</code>：</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from bbfreeze import Freezer</span><br><span class="line"></span><br><span class="line">freezer = Freezer(distdir=<span class="string">'dist'</span>)</span><br><span class="line">freezer.addScript(<span class="string">'foobar.py'</span>, gui_only=<span class="keyword">True</span>)</span><br><span class="line">freezer()</span><br></pre></td></tr></table></figure><blockquote><h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><p>这将适用于最基本的文件脚本。 有时候你需要高级的用法，如包含或者排除某些路径，如下：<br><code>freezer = Freezer(distdir=&#39;dist&#39;, includes=[&#39;my_code&#39;], excludes=[&#39;docs&#39;])</code></p></blockquote><ol><li>(可选) 包含图标</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freezer.setIcon(<span class="string">'my_awesome_icon.ico'</span>)</span><br></pre></td></tr></table></figure><ol><li>为冻结器（freezer）提供 Microsoft Visual C 运行时 DLL，我们有一般有两种方法，第一种是将Microsoft Visual Studio 路径 附加您的 <code>sys.path</code> 中，第二种是在脚本所在同一文件夹中放置 <code>msvcp90.dll</code> 文件。</li><li>开始冻结!</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python bb_setup.py</span><br></pre></td></tr></table></figure><h3 id="py2exe"><a href="#py2exe" class="headerlink" title="py2exe"></a>py2exe</h3><p>前置要求是安装了 <a href="http://pythonguidecn.readthedocs.io/zh/latest/starting/install/win.html#install-windows" target="_blank" rel="noopener">Python on Windows</a>。</p><ol><li>下载并且安装 <a href="http://sourceforge.net/projects/py2exe/files/py2exe/" target="_blank" rel="noopener">http://sourceforge.net/projects/py2exe/files/py2exe/</a></li><li>编写 <code>setup.py</code> (<a href="http://www.py2exe.org/index.cgi/ListOfOptions" target="_blank" rel="noopener">配置选项清单</a>):</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from distutils.core import setup</span><br><span class="line">import py2exe</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    windows=[&#123;<span class="string">'script'</span>: <span class="string">'foobar.py'</span>&#125;],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>(可选) <a href="http://www.py2exe.org/index.cgi/CustomIcons" target="_blank" rel="noopener">包含图标</a></li><li>(可选) <a href="http://stackoverflow.com/questions/112698/py2exe-generate-single-executable-file#113014" target="_blank" rel="noopener">单文件模式</a></li><li>生成 :file: <em>.exe</em> 到 <code>dist</code> 目录:</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python setup.py py2exe</span><br></pre></td></tr></table></figure><ol><li>两种方式来提供 Microsoft Visual C 运行时 DLL。两个选项: <a href="https://www.microsoft.com/en-us/download/details.aspx?id=29" target="_blank" rel="noopener">在目标机器全局安装 dll</a> 或者 <a href="http://www.py2exe.org/index.cgi/Tutorial#Step52" target="_blank" rel="noopener">与 .exe 一起分发 dll</a>。</li></ol><h3 id="PyInstaller"><a href="#PyInstaller" class="headerlink" title="PyInstaller"></a>PyInstaller</h3><p>前置条件是安装 <a href="http://pythonguidecn.readthedocs.io/zh/latest/starting/install/win.html#install-windows" target="_blank" rel="noopener">Python, Setuptools 以及pywin32 依赖项</a>.</p><ul><li><a href="http://bojan-komazec.blogspot.com/2011/08/how-to-create-windows-executable-from.html" target="_blank" rel="noopener">更多的简单教程</a></li><li><a href="https://pyinstaller.readthedocs.io/en/stable/" target="_blank" rel="noopener">官方手册</a></li></ul><h2 id="OS-X"><a href="#OS-X" class="headerlink" title="OS X"></a>OS X</h2><h3 id="py2app"><a href="#py2app" class="headerlink" title="py2app"></a>py2app</h3><h3 id="PyInstaller-1"><a href="#PyInstaller-1" class="headerlink" title="PyInstaller"></a>PyInstaller</h3><p>PyInstaller可用于在 Mac OS X 10.6（Snow Leopard）或更新版本上构建 Unix 可执行文件和窗口应用程序。</p><p>要安装 PyInstaller，使用 pip：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pyinstaller</span><br></pre></td></tr></table></figure><p>要创建标准的 Unix 可执行文件，使用 <code>script.py</code> ：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pyinstaller script.py</span><br></pre></td></tr></table></figure><p>这会创建：</p><ul><li><code>script.spec</code> 文件, 类似于 <code>make</code> 文件</li><li><code>build</code> 文件夹, 存放日志文件</li><li><code>dist</code> 文件夹, 存放主要的可执行文件 <code>script</code> ，和一些依赖的Python库</li></ul><p><code>script.py</code> 会把全部内容放在同一个文件夹中。PyInstaller 将所有 <code>script.py</code> 用到的 Python 库放到 <code>dist</code> 文件夹中。所以在分发可执行文件时，会分发整个 <code>dist</code> 文件夹。</p><p><code>script.spec</code> 文件可以编辑成 <a href="http://pythonhosted.org/PyInstaller/#spec-file-operation" target="_blank" rel="noopener">自定义构建</a> ， 比如可以：</p><ul><li>将数据文件与可执行文件绑定在一起</li><li>包含 PyInstaller 无法自动推断的运行时库（ <code>.dll</code> 或 <code>.so</code> 文件）</li><li>将 Python 运行时选项添加到可执行文件中</li></ul><p>现在：代码 <code>script.spec</code> 可以用 <code>pyinstaller</code> （而不是再次使用 <code>script.py</code> ）运行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pyinstaller script.spec</span><br></pre></td></tr></table></figure><p>要创建独立的 OS X 窗口应用程序，请使用 <code>--windowed</code> 选项：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pyinstaller --windowed script.spec</span><br></pre></td></tr></table></figure><p>这将在 <code>dist</code> 文件夹中创建一个 <code>script.app</code> 。请确保在 Python 代码中 使用 GUI 软件包，例如 <a href="https://riverbankcomputing.com/software/pyqt/intro" target="_blank" rel="noopener">PyQt</a> 或 <a href="http://wiki.qt.io/About-PySide" target="_blank" rel="noopener">PySide</a>来控制应用程序的图形部分。</p><p><code>script.spec</code> 有几个与 Mac OS X 应用程序捆绑有关的 <a href="http://pythonhosted.org/PyInstaller/spec-files.html#spec-file-options-for-a-mac-os-x-bundle" target="_blank" rel="noopener">选项</a> 。 例如，要指定应用程序的图标，请使用 <code>icon=\path\to\icon.icns</code> 选项。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://packaging.python.org/tutorials/packaging-projects/#initial-files" target="_blank" rel="noopener">Python官方文档</a></li><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li><li><a href="https://blog.zengrong.net/post/2169.html" target="_blank" rel="noopener">https://blog.zengrong.net/post/2169.html</a></li><li><a href="http://ju.outofmemory.cn/entry/106479" target="_blank" rel="noopener">http://ju.outofmemory.cn/entry/106479</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;打包Python项目&quot;&gt;&lt;a href=&quot;#打包Python项目&quot; class=&quot;headerlink&quot; title=&quot;打包Python项目&quot;&gt;&lt;/a&gt;打包Python项目&lt;/h1&gt;&lt;p&gt;本教程将指导您如何打包一个简单的Python项目。它将向您展示如何添加必要的
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-关于项目License</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AELicense/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-关于项目License/</id>
    <published>2018-09-15T04:40:43.334Z</published>
    <updated>2018-09-15T09:43:04.196Z</updated>
    
    <content type="html"><![CDATA[<p>您的源码发布 <em>需要</em> 一个许可证。在美国，如果没有指定许可证，用户就没有合法的权利下载、修改或分发。此外，除非你告诉他们要遵循什么规则，否则人们不能对你的代码做出贡献。选择一个许可证是很复杂的，所以这里有一些建议:</p><p>开源许可。 这里有许多可以选择 <a href="http://opensource.org/licenses/alphabetical" target="_blank" rel="noopener"> 开源许可 </a>  。</p><p>通常, 这些许可分为两类：</p><ol><li>一类是让使用者能自由地使用软件 (像这种更加开发的开源许可有 MIT ， BSD &amp; Apache) 。</li><li>另一类是确保代码本身–无论发生任何修改或发布–该软件代码都应该是免费的 (像这种有一定限制的免费开源软件许可有 GPL 和 LGPL) 。</li></ol><p>后者在某种意义上是不那么宽容开放的，因为他们不允许有人向软件中添加代码，并在不包括其更改的源代码的情况下发布代码。</p><p>为了帮助你为自己的项目选择一个许可证，请 <strong>使用</strong> <a href="http://choosealicense.com/" target="_blank" rel="noopener">许可证选择器</a> 。</p><p><strong>更宽容的</strong></p><ul><li>PSFL (Python Software Foundation License) – 用于对 Python 本身作出贡献。</li><li>MIT / BSD / ISC<ul><li>MIT (X11)</li><li>New BSD</li><li>ISC</li></ul></li><li>Apache</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;您的源码发布 &lt;em&gt;需要&lt;/em&gt; 一个许可证。在美国，如果没有指定许可证，用户就没有合法的权利下载、修改或分发。此外，除非你告诉他们要遵循什么规则，否则人们不能对你的代码做出贡献。选择一个许可证是很复杂的，所以这里有一些建议:&lt;/p&gt;
&lt;p&gt;开源许可。 这里有许多可以选
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-常见陷阱</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-常见陷阱/</id>
    <published>2018-09-15T04:40:16.342Z</published>
    <updated>2018-09-15T09:42:52.940Z</updated>
    
    <content type="html"><![CDATA[<p>通常，Python 旨在成为一门简洁一致的语言，避免发生意外。然而，有些情况可能会给新手们造成困惑。</p><p>在这些情况中，有一些虽是有意为之，但还是有潜在风险。还有一些则可以说是语言设计缺陷了。总之，下面列出的这些情况都是些乍一看很不好理解的行为，不过一旦您了解了这些奇怪行为背后的机理，也就基本上能理解了。</p><h2 id="可变默认参数"><a href="#可变默认参数" class="headerlink" title="可变默认参数"></a>可变默认参数</h2><p>似乎每个 Python 新手都会感到惊讶的一点是 Python 在函数定义中对待可变默认参数的方法。</p><h3 id="您所写的"><a href="#您所写的" class="headerlink" title="您所写的"></a>您所写的</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def append_to(element, to=[]):</span><br><span class="line">    to.append(element)</span><br><span class="line">    <span class="keyword">return</span> to</span><br></pre></td></tr></table></figure><h3 id="您可能期待的结果"><a href="#您可能期待的结果" class="headerlink" title="您可能期待的结果"></a>您可能期待的结果</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_list = append_to(<span class="number">12</span>)</span><br><span class="line"><span class="keyword">print</span> my_list</span><br><span class="line"></span><br><span class="line">my_other_list = append_to(<span class="number">42</span>)</span><br><span class="line"><span class="keyword">print</span> my_other_list</span><br></pre></td></tr></table></figure><p>函数每次被调用时，如果不提供第二个参数，就创建一个新的列表。所以结果就应该是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">12</span>]</span><br><span class="line">[<span class="number">42</span>]</span><br></pre></td></tr></table></figure><h3 id="实际上的结果"><a href="#实际上的结果" class="headerlink" title="实际上的结果"></a>实际上的结果</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">12</span>]</span><br><span class="line">[<span class="number">12</span>, <span class="number">42</span>]</span><br></pre></td></tr></table></figure><p><em>一旦</em> 完成了函数定义，一个新的列表就创建出来了，而且在随后的每一次函数调用中被使用的都是这个列表。</p><p><em>一旦</em> 完成了函数定义，Python 的默认参数就被赋值了，而且在随后的每一次函数调用中都不会再被默认值重复赋值（就像是在，嗯，Ruby 里那样）。这就意味着如果您使用了一个可变默认参数，并且改变了它，您也会且 <em>将会</em> 在未来的所有函数调用中改变这同一个参数对象。</p><h3 id="您实际上应该做的"><a href="#您实际上应该做的" class="headerlink" title="您实际上应该做的"></a>您实际上应该做的</h3><p>使用一个默认值来表示我们并不想给这个参数赋值，从而每次在函数被调用时我们都创建一个新的对象。（<a href="http://docs.python.org/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 作为默认值通常是个好选择）。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def append_to(element, to=None):</span><br><span class="line">    <span class="keyword">if</span> to is None:</span><br><span class="line">        to = []</span><br><span class="line">    to.append(element)</span><br><span class="line">    <span class="keyword">return</span> to</span><br></pre></td></tr></table></figure><p>可别忘了，您所传递的第二个参数仍应该是个 <em>列表</em> 对象。</p><h3 id="利用好『缺陷』"><a href="#利用好『缺陷』" class="headerlink" title="利用好『缺陷』"></a>利用好『缺陷』</h3><p>有时你可以专门 <strong>利用</strong>（或者说特地使用）这种行为来维护函数调用间的状态。这通常用于编写缓存函数。</p><h2 id="延迟绑定闭包"><a href="#延迟绑定闭包" class="headerlink" title="延迟绑定闭包"></a>延迟绑定闭包</h2><p>另一个常见的困惑是 Python 在闭包（或在周围全局作用域）中绑定变量的方式。</p><h3 id="当你写下"><a href="#当你写下" class="headerlink" title="当你写下"></a>当你写下</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def create_multipliers():</span><br><span class="line">    <span class="keyword">return</span> [lambda x : i * x <span class="keyword">for</span> i in range(<span class="number">5</span>)]</span><br></pre></td></tr></table></figure><h3 id="你期望发生"><a href="#你期望发生" class="headerlink" title="你期望发生"></a>你期望发生</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> multiplier in create_multipliers():</span><br><span class="line">    <span class="keyword">print</span> multiplier(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>一个包含五个函数的列表，每个函数有它们自己的封闭变量 <code>i</code> 乘以它们的参数，得到:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="而事实是："><a href="#而事实是：" class="headerlink" title="而事实是："></a>而事实是：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>五个函数被创建了，它们全都用 4 乘以 <code>x</code> 。</p><p>Python 的闭包是 <strong>延迟绑定的</strong> 。 这意味着闭包中用到的变量的值，是在内部函数被调用时查询得到的。</p><p>这里，不论 <strong>任何</strong> 返回的函数是如何被调用的， <code>i</code> 取的是调用时周围作用域里的值。 当循环完成时， <code>i</code> 的值最终变成了 4。</p><p>关于这个陷阱有一个普遍严重的误解，它被认为只针对 Python 的 <a href="http://docs.python.org/reference/expressions.html#lambda" target="_blank" rel="noopener">闭包 lambda</a> 定义方式。 事实上，由 <code>lambda</code> 表达式创建的函数并没什么特别，同样的问题也出现在使用普通的 <code>def</code> 上：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def create_multipliers():</span><br><span class="line">    multipliers = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">5</span>):</span><br><span class="line">        def multiplier(x):</span><br><span class="line">            <span class="keyword">return</span> i * x</span><br><span class="line">        multipliers.append(multiplier)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> multipliers</span><br></pre></td></tr></table></figure><h3 id="以上正确的做法应该是："><a href="#以上正确的做法应该是：" class="headerlink" title="以上正确的做法应该是："></a>以上正确的做法应该是：</h3><p>最简单通用的解决方案可以说是有点取巧（hack）。由于 Python 拥有在前文提到的『为函数默认参数赋值』的行为（参见 <a href="http://pythonguidecn.readthedocs.io/zh/latest/writing/gotchas.html#default-args" target="_blank" rel="noopener">可变默认参数</a> ），你可以创建一个立即绑定参数的闭包，像下面这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def create_multipliers():</span><br><span class="line">    <span class="keyword">return</span> [lambda x, i=i : i * x <span class="keyword">for</span> i in range(<span class="number">5</span>)]</span><br></pre></td></tr></table></figure><p>或者，使用 <code>functools.partial</code> 函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from functools import partial</span><br><span class="line">from operator import mul</span><br><span class="line"></span><br><span class="line">def create_multipliers():</span><br><span class="line">    <span class="keyword">return</span> [partial(mul, i) <span class="keyword">for</span> i in range(<span class="number">5</span>)]</span><br></pre></td></tr></table></figure><h3 id="缺陷并不可怕"><a href="#缺陷并不可怕" class="headerlink" title="缺陷并不可怕"></a>缺陷并不可怕</h3><p>有时你就想要闭包有如此表现，延迟绑定在很多情况下是一个很赞的特性。不幸的是，循环创建独立函数是一种会使它们出差错的情况。</p><h2 id="字节码（-pyc）文件无处不在！"><a href="#字节码（-pyc）文件无处不在！" class="headerlink" title="字节码（.pyc）文件无处不在！"></a>字节码（.pyc）文件无处不在！</h2><p>默认情况下，当你直接执行 Python 脚本文件时，Python 解释器会自动将该文件的字节码版本写入同目录下。 比如， <code>module.pyc</code>。</p><p>这些 <code>.pyc</code> 文件不应该被纳入源代码仓库。</p><p>理论上，出于性能原因，此行为默认为开启。 没有这些字节码文件， Python 会在每次加载文件时重新生成字节码文件。</p><h3 id="禁用字节码（-pyc）文件"><a href="#禁用字节码（-pyc）文件" class="headerlink" title="禁用字节码（.pyc）文件"></a>禁用字节码（.pyc）文件</h3><p>幸运的是，生成字节码的过程非常快，在开发代码时不需要担心。</p><p>那些文件很讨厌，所以让我们摆脱他们吧！</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export PYTHONDONTWRITEBYTECODE=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用 <code>$PYTHONDONTWRITEBYTECODE</code> 环境变量来命令 Python 不将这些文件写入磁盘， 开发环境将会保持整洁和干净。</p><p>我建议在你的 <code>~/.profile</code> 里设置这个环境变量。</p><h3 id="删除字节码（-pyc）文件"><a href="#删除字节码（-pyc）文件" class="headerlink" title="删除字节码（.pyc）文件"></a>删除字节码（.pyc）文件</h3><p>以下是删除所有已存在字节码文件的好方法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -type f -name <span class="string">"*.py[co]"</span> -delete -<span class="keyword">or</span> -type d -name <span class="string">"__pycache__"</span> -delete</span><br></pre></td></tr></table></figure><p>从项目根目录运行，所有 <code>.pyc</code> 文件会瞬间消失。</p><h3 id="版本控制忽略"><a href="#版本控制忽略" class="headerlink" title="版本控制忽略"></a>版本控制忽略</h3><p>如果由于性能原因仍然需要 <code>.pyc</code> 文件，你可以随时将它们添加到版本控制存储库的忽略文件中。 流行的版本控制系统能够使用文件中定义的通配符来应用特殊规则。</p><p>一份忽略文件将确保匹配的文件未被检入存储库。 <a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a> 使用 <code>.gitignore</code>，而 <a href="https://www.mercurial-scm.org/" target="_blank" rel="noopener">Mercurial</a> 使用 <code>.hgignore</code>。</p><p>忽略文件里至少应该具备以下内容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syntax:glob   <span class="comment"># This line is not needed for .gitignore files.</span></span><br><span class="line">*.py[cod]     <span class="comment"># Will match .pyc, .pyo and .pyd files.</span></span><br><span class="line">__pycache__/  <span class="comment"># Exclude the whole folder</span></span><br></pre></td></tr></table></figure><p>可按需添加更多文件和目录。下次提交到存储库时，这些文件将不被包括。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常，Python 旨在成为一门简洁一致的语言，避免发生意外。然而，有些情况可能会给新手们造成困惑。&lt;/p&gt;
&lt;p&gt;在这些情况中，有一些虽是有意为之，但还是有潜在风险。还有一些则可以说是语言设计缺陷了。总之，下面列出的这些情况都是些乍一看很不好理解的行为，不过一旦您了解了这
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-日志记录</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-日志记录/</id>
    <published>2018-09-15T04:39:54.022Z</published>
    <updated>2018-09-15T09:43:07.988Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://docs.python.org/library/logging.html#module-logging" target="_blank" rel="noopener"><code>logging</code></a> 模块自 2.3 版以来一直是 Python 标准库的一部分。在 <a href="https://www.python.org/dev/peps/pep-0282" target="_blank" rel="noopener"><strong>PEP 282</strong></a> 中有对它的简洁描述。除了 <a href="http://docs.python.org/howto/logging.html#logging-basic-tutorial" target="_blank" rel="noopener">基础日志教程</a>之外，这些文档是非常难以阅读的。</p><p>日志记录一般有两个目的：</p><ul><li><strong>诊断日志</strong> 记录与应用程序操作相关的日志。例如，当用户遇到程序报错时， 可通过搜索诊断日志以获得上下文信息。</li><li><strong>审计日志</strong> 为商业分析而记录的日志。从审计日志中，可提取用户的交易信息， 并结合其他用户资料构成用户报告，或者用来作为优化商业目标的数据支撑。</li></ul><h2 id="…-或者使用打印（print）"><a href="#…-或者使用打印（print）" class="headerlink" title="… 或者使用打印（print）?"></a>… 或者使用打印（print）?</h2><p>当需要在命令行应用中显示帮助文档时， <code>print</code> 是一个相对于日志更好的选择。 而在其他时候，日志总能优于 <code>print</code> ，理由如下：</p><ul><li>日志事件产生的 <a href="https://docs.python.org/library/logging.html#logrecord-attributes" target="_blank" rel="noopener">日志记录</a> ，包含清晰可用的诊断信息，如文件名称、路径、函数名和行号等。</li><li>包含日志模块的应用，默认可通过根记录器对应用的日志流进行访问，除非你做了日志过滤。</li><li>可通过 <a href="http://docs.python.org/library/logging.html#logging.Logger.setLevel" target="_blank" rel="noopener"><code>logging.Logger.setLevel()</code></a> 方法有选择地记录日志， 或可通过设置 <code>logging.Logger.disabled</code> 属性为 <code>True</code> 来禁用日志记录。</li></ul><h2 id="在库中记录日志"><a href="#在库中记录日志" class="headerlink" title="在库中记录日志"></a>在库中记录日志</h2><p>官方的 <a href="http://docs.python.org/howto/logging.html" target="_blank" rel="noopener">日志指南</a>  里有相关的 <a href="https://docs.python.org/howto/logging.html#configuring-logging-for-a-library" target="_blank" rel="noopener">库日志配置</a> 的说明。由于是 <em>用户</em> ，而非库来指定如何响应日志事件， 因此这里有一个值得反复说明的忠告：</p><blockquote><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>强烈建议不要向您的库日志中加入除 NullHandler 外的其它处理程序。</p></blockquote><p>在库中，声明日志的最佳方式是通过 <code>__name__</code> 全局变量： <a href="http://docs.python.org/library/logging.html#module-logging" target="_blank" rel="noopener"><code>logging</code></a> 模块通过点（<code>.</code>）运算符创建层级排列的日志，因此，用 <code>__name__</code> 可以避免名字冲突。</p><p>以下是一个来自 <a href="https://github.com/kennethreitz/requests" target="_blank" rel="noopener">requests 资源</a> 的最佳实践的例子 —— 请将它放置在 <code>__init__.py</code> 文件中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.getLogger(__name__).addHandler(logging.NullHandler())</span><br></pre></td></tr></table></figure><h2 id="在应用程序中记录日志"><a href="#在应用程序中记录日志" class="headerlink" title="在应用程序中记录日志"></a>在应用程序中记录日志</h2><p>应用程序开发的权威指南  <a href="http://12factor.net/" target="_blank" rel="noopener">《twelve factor app》</a>  也在其中一节描述了 <a href="http://12factor.net/logs" target="_blank" rel="noopener">日志的作用</a> 。它特别强调将日志视为事件流， 并将其发送至取决于应用环境配置的标准输出中。</p><p>至少有以下三种配置日志方式：</p><ul><li>使用 INI 格式文件：<ul><li><strong>优点</strong>：使用 <a href="http://docs.python.org/library/logging.config.html#logging.config.listen" target="_blank" rel="noopener"><code>logging.config.listen()</code></a> 函数监听 socket，可在运行过程中更新配置</li><li><strong>缺点</strong>：相比代码里控制，可控性要弱（ <em>例如</em> 子类化定制的 <code>filters</code> 或 <code>loggers</code>）。</li></ul></li><li>使用字典或 JSON 格式文件：<ul><li><strong>优点</strong>：除了可在运行时动态更新，在 Python 2.6 之后，还可通过 <a href="http://docs.python.org/library/json.html#module-json" target="_blank" rel="noopener"><code>json</code></a> 模块从其它文件中导入配置。</li><li><strong>缺点</strong>：相比代码里控制，可控性要弱</li></ul></li><li>使用代码控制：<ul><li><strong>优点</strong>：相比配置来讲，有绝对的控制。</li><li><strong>缺点</strong>：需要对源码进行修改。</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://docs.python.org/library/logging.html#module-logging&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/a&gt; 模块自 2.3 版以来一
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-代码测试</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-代码测试/</id>
    <published>2018-09-15T04:39:30.430Z</published>
    <updated>2018-09-15T09:42:56.838Z</updated>
    
    <content type="html"><![CDATA[<p>测试你的代码是非常重要的。</p><p>习惯于同时写测试用例和运行代码，现在被视为一个好的习惯。如果使用得当，这种方式将帮助你更加明确自己代码的功能，以及拥有更加可解耦的结构。</p><p>你应对自己编写的函数和类进行测试。这样你就能够更加确定自己所做的工作不会破坏项目的其他部分，你就能够随心所欲地改进既有的代码了。</p><p>如果你在项目中包含了初步测试用例，其他程序猿更敬佩你，更愿意work with you together ，他们将能够更得心应手地尝试使用你编写的代码，也更愿意与你合作开发项目。</p><p>测试的通用规则：</p><ul><li>测试单元应该集中于最小部分功能，并且证明它是正确的。</li><li>每个测试单元必须完全独立。他们都能够单独运行，也可以在测试套件中运行，而不用考虑被调用的顺序。 要想实现这个规则，测试单元应该加载最新的数据集，之后再做一些清理。 这通常用方法 <code>setUp()</code> 和 <code>tearDown()</code> 处理。</li><li>尽量使测试单元快速运行。如果一个单独的测试单元需要较长的时间去运行，开发进度将会延迟， 测试单元将不能如期常态性运行。有时候，因为测试单元需要复杂的数据结构， 并且当它运行时每次都要加载，所以其运行时间较长。请把运行速度较慢的测试单元放在单独的测试组件中， 并且按照需要运行其它测试单元。</li><li>学习使用工具，学习如何运行一个单独的测试或者测试用例。当为某个模块开发了一个新功能时， 我们需要经常运行这个功能的测试用例，理想情况下需配置工具让其在保存代码文件时自动触发运行测试。</li><li>在编码工作开始前后，请运行完整的测试组件。只有这样，你才会坚信现有的代码不会出现错误。</li><li>使用钩子（hook）是一个非常推荐的做法，一旦把代码提交到共享的代码仓库时（译者注：很多时候你会选择 Github）， 即可触发钩子运行所有的测试。</li><li>如果你在开发期间不得不打断自己的工作，请先为你下一步要开发的功能写一个未通过的测试，这样当你回到工作时，将可以很快地回到原先被打断的地方，并且步入正轨。</li><li><p>当你调试代码的时候，首先需要写一个精确定位 Bug 的测试单元。尽管这样做很难， 但是捕捉 Bug 的单元测试在项目中很重要。</p></li><li><p>测试函数需使用长且描述性的名字。测试的编码规范与代码编码规范有点不一样，代码更倾向于使用短的名字， 而测试函数不会直接被调用。在运行代码中，<code>square()</code> 或者甚至 <code>sqr()</code> 这样的命名都是可以的， 但是在测试代码中，您应该这样取名 <code>test_square_of_number_2()</code>，<code>test_square_negative_number()</code>。 当测试单元失败时，函数名会被直接显示出来，此时函数名称的描述性将变得重要。</p></li><li>当业务逻辑不得不变更时，如果代码中有一套不错的测试单元， 维护者将很大一部分依靠测试组件解决问题，或者确保改动不会影响到其他代码。此时测试代码会经常被阅读， 阅读的频率甚至多于业务逻辑代码。目的不明确的测试单元在这种情况下没有多少用处，因此请尽量避免书写目的不明确的测试代码。</li><li>测试代码的另外一个用处是作为新开发人员的入门介绍。当有人需要基于现有的代码库工作时， 运行并且阅读相关的测试代码是最好的做法。他们会或者应该发现业务代码的重点、难点、以及边界场景。 如果他们必须添加一些功能，第一步应该是添加一个测试，以确保新功能开发能保持测试的传统。</li></ul><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="Unittest-单元测试"><a href="#Unittest-单元测试" class="headerlink" title="Unittest 单元测试"></a>Unittest 单元测试</h3><p><a href="http://docs.python.org/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 是 Python 标准库中自带的测试模块。任何一个使用过 Junit，nUnit, 或 CppUnit 工具的人对它的 API 都会比较熟悉。</p><p>我们可以通过继承 <a href="http://docs.python.org/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>unittest.TestCase</code></a> 来创建测试用例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">def fun(x):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">class MyTest(unittest.TestCase):</span><br><span class="line">    def test(<span class="keyword">self</span>):</span><br><span class="line">        <span class="keyword">self</span>.assertEqual(fun(<span class="number">3</span>), <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>Python 2.7 以后，<code>unittest</code> 已支持测试自动发现机制。</p><blockquote><p><a href="http://docs.python.org/library/unittest.html" target="_blank" rel="noopener">关于 unittest 的标准库文档</a></p></blockquote><h3 id="Doctest"><a href="#Doctest" class="headerlink" title="Doctest"></a>Doctest</h3><p><a href="http://docs.python.org/library/doctest.html#module-doctest" target="_blank" rel="noopener"><code>doctest</code></a> 模块会在代码的 Docstrings 中寻找类似于 Python 交互会话的字串（译者注：<code>&gt;&gt;&gt;</code>），并会将其执行，以证实工作正常。</p><p>Doctest 模块的使用场景与单元测试有所不同：它们通常不是很详细，并且不会用特别的用例或者处理复杂的 Bug。Doctest 主要是作为模块和其部件主要用例的表述性文档，因此，Doctest 需在每一次完整测试 套件运行时自动运行。</p><p>函数中的一个简单 Doctest 例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def square(x):</span><br><span class="line">    <span class="string">""</span><span class="string">"Return the square of x.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; square(2)</span></span><br><span class="line"><span class="string">    4</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; square(-2)</span></span><br><span class="line"><span class="string">    4</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    import doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure><p>当使用 <code>python module.py</code> 这样的命令行运行这个模块时，Doctest 将会运行，并会在结果与文档字符串的描述不一致时报错。</p><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><h3 id="py-test"><a href="#py-test" class="headerlink" title="py.test"></a>py.test</h3><p>相比于 Python 标准库里的 unittest 模块，py.test 也是一个没有模板（no-boilerplate）的备选方案：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pytest</span><br></pre></td></tr></table></figure><p>尽管这个测试工具功能完备，并且可扩展，它仍然能保持语法很简单。创建一个测试组件和写一个带有诸多函数的模块一样容易：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># content of test_sample.py</span></span><br><span class="line">def func(x):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">def test_answer():</span><br><span class="line">    assert func(<span class="number">3</span>) == <span class="number">5</span></span><br></pre></td></tr></table></figure><p>运行命令 py.test ：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ py.test</span><br><span class="line">=========================== test session starts ============================</span><br><span class="line">platform darwin -- Python <span class="number">2.7</span><span class="number">.1</span> -- pytest<span class="number">-2.2</span><span class="number">.1</span></span><br><span class="line">collecting ... collected <span class="number">1</span> items</span><br><span class="line"></span><br><span class="line">test_sample.py F</span><br><span class="line"></span><br><span class="line">================================= FAILURES =================================</span><br><span class="line">_______________________________ test_answer ________________________________</span><br><span class="line"></span><br><span class="line">    def test_answer():</span><br><span class="line">&gt;       assert func(<span class="number">3</span>) == <span class="number">5</span></span><br><span class="line">E       assert <span class="number">4</span> == <span class="number">5</span></span><br><span class="line">E        +  where <span class="number">4</span> = func(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">test_sample.py:<span class="number">5</span>: AssertionError</span><br><span class="line">========================= <span class="number">1</span> failed in <span class="number">0.02</span> seconds =========================</span><br></pre></td></tr></table></figure><p>可以看出，这要比 unittest 模块中实现相同功能所要求的工作量少得多。</p><blockquote><p><a href="https://docs.pytest.org/en/latest/" target="_blank" rel="noopener">py.test</a></p></blockquote><h3 id="Hypothesis"><a href="#Hypothesis" class="headerlink" title="Hypothesis"></a>Hypothesis</h3><p>Hypothesis 让你编写被示例源码参数化的测试库。它会生成简单易懂的例子，使你的测试失败， 让你花更少的力气找到更多的错误。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install hypothesis</span><br></pre></td></tr></table></figure><p>例如，测试浮动列表要尝试很多例子，但是会报告每个错误的最小例子（区分异常类型和位置）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@given(lists(floats(allow_nan=<span class="keyword">False</span>, allow_infinity=<span class="keyword">False</span>), min_size=<span class="number">1</span>))</span><br><span class="line">def test_mean(xs):</span><br><span class="line">    mean = sum(xs) / len(xs)</span><br><span class="line">    assert min(xs) &lt;= mean(xs) &lt;= max(xs)</span><br><span class="line">Falsifying example: test_mean(</span><br><span class="line">    xs=[<span class="number">1.7976321109618856e+308</span>, <span class="number">6.102390043022755e+303</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Hypothesis 是实用且强大的工具，很多时候它都会找出被其他测试工具所遗漏的错误。 它能与 py.test 很好地集成，无论是简单亦或者是高级场景中，你都会觉得它很趁手。</p><blockquote><p><a href="https://hypothesis.readthedocs.io/en/latest/" target="_blank" rel="noopener">hypothesis</a></p></blockquote><h3 id="tox"><a href="#tox" class="headerlink" title="tox"></a>tox</h3><p>tox 是一个自动化测试环境管理，并能针对多版本解释器配置进行测试的工具。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install tox</span><br></pre></td></tr></table></figure><p>tox 允许你通过简单的配置文件，来设置复杂的多参数测试矩阵。</p><blockquote><p><a href="https://tox.readthedocs.io/en/latest/" target="_blank" rel="noopener">tox</a></p></blockquote><h3 id="Unittest2"><a href="#Unittest2" class="headerlink" title="Unittest2"></a>Unittest2</h3><p>Unittest2 是 Python 2.7 中 unittest 模块的向后兼容补丁，对比 Python 2.7 之前的版本提供了更好的 API 和断言语法。</p><p>如果使用 Python 2.6 版本或者以下，你可以使用 pip 安装 unittest2：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install unittest2</span><br></pre></td></tr></table></figure><p>推荐你使用 unittest 之名导入模块，目的是更容易地把代码移植到新的版本中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import unittest2 <span class="keyword">as</span> unittest</span><br><span class="line"></span><br><span class="line">class MyTest(unittest.TestCase):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>如果切换到新的 Python 版本，并且不再需要 unittest2 模块，你只需要在测试模块中改变 import 内容，而不必改变其它代码。</p><blockquote><p><a href="http://pypi.python.org/pypi/unittest2" target="_blank" rel="noopener">unittest2</a></p></blockquote><h3 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h3><p><a href="http://docs.python.org/library/unittest.mock.html#module-unittest.mock" target="_blank" rel="noopener"><code>unittest.mock</code></a> 是 Python 中用于测试的一个库。 Python 3.3 版本中，将存在于自带的标准库中 —— <a href="https://docs.python.org/dev/library/unittest.mock" target="_blank" rel="noopener">标准库中的 unittest.mock</a>。</p><p>对于 Python 相对早的版本，如下操作：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install mock</span><br></pre></td></tr></table></figure><p>在测试环境下，使用 mock 对象能够替换部分系统，并且对它们的使用进行断言。</p><p>例如，你可以对一个方法打猴子补丁：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from mock import MagicMock</span><br><span class="line">thing = ProductionClass()</span><br><span class="line">thing.method = MagicMock(return_value=<span class="number">3</span>)</span><br><span class="line">thing.method(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, key=<span class="string">'value'</span>)</span><br><span class="line"></span><br><span class="line">thing.method.assert_called_with(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, key=<span class="string">'value'</span>)</span><br></pre></td></tr></table></figure><p>在测试环境下，你可以使用 <code>patch</code> 修饰器来 mock 某个模块中的类或对象。在下面这个例子中，一直返回相同结果的外部查询系统使用 mock 替换（但仅用在测试期间）。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def mock_search(<span class="keyword">self</span>):</span><br><span class="line">    class MockSearchQuerySet(SearchQuerySet):</span><br><span class="line">        def __iter__(<span class="keyword">self</span>):</span><br><span class="line">            <span class="keyword">return</span> iter([<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>])</span><br><span class="line">    <span class="keyword">return</span> MockSearchQuerySet()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的 SearchForm 指的是 myapp 引入的类,</span></span><br><span class="line"><span class="comment"># 而不是类 SearchForm 本身自己</span></span><br><span class="line">@mock.patch(<span class="string">'myapp.SearchForm.search'</span>, mock_search)</span><br><span class="line">def test_new_watchlist_activities(<span class="keyword">self</span>):</span><br><span class="line">    <span class="comment"># get_search_results 运行一次搜索并对结果进行迭代</span></span><br><span class="line">    <span class="keyword">self</span>.assertEqual(len(myapp.get_search_results(q=<span class="string">"fish"</span>)), <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>Mock 还提供许多其它方法，你可以很轻松地配置和控制它的行为。</p><blockquote><p><a href="http://www.voidspace.org.uk/python/mock/" target="_blank" rel="noopener">Mock 的文档</a></p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;测试你的代码是非常重要的。&lt;/p&gt;
&lt;p&gt;习惯于同时写测试用例和运行代码，现在被视为一个好的习惯。如果使用得当，这种方式将帮助你更加明确自己代码的功能，以及拥有更加可解耦的结构。&lt;/p&gt;
&lt;p&gt;你应对自己编写的函数和类进行测试。这样你就能够更加确定自己所做的工作不会破坏项目
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-项目文档</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-项目文档/</id>
    <published>2018-09-15T04:39:18.634Z</published>
    <updated>2018-09-15T09:43:11.588Z</updated>
    
    <content type="html"><![CDATA[<p>可读性是 Python 开发人员在项目和代码文档中的主要关注点。遵循一些简单的最佳实践可以为您和其他人节省大量时间。</p><h2 id="项目文档"><a href="#项目文档" class="headerlink" title="项目文档"></a>项目文档</h2><p>在根目录下 <code>README</code> 文件应该对用户和项目维护者提供概述信息。它应该是原始文本或非常容易阅读的标记写成，如 <a href="http://docs.python-guide.org/en/latest/writing/documentation/#restructuredtext-ref" target="_blank" rel="noopener">reStructuredText</a> 或 Markdown。 它应该包含几行对项目或库的作用的解释（假设用户不知道项目的任何内容），软件源站点的 URL 和一些基本的信用信息。这个文件应该是代码阅读者的主要入口点。</p><p><code>INSTALL</code> 文件对 Python 来说不是必需的。安装指令通常被简化为一个命令，如 <code>pip install module</code> 或 <code>python setup.py install</code> 并且添加到 <code>README</code> 文件中。</p><p><code>LICENSE</code> 文件应该 <em>始终</em> 存在并且详细说明软件在什么许可证下对公众可用。</p><p><code>TODO</code> 文件或 <code>README</code> 文件中的 <code>TODO</code> 部分应该列出代码的开发计划。</p><p><code>CHANGELOG</code> 文件或在 <code>README</code> 对应的部分应该基于最新版本编写一个代码变更概述。</p><h2 id="其他文档"><a href="#其他文档" class="headerlink" title="其他文档"></a>其他文档</h2><p>根据项目的不同，文档中最好能包含下列部分或所有的内容：</p><ul><li>一份 <strong>简短介绍</strong> ，应该包含几个简化的用例，简要概述该产品能够用来做什么。</li><li>一份 <strong>教程</strong> ，应该展示一些主要的用例以及更多的使用细节。读者能够跟着一步步成功搭建工作原型。</li><li>一份 <strong>API 文档</strong>，通常从代码中产生（参见 <a href="http://pythonguidecn.readthedocs.io/zh/latest/writing/documentation.html#docstring-ref" target="_blank" rel="noopener">docstrings</a>）。它会列出所有的可供公共访问的接口、参数和返回值。</li><li>一份 <strong>贡献文档</strong> 适用于潜在贡献者。这可以包括项目的代码规范和通用设计的策略讲解。</li></ul><h3 id="Sphinx"><a href="#Sphinx" class="headerlink" title="Sphinx"></a>Sphinx</h3><p><a href="http://sphinx.pocoo.org/" target="_blank" rel="noopener">Sphinx</a> 无疑是最流行的 Python 文档工具。<strong>我们推荐在项目中使用 Sphinx。</strong> 它能把 <a href="http://pythonguidecn.readthedocs.io/zh/latest/writing/documentation.html#restructuredtext-ref" target="_blank" rel="noopener">reStructuredText</a> 标记语言转换为流行的输出格式，包括 HTML、LaTeX (可打印 PDF 版本)、手册和纯文本。</p><p><a href="http://readthedocs.org/" target="_blank" rel="noopener">Read The Docs</a> 是一个 <em>超棒的</em> 并且 <em>免费的</em> 文档托管平台，可以托管您的 <a href="http://sphinx.pocoo.org/" target="_blank" rel="noopener">Sphinx</a> 文档。您可以为它配置提交钩子到您的代码库中，这样文档的重新构建即可自动进行。</p><p>运行 <a href="http://sphinx.pocoo.org/" target="_blank" rel="noopener">Sphinx</a> 时首先导入你的代码，它会使用 Python 的内省功能来提取所有函数，方法和类签名，同时提取附带的文档字符串，并将其全部编译成结构良好且易于阅读的文档。</p><blockquote><p>Sphinx 因生成 API 文档而著名，但它也适用于普通的文档。本指南（译者注：原始文档）使用 <a href="http://sphinx.pocoo.org/" target="_blank" rel="noopener">Sphinx</a> 进行构建， 并托管在 <a href="http://readthedocs.org/" target="_blank" rel="noopener">Read The Docs</a> 上。</p></blockquote><h3 id="reStructuredText"><a href="#reStructuredText" class="headerlink" title="reStructuredText"></a>reStructuredText</h3><p>大多数 Python 文档是用 <a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="noopener">reStructuredText</a> 编写的。它是一个内建了所有可选扩展的 Markdown 解析器。</p><p><a href="http://sphinx.pocoo.org/rest.html" target="_blank" rel="noopener">reStructuredText Primer</a> 和 <a href="http://docutils.sourceforge.net/docs/user/rst/quickref.html" target="_blank" rel="noopener">reStructuredText Quick Reference</a> 这两个文档应该能帮助你快速熟悉它的语法。</p><h2 id="源码文档建议"><a href="#源码文档建议" class="headerlink" title="源码文档建议"></a>源码文档建议</h2><p>注释能使代码清晰，将其加入到代码中是为了理解代码起来更容易。注释在 Python 中以一个 hash 开始（数字符号）（”#”）。</p><p>在 Python 中我们使用 <em>文档字符串（docstrings）</em> 用来描述模块、类和函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def square_and_rooter(x):</span><br><span class="line">    <span class="string">""</span><span class="string">"Return the square root of self times self."</span><span class="string">""</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>一般来说，我们要遵循 <a href="https://www.python.org/dev/peps/pep-0008#comments" target="_blank" rel="noopener"><strong>PEP 8#comments</strong></a> （” Python 风格指南”）的注释部分。 更多关于 docstrings 的内容可以在 <a href="https://www.python.org/dev/peps/pep-0257#specification" target="_blank" rel="noopener"><strong>PEP 0257#specification</strong></a> （docstrings 约定指南） 上找到。</p><h3 id="注释代码块"><a href="#注释代码块" class="headerlink" title="注释代码块"></a>注释代码块</h3><p><em>请不要使用三引号去注释代码</em>。 这不是好的实践，因为面向行的命令行处理工具， 比如说 <code>grep</code>，将会很难判断注释掉的代码是否是激活的。对每一个注释行，最好使用带有合适缩进的井号。您的编辑器可能很容易做到这一点，并能使用快捷键就切换 注释 / 取消注释。</p><h3 id="Docstrings-的魔法"><a href="#Docstrings-的魔法" class="headerlink" title="Docstrings 的魔法"></a>Docstrings 的魔法</h3><p>一些工具使用 Docstrings 来嵌入不止是文档的行为， 比如说单元测试逻辑等。接下来会给你讲解 Docstrings 的一些奇特的用法，不过话说回来，如果你只是使用 Docstrings 来做函数文档也是完全合理的。</p><p>像 <a href="http://sphinx.pocoo.org/" target="_blank" rel="noopener">Sphinx</a> 这样的工具会将 Docstrings 解析为 reStructuredText，并以 HTML 格式正确呈现。 这使得将示例代码片段嵌入到项目文档成为可能。</p><p>此外， <a href="https://docs.python.org/3/library/doctest.html" target="_blank" rel="noopener">Doctest</a> 能够读取所有内嵌的看起来像 Python 命令行输入（以 <code>&gt;&gt;&gt;</code> 为前缀）的 Docstrings 并对其进行运行，以检查命令输出是否匹配其下行内容。这允许开发人员在源码中嵌入真实的示例和函数的用法。 此外，它还能确保代码运行过测试并且正常工作。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def my_function(a, b):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; my_function(2, 3)</span></span><br><span class="line"><span class="string">    6</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; my_function('a', 3)</span></span><br><span class="line"><span class="string">    'aaa'</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    <span class="keyword">return</span> a * b</span><br></pre></td></tr></table></figure><h3 id="Docstrings-与块注释的比较"><a href="#Docstrings-与块注释的比较" class="headerlink" title="Docstrings 与块注释的比较"></a>Docstrings 与块注释的比较</h3><p>他们俩是不可互换。对于函数或类，开头的注释区是程序员的注解。而Docstrings 描述了函数或类的 <em>操作性文档</em> ：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 出于某种原因此函数用来减慢程序执行的</span></span><br><span class="line">def square_and_rooter(x):</span><br><span class="line">    <span class="string">""</span><span class="string">"返回自己乘以自己的平方根。"</span><span class="string">""</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>块注释会在脚本执行时被优化掉，与块注释不同，Docstrings 内置于 Python 语言本身。这意味着你可以使用 Python 强大的内省功能以在运行时获得 Docstrings 。对于几乎每个 Python 对象，我们都可以通过其 <strong>*doc*</strong> 属性或使用内置的 <code>help()</code> 函数来访问 Docstrings。</p><p>块注释通常用于解释一段代码是 <em>做什么</em> ，或是算法的细节。而 Docstrings 更适合于向其他用户（或是写完代码 6 个月以后的你）解释代码中的特定功能是 <em>如何</em> 使用， 或是方法、类和模块的作用。</p><h3 id="编写-Docstrings"><a href="#编写-Docstrings" class="headerlink" title="编写 Docstrings"></a>编写 Docstrings</h3><p>取决于函数、方法或类的复杂度，使用单行的 Docstrings 可能十分合适。 以下通常用于非常明显的情况，例如:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def add(a, b):</span><br><span class="line">    <span class="string">""</span><span class="string">"两个数字相加，并返回结果。"</span><span class="string">""</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><p>Docstrings 应该以易于理解的方式来描述函数。另一方面，对于简单的函数和类， 将函数的签名（即 <code>add(a, b) -&gt; result</code> ）嵌入到 Docstrings 中是没有必要的。这是因为使用 Python 的 “inspect” 模块可以很容易地找到这些信息。 此外，这些信息也可以简单地通过阅读源代码来获得。</p><p>在更大或更复杂的项目中，我们建议提供相关函数的更多信息，包括它是做什么的， 所抛的任何异常，返回的内容或参数的相关细节。</p><p>对于更详细的代码文档，用于 Numpy 项目上的 Docstrings 风格会更为流行，通常称为 <a href="http://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_numpy.html" target="_blank" rel="noopener">Numpy style</a> Docstrings。因为可以占用更多的行，所以它允许开发人员写入更多的信息。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def random_number_generator(arg1, arg2):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    摘要行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    扩展功能描述。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    arg1：int</span></span><br><span class="line"><span class="string">        arg1的描述</span></span><br><span class="line"><span class="string">    arg2：str</span></span><br><span class="line"><span class="string">        arg2的描述</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    int</span></span><br><span class="line"><span class="string">        返回值说明</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br></pre></td></tr></table></figure><p>Sphinx 下使用 <a href="https://sphinxcontrib-napoleon.readthedocs.io/" target="_blank" rel="noopener">sphinx.ext.napoleon</a> 插件即可解析这种风格的 Docstrings， 使您可以轻松地将 NumPy 风格文档植入到你的项目中。</p><p>最后，编写 Docstrings 的风格并没那么重要，它们的目的是为任何可能需要阅读或更改代码的人提供文档。 只要它是正确的，可以理解的，切中相关点，那么它就很完美地完成了它的使命。</p><p>要进一步阅读 Docstrings，请随时参见 <a href="https://www.python.org/dev/peps/pep-0257" target="_blank" rel="noopener"><strong>PEP 257</strong></a></p><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><p>你可能在其他场景看到过这些，不过没有特殊情况的话，请尽量使用 <a href="http://pythonguidecn.readthedocs.io/zh/latest/writing/documentation.html#sphinx-ref" target="_blank" rel="noopener">Sphinx</a>。</p><p><a href="https://pycco-docs.github.io/pycco/" target="_blank" rel="noopener">Pycco</a></p><p>Pycco是一个 “文学编程风格的文档生成器”，它是 node.js <a href="http://jashkenas.github.com/docco" target="_blank" rel="noopener">Docco</a> 的移植版本。它将代码生成为一个并排的 HTML 代码区块和对应的文档。</p><p><a href="https://github.com/rtomayko/ronn" target="_blank" rel="noopener">Ronn</a></p><p>Ronn 用来构建 Unix 手册。它将人可读的文本文件转换成用于终端显示的 roff 文件, 以及用于 web 的 HTML 文件。</p><p><a href="http://epydoc.sourceforge.net/" target="_blank" rel="noopener">Epydoc</a></p><p>Epydoc 已经停止维护。请使用 <a href="http://pythonguidecn.readthedocs.io/zh/latest/writing/documentation.html#sphinx-ref" target="_blank" rel="noopener">Sphinx</a> 来替代。</p><p><a href="http://www.mkdocs.org/" target="_blank" rel="noopener">MkDocs</a></p><p>MkDocs 是一个快速简单的静态网站生成器，它适合于构建使用 Markdown 编写的项目文档。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可读性是 Python 开发人员在项目和代码文档中的主要关注点。遵循一些简单的最佳实践可以为您和其他人节省大量时间。&lt;/p&gt;
&lt;h2 id=&quot;项目文档&quot;&gt;&lt;a href=&quot;#项目文档&quot; class=&quot;headerlink&quot; title=&quot;项目文档&quot;&gt;&lt;/a&gt;项目文档&lt;/h2
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-Reading Great Code</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-Reading-Great-Code/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-Reading-Great-Code/</id>
    <published>2018-09-15T04:38:30.150Z</published>
    <updated>2018-09-15T09:43:19.250Z</updated>
    
    <content type="html"><![CDATA[<p>Python 设计背后的核心原则之一就是创建可读的代码。这个设计背后的动机很简单： Python 程序员所做的第一件事就是阅读代码。</p><p>成为一个著名的 Python 程序猿的秘诀之一就是阅读，理解和理解优秀的代码。</p><p>优秀的代码通常遵循 <a href="http://docs.python-guide.org/en/latest/writing/style/#code-style" target="_blank" rel="noopener">Code Style</a> 中概述的指导方针，并想读者表达清晰简洁的意图。</p><p>下面是一些推荐的 Python 项目供读者参阅。这些项目中每一项都是 Python 编码的一个典范。</p><ul><li><a href="https://github.com/gleitz/howdoi" target="_blank" rel="noopener">Howdoi</a> Howdoi 使用 Python 实现的代码搜索工具。</li><li><a href="https://github.com/mitsuhiko/flask" target="_blank" rel="noopener">Flask</a> Flask 是基于 Werkzeug and Jinja2 的 Python 微框架。 它的目的是快速入门并开发实现你头脑中的好主意。</li><li><a href="https://github.com/python-diamond/Diamond" target="_blank" rel="noopener">Diamond</a> Diamond 是使用 python 实现的用于收集监控数据的工具，主要收集 metrics 类型的数据，并将其发布到 Graphite 或其他后台。它能够收集 cpu ， 内存， 网络， i/o ，负载和磁盘 metrics 数据。此外，它还提供 API 用以实现自定义收集器从任意来源中收集指标数据。</li><li><a href="https://github.com/mitsuhiko/werkzeug" target="_blank" rel="noopener">Werkzeug</a> Werkzeug 最初是 WSGI 应用程序的各种实用工具的简单集合，并已成为最先进的 WSGI 实用程序模块之一。它包括强大的调试器、功能齐全的请求和响应对象、处理实体标记的 HTTP 实用程序、缓存控制头、HTTP 日期、cookie 处理、文件上传、强大的 URL 路由系统和一群社区贡献的插件模块。</li><li><a href="https://github.com/kennethreitz/requests" target="_blank" rel="noopener">Requests</a> Requests 是一个用 Python 实现的 Apache2 授权的 HTTP 库供大家使用。</li><li><a href="https://github.com/kennethreitz/tablib" target="_blank" rel="noopener">Tablib</a> Tablib 是用 Python 实现的无格式的表格数据集库。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python 设计背后的核心原则之一就是创建可读的代码。这个设计背后的动机很简单： Python 程序员所做的第一件事就是阅读代码。&lt;/p&gt;
&lt;p&gt;成为一个著名的 Python 程序猿的秘诀之一就是阅读，理解和理解优秀的代码。&lt;/p&gt;
&lt;p&gt;优秀的代码通常遵循 &lt;a hre
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-Code Style</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-Code-Style/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-Code-Style/</id>
    <published>2018-09-15T04:38:05.984Z</published>
    <updated>2018-09-15T09:43:15.538Z</updated>
    
    <content type="html"><![CDATA[<p>如果有人问起 Python 程序员他们最喜欢 Python 哪一点，他们一定会提到 Python 的高可读性。确实，对于 Python 来说，其高可读性一直是 Python 这门语言设计的核心。一个不争的事实是，相对于写代码而言，读代码才是更加平常的事情。</p><p>Python 代码有高可读性的一个原因就是其有着相对而言更加完善的编码风格准则和 「Python化」习语。</p><p>当 Python 老手（Pythonista）认为一段代码不「Python化」，他们通常的意思是这段代码没有遵循一般准则，同时亦没有以最佳的（最具可读性的）方式表达出代码的意图。</p><p>在一些极端的情况下，没有公认最佳的方式来表达 Python 代码的意图，不过这种极端情况非常罕见。</p><h2 id="一般概念"><a href="#一般概念" class="headerlink" title="一般概念"></a>一般概念</h2><h3 id="明确代码意义"><a href="#明确代码意义" class="headerlink" title="明确代码意义"></a>明确代码意义</h3><p>尽管 Python 可以写出从各种意义上来说都像是黑魔法的代码，但最简单直白的表达才是正道。</p><p><strong>不好</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def make_complex(*args):</span><br><span class="line">    x, y = args</span><br><span class="line">    <span class="keyword">return</span> dict(**locals())</span><br></pre></td></tr></table></figure><p><strong>好</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def make_complex(x, y):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'x'</span>: x, <span class="string">'y'</span>: y&#125;</span><br></pre></td></tr></table></figure><p>在上述好的代码中，x 和 y 清晰明了的从参数中获取值，并清晰明了的返回了一个字典。当开发者看到这个函数后就可以明了这个函数的用途，而不好的代码则不行。</p><h3 id="一行一个声明语句"><a href="#一行一个声明语句" class="headerlink" title="一行一个声明语句"></a>一行一个声明语句</h3><p>虽然在 Python 中我们推崇使用形如列表生成式这种简洁明了的复合语句，但是除此以外，我们应该尽量避免将两句独立分割的代码写在同一行。</p><p><strong>不好的风格</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">'one'</span>; <span class="keyword">print</span> <span class="string">'two'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x == <span class="number">1</span>: <span class="keyword">print</span> <span class="string">'one'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> &lt;complex comparison&gt; <span class="keyword">and</span> &lt;other complex comparison&gt;:</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure><p><strong>好的风格</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">'one'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'two'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'one'</span></span><br><span class="line"></span><br><span class="line">cond1 = &lt;complex comparison&gt;</span><br><span class="line">cond2 = &lt;other complex comparison&gt;</span><br><span class="line"><span class="keyword">if</span> cond1 <span class="keyword">and</span> cond2:</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>函数的参数可以使用四种不同的方式传递给函数。</p><ol><li><strong>必选参数</strong> 是没有默认值的必填的参数。 必选参数是最简单的参数构成，用于参数较少的函数的构成，是该函数意义的一部分，使用他们的顺序是按照定义自然排序的。举个例子，对于 <code>send(message, recipient)</code> 和  <code>point(x, y)</code> 这两个函数，使用函数的人需要知道这个函数需要两个参数，并且记住两个参数的顺序。</li></ol><p>在调用函数的时候，我们也可以使用参数的名称调用。使用参数的名称的方式可以调换参数的顺序，就像 <code>send(recipient=&#39;World&#39;,message=&#39;Hello&#39;)</code> 和 <code>point(y=2, x=1)</code> 这样。但这样的做法会降低代码的可读性，并且使代码冗长，因此更建议使用 <code>send(&#39;Hello&#39;, &#39;World&#39;)</code> 和<code>point(1,2)</code> 这样的方式调用。</p><ol><li><strong>关键字参数</strong> 是非强制的，且有默认值。它们经常被用在传递给函数的可选参数中。 当一个函数有超过两个或三个位置参数时，函数签名会变得难以记忆，使用带有默认参数的关键字参数有时候会给你带来便利。比如，一个更完整的 <code>send</code> 函数可以被定义为<code>send(message, to, cc=None, bcc=None)</code>。这里的 <code>cc</code> 和 <code>bcc</code> 是可选的， 当没有传递给它们其他值的时候，它们的值就是 None。</li></ol><p>Python 中有多种方式调用带关键字参数的函数。比如说，我们可以按照定义时的参数顺序而无需明确的命名参数来调用函数，就像 <code>send(&#39;Hello&#39;, &#39;World&#39;, &#39;Cthulhu&#39;, &#39;God&#39;)</code> 是将密件发送给上帝。我们也可以使用命名参数而无需遵循参数顺序来调用函数，就像<code>send(&#39;Hello again&#39;, &#39;World&#39;, bcc=&#39;God&#39;, cc=&#39;Cthulhu&#39;)</code> 。没有特殊情况的话，这两种方式都需要尽力避免，最优的调用方式是与定义方式一致：<code>send(&#39;Hello&#39;, &#39;World&#39;, cc=&#39;Cthulhu&#39;,bcc=&#39;God&#39;)</code> 。</p><p>作为附注，请遵循 <a href="http://en.wikipedia.org/wiki/You_ain&#39;t_gonna_need_it" target="_blank" rel="noopener">YAGNI</a> 原则。 通常，移除一个用作『以防万一』但从未使用的可选参数（以及它在函数中的逻辑），比添加一个所需的新的可选参数和它的逻辑要来的困难。</p><ol><li><strong>任意参数列表</strong> 是第三种给函数传参的方式。如果函数的参数数量是动态的，该函数可以被定义成 <code>*args</code> 的结构。在这个函数体中， <code>args</code> 是一个元组，它包含所有剩余的位置参数。举个例子， 我们可以用任何容器作为参数去调用 <code>send(message, *args)</code> ，比如 <code>send(&#39;Hello&#39;, &#39;God&#39;, &#39;Mom&#39;,&#39;Cthulhu&#39;)</code>。 在此函数体中， <code>args</code> 相当于 <code>(&#39;God&#39;,&#39;Mom&#39;, &#39;Cthulhu&#39;)</code>。</li></ol><p>然而，这种结构有一些缺点，使用时应该特别注意。如果一个函数接受的参数列表具有相同的性质，通常把它定义成一个参数，这个参数是一个列表或者其他任何序列会更清晰。 在这里，如果 <code>send</code> 参数有多个容器（recipients），将之定义成 <code>send(message,recipients)</code> 会更明确，调用它时就使用 <code>send(&#39;Hello&#39;, [&#39;God&#39;, &#39;Mom&#39;, &#39;Cthulhu&#39;])</code>。这样的话， 函数的使用者可以事先将容器列表维护成列表（list）形式，这为传递各种不能被转变成其他序列的序列（包括迭代器）带来了可能。</p><ol><li><strong>任意关键字参数字典</strong> 是最后一种给函数传参的方式。如果函数要求一系列待定的命名参数，我们可以使用 <code>**kwargs</code> 的结构。在函数体中， <code>kwargs</code> 是一个字典，它包含所有传递给函数但没有被其他关键字参数捕捉的命名参数。</li></ol><p>和 <strong>任意参数列表</strong> 中所需注意的一样，相似的原因是：这些强大的技术在非特殊情况下，都要尽量避免使用，因为其缺乏简单和明确的结构来足够表达函数意图。</p><p>编写函数的时候采用何种参数形式，是用位置参数，还是可选关键字参数，是否使用形如任意参数 的高级技术，这些都由程序员自己决定。如果能明智地遵循上述建议，即可轻松写出这样的 Python 函数：</p><ul><li>易读（名字和参数无需解释）</li><li>易改（添加新的关键字参数不会破坏代码的其他部分）</li></ul><h3 id="避免魔法方法"><a href="#避免魔法方法" class="headerlink" title="避免魔法方法"></a>避免魔法方法</h3><p>Python 对骇客来说是一个强有力的工具，它拥有非常丰富的钩子（hook）和工具，允许你施展几乎任何形式的技巧。比如说，它能够做以下：</p><ul><li>改变对象创建和实例化的方式；</li><li>改变 Python 解释器导入模块的方式；</li><li>甚至可能（如果需要的话也是被推荐的）在 Python 中嵌入 C 程序。</li></ul><p>尽管如此，所有的这些选择都有许多缺点。使用最直接的方式来达成目标通常是最好的方法。它们最主要的缺点是可读性不高。许多代码分析工具，比如说 pylint 或者 pyflakes，将无法解析这种『魔法』代码。</p><p>我们认为 Python 开发者应该知道这些近乎无限的可能性，因为它为我们灌输了没有不可能完成的任务的信心。然而，知道何时 <strong>不能</strong> 使用它们也是非常重要的。</p><p>就像一位功夫大师，一个 Pythonista 知道如何用一个手指杀死对方，但从不会那么去做。</p><h3 id="我们都是负责任的用户"><a href="#我们都是负责任的用户" class="headerlink" title="我们都是负责任的用户"></a>我们都是负责任的用户</h3><p>如前所述，Python 允许很多技巧，其中一些具有潜在的危险。一个好的例子是：任何客户端代码能够重写一个对象的属性和方法（Python 中没有 <code>private</code> 关键字）。这种哲学是在说：『我们都是负责任的用户』，它和高度防御性的语言（如 Java，拥有很多机制来预防错误操作）有着非常大的不同。</p><p>这并不意味着，比如说，Python 中没有属性是私有的，也不意味着没有合适的封装方法。 与其依赖在开发者的代码之间树立起的一道道隔墙，Python 社区更愿意依靠一组约定，来表明这些元素不应该被直接访问。</p><p>私有属性的主要约定和实现细节是在所有的 <strong>内部</strong> 变量前加一个下划线。如果客户端代码打破了这条规则并访问了带有下划线的变量，那么因内部代码的改变而出现的任何不当的行为或问题，都是客户端代码的责任。</p><p>鼓励大方地使用此约定：<strong>任何不开放给客户端代码使用的方法或属性，应该有一个下划线前缀</strong>。这将保证更好的职责划分以及更容易对已有代码进行修改。将一个私有属性公开化总是可能的，但是把一个公共属性私有化可能是一个更难的选择。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>当一个函数变得复杂，在函数体中使用多返回值的语句并不少见。然而，为了保持函数的可读性，建议在函数体中避免使用返回多个有意义的值。</p><p>在函数中返回结果主要有两种情况：函数正常运行并返回它的结果，以及错误的情况，要么因为一个错误的输入参数，要么因为其他导致函数无法完成计算或任务的原因。</p><p>如果你在面对第二种情况时不想抛出异常，返回一个值（比如说 None 或 False ）来表明函数无法正确运行，可能是需要的。在这种情况下，越早返回所发现的不正确上下文越好。 这将帮助扁平化函数的结构：我们假定在『因为错误而返回』的语句后的所有代码都能够满足函数主要结果运算。这种类型的多发挥结果，是有必要的。</p><p>然而，当一个函数在其正常运行过程中有多个主要出口点时，它会变得难以调试其返回结果，所以保持单个出口点可能会更好。这也将有助于提取某些代码路径，而且多个出口点很有可能意味着这里需要重构：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def complex_function(a, b, c):</span><br><span class="line">    <span class="keyword">if</span> not a:</span><br><span class="line">        <span class="keyword">return</span> None  <span class="comment"># 抛出一个异常可能会更好</span></span><br><span class="line">    <span class="keyword">if</span> not b:</span><br><span class="line">        <span class="keyword">return</span> None  <span class="comment"># 抛出一个异常可能会更好</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一些复杂的代码试着用 a,b,c 来计算x</span></span><br><span class="line">    <span class="comment"># 如果成功了，抵制住返回 x 的诱惑</span></span><br><span class="line">    <span class="keyword">if</span> not x:</span><br><span class="line">        <span class="comment"># 使用其他的方法来计算出 x</span></span><br><span class="line">    <span class="keyword">return</span> x  <span class="comment"># 返回值 x 只有一个出口点有利于维护代码</span></span><br></pre></td></tr></table></figure><h2 id="习语（Idiom）"><a href="#习语（Idiom）" class="headerlink" title="习语（Idiom）"></a>习语（Idiom）</h2><p>编程习语，说得简单些，就是写代码的 <strong>方式</strong>。编程习语的概念在 <a href="http://c2.com/cgi/wiki?ProgrammingIdiom" target="_blank" rel="noopener">c2</a> 和 <a href="http://stackoverflow.com/questions/302459/what-is-a-programming-idiom" target="_blank" rel="noopener">Stack Overflow</a> 上有详尽的讨论。</p><p>符合习语的 Python 代码通常被称为 <strong>Pythonic</strong>。</p><p>通常只有一种、而且最好只有一种明显的方式去编写代码。对 Python 初学者来说，无意识的情况下很少能写出习语式 Python 代码，所以应该有意识地去获取习语的书写方式。</p><p>如下有一些常见的Python习语：</p><h3 id="解包（Unpacking）"><a href="#解包（Unpacking）" class="headerlink" title="解包（Unpacking）"></a>解包（Unpacking）</h3><p>如果你知道一个列表或者元组的长度，你可以将其解包并为它的元素取名。比如，<code>enumerate()</code> 会对 list 中的每个项提供包含两个元素的元组：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, item in enumerate(some_list):</span><br><span class="line">    <span class="comment"># do something with index and item</span></span><br></pre></td></tr></table></figure><p>你也能通过这种方式交换变量：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure><p>嵌套解包也能工作：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, (b, c) = <span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>Python 3 提供了扩展解包的新方法在 <a href="https://www.python.org/dev/peps/pep-3132" target="_blank" rel="noopener"><strong>PEP 3132</strong></a> 有介绍：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a, *rest = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># a = 1, rest = [2, 3]</span></span><br><span class="line">a, *middle, c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment"># a = 1, middle = [2, 3], c = 4</span></span><br></pre></td></tr></table></figure><h3 id="创建一个被忽略的变量"><a href="#创建一个被忽略的变量" class="headerlink" title="创建一个被忽略的变量"></a>创建一个被忽略的变量</h3><p>如果你需要赋值（比如，在 <a href="http://pythonguidecn.readthedocs.io/zh/latest/writing/style.html#unpacking-ref" target="_blank" rel="noopener">解包（Unpacking）</a> ）但不需要这个变量，请使用 <code>__</code>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'foobar.txt'</span></span><br><span class="line">basename, __, ext = filename.rpartition(<span class="string">'.'</span>)</span><br></pre></td></tr></table></figure><blockquote><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>许多 Python 风格指南建议使用单下划线的 <code>_</code> 而不是这里推荐的双下划线 <code>__</code> 来标记废弃变量。问题是， <code>_</code> 常用在作为 <a href="http://docs.python.org/library/gettext.html#gettext.gettext" target="_blank" rel="noopener"><code>gettext()</code></a> 函数的别名，也被用在交互式命令行中记录最后一次操作的值。相反，使用双下划线 十分清晰和方便，而且能够消除使用其他这些用例所带来的意外干扰的风险。</p></blockquote><h3 id="创建一个含-N-个对象的列表"><a href="#创建一个含-N-个对象的列表" class="headerlink" title="创建一个含 N 个对象的列表"></a>创建一个含 N 个对象的列表</h3><p>使用 Python 列表中的 <code>*</code> 操作符：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">four_nones = [None] * <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="创建一个含-N-个列表的列表"><a href="#创建一个含-N-个列表的列表" class="headerlink" title="创建一个含 N 个列表的列表"></a>创建一个含 N 个列表的列表</h3><p>因为列表是可变的，所以 <code>*</code> 操作符（如上）将会创建一个包含 N 个且指向 <strong>同一个</strong> 列表的列表，这可能不是你想用的。取而代之，请使用列表解析：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">four_lists = [[] <span class="keyword">for</span> __ in xrange(<span class="number">4</span>)]</span><br></pre></td></tr></table></figure><p>注意：在 Python 3 中使用 <code>range()</code> 而不是 <code>xrange()</code>。</p><h3 id="根据列表来创建字符串"><a href="#根据列表来创建字符串" class="headerlink" title="根据列表来创建字符串"></a>根据列表来创建字符串</h3><p>创建字符串的一个常见习语是在空的字符串上使用 <a href="http://docs.python.org/library/stdtypes.html#str.join" target="_blank" rel="noopener"><code>str.join()</code></a> ：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">letters = [<span class="string">'s'</span>, <span class="string">'p'</span>, <span class="string">'a'</span>, <span class="string">'m'</span>]</span><br><span class="line">word = <span class="string">''</span>.join(letters)</span><br></pre></td></tr></table></figure><p>这会将 <strong>word</strong> 变量赋值为 <code>spam</code>。这个习语可以用在列表和元组中。</p><h3 id="在集合体（collection）中查找一个项"><a href="#在集合体（collection）中查找一个项" class="headerlink" title="在集合体（collection）中查找一个项"></a>在集合体（collection）中查找一个项</h3><p>有时我们需要在集合体中查找。让我们看看这两个选择，列表和集合（set），用如下代码举个例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="string">'s'</span>, <span class="string">'p'</span>, <span class="string">'a'</span>, <span class="string">'m'</span>])</span><br><span class="line">l = [<span class="string">'s'</span>, <span class="string">'p'</span>, <span class="string">'a'</span>, <span class="string">'m'</span>]</span><br><span class="line"></span><br><span class="line">def lookup_set(s):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'s'</span> in s</span><br><span class="line"></span><br><span class="line">def lookup_list(l):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'s'</span> in l</span><br></pre></td></tr></table></figure><p>即使两个函数看起来完全一样，但因为 <strong>查找集合</strong> 是利用了 Python 中的『集合是可哈希』的特性，两者的查询性能是非常不同的。为了判断一个项是否在列表中，Python 将会查看每个项直到它找到匹配的项。这是耗时的任务，尤其是对长列表而言。另一方面，在集合中， 项的哈希值将会告诉 Python 在集合的哪里去查找匹配的项。结果是，即使集合很大，查询的速度也很快。在字典中查询也是同样的原理。想了解更多内容，请见 <a href="http://stackoverflow.com/questions/513882/python-list-vs-dict-for-look-up-table" target="_blank" rel="noopener">StackOverflow</a> 。想了解在每种数据结构上的多种常见操作的花费时间的详细内容， 请见 <a href="https://wiki.python.org/moin/TimeComplexity?" target="_blank" rel="noopener">此页面</a>。</p><p>因为这些性能上的差异，在下列场景中，使用集合或者字典而不是列表，通常会是个好主意：</p><ul><li>集合体中包含大量的项；</li><li>你将在集合体中重复地查找项；</li><li>你没有重复的项。</li></ul><p>对于小的集合体、或者你不会频繁查找的集合体，建立哈希带来的额外时间和内存的开销经常会大过改进搜索速度所节省的时间。</p><h2 id="Python之禅"><a href="#Python之禅" class="headerlink" title="Python之禅"></a>Python之禅</h2><p>又名 <a href="https://www.python.org/dev/peps/pep-0020" target="_blank" rel="noopener"><strong>PEP 20</strong></a>, 是 Python 设计的指导原则。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="string">'t special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you'</span>re Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line"><span class="keyword">If</span> the implementation is hard to explain, it<span class="string">'s a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let'</span>s <span class="keyword">do</span> more of those!</span><br><span class="line"></span><br><span class="line">Python之禅 by Tim Peters</span><br><span class="line"></span><br><span class="line">优美胜于丑陋（Python 以编写优美的代码为目标）</span><br><span class="line">明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）</span><br><span class="line">简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）</span><br><span class="line">复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）</span><br><span class="line">扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）</span><br><span class="line">间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）</span><br><span class="line">可读性很重要（优美的代码是具备高可读性的）</span><br><span class="line">即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）</span><br><span class="line">不要包容所有错误，除非您确定需要这样做（精准地捕获异常，不写 `except:pass` 风格的代码）</span><br><span class="line">当存在多种可能，不要尝试去猜测</span><br><span class="line">而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）</span><br><span class="line">虽然这并不容易，因为您不是 Python 之父（这里的 Dutch 是指 Guido ）</span><br><span class="line">做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）</span><br><span class="line">如果您无法向人描述您的方案，那肯定不是一个好方案；反之亦然（方案测评标准）</span><br><span class="line">命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）</span><br></pre></td></tr></table></figure><p>想要了解一些 Python 优雅风格的例子，请见 <a href="http://artifex.org/~hblanks/talks/2011/pep20_by_example.pdf" target="_blank" rel="noopener">这些来自于 Python 用户的幻灯片</a>。</p><h2 id="PEP-8"><a href="#PEP-8" class="headerlink" title="PEP 8"></a>PEP 8</h2><p><a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener"><strong>PEP 8</strong></a> 是 Python 实际意义上的代码风格指南，我们可以在 <a href="http://pep8.org/" target="_blank" rel="noopener">pep8.org</a> 上获得高质量的、可读性更高的 PEP 8 版本。</p><p>强烈推荐阅读这部分。整个 Python 社区都尽力遵循本文档中规定的准则。这其中，一些项目可能受其影响， 而其他项目可能 <a href="http://docs.python-equests.org/en/master/dev/contributing/kenneth-reitz-s-code-style" target="_blank" rel="noopener">修改其建议</a>。</p><p>也就是说，让你的 Python 代码遵循 PEP 8 通常是个好主意，这也有助于在与其他开发人员 一起工作时使代码更加具一致性。命令行程序 pycodestyle <a href="https://github.com/PyCQA/pycodestyle" target="_blank" rel="noopener">https://github.com/PyCQA/pycodestyle</a> （以前叫做<code>pep8</code>），可以检查代码一致性。在你的终端上运行以下命令来安装它：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pycodestyle</span><br></pre></td></tr></table></figure><p>然后，对一个文件或者一系列的文件运行它，来获得任何违规行为的报告：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ pycodestyle optparse.py</span><br><span class="line">optparse.py:<span class="number">69</span>:<span class="number">11</span>: E401 multiple imports on one line</span><br><span class="line">optparse.py:<span class="number">77</span>:<span class="number">1</span>: E302 expected <span class="number">2</span> blank lines, found <span class="number">1</span></span><br><span class="line">optparse.py:<span class="number">88</span>:<span class="number">5</span>: E301 expected <span class="number">1</span> blank line, found <span class="number">0</span></span><br><span class="line">optparse.py:<span class="number">222</span>:<span class="number">34</span>: W602 deprecated form of raising <span class="keyword">exception</span></span><br><span class="line">optparse.py:<span class="number">347</span>:<span class="number">31</span>: E211 whitespace before <span class="string">'('</span></span><br><span class="line">optparse.py:<span class="number">357</span>:<span class="number">17</span>: E201 whitespace after <span class="string">'&#123;'</span></span><br><span class="line">optparse.py:<span class="number">472</span>:<span class="number">29</span>: E221 multiple spaces before operator</span><br><span class="line">optparse.py:<span class="number">544</span>:<span class="number">21</span>: W601 .has_key() is deprecated, <span class="keyword">use</span> '<span class="title">in</span>'</span><br></pre></td></tr></table></figure><p>程序 <a href="https://pypi.python.org/pypi/autopep8/" target="_blank" rel="noopener">autopep8</a> 能自动将代码格式化成 PEP 8 风格。用以下指令安装此程序：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install autopep8</span><br></pre></td></tr></table></figure><p>用以下指令格式化一个文件：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ autopep8 --in-place optparse.py</span><br></pre></td></tr></table></figure><p>不包含 <code>--in-place</code> 标志将会使得程序直接将更改的代码输出到控制台，以供审查。 <code>--aggressive</code> 标志则会执行更多实质性的变化，而且可以多次使用以达到更佳的效果。</p><h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>这里有一些你应该遵循的约定，以让你的代码更加易读。</p><h3 id="检查变量是否等于常量"><a href="#检查变量是否等于常量" class="headerlink" title="检查变量是否等于常量"></a>检查变量是否等于常量</h3><p>你不需要明确地比较一个值是 True，或者 None，或者 0 - 你可以仅仅把它放在 <code>if</code> 语句中。 参阅 <a href="http://docs.python.org/library/stdtypes.html#truth-value-testing" target="_blank" rel="noopener">真值测试</a> 来了解什么被认为是 false：</p><p><strong>糟糕</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> attr == <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'True!'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> attr == None:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'attr is None!'</span></span><br></pre></td></tr></table></figure><p><strong>优雅</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查值</span></span><br><span class="line"><span class="keyword">if</span> attr:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'attr is truthy!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者做相反的检查</span></span><br><span class="line"><span class="keyword">if</span> not attr:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'attr is falsey!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者，None 等于 false，你可以直接相较它进行匹配</span></span><br><span class="line"><span class="keyword">if</span> attr is None:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'attr is None!'</span></span><br></pre></td></tr></table></figure><h3 id="访问字典元素"><a href="#访问字典元素" class="headerlink" title="访问字典元素"></a>访问字典元素</h3><p>不要使用 <code>dict.has_key()</code>方法。 相反，使用 <code>x in d</code> 语法，或者将默认参数传递给 <a href="http://docs.python.org/library/stdtypes.html#dict.get" target="_blank" rel="noopener"><code>dict.get()</code></a> 方法。</p><p><strong>坏的示例</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'hello'</span>: <span class="string">'world'</span>&#125;</span><br><span class="line"><span class="keyword">if</span> d.has_key(<span class="string">'hello'</span>):</span><br><span class="line">    <span class="keyword">print</span> d[<span class="string">'hello'</span>]    <span class="comment"># prints 'world'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'default_value'</span></span><br></pre></td></tr></table></figure><p><strong>推荐的示例</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'hello'</span>: <span class="string">'world'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> d.get(<span class="string">'hello'</span>, <span class="string">'default_value'</span>) <span class="comment"># prints 'world'</span></span><br><span class="line"><span class="keyword">print</span> d.get(<span class="string">'thingy'</span>, <span class="string">'default_value'</span>) <span class="comment"># prints 'default_value'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者:</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'hello'</span> in d:</span><br><span class="line">    <span class="keyword">print</span> d[<span class="string">'hello'</span>]</span><br></pre></td></tr></table></figure><h3 id="操作列表的简便方法"><a href="#操作列表的简便方法" class="headerlink" title="操作列表的简便方法"></a>操作列表的简便方法</h3><p><a href="http://docs.python.org/tutorial/datastructures.html#list-comprehensions" target="_blank" rel="noopener">列表推导式</a> 提供了一个强大并且简洁的方法来对列表价进行操作。除此之外，<a href="http://docs.python.org/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a> 和 <a href="http://docs.python.org/library/functions.html#filter" target="_blank" rel="noopener"><code>filter()</code></a>  函数在列表的操作上也是非常简洁的。</p><p><strong>坏</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Filter elements greater than 4</span></span><br><span class="line">a = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b = []</span><br><span class="line"><span class="keyword">for</span> i in a:</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">4</span>:</span><br><span class="line">        b.append(i)</span><br></pre></td></tr></table></figure><p><strong>好</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b = [i <span class="keyword">for</span> i in a <span class="keyword">if</span> i &gt; <span class="number">4</span>]</span><br><span class="line"><span class="comment"># Or:</span></span><br><span class="line">b = filter(lambda x: x &gt; <span class="number">4</span>, a)</span><br></pre></td></tr></table></figure><p><strong>坏</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add three to all list members.</span></span><br><span class="line">a = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i in range(len(a)):</span><br><span class="line">    a[i] += <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>好</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">a = [i + <span class="number">3</span> <span class="keyword">for</span> i in a]</span><br><span class="line"><span class="comment"># Or:</span></span><br><span class="line">a = map(lambda i: i + <span class="number">3</span>, a)</span><br></pre></td></tr></table></figure><p>使用 <a href="http://docs.python.org/library/functions.html#enumerate" target="_blank" rel="noopener"><code>enumerate()</code></a> 来跟踪正在被处理的元素索引。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i, item in enumerate(a):</span><br><span class="line">    <span class="keyword">print</span> i, item</span><br><span class="line"><span class="comment"># prints</span></span><br><span class="line"><span class="comment"># 0 3</span></span><br><span class="line"><span class="comment"># 1 4</span></span><br><span class="line"><span class="comment"># 2 5</span></span><br></pre></td></tr></table></figure><p>比起手动计数，使用<a href="http://docs.python.org/library/functions.html#enumerate" target="_blank" rel="noopener"><code>enumerate()</code></a> 函数有更好的可读性，而且，他更加适合在迭代器中使用。</p><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>使用 <code>with open</code> 语法来读文件，它能够为你自动关闭文件。</p><p><strong>坏</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'file.txt'</span>)</span><br><span class="line">a = f.read()</span><br><span class="line"><span class="keyword">print</span> a</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p><strong>好</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(<span class="string">'file.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line in f:</span><br><span class="line">        <span class="keyword">print</span> line</span><br></pre></td></tr></table></figure><p>即使在 <code>with</code> 控制块中出现了异常，它也能确保你关闭了文件，因此，使用 <code>with</code> 语法是更加优雅的。</p><h3 id="行的延续"><a href="#行的延续" class="headerlink" title="行的延续"></a>行的延续</h3><p>当一个代码逻辑行的长度超过可接受的限度时，你需要将之分为多个物理行。如果行的结尾是一个反斜杠，Python 解释器会把这些连续行拼接在一起。这在某些情况下很有帮助， 但我们总是应该避免使用，因为它的脆弱性：如果在行的结尾，在反斜杠后加了空格，这会破坏代码，而且可能有意想不到的结果。</p><p>一个更好的解决方案是在元素周围使用括号。左边以一个未闭合的括号开头，Python 解释器会把行的结尾和下一行连接起来直到遇到闭合的括号。同样的行为适用中括号和大括号。</p><p><strong>糟糕</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_very_big_string = <span class="string">"""For a long time I used to go to bed early. Sometimes,\</span></span><br><span class="line"><span class="string">    when I had put out my candle, my eyes would close so quickly that I had not even\</span></span><br><span class="line"><span class="string">    time to say "I'm going to sleep."""</span><span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">from some.deep.module.inside.a.module import a_nice_function, another_nice_function,\</span></span><br><span class="line"><span class="string">    yet_another_nice_function</span></span><br></pre></td></tr></table></figure><p><strong>优雅</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_very_big_string = (</span><br><span class="line">    <span class="string">"For a long time I used to go to bed early. Sometimes, "</span></span><br><span class="line">    <span class="string">"when I had put out my candle, my eyes would close so quickly "</span></span><br><span class="line">    <span class="string">"that I had not even time to say "</span>I<span class="string">'m going to sleep.""</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">from some.deep.module.inside.a.module import (</span></span><br><span class="line"><span class="string">    a_nice_function, another_nice_function, yet_another_nice_function)</span></span><br></pre></td></tr></table></figure><p>尽管如此，通常情况下，必须去分割一个长逻辑行意味着你同时想做太多的事，这可能影响可读性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">Python漫游指南</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果有人问起 Python 程序员他们最喜欢 Python 哪一点，他们一定会提到 Python 的高可读性。确实，对于 Python 来说，其高可读性一直是 Python 这门语言设计的核心。一个不争的事实是，相对于写代码而言，读代码才是更加平常的事情。&lt;/p&gt;
&lt;p&gt;P
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>Hitchhiker&#39;s Guide to Python-代码结构</title>
    <link href="https://yo42.github.io/2018/09/15/Hitchhiker%E2%80%99s-Guide-to-Python-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>https://yo42.github.io/2018/09/15/Hitchhiker’s-Guide-to-Python-代码结构/</id>
    <published>2018-09-15T04:28:12.303Z</published>
    <updated>2018-09-15T09:43:00.539Z</updated>
    
    <content type="html"><![CDATA[<p>这里我们所说的「结构」就是关于如何让项目达到预期的目标。我们需要考虑的是如何更好的利用 Python 的特性创造出干净、有效的代码。实际上，「结构」意味着代码的结构、依赖非常的清晰，像文件系统中的文件和文件夹一样。</p><p>哪些函数应该放在哪个模块中？项目中的数据流是怎样的？哪些函数应该组织在一起或者分离开？从广义上讲，通过回答这些问题，你就可以开始规划你的项目长什么样子。</p><p>在本节中，我们将深入研究 Python 的模块和导入系统，因为它们是项目结构中的核心元素。然后我们将探讨如何构建可扩展易测试的代码结构的各种观点。</p><h2 id="仓库结构"><a href="#仓库结构" class="headerlink" title="仓库结构"></a>仓库结构</h2><h3 id="That-is-important"><a href="#That-is-important" class="headerlink" title="That is important!"></a>That is important!</h3><p>就像代码风格，API 设计和自动化对于健康的开发周期是必不可少的，仓库结构也是项目<a href="http://www.amazon.com/gp/product/1257638017/ref=as_li_ss_tl?ie=UTF8&amp;tag=bookforkind-20&amp;linkCode=as2&amp;camp=1789&amp;creative=39095&amp;creativeASIN=1257638017" target="_blank" rel="noopener">体系结构</a>中的重要组成部分。</p><p>当一个潜在用户或贡献者打开你的仓库页面，他们将看到：</p><ul><li>项目名称</li><li>项目描述</li><li>大堆的文件</li></ul><p>只有当他们在下滑滚动时，才能看到项目里的自述文档。</p><p>如果你的仓库包含了大量的垃圾文件或者混乱嵌套的目录结构，即使有漂亮的自述文档，用户也可能尚未看到就前往查看其他项目了。</p><blockquote><p>为你想要的工作而装扮，而不是你现在做的工作而装扮。</p></blockquote><p>当然，第一印象并不代表全部。你和你的同事可能花费数个小时在这个仓库中，最终对每个细节都非常熟悉。它的布局很重要。</p><h3 id="简单的仓库"><a href="#简单的仓库" class="headerlink" title="简单的仓库"></a>简单的仓库</h3><p><strong>简述</strong>: 这个仓库是  <a href="http://kennethreitz.org/" target="_blank" rel="noopener">Kenneth Reitz</a>  的建议。</p><p>可以在 <a href="https://github.com/kennethreitz/samplemod" target="_blank" rel="noopener">GitHub</a> 上看到。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">README.rst</span><br><span class="line">LICENSE</span><br><span class="line">setup.py</span><br><span class="line">requirements.txt</span><br><span class="line">sample/__init__.py</span><br><span class="line">sample/core.py</span><br><span class="line">sample/helpers.py</span><br><span class="line">docs/conf.py</span><br><span class="line">docs/index.rst</span><br><span class="line">tests/test_basic.py</span><br><span class="line">tests/test_advanced.py</span><br></pre></td></tr></table></figure><p>让我们深入了解一些细节。</p><h3 id="具体模块"><a href="#具体模块" class="headerlink" title="具体模块"></a>具体模块</h3><table><thead><tr><th>位置</th><th><code>./sample/</code> 或 <code>./sample.py</code></th></tr></thead><tbody><tr><td>目的</td><td>具体代码</td></tr></tbody></table><p>模块包是仓库的核心。它不应该被藏起来：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sample/</span><br></pre></td></tr></table></figure><p>如果你的模块内只有一个文件，你可以直接把这个文件放在仓库的根目录下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sample.py</span><br></pre></td></tr></table></figure><p>你的模块不应属于一个模糊的 src 目录或 python 的子目录。</p><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><table><thead><tr><th>位置</th><th><code>./LICENSE</code></th></tr></thead><tbody><tr><td>目的</td><td>法律相关</td></tr></tbody></table><p>除了源码本身外，这可以说是仓库中最重要的部分。在这个文件中应该包含完整的许可证文本和版权声明。</p><p>如果你不确定项目中应该使用哪种授权，请参考 <a href="http://choosealicense.com/" target="_blank" rel="noopener">choosealicense.com</a> 。</p><p>当然，你也可以发布不包含授权的代码，但这可能会让很多人不去使用你的代码。</p><h3 id="Setup-py"><a href="#Setup-py" class="headerlink" title="Setup.py"></a>Setup.py</h3><table><thead><tr><th>位置</th><th><code>./setup.py</code></th></tr></thead><tbody><tr><td>目的</td><td>包安装和分发管理</td></tr></tbody></table><p>如果你的模块包在仓库的根目录下，这个文件也应该位于根目录。</p><h3 id="依赖文件"><a href="#依赖文件" class="headerlink" title="依赖文件"></a>依赖文件</h3><table><thead><tr><th>位置</th><th><code>./requirements.txt</code></th></tr></thead><tbody><tr><td>目的</td><td>开发中的依赖</td></tr></tbody></table><p> <a href="https://pip.pypa.io/en/stable/user_guide/#requirements-files" target="_blank" rel="noopener">pip requirements file</a>  应该放置在仓库的根目录下。它应指出项目所需的依赖关系，包括测试、构建和生成文档过程中的。</p><p>如果该项目开发不需要依赖，或者你喜欢通过  <code>setup.py</code> 安装开发环境，这个文件可能不是必须的。</p><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><table><thead><tr><th>位置</th><th><code>./docs/</code></th></tr></thead><tbody><tr><td>目的</td><td>项目的参考文档</td></tr></tbody></table><p>没有理由把它放在其他地方。</p><h3 id="测试套件"><a href="#测试套件" class="headerlink" title="测试套件"></a>测试套件</h3><p><em>有关编写测试的建议，请参考</em>  <a href="http://docs.python-guide.org/en/latest/writing/tests/" target="_blank" rel="noopener"><em>Testing Your Code</em></a> 。</p><table><thead><tr><th>位置</th><th><code>./test_sample.py</code> 或 <code>./tests</code></th></tr></thead><tbody><tr><td>目的</td><td>软件包集成和单元测试</td></tr></tbody></table><p>开始时，一个小的测试套件经常在一个文件中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test_sample.py</span><br></pre></td></tr></table></figure><p>一旦测试套件多起来时，可以像这样把各套件放在一个文件夹中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tests/test_basic.py</span><br><span class="line">tests/test_advanced.py</span><br></pre></td></tr></table></figure><p>显然，这些测试套件需要你导入包模块才能运行测试。你可以通过这些方法来做：</p><ul><li>将包安装在 site-packages 中。</li><li>使用一个简单（但是<em>明确</em>）的路径去修正解决它。</li></ul><p>我强烈推荐后者。需要开发者在修改代码后主动运行 <code>setup.py develop</code> 去测试，也需要为每个代码库实例设置独立的运行环境。</p><p>要给单个测试导入上下文，请创建一个 tests/context.py 文件：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, os.path.abspath(os.path.join(os.path.dirname(<span class="keyword">__file__</span>), <span class="string">'..'</span>)))</span><br><span class="line"></span><br><span class="line">import sample</span><br></pre></td></tr></table></figure><p>然后，在各个测试模块中导入这个上下文模块：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from .context import sample</span><br></pre></td></tr></table></figure><p>无论安装方式如何，这通常都会像预期那样工作。</p><p>有的人会建议你应该把测试放在你自己的代码模块内，我不同意这个观点。这通常会增加用户的复杂性，而且许多的测试套件往往需要额外的依赖和运行时上下文。</p><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><table><thead><tr><th>位置</th><th><code>./Makefile</code></th></tr></thead><tbody><tr><td>目的</td><td>通用的管理任务。</td></tr></tbody></table><p>如果你看过我的大部分项目或任何 Pocoo 项目，你都会注意到有一个 Makefile 文件。 为什么？ 这些项目不是用 C 语言编写的… 简而言之， make 是一个定义项目通用任务的非常有用的工具。</p><p><strong>一个简单的 Makefile：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">init:</span><br><span class="line">    pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">    py.test tests</span><br><span class="line"></span><br><span class="line">.PHONY: init test</span><br></pre></td></tr></table></figure><p>其他通用的管理脚本（例如 <code>manage.py</code> 或 <code>fabfile.py</code> ）也应放在仓库的根目录。</p><h3 id="关于-Django-应用程序"><a href="#关于-Django-应用程序" class="headerlink" title="关于 Django 应用程序"></a>关于 Django 应用程序</h3><p>自从 Django 1.4发布以来，我注意到了 Django 应用程序的一个新趋势。 由于新的捆绑应用程序模板，许多开发人员构建其仓库的效果很差。</p><p>怎样做的呢？他们总是在一个新的仓库中运行以下内容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ django-admin.py startproject samplesite</span><br></pre></td></tr></table></figure><p>这样生成的仓库结构如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">README.rst</span><br><span class="line">samplesite/manage.py</span><br><span class="line">samplesite/samplesite/settings.py</span><br><span class="line">samplesite/samplesite/wsgi.py</span><br><span class="line">samplesite/samplesite/sampleapp/models.py</span><br></pre></td></tr></table></figure><p>不要这样做。</p><p>重复的路径会让你的工具和开发人员感到困惑。不必要的嵌套对任何人都没有帮助（除非他们怀念单一的 SVN 仓库）。</p><p>让我们正确的做到这一点：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ django-admin.py startproject samplesite .</span><br></pre></td></tr></table></figure><p>注意那个 <code>.</code> 。</p><p>由此生成的仓库结构如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">README.rst</span><br><span class="line">manage.py</span><br><span class="line">samplesite/settings.py</span><br><span class="line">samplesite/wsgi.py</span><br><span class="line">samplesite/sampleapp/models.py</span><br></pre></td></tr></table></figure><h2 id="代码结构是关键"><a href="#代码结构是关键" class="headerlink" title="代码结构是关键"></a>代码结构是关键</h2><p>Python 处理了导入和模块，因此构建 Python 项目相对容易。容易是指没有太多的约束，并且模块导入模型很容易掌握。因此，您所剩的是纯架构方面的任务，比如设计项目的不同点及其交互。</p><p>一个项目的结构简单意味着它也很容易做得不好。结构不佳的项目包括以下一些特征：</p><ul><li>多个杂乱的循环依赖关系：假如 <code>furn.py</code> 中 Table (桌子) 和 Chair （椅子）类需要从 <code>workers.py</code> 导入 Carpenter （木匠） 来回答诸如 <code>table.isdoneby()</code> 的问题；相反地，假如 Carpenter 类需要导入 Table 和 Chair 来回答诸如 <code>carpenter.whatdo()</code> 的问题。这样，就产生了一个循环依赖关系。在这种情况下，你不得不凭借脆弱的技巧，例如在方法或函数内使用导入语句。</li><li>隐藏的耦合关系： Table 实现中的每一次更改会在不相关的测试用例中中断20次测试，因为它破坏了 Carpenter 的代码，需要非常仔细的处理来适应此次更改。这意味着在 Carpenter 中有较多关于 Table 的假设，或在 Table 中有较多关于 Carpenter 的假设。</li><li>对全局状态或上下文的大量使用： Table 和 Carpenter 依赖于可修改的全局变量（可由不同的代理进行修改），而不是显式传递 <code>(高度、宽度、类型、木材)</code> 。你需要检查对这些全局变量的所有访问，以了解为什么长方形桌子变成了正方形，然后发现远程模板代码也在修改此上下文，从而弄乱了桌子的尺寸。</li><li>“意大利面条”式代码: 代码有多页嵌套 if 子句、 for 循环，有大量的复制粘贴程序代码，并没有适当的分块称为“意大利面条”式代码。 Python 的有意义的缩进 (最具争议性的特征之一) 使得维护这种代码变得非常困难。好消息是你可能看不到太多这种情况。</li><li>在 Python 中更有可能看到的是“意大利饺子”式代码：它由数百个类似的小逻辑片段组成，通常是类或对象，没有适当的结构。如果你不记得是否应该使用 FurnitureTable 、 AssetTable ，还是 TableNew 来完成手头上的任务，那么你可能会在“意大利饺子”式代码中漫无目的地游着。</li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>Python 模块是可用的主要抽象层之一，也是最自然的一个。抽象层允许将代码分成包含相关数据和功能的多个部分。</p><p>例如，项目的一层可以处理用户操作的接口，而另一层可以处理数据的底层操作。将这两层分离最自然的方法是：将所有接口功能组合在一个文件中，而在另一个文件中组合数据底层操作。在这种情况下，接口文件需要导入数据底层操作文件，这是通过 <code>import</code> 和 <code>from... import</code> 语句完成的。</p><p>一旦使用 <em>import</em> 语句，就会使用模块。这些模块可以是内置的模块，如 <em>os</em> 和 <em>sys</em>、环境中安装的第三方模块，或项目中的内部模块。</p><p>要与样式指南保持一致，需保持模块名称简短、小写，并确保避免使用特殊符号，如点（.）或问号（？）。所以应该避免像 <code>my.spam.py</code> 这样的文件名！以这种方式命名会影响 Python 查找模块的方式。</p><p>在这个 <em>my.spam.py</em> 情况下， Python 希望在名为 <code>my</code> 的文件夹中找到一个 <code>spam.py</code> 文件，但不应该这样命名。在 Python 文档中有一个应该如何使用点表示法的 <a href="http://docs.python.org/tutorial/modules.html#packages" target="_blank" rel="noopener">例子</a> 。</p><p>如果你希望将模块命名为 <code>my_spam.py</code> ，但其实下划线也不应该在模块名称中经常出现。在模块名称中使用其他字符（空格或连字符）将会阻止导入（- 是减操作符），因此请尽量保持模块名称的简短，这样就不需要将单词分开了。而且，最重要的是，不要使用带下划线的名称空间，应该使用子模块。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以</span></span><br><span class="line">import library.plugin.foo</span><br><span class="line"><span class="comment"># 不行</span></span><br><span class="line">import library.foo_plugin</span><br></pre></td></tr></table></figure><p>除了一些命名限制之外， Python 文件并不是一个特殊的模块，但你需要了解导入机制才能正确使用这个概念并避免一些问题。</p><p>具体地说， <code>import modu</code> 语句会去查找正确的文件，首先会在调用者所在的目录中查找 <code>modu.py</code> 。如果找不到，Python 解释器将递归搜索 “path” 中的 <code>modu.py</code> 。如果未找到，则引发 ImportError 异常。</p><p>一旦找到 <code>modu.py</code> ，Python 解释器将在一个隔离的空间内执行该模块。 <code>modu.py</code> 中的任何顶级语句都将被执行，包括其他导入（如果有的话）。 函数和类的定义存储在模块的字典中。</p><p>然后，模块的变量，函数和类将通过模块的名称空间提供给调用者，这是编程中的一个核心理念，在 Python 中特别有用而且功能强大。</p><p>在许多语言中，预处理器使用 <code>include file</code> 指令来获取文件中的所有代码，并将其复制到调用者的代码中。 这在 Python 中有所不同：导入的代码会被隔离在模块的命名空间内，这意味着你通常不必担心导入代码可能会产生不需要的效果，例如导入模块中有用相同的名称不会覆盖已有的函数。</p><p>通过使用 import 语句的特殊语法可以模拟更标准的行为：<code>from modu import *</code>。 这通常被认为是不好的做法。 <strong>使用</strong> <code>import *</code> <strong>会使代码更难阅读，并使得依赖更少的分块</strong>。</p><p>使用 <code>from modu import func</code> 是一种精确定位您想要导入的函数并将其放入全局命名空间的方法。 它比 <code>import *</code> 危害更小，因为它显式地显示了在全局命名空间中要导入的内容，它比简单的 <code>import modu</code> 的唯一优点是它可以节省一些输入。</p><p><strong>非常槽糕</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">from modu import *</span><br><span class="line">[...]</span><br><span class="line">x = sqrt(<span class="number">4</span>)  <span class="comment">#  sqrt是modu的一部分吗? 内置的? 上面定义了?</span></span><br></pre></td></tr></table></figure><p><strong>好一点的</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from modu import sqrt</span><br><span class="line">[...]</span><br><span class="line">x = sqrt(<span class="number">4</span>)  <span class="comment"># sqrt 可能是modu的一部分, 如果不在之间重新定义的话</span></span><br></pre></td></tr></table></figure><p><strong>最佳</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import modu</span><br><span class="line">[...]</span><br><span class="line">x = modu.sqrt(<span class="number">4</span>)  <span class="comment"># sqrt显然是modu的命名空间的一部分</span></span><br></pre></td></tr></table></figure><p>如 <a href="http://docs.python-guide.org/en/latest/writing/style/#code-style" target="_blank" rel="noopener">Code Style</a> 部分所述, 可读性是 Python 的主要特性之一。可读性意味着避免无用的样板文字和混乱，因此有必要花费一些努力来达到一定程度的简洁性上。但简洁不是简短和晦涩难懂。如 <code>modu.func</code> 的习惯用法，就能够立即判断类或函数来自何处。 除了最简单的单个文件项目之外，这样写可以大大提高了代码的可读性和可理解性。</p><h2 id="包系统"><a href="#包系统" class="headerlink" title="包系统"></a>包系统</h2><p>Python 提供了一个非常简单的封装系统，它只是模块机制到目录的扩展。</p><p>任何一个带有 <code>__init__.py</code> 文件的目录都被认为是 Python 包。包中的不同模块以类似于普通模块的方式导入，但 <code>__init__.py</code> 文件具有特殊的行为，该文件用于收集所有包范围的定义。</p><p>一个在目录 <code>pack/</code> 中的 <code>modu.py</code> 文件通过语句 <code>import pack.modu</code> 来导入。这个语句将在 <code>pack</code> 目录中查找 <code>__init__.py</code> 文件，并执行其所有顶级语句。接着它将查找一个叫 <code>pack/modu.py</code> 的文件并执行其所有顶级语句。在这些操作时候定义在 <code>modu.py</code> 中的任何变量，函数或类都在 pack.modu 命名空间中可用。</p><p>一个常见的问题是添加太多的代码到 <code>__init__.py</code> 文件中。当项目的复杂度增长时，在深层目录结构中可能由子包和子子包。在这种情况下，从子子包中导入单个项时遍历目录树时将需要执行所有 <code>__init__.py</code> 文件。</p><p>如果一个包的模块和子包不需要共享任何代码，那么让 <code>__init__.py</code> 文件保持为空是正常的，甚至是一个好的实践。</p><p>最后，一个简便的语法可以用来导入深度嵌套的包：<code>import very.deep.module as mod</code> 这允许你使用 <em>mod</em> 来代替冗长罗嗦的 <code>very.deep.module</code>。</p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>Python 有时被描述为一种面向对象的编程语言。这可能对大家有些误导，需要加以澄清。</p><p>在 Python 中，所有东西都视为一个对象，并且可以按对象处理。当我们说，函数是“一级”对象，就是将函数视为对象的意思。函数、类、字符串，甚至类型都是 Python 中的对象：像任何对象一样，它们有一个类型，可以作为函数参数传递，并且它们可能有方法和属性。按这种理解， Python 是一种面向对象的语言。</p><p>但是，与 Java 不同， Python 并没有将面向对象的编程作为主要的编程范例来实施。 Python 项目不采用面向对象的方式是完全可行的，即不使用或很少使用类定义、类继承或特定于面向对象编程的任何其他机制。</p><p>此外，从 <a href="http://docs.python-guide.org/en/latest/writing/structure/#modules" target="_blank" rel="noopener">模块</a> 部分可以看出， Python 处理模块和名称空间的方式为开发人员提供了一种自然的方法来确保抽象层的封装和分离，这两者都是使用面向对象的最常见原因。因此，当业务模型不需要面向对象时， Python 程序员有更大的自由来不使用面向对象编程。</p><p>基于一些因素的考虑，我们应避免不必要的面向对象编程。当我们想将一些状态和功能粘合在一起时，定义自定义类是很有用的。在函数编程的讨论中，我们指出，“不必要的面向对象编程”这个问题出自方程的“状态”部分。</p><p>在某些体系结构中，例如典型的 web 应用程序，会生成多个 Python 进程实例，以响应可能同时发生的外部请求。在这种情况下，将一些状态保存到实例对象中，意味着保留一些关于世界的静态信息，这很容易出现并发或竞争问题。有时，在对象的初始化（通常用 <code>__init__()</code> 方法来完成）状态和实际使用对象方法的状态之间，世界信息可能已经改变，保持的状态可能已经过时。例如，一个请求加载了内存中的某一项，并将其标记为由用户读取。而另一个请求同时要求删除该项，这可能发生在第一个进程加载该项之后，然后我们必须将其标记为已删除对象。</p><p>上述以及其他问题引出了这样的想法：使用无状态函数是一种更好的编程范例。</p><p>另一种说法是建议尽可能少的使用具有隐式上下文和副作用的函数和程序。函数的隐式上下文由全局变量和持久层中的数据项（使用方法访问）组成。副作用是指函数对其隐式上下文所做的更改。如果函数会保存或删除全局变量或持久层中的数据，则称它有副作用。</p><p>将有上下文和副作用的函数与逻辑函数（称为纯函数）隔离开来，可以获得以下好处：</p><ul><li>纯函数是确定性的：给定一个固定的输入，输出始终是相同的。</li><li>纯函数需要重构或优化时，更容易更改或替换。</li><li>纯函数更易于使用单元测试进行测试：对于复杂的上下文设置和事后的数据清理的需求更少。</li><li>纯函数更容易操作、修饰和传递。</li></ul><p>总之，针对某些体系结构，由于没有上下文或副作用，纯函数是比类和对象更有效的构建块。</p><p>显然，面向对象编程在许多情况下是有用的，甚至是必要的，例如在开发图形化桌面应用程序或游戏时，被操作的东西（窗口、按钮、化身、车辆）在计算机内存中具有相对较长的寿命。</p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>Python 语言提供了一种简单而强大的语法，称为“装饰器”。装饰器是一个函数或类，它包装（或装饰）了函数或方法。装饰器函数或方法将替换原来“未装饰”的函数或方法。因为函数是 Python 中的一级对象，所以可以“手动”完成（参见下述示例），但是使用 @decorator 语法则更清晰，也更受青睐。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    <span class="comment"># 一些操作</span></span><br><span class="line"></span><br><span class="line">def decorator(func):</span><br><span class="line">    <span class="comment"># 处理 func</span></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">foo = decorator(foo)  <span class="comment"># 手动装饰</span></span><br><span class="line"></span><br><span class="line">@decorator</span><br><span class="line">def bar():</span><br><span class="line">    <span class="comment"># 一些操作</span></span><br><span class="line"><span class="comment"># bar() 被装饰了</span></span><br></pre></td></tr></table></figure><p>此机制对于分离关注点和避免外部非相关逻辑“污染”函数或方法的核心逻辑很有用。最好采用装饰器来处理的一个功能示例是 <a href="https://en.wikipedia.org/wiki/Memoization#Overview" target="_blank" rel="noopener">备注</a> 或缓存：你希望将计算非常耗时/耗空间的函数的结果存储在表中，并直接使用这些结果，而不是在已经计算过以后重新调用并计算。这显然不是函数逻辑的一部分。</p><h2 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h2><p>上下文管理器是一个 Python 对象，为操作提供了额外的上下文信息。 这种额外的信息， 在使用 <code>with</code> 语句初始化上下文，以及完成 <code>with</code> 块中的所有代码时，采用可调用的形式。 这里展示了使用上下文管理器的为人熟知的示例，打开文件：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(<span class="string">'file.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    contents = f.read()</span><br></pre></td></tr></table></figure><p>任何熟悉这种模式的人都知道以这种形式调用 <code>open</code> 能确保 <code>f</code> 的 <code>close</code> 方法会在某个时候被调用。 这样可以减少开发人员的认知负担，并使代码更容易阅读。</p><p>实现这个功能有两种简单的方法：使用类或使用生成器。 让我们自己实现上面的功能，以使用类方式开始：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class CustomOpen(object):</span><br><span class="line">    def __init__(<span class="keyword">self</span>, filename):</span><br><span class="line">        <span class="keyword">self</span>.file = open(filename)</span><br><span class="line"></span><br><span class="line">    def __enter__(<span class="keyword">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.file</span><br><span class="line"></span><br><span class="line">    def __exit__(<span class="keyword">self</span>, ctx_type, ctx_value, ctx_traceback):</span><br><span class="line">        <span class="keyword">self</span>.file.close()</span><br><span class="line"></span><br><span class="line">with CustomOpen(<span class="string">'file'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    contents = f.read()</span><br></pre></td></tr></table></figure><p>这只是一个常规的 Python 对象，它有两个由 <code>with</code> 语句使用的额外方法。 CustomOpen 首先被实例化，然后调用它的 <code>__enter__</code> 方法，而且 <code>__enter__</code> 的返回值在 <code>as f</code> 语句中被赋给 <code>f</code> 。 当 <code>with</code> 块中的内容执行完后，会调用 <code>__exit__</code> 方法。</p><p>现在我们演示生成器方式，我们将使用了 Python 自带的 <a href="https://docs.python.org/2/library/contextlib.html" target="_blank" rel="noopener">contextlib</a>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from contextlib import contextmanager</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def custom_open(filename):</span><br><span class="line">    f = open(filename)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> f</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">with custom_open(<span class="string">'file'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    contents = f.read()</span><br></pre></td></tr></table></figure><p>这与上面的类示例道理相通，尽管它更简洁。<code>custom_open</code> 函数一直运行到 <code>yield</code> 语句。 然后它将控制权返回给 <code>with</code> 语句，然后在 <code>as f</code> 部分将 yield 的 <code>f</code> 赋值给 <code>f</code>。 <code>finally</code> 确保不论 <code>with</code> 中是否发生异常， <code>close()</code> 都会被调用。</p><p>由于这两种方法都是一样的，所以我们应该遵循 Python 之禅来决定何时使用哪种。 如果封装的逻辑量很大，则类的方法可能会更好。 而对于处理简单操作的情况，函数方法可能会更好。</p><h2 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h2><p>Python 是动态类型语言，这意味着变量并没有固定的类型。实际上，Python 中的变量和其他语言有很大的不同，特别是静态类型语言。变量并不是计算机内存中被写入的某个值，它们只是指向内存的『标签』或『名称』。因此可能存在这样的情况，变量 <code>a</code> 先代表值 1，然后变成 字符串 <code>a string</code> , 然后又变为指向一个函数。</p><p>Python 的动态类型常被认为是它的缺点，的确这个特性会导致复杂度提升和难以调试的代码。 命名为 <code>a</code> 的变量可能是各种类型，开发人员或维护人员需要在代码中追踪命名，以保证它 没有被设置到毫不相关的对象上。</p><p>这里有些避免发生类似问题的参考方法：</p><ul><li>避免对不同类型的对象使用同一个变量名</li></ul><p><strong>不推荐</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">a = <span class="string">'a string'</span></span><br><span class="line">def a():</span><br><span class="line">    pass  <span class="comment"># Do something</span></span><br></pre></td></tr></table></figure><p><strong>推荐</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">1</span></span><br><span class="line">msg = <span class="string">'a string'</span></span><br><span class="line">def func():</span><br><span class="line">    pass  <span class="comment"># Do something</span></span><br></pre></td></tr></table></figure><p>使用简短的函数或方法能降低对不相关对象使用同一个名称的风险。</p><p>即使是相关的不同 类型的对象，也更建议使用不同命名：</p><p><strong>不推荐</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items = <span class="string">'a b c d'</span>  <span class="comment"># This is a string...</span></span><br><span class="line">items = items.split(<span class="string">' '</span>)  <span class="comment"># ...becoming a list</span></span><br><span class="line">items = set(items)  <span class="comment"># ...and then a set</span></span><br></pre></td></tr></table></figure><p>重复使用命名对效率并没有提升：赋值时无论如何都要创建新的对象。然而随着复杂度的提升，赋值语句被其他代码包括 <code>if</code> 分支和循环分开，使得更难查明指定变量的类型。</p><p>在某些代码的做法中，例如函数编程，推荐的是从不重复对同一个变量命名赋值。Java 内的实现方式是使用 <code>final</code> 关键字。Python 并没有 <code>final</code> 关键字而且这与它的哲学 相悖。尽管如此，避免给同一个变量命名重复赋值仍是是个好的做法，并且有助于掌握 可变与不可变类型的概念。</p><h2 id="可变和不可变类型"><a href="#可变和不可变类型" class="headerlink" title="可变和不可变类型"></a>可变和不可变类型</h2><p>Python提供两种内置或用户定义的类型。</p><p>可变类型允许内容的内部修改。典型的动态类型 包括列表与字典：列表都有可变方法，如 <code>list.append()</code> 和 <code>list.pop()</code>， 并且能就地修改。字典也是一样。</p><p>不可变类型没有修改自身内容的方法。比如，赋值为整数 6 的变量 x 并没有 “自增” 方法，如果需要计算 x + 1，必须创建另一个整数变量并给其命名。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_list[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line"><span class="keyword">print</span> my_list  <span class="comment"># [4, 2, 3] &lt;- The same list has changed</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">6</span></span><br><span class="line">x = x + <span class="number">1</span>  <span class="comment"># The new x is another object</span></span><br></pre></td></tr></table></figure><p>这种差异导致的一个后果就是，可变类型是不 ‘稳定 ‘的，因而不能作为字典的键使用。</p><p>合理地使用可变类型与不可变类型有助于阐明代码的意图。</p><p>例如与列表相似的不可变类型是元组， 创建方式为 <code>(1, 2)</code>。元组是不可修改的，并能作为字典的键使用。</p><p>Python 中一个可能会让初学者惊讶的特性是：字符串是不可变类型。这意味着当需要组合一个 字符串时，将每一部分放到一个可变列表里，使用字符串时再组合 (<code>join</code>) 起来的做法更高效。 值得注意的是，使用列表推导的构造方式比在循环中调用 <code>append()</code> 来构造列表更好也更快。</p><p>还有一个选项是使用 <code>map</code> 函数，它可以 <code>map</code> 一个函数 <code>str</code> 到可序列化对象上 ( 例如 <code>range(20)</code>)。 结果会产生一个集合，你可以对结果进行 <code>join</code> 在一起，就如其他的例子一样。<code>map</code> 函数在一些场景下速度会更快。</p><p><strong>差</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 0 到 19 创建一个连续的字符串（例如「012..1819」）</span></span><br><span class="line">nums = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> n in range(<span class="number">20</span>):</span><br><span class="line">    nums += str(n)   <span class="comment"># slow and inefficient</span></span><br><span class="line"><span class="keyword">print</span> nums</span><br></pre></td></tr></table></figure><p><strong>好</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 0 到 19 创建一个连续的字符串（例如「012..1819」）</span></span><br><span class="line">nums = []</span><br><span class="line"><span class="keyword">for</span> n in range(<span class="number">20</span>):</span><br><span class="line">    nums.append(str(n))</span><br><span class="line"><span class="keyword">print</span> <span class="string">""</span>.join(nums)  <span class="comment"># much more efficient</span></span><br></pre></td></tr></table></figure><p><strong>较好</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 0 到 19 创建一个连续的字符串（例如「012..1819」）</span></span><br><span class="line">nums = [str(n) <span class="keyword">for</span> n in range(<span class="number">20</span>)]</span><br><span class="line"><span class="keyword">print</span> <span class="string">""</span>.join(nums)</span><br></pre></td></tr></table></figure><p><strong>最好</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 0 到 19 创建一个连续的字符串（例如「012..1819」）</span></span><br><span class="line">nums = map(str, range(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">""</span>.join(nums)</span><br></pre></td></tr></table></figure><p>最后关于字符串的说明的一点是，使用 <code>join()</code> 并不总是最好的选择。比如当用预先确定数量的字符串创建一个新的字符串时，使用加法操作符确实更快，但在上文提到的情况 下或添加到已存在字符串的情况下，使用 <code>join()</code> 是更好的选择。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="string">'foo'</span></span><br><span class="line">bar = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line">foobar = foo + bar  <span class="comment"># This is good</span></span><br><span class="line">foo += <span class="string">'ooo'</span>  <span class="comment"># This is bad, instead you should do:</span></span><br><span class="line">foo = <span class="string">''</span>.join([foo, <span class="string">'ooo'</span>])</span><br></pre></td></tr></table></figure><blockquote><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>除了 <a href="http://docs.python.org/library/stdtypes.html#str.join" target="_blank" rel="noopener"><code>str.join()</code></a> 和 <code>+</code>，您也可以使用 <a href="http://docs.python.org/library/string.html#string-formatting" target="_blank" rel="noopener">%</a> 格式运算符来连接确定数量的字符串，但 <a href="https://www.python.org/dev/peps/pep-3101" target="_blank" rel="noopener">PEP 3101</a> 建议使用 <a href="http://docs.python.org/library/stdtypes.html#str.format" target="_blank" rel="noopener"><code>str.format()</code></a> 替代 <code>%</code> 操作符。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="string">'foo'</span></span><br><span class="line">bar = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line">foobar = <span class="string">'%s%s'</span> % (foo, bar) <span class="comment"># It is OK</span></span><br><span class="line">foobar = <span class="string">'&#123;0&#125;&#123;1&#125;'</span>.format(foo, bar) <span class="comment"># It is better</span></span><br><span class="line">foobar = <span class="string">'&#123;foo&#125;&#123;bar&#125;'</span>.format(foo=foo, bar=bar) <span class="comment"># It is best</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://docs.python-guide.org/writing/structure/#structure-of-the-repository" target="_blank" rel="noopener">Python漫游指南</a></li><li><a href="http://www.diveintopython.net/toc/index.html" target="_blank" rel="noopener">http://www.diveintopython.net/toc/index.html</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里我们所说的「结构」就是关于如何让项目达到预期的目标。我们需要考虑的是如何更好的利用 Python 的特性创造出干净、有效的代码。实际上，「结构」意味着代码的结构、依赖非常的清晰，像文件系统中的文件和文件夹一样。&lt;/p&gt;
&lt;p&gt;哪些函数应该放在哪个模块中？项目中的数据流是
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>部署postgresql</title>
    <link href="https://yo42.github.io/2018/09/11/%E9%83%A8%E7%BD%B2postgresql/"/>
    <id>https://yo42.github.io/2018/09/11/部署postgresql/</id>
    <published>2018-09-11T06:55:29.804Z</published>
    <updated>2018-09-15T03:22:00.637Z</updated>
    
    <content type="html"><![CDATA[<h3 id="部署postgres数据库-Docker"><a href="#部署postgres数据库-Docker" class="headerlink" title="部署postgres数据库(Docker)"></a>部署postgres数据库(Docker)</h3><h4 id="使用sameersbn-postgresql"><a href="#使用sameersbn-postgresql" class="headerlink" title="使用sameersbn/postgresql"></a>使用sameersbn/postgresql</h4><h4 id="工作目录-home-postgres"><a href="#工作目录-home-postgres" class="headerlink" title="工作目录:/home/postgres"></a>工作目录:/home/postgres</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">postgresql:</span><br><span class="line">  restart: always</span><br><span class="line">  image: sameersbn/postgresql:9.6-2</span><br><span class="line">  volumes:</span><br><span class="line">    - $PWD:/var/lib/postgresql</span><br><span class="line">    - /var/run/postgresql/:/var/run/postgresql/</span><br><span class="line">    - /home/nucleus-d1/rsyncd/data/:/home/nucleus-d1/rsyncd/data/</span><br><span class="line">    - /home/postgres/zhangxiaohao/:/home/postgres/zhangxiaohao/</span><br><span class="line">  environment:</span><br><span class="line">    - DB_USER=postgres</span><br><span class="line">    - DB_PASS=xxxxx</span><br><span class="line">    - DB_EXTENSION=</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;0.0.0.0:5432:5432&quot;</span><br></pre></td></tr></table></figure><h4 id="9-6-main-pg-hba-conf-权限配置"><a href="#9-6-main-pg-hba-conf-权限配置" class="headerlink" title="9.6/main/pg_hba.conf # 权限配置"></a>9.6/main/pg_hba.conf # 权限配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># &quot;local&quot; is for Unix domain socket connections only</span><br><span class="line">local   all             all                                  trust</span><br><span class="line">host    all             all             112.94.5.240/28      md5</span><br><span class="line">host    all             all             192.168.0.0/16       md5</span><br><span class="line">host    all             all             0.0.0.0/0            md5</span><br><span class="line"># IPv4 local connections:</span><br><span class="line">host    all             all             127.0.0.1/32         trust</span><br><span class="line">host    all             all             112.94.5.240/28      md5</span><br><span class="line">host    all             all             192.168.0.0/16       md5</span><br><span class="line">host    all             all             0.0.0.0/0            md5</span><br></pre></td></tr></table></figure><p>开放办公室ssh通道连接pgsql数据库</p><h4 id="centos-安装postgresql-client"><a href="#centos-安装postgresql-client" class="headerlink" title="centos 安装postgresql-client"></a>centos 安装postgresql-client</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install postgresql</span><br></pre></td></tr></table></figure><h4 id="修改默认密码"><a href="#修改默认密码" class="headerlink" title="修改默认密码"></a>修改默认密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user postgres  with password xxx</span><br></pre></td></tr></table></figure><h4 id="配置java应用连接pgsql数据库"><a href="#配置java应用连接pgsql数据库" class="headerlink" title="配置java应用连接pgsql数据库"></a>配置java应用连接pgsql数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- data_center_jdbc_url=jdbc:postgresql://192.168.8.143:5432/d1_statistics?autoReconnect=true&amp;useUnicode=true&amp;rewriteBatchedStatements=true&amp;useSSL=false</span><br><span class="line">- data_center_jdbc_username=postgres</span><br><span class="line">- data_center_jdbc_password=xxx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;部署postgres数据库-Docker&quot;&gt;&lt;a href=&quot;#部署postgres数据库-Docker&quot; class=&quot;headerlink&quot; title=&quot;部署postgres数据库(Docker)&quot;&gt;&lt;/a&gt;部署postgres数据库(Docker)&lt;/h3
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>游戏服内外网穿透</title>
    <link href="https://yo42.github.io/2018/09/11/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%86%85%E5%A4%96%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>https://yo42.github.io/2018/09/11/游戏服内外网穿透/</id>
    <published>2018-09-11T06:14:35.348Z</published>
    <updated>2018-09-11T06:42:22.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于游戏服内外网穿透"><a href="#关于游戏服内外网穿透" class="headerlink" title="关于游戏服内外网穿透"></a>关于游戏服内外网穿透</h2><p>大致一个场景:公司网络区分了内外网，游戏服务器架设在内网，而手机连接wifi是属于外网，需要满足个需求，外网环境(公司wifi、或个人办工电脑机器)实现正常访问内网游戏服。</p><p>涉及HTTP七层的转发以及TCP四层的转发</p><p>大致原理:部署转发代理服(包含外网网卡)，通过NGinx代理转发请求，内外网DNS劫持，实现。因为Nginx从1.9版本开始支持了TCP四层的转发，故使用Nginx的Stream模块进行实现，此外使用开源的HAproxy也是一个解决方案。</p><p>逻辑图:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="内外网穿透.png" alt="内外网穿透" title="">                </div>                <div class="image-caption">内外网穿透</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="内外网穿透2.png" alt="内外网穿透" title="">                </div>                <div class="image-caption">内外网穿透</div>            </figure><p>Nginx配置nginx.conf:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line"></span><br><span class="line"> include /etc/nginx/vhost.d/01-proxy.conf;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TCP转发:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> server &#123;</span><br><span class="line">    listen        7011;</span><br><span class="line">    proxy_pass    192.168.8.137:7011;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> server &#123;</span><br><span class="line">     listen        7012;</span><br><span class="line">     proxy_pass    192.168.8.137:7012;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen        27011;</span><br><span class="line">     proxy_pass    192.168.8.137:27011;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen       27012;</span><br><span class="line">     proxy_pass    192.168.8.137:27012;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> server &#123;</span><br><span class="line">     listen        27013;</span><br><span class="line">     proxy_pass    192.168.8.137:27013;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen        10004;</span><br><span class="line">     proxy_pass    192.168.8.137:10004;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen        10005;</span><br><span class="line">     proxy_pass    192.168.8.137:10005;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen        10006;</span><br><span class="line">     proxy_pass    192.168.8.137:10006;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen        10007;</span><br><span class="line">     proxy_pass    192.168.8.137:10007;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen        10008;</span><br><span class="line">     proxy_pass    192.168.8.137:10008;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen        10009;</span><br><span class="line">     proxy_pass    192.168.8.137:10009;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen         8111;</span><br><span class="line">     proxy_pass    192.168.8.137:8111;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> HTTP转发:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8080;</span><br><span class="line">    listen       8443 ssl;</span><br><span class="line">    server_name  proxydevh7d.demigame.com;</span><br><span class="line"></span><br><span class="line">    proxy_set_header Host             $host;</span><br><span class="line">    proxy_set_header X-Real-IP        $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-Forwarded-For2 $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">    server_name_in_redirect off;</span><br><span class="line"></span><br><span class="line">    include /home/nucleus-h7/global/nginx-137/conf/ssl.cfg;</span><br><span class="line">    include /home/nucleus-h7/global/nginx-137/conf/vhost.d/games-out.cfg;</span><br><span class="line"></span><br><span class="line">    error_log  /home/nucleus-h7/global/nginx-137/logs/games_errors_log   notice;</span><br><span class="line">    access_log /home/nucleus-h7/global/nginx-137/logs/games_access_log combined;</span><br><span class="line"></span><br><span class="line">    location ~* ^/ &#123;</span><br><span class="line">         proxy_pass http://192.168.8.137;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    location ~* ^/h7d/download/ &#123;</span><br><span class="line">    autoindex on;</span><br><span class="line">    autoindex_localtime on;</span><br><span class="line">    rewrite /h7d/(.*) /$1 break;</span><br><span class="line">        proxy_pass http://192.168.8.137;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:在内外网网关机器使用的是centos7 dnsmasq</p><p>1、在内网网关机器添加hosts劫持DNS，指向内网服务器的ip地址</p><p>2、在外网网关机器添加hosts劫持DNS，指向外网服务器的ip地址</p><p>3、测试解析</p><p>TODO:</p><p>1、目前H7的代理服h7-proxy-s189只有一个外网接口，所以采用新增虚接口的形式实现多网卡。</p><p>2、缺点:机器一重启虚拟接口就消失，需要手动执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip a a 192.168.1.54/22 dev eth1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于游戏服内外网穿透&quot;&gt;&lt;a href=&quot;#关于游戏服内外网穿透&quot; class=&quot;headerlink&quot; title=&quot;关于游戏服内外网穿透&quot;&gt;&lt;/a&gt;关于游戏服内外网穿透&lt;/h2&gt;&lt;p&gt;大致一个场景:公司网络区分了内外网，游戏服务器架设在内网，而手机连接wifi
      
    
    </summary>
    
      <category term="Technology" scheme="https://yo42.github.io/categories/Technology/"/>
    
    
      <category term="Technology" scheme="https://yo42.github.io/tags/Technology/"/>
    
  </entry>
  
</feed>

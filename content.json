[{"title":"python模块","date":"2018-09-06T11:25:23.588Z","path":"2018/09/06/python模块/","text":"如果你从 Python 解释器退出然后再进入它，你所做的定义（函数和变量）都会消失。因此，如果你想写某些更长的程序，你最好使用一个文本编辑器来为解释器准备输入，然后以这个文件作为输入来运行程序。这也被称为创建一个 脚本。当你的程序变得更长，你也许会想将它分成几个文件方便管理。你也许还想在几个程序中直接使用函数而不用在每个程序中拷贝函数定义。 为了支持这种特性，Python 可以把定义放入一个文件中然后在一个脚本或交互式解释器实例中使用它。这个文件被叫做 模块 （module），模块中的定义可以通过 导入 进入到其他模块或者 主 模块（你在顶层和计算器模式下执行的脚本中可以访问的变量集合）。 一个模块是一个包含 Python 定义和声明的文件。文件是模块名加上 .py 后缀。在一个模块中，模块名（字符串类型）可以通过全局变量 __name__ 获取。例如，使用你最喜欢的文本编辑器在当前目录下创建一个叫 fibo.py 的文件，这个文件包含以下内容 12345678910111213141516# 斐波那契数模块def fib(n): # 打印斐波那契数直到 n a, b = 0, 1 while a &lt; n: print(a, end=' ') a, b = b, a+b print()def fib2(n): # 返回到 n 的斐波那契数 result = [] a, b = 0, 1 while a &lt; n: result.append(a) a, b = b, a+b return result 现在进入 Python解释器然后通过下面的命令导入这个模块 1&gt;&gt;&gt; import fibo 这样做不会直接在当前环境中导入 fibo 中定义的函数名，只会导入名为 fibo 的模块。使用模块名可以获取模块中定义的函数： 123456&gt;&gt;&gt; fibo.fib(1000)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987&gt;&gt;&gt; fibo.fib2(100)[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]&gt;&gt;&gt; fibo.__name__'fibo' 如果你打算经常使用一个函数，你可以把它赋值给一个局部变量 123&gt;&gt;&gt; fib = fibo.fib&gt;&gt;&gt; fib(500)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 模块进阶一个模块可以包含可执行声明包括函数定义。这些声明被用于初始化模块。它们只在模块被 第一 次导入时执行。 [1]（如果文件被作为脚本运行它们也会被执行） 每个模块都有其私有的符号表，模块中定义的所有函数将这个符号表作为全局符号表。因此，一个模块的作者可以在模块中使用全局变量而无需担心与其他模块的全部变量冲突。另一方面，如果你知道你在干什么，你同样可以使用 模块.变量 的方式来获取一个模块的全局变量。 模块可以导入其他模块。将所有 import 语句放在模块（或者脚本，如果这个问题重要的话）的开头不是必须的，但习惯如此。被导入的模块名被放置于当前模块的全局符号表中。 import 声明的一种变体可以把一个模块中的变量直接导入当前模块的符号表中。例如： 123&gt;&gt;&gt; from fibo import fib, fib2&gt;&gt;&gt; fib(500)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 这样做不会把模块名引入本地符号表中（因此上面的例子里，fibo 没有被定义） 还有一种导入声明的变体可以导入一个模块中定义的所有变量： 123&gt;&gt;&gt; from fibo import *&gt;&gt;&gt; fib(500)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 这会导入模块中除了以下划线（_）开头的所有名称。大多数情况下 Python 程序员不使用这个机制，因为它会为解释器引入一系列位置未知变量，从而有可能覆盖你已经定义的某些变量。 请注意，一般来说，使用 import * 导入模块或包是不受欢迎的，因为这通常会降低代码可读性。但在使用交互型解释器为了减少打字而使用它是允许的。 如果模块名后紧跟 as, 那么 as 后的变量名会与被导入的模块名绑定。 123&gt;&gt;&gt; import fibo as fib&gt;&gt;&gt; fib.fib(500)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 这与 import fibo 的方式导入相同，除了模块现在被命名为 fib 而不是 fibo。 使用 from 时可以使用这个机制达到相同的效果： 123&gt;&gt;&gt; from fibo import fib as fibonacci&gt;&gt;&gt; fibonacci(500)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 注意由于性能原因，每个模块在每个解释器会话中只会被导入一次。因此，如果你改变了你的模块，你必须重启解释器 – 或者你只想交互式地测试一个模块，你可以使用 importlib.reload()，例如，import importlib;importlib.reload(modulename)。 将可执行模块当做脚本当你这样使用一个 Python 模块 1python fibo.py &lt;arguments&gt; 模块中的代码会被执行，就如你导入这个模块一样，除了 __name__ 变量被赋值为 &quot;__main__&quot;。这意味着在模块的末尾添加下面的代码： 123if __name__ == \"__main__\": import sys fib(int(sys.argv[1])) 你可以让一个文件当成脚本来使用同时也可以将其作为一个可导入模块，因为代码会解析命令行，并只在模块作为 “main” 文件时才会执行。 12$ python fibo.py 500 1 1 2 3 5 8 13 21 34 如果模块被导入，代码不会运行： 12&gt;&gt;&gt; import fibo&gt;&gt;&gt; 这经常被用于提供模块的用户接口或测试（以脚本的形式运行模块来执行某个测试集） 模块搜索路径 当一个名为 spam 的模块被导入时，解释器首先寻找同名的内建模块。如果没有发现同名内建模块，解释器会根据 sys.path 提供的一系列路径下寻找名为 spam.py 的文件。sys.path 根据下面这些位置进行初始化： 包含输入脚本的目录（如果没有指明文件则为当前目录） PYTHONPATH 一个目录的列表，语法与 shell 的 PATH 变量相同。 安装依赖默认路径 注意在支持符号链接的文件系统上，包含输入脚本的目录在符号链接被跟随之后才被计算。换句话说，包含符号链接的目录 不会 被添加到模块搜索路径。 初始化后，Python 程序会修改 sys.path。包含当前运行脚本的目录会被放在搜索路径的首位，位于标准库之前。这意味着该目录中与标准库同名的文件将会被导入，而相应的标准库则不会被导入。这将导致错误，除非你有意替换。参考 Standard Modules 获取更多信息。 “编译的” Python 文件为了加快模块载入速度，Python 将每个模块的编译版本以 module.*version*.pyc 的名称缓存在 __pycache__ 目录下，”version” 编码编译文件的格式，它通常包含 Python 版本号。例如，在 CPython 3.3 编译的 spam.py 文件缓存在 __pycache__/spam.cpython-33.py 中。这种命名方式允许不同发行版本和不同版本的 Python 编译文件共存。 Python 检查源文件修改日期并与编译的文件进行比较以确认编译文件是否过时，需要重新编译。这是一个全自动过程。同样的，编译的模块不依赖于操作系统，所以相同的库可以在不同架构的系统之间分享。 Python 在两种情况下不检查缓存。首先，Python 总会重新编译且不会缓存从命令行直接导入模块。其次，如果没有源模块，Python 也不会检查缓存。为了支持无源文件（只有编译文件）发布，编译的模块必须位于源目录，且不能有一个源模块。 对于高阶玩家的提醒： 你可以使用 -O 或 -OO Python 命令开关来减少一个编译模块的大小. -O 选项会去除断言声明，-OO 选项会去除断言声明和 __doc__ 字符串。由于一些程序依赖于这些变量，请只有在你明确知道自己在干嘛时使用这两个选项。“优化” 过的模块有一个 opt- 标签通常会更小。以后的版本也许会改版优化的效果。 从 .pyc 文件读取的程序不会比从 .py 文件读取的程序快；.pyc 只在载入时更快。 模块 compileall 可以在一个目录下创建所有模块的 .pyc 文件。 编译过程还有更多细节，包括一个决策流程图，它可以在 PEP 3147 找到。 标准模块Python 带有一个标准模块库，并发布有独立的文档，名为 Python 库参考手册（此后称其为”库参考手册”）。有一些模块内置于解释器之中，这些操作的访问接口不是语言内核的一部分，但是已经内置于解释器了。这既是为了提高效率，也是为了给系统调用等操作系统原生访问提供接口。这类模块集合是一个依赖于底层平台的配置选项。例如，winreg 模块只提供在 Windows 系统上才有。有一个具体的模块值得注意： sys ，这个模块内置于所有的 Python 解释器。变量 sys.ps1 和 sys.ps2定义了主提示符和辅助提示符字符串： 123456789&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.ps1'&gt;&gt;&gt; '&gt;&gt;&gt; sys.ps2'... '&gt;&gt;&gt; sys.ps1 = 'C&gt; 'C&gt; print('Yuck!')Yuck!C&gt; 这两个变量只在解释器的交互模式下有意义。 变量 sys.path 是解释器模块搜索路径的字符串列表。它由环境变量 PYTHONPATH 初始化，如果没有设定 PYTHONPATH ，就由内置的默认值初始化。你可以用标准的字符串操作修改它： 12&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append('/ufs/guido/lib/python') dir() 函数内置函数 dir() 用于按模块名搜索模块定义，它返回一个字符串类型的存储列表： 123456789101112131415161718192021&gt;&gt;&gt; import fibo, sys&gt;&gt;&gt; dir(fibo)['__name__', 'fib', 'fib2']&gt;&gt;&gt; dir(sys)['__displayhook__', '__doc__', '__excepthook__', '__loader__', '__name__', '__package__', '__stderr__', '__stdin__', '__stdout__', '_clear_type_cache', '_current_frames', '_debugmallocstats', '_getframe', '_home', '_mercurial', '_xoptions', 'abiflags', 'api_version', 'argv', 'base_exec_prefix', 'base_prefix', 'builtin_module_names', 'byteorder', 'call_tracing', 'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info', 'float_repr_style', 'getcheckinterval', 'getdefaultencoding', 'getdlopenflags', 'getfilesystemencoding', 'getobjects', 'getprofile', 'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval', 'gettotalrefcount', 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info', 'intern', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'ps1', 'setcheckinterval', 'setdlopenflags', 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout', 'thread_info', 'version', 'version_info', 'warnoptions'] 无参数调用时，dir() 函数返回当前定义的命名： 12345&gt;&gt;&gt; a = [1, 2, 3, 4, 5]&gt;&gt;&gt; import fibo&gt;&gt;&gt; fib = fibo.fib&gt;&gt;&gt; dir()['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys'] 注意该列表列出了所有类型的名称：变量，模块，函数，等等。 dir() 不会列出内置函数和变量名。如果你想列出这些内容，它们在标准模块 builtins 中定义： 12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; import builtins&gt;&gt;&gt; dir(builtins)['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__', '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip'] 包包通常是使用『圆点模块名』的结构化模块命名空间。例如，名为 A.B 的模块表示了名为 A 的包中名为 B 的子模块。正如同用模块来保存不同的模块架构可以避免全局变量之间的相互冲突，使用圆点模块名保存像 NumPy 或 Python Imaging Library 之类的不同类库架构可以避免模块之间的命名冲突。 现在，你必须开始遵守用以组织你的程序的层次结构。变量通常位于函数内部，函数与全局变量通常位于模块内部。如果你希望组织起这些模块的话，应该怎么办？这便是包（Packages）应当登场的时刻。 包是指一个包含模块与一个特殊的 __init__.py 文件的文件夹，后者向 Python 表明这一文件夹是特别的，因为其包含了 Python 模块。 让我们这样设想：你想创建一个名为“world”的包，其中还包含着 “asia”、“africa”等其它子包，同时这些子包都包含了诸如“india”、 “madagascar”等模块。 假设你现在想要设计一个模块集（一个”包”）来统一处理声音文件和声音数据。存在几种不同的声音格式（通常由它们的扩展名来标识，例如：.wav， .aiff，.au ），于是，为了在不同类型的文件格式之间转换，你需要维护一个不断增长的包集合。可能你还想要对声音数据做很多不同的操作（例如混音，添加回声，应用平衡 功能，创建一个人造效果），所以你要加入一个无限流模块来执行这些操作。你的包可能会是这个样子（通过分级的文件体系来进行分组）： 1234567891011121314151617181920212223sound/ Top-level package __init__.py Initialize the sound package formats/ Subpackage for file format conversions __init__.py wavread.py wavwrite.py aiffread.py aiffwrite.py auread.py auwrite.py ... effects/ Subpackage for sound effects __init__.py echo.py surround.py reverse.py ... filters/ Subpackage for filters __init__.py equalizer.py vocoder.py karaoke.py ... 当导入这个包时，Python 通过 sys.path 搜索路径查找包含这个包的子目录。 为了让 Python 将目录当做内容包，目录中必须包含 __init__.py 文件。这是为了避免一个含有烂俗名字的目录无意中隐藏了稍后在模块搜索路径中出现的有效模块，比如 string。最简单的情况下，只需要一个空的 __init__.py 文件即可。当然它也可以执行包的初始化代码，或者定义稍后介绍的 __all__ 变量。 用户可以每次只导入包里的特定模块，例如： 1import sound.effects.echo 这样就导入了 sound.effects.echo 子模块。它必需通过完整的名称来引用： 1sound.effects.echo.echofilter(input, output, delay=0.7, atten=4) 导入包时有一个可以选择的方式： 1from sound.effects import echo 这样就加载了 echo 子模块，并且使得它在没有包前缀的情况下也可以使用，所以它可以如下方式调用： 1echo.echofilter(input, output, delay=0.7, atten=4) 还有另一种变体用于直接导入函数或变量： 1from sound.effects.echo import echofilter 这样就又一次加载了 echo 子模块，但这样就可以直接调用它的 echofilter() 函数： 1echofilter(input, output, delay=0.7, atten=4) 需要注意的是使用 from package import item 方式导入包时，这个子项（item）既可以是包中的一个子模块（或一个子包），也可以是包中定义的其它命名，像函数、类或变量。import 语句首先核对是否包中有这个子项，如果没有，它假定这是一个模块，并尝试加载它。如果没有找到它，会引发一个 ImportError 异常。 相反，使用类似 import item.subitem.subsubitem 这样的语法时，这些子项必须是包，最后的子项可以是包或模块，但不能是前面子项中定义的类、函数或变量。 使用 * 导入包那么当用户写下 from sound.effects import * 时会发生什么事？理想中，总是希望在文件系统中找出包中所有的子模块，然后导入它们。这可能会花掉很长时间，并且出现期待之外的边界效应，导出了希望只能显式导入的包。 对于包的作者来说唯一的解决方案就是给提供一个明确的包索引。import 语句按如下条件进行转换：执行 from package import * 时，如果包中的 __init__.py 代码定义了一个名为 __all__ 的列表，就会按照列表中给出的模块名进行导入。新版本的包发布时作者可以任意更新这个列表。如果包作者不想 import *的时候导入他们的包中所有模块，那么也可能会决定不支持它（ import * ）。例如， sound/effects/__init__.py 这个文件可能包括如下代码： 1__all__ = [\"echo\", \"surround\", \"reverse\"] 这意味着 from sound.effects import * 语句会从 sound 包中导入以上三个已命名的子模块。 如果没有定义 __all__ ， from sound.effects import * 语句 不会 从 sound.effects 包中导入所有的子模块。无论包中定义多少命名，只能确定的是导入了 sound.effects 包（可能会运行 __init__.py 中的初始化代码）以及包中定义的所有命名会随之导入。这样就从 __init__.py 中导入了每一个命名（以及明确导入的子模块）。同样也包括了前述的 import 语句从包中明确导入的子模块，考虑以下代码： 123import sound.effects.echoimport sound.effects.surroundfrom sound.effects import * 在这个例子中，echo 和 surround 模块导入了当前的命名空间，这是因为执行 from...import 语句时它们已经定义在 sound.effects 包中了（定义了 __all__ 时也会同样工作）。 尽管某些模块设计为使用 import * 时它只导出符合某种规范/模式的命名，仍然不建议在生产代码中使用这种写法。 记住，from Package import specific_submodule 没有错误！事实上，除非导入的模块需要使用其它包中的同名子模块，否则这是推荐的写法。 包内引用如果包中使用了子包结构（就像示例中的 sound 包），可以按绝对位置从相邻的包中引入子模块。例如，如果 sound.filters.vocoder 包需要使用 sound.effects 包中的 echo 模块，它可以 from sound.Effects import echo。 你可以用这样的形式 from module import name 来写显式的相对位置导入。那些显式相对导入用点号标明关联导入当前和上级包。以 surround 模块为例，你可以这样用： 123from . import echofrom .. import formatsfrom ..filters import equalizer 需要注意的是显式或隐式相对位置导入都基于当前模块的命名。因为主模块的名字总是 &quot;__main__&quot;，Python 应用程序的主模块应该总是用绝对导入。 多重目录中的包包支持一个更为特殊的特性， path。 在包的 __init__.py 文件代码执行之前，该变量初始化一个目录名列表。该变量可以修改，它作用于包中的子包和模块的搜索功能。 这个功能可以用于扩展包中的模块集，不过它不常用。 参考资料","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"深入Python 流程控制","date":"2018-09-04T11:54:15.449Z","path":"2018/09/04/深入Python-流程控制/","text":"if 语句Example: 12345678910111213&gt;&gt;&gt; x = int(input(\"Please enter an integer: \"))Please enter an integer: 42&gt;&gt;&gt; if x &lt; 0:... x = 0... print('Negative changed to zero')... elif x == 0:... print('Zero')... elif x == 1:... print('Single')... else:... print('More')...More 这边可以v 有 0 个或者多个 elif 部分，并且 else 部分是可选的。关键字 elif 是 ‘else if’ 的缩写，它有助于避免过度缩进。 一个 if… elif … elif … 序列可以替代其他语言中的 switch 或 case 语句。 for 语句Python 中for 语句有点不同于 C 和 Pascal 中的 for 语句。Python 的 for 语句按照项目在序列中出现的顺序迭代任何序列（列表或字符串），而不是总是迭代数学的算术级数（如 Pascal 中），或者让用户能够定义迭代步骤和停止条件（如 C），例如（没有双关语）： 12345678&gt;&gt;&gt; # 测量字符串：... words = ['cat', 'window', 'defenestrate']&gt;&gt;&gt; for w in words:... print(w, len(w))...cat 3window 6defenestrate 12 如果你需要修改序列在循环内的迭代（例如复制所选项目），建议你先复制。迭代序列操作并不会隐式地复制。切片方法使这一操作特别方便： 123456&gt;&gt;&gt; for w in words[:]: # 循环遍历整个列表的切片副本。... if len(w) &gt; 6:... words.insert(0, w)...&gt;&gt;&gt; words['defenestrate', 'cat', 'window', 'defenestrate'] 使用 for w in words:，该示例将尝试创建一个无穷列表，反复的插入 defenestrate 。 range() 函数如果你需要迭代一系列的数字，内建的函数 range() 会非常有用。如，生成等差数列： 12345678&gt;&gt;&gt; for i in range(5):... print(i)...01234 给定的停止位是不会出现在生成的序列中的； range(10) 生成 10 个值，是长度为 10 的序列的项的合法指数。可以让区间开始于其他的数字，或者指定不同的增量（甚至是负数；有时候这被叫做 ‘步长’）： 12345678range(5, 10) 5, 6, 7, 8, 9range(0, 10, 3) 0, 3, 6, 9range(-10, -100, -30) -10, -40, -70 要遍历一个序列的索引，你可以像下面这样组合 range() 和 len() ： 123456789&gt;&gt;&gt; a = ['Mary', 'had', 'a', 'little', 'lamb']&gt;&gt;&gt; for i in range(len(a)):... print(i, a[i])...0 Mary1 had2 a3 little4 lamb 然而，在大多数情况下，使用 enumerate() 函数更方便，可以看 循环技术. 如果你直接打印一个区间的话，会发生奇怪的事情： 12&gt;&gt;&gt; print(range(10))range(0, 10) 在很多方面， range() 返回的对象的行为像列表，但实际上它不是。它是一个对象，当你迭代它的时候，会连续的返回整个序列的项目，但不会真的创建列表，从而节省空间。 我们称这样的对象为 可迭代的 ，也就是说，它很适合于当作函数或者构造函数的目标，它们期望从这里可以获得连续的项目直到耗尽。我们已经看到 for 语句是一个 迭代器 。list() 函数是另一个；它可从可迭代对象中创建列表： 12&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4] 稍后，我们会看到更多返回可迭代对象和将可迭代对象当作参数的函数。 break 和 continue 语句，以及循环上的 else 子句break 语句，类似于 C ，会打破 for 或 while 循环的最内层。 循环语句可能有 else 子句；它会在列表耗尽（用 for ）从而终止循环或者条件为假（用 while ）的时候被执行，而不是循环被 break 语句终止的时候；这被下面的这个查找素数的循环例证了： 1234567891011121314151617&gt;&gt;&gt; for n in range(2, 10):... for x in range(2, n):... if n % x == 0:... print(n, 'equals', x, '*', n//x)... break... else:... # 没有找到一个因数导致的循环失败... print(n, 'is a prime number')...2 is a prime number3 is a prime number4 equals 2 * 25 is a prime number6 equals 2 * 37 is a prime number8 equals 2 * 49 equals 3 * 3 （是的，这是正确的代码。密切关注： for 循环的 else 子句，不是 if 语句。） 当在循环使中使用 else 子句时，与其说很类似于if 语句，不如说更类似于 try 语句中的 else 子句：一个 try 语句的 else 子句会在没有异常发生的时候执行，而一个循环的 else 子句会在没有 break 发生的时候执行。要了解更多 try 语句和异常，请看 异常处理. continue 语句，也是从 C 借来的，用于继续循环的下一次迭代： 12345678910111213&gt;&gt;&gt; for num in range(2, 10):... if num % 2 == 0:... print(\"Found an even number\", num)... continue... print(\"Found a number\", num)Found an even number 2Found a number 3Found an even number 4Found a number 5Found an even number 6Found a number 7Found an even number 8Found a number 9 pass 语句pass 语句什么也不做。它可以用于语法上需要，但程序不需要做什么的时候。例如： 123&gt;&gt;&gt; while True:... pass # 等待键盘中断（Ctrl+C）... 通常也用于创建小类的时候： 123&gt;&gt;&gt; class MyEmptyClass:... pass... 其他地方， pass 可以在你处理新代码的时候，用作函数或者条件体的占位符，从而让你继续思考更抽象层级的事情。 pass 被默默地忽略了： 123&gt;&gt;&gt; def initlog(*args):... pass # 记住实现它！... 定义函数我们可以创建一个能打印出任意项的斐波那契数列的函数： 1234567891011&gt;&gt;&gt; def fib(n): # 将斐波那契数列打印到第 n 项... \"\"\"将斐波那契数列打印到第 n 项\"\"\"... a, b = 0, 1... while a &lt; n:... print(a, end=' ')... a, b = b, a+b... print()...&gt;&gt;&gt; # 调用上面定义的函数... fib(2000)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 关键字 def 引入了一个函数 定义 。其后面必须跟随有函数的名称以及用括号包起来的一系列参数。构成函数体的语句从下一行开始，并且必须缩进。 函数体的第一个语句可以是一个字符串常量，这个字符串常量就是这个函数的文档字符串，或者说是 docstring。（更多关于文档字符串的内容可参考章节 Documentation Strings 。）有很多工具可以用于在线或者可打印文档的自动化生成，或者可以让用户交互地在代码中浏览文档；在代码中写文档字符串是比较好的实践，所以请养成写文档字符串的习惯。 函数的 执行 引入了一个新的符号表用于存储函数的局部变量。更准确地说，在函数内的所有变量赋值都会被存储到这张局部符号表中；所以在查找一个变量的引用时，会先查找局部符号表，然后查找闭包函数的局部符号表，接着是全局符号表，最后才是内置名称表。因此，尽管可能在函数中引用全局变量，但在函数中无法对全局变量直接进行赋值（除非用 global 语句来定义一个变量） 当一个函数被调用时，函数参数被引入到局部符号表中；因此，参数是通过 按值传递 的方式来传递的（这个值表示一个对象的 引用 ，而不是该对象的值）。[1] 当在一个函数中调用另外一个函数时，将会为这次调用创建一个新的局部符号表。 一个函数定义将会在当前符号表中引入函数的名称。这个函数的名称对应的值的类型会被解释器解释为用户定义的函数。这个值可以被赋值给另外一个名称，并且将这名称可以当作一个函数来使用。这是一种常用的重命名机制： 12345&gt;&gt;&gt; fib&lt;function fib at 10042ed0&gt;&gt;&gt;&gt; f = fib&gt;&gt;&gt; f(100)0 1 1 2 3 5 8 13 21 34 55 89 如果你学习了别的编程语言，你可能认为 fib 不是一个函数而是一个过程，因为它没有返回值。事实上，一个不包含 return 语句的函数也是会返回一个值的。这个值是 None （这是一个内置名称）。 一般来说解释器不会打印出单独的返回值 None ，如果你真的想打印出 None ，你可以使用 print() ： 123&gt;&gt;&gt; fib(0)&gt;&gt;&gt; print(fib(0))None 写一个返回包含斐波那契数列的列表的函数比写一个打印斐波那契数列的函数要简单： 123456789101112&gt;&gt;&gt; def fib2(n): # 返回斐波那契数列的前 n 项... \"\"\"返回包含斐波那契数列前 n 项的列表的函数\"\"\"... result = []... a, b = 0, 1... while a &lt; n:... result.append(a) # 看上面的解释... a, b = b, a+b... return result...&gt;&gt;&gt; f100 = fib2(100) # 调用函数&gt;&gt;&gt; f100 # 输出结果[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89] 这个例子和之前一样阐述了一些 Python 的新特性： 函数通过 return 语句来返回结果值。不包含参数表达式的 return 语句返回表示函数返回 None。函数执行到末端的时候也返回 None result.append(a) 语句调用了列表 result 的 方法。方法是 “属于” 一个对象的函数，被命名为 obj.methodname, obj 表示这个对象（也可以是一个表达式），methodname 表示该对象类型定义中方法的名字。不同的类型定义了不同的方法。不同类型的方法的名字可以是相同的且不会产生歧义。（你可以使用 classes 来定一个你自己的对象类型和方法，参见 Classes）例子中的 append() 方法是列表对象定义的。它添加了一个新的元素到列表的末端，相当于 result =result + [a]，但是更高效。 更多关于定义函数的内容也可以使用可变数量的参数定义函数。 一共有三种方式，并且它们可以组合使用。 默认参数值最常用的形式是为一个或多个参数指定默认值。这样，函数可以以少于其定义的参数被调用。比如： 1234567891011def ask_ok(prompt, retries=4, reminder='Please try again!'): while True: ok = input(prompt) if ok in ('y', 'ye', 'yes'): return True if ok in ('n', 'no', 'nop', 'nope'): return False retries = retries - 1 if retries &lt; 0: raise ValueError('invalid user response') print(reminder) 该函数可以有几种不同的调用方式： 只指定强制的参数参数: ask_ok(&#39;Do you really want to quit?&#39;) 提供一个可选参数参数: ask_ok(&#39;OK to overwrite the file?&#39;, 2) 或者给定全部的参数参数: ask_ok(&#39;OK to overwrite the file?&#39;, 2, &#39;Come on, onlyyes or no!&#39;) 上述例子顺便也提及了 in 关键字。它是用来测试某个特定值是否在一个序列中。 默认值是在定义函数时的“定义过程中” （defining ）的范围内评估的， 所以， 1234567i = 5def f(arg=i): print(arg)i = 6f() 会打印 5. 重要提示： 默认值只被评估一次。 这个特性会导致当默认值是列表，字典，或者大多数类的实例时，默认值会是一个可变对象。比如，以下函数会累积在一系列的调用过程中所提供的参数： 1234567def f(a, L=[]): L.append(a) return Lprint(f(1))print(f(2))print(f(3)) 会打印出： 123[1][1, 2][1, 2, 3] 你可以把上面的函数写成以下的形式，以避免默认值被不同的函数调用所共享： 12345def f(a, L=None): if L is None: L = [] L.append(a) return L 关键字参数函数 关键字参数 同样可以使用 kwarg=value 的形式。例如，以下函数： 12345def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'): print(\"-- This parrot wouldn't\", action, end=' ') print(\"if you put\", voltage, \"volts through it.\") print(\"-- Lovely plumage, the\", type) print(\"-- It's\", state, \"!\") 接收一个必选参数 （voltage ） 和三个可选参数（ state，action， 和 type ）。这个函数下方式调用： 123456parrot(1000) # 一个位置参数parrot(voltage=1000) # 一个关键字参数parrot(voltage=1000000, action='VOOOOOM') # 2个关键字参数parrot(action='VOOOOOM', voltage=1000000) # 2个关键字参数parrot('a million', 'bereft of life', 'jump') # 3个位置参数parrot('a thousand', state='pushing up the daisies') # 一个位置参数，一个关键字参数 但是下列的所有调用方式是无效的： 1234parrot() # 必选参数缺失parrot(voltage=5.0, 'dead') # 非关键字参数在关键字参数后面parrot(110, voltage=220) # 同一参数重复赋值parrot(actor='John Cleese') # 未知关键字参数 在函数调用中，关键字参数必须遵循参数位置。传递的所有关键字参数必须跟函数接受的其中一个参数匹配。（例如： actor 在函数 parrot 中不是一个有效的参数），并且它们的顺序并不重要。这同样也包括那些非必选参数 （例如 parrot(voltage=1000) 同样有效）。没有参数可能多次获取一个值。下例就是因此而失败的： 1234567&gt;&gt;&gt; def function(a):... pass...&gt;&gt;&gt; function(0, a=0)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: function() got multiple values for keyword argument 'a' 当最后存在 **name 形式的参数时，它最后会接收一个字典, (参见 Mapping Types — dict) 包含所有除了和形式参数相对应的关键字参数。这可以与 * name 形式的形式参数（在下一小节中描述）结合，该参数接收包含正式参数列表之外的位置参数的元组。 (*name 必须出现在 **name 之前。) 例如，我们如果定义一个如下函数： 12345678def cheeseshop(kind, *arguments, **keywords): print(\"-- Do you have any\", kind, \"?\") print(\"-- I'm sorry, we're all out of\", kind) for arg in arguments: print(arg) print(\"-\" * 40) for kw in keywords: print(kw, \":\", keywords[kw]) 它可以像这样调用： 12345cheeseshop(\"Limburger\", \"It's very runny, sir.\", \"It's really very, VERY runny, sir.\", shopkeeper=\"Michael Palin\", client=\"John Cleese\", sketch=\"Cheese Shop Sketch\") 最终它会打印如下： 12345678-- Do you have any Limburger ?-- I'm sorry, we're all out of LimburgerIt's very runny, sir.It's really very, VERY runny, sir.----------------------------------------shopkeeper : Michael Palinclient : John Cleesesketch : Cheese Shop Sketch 请注意，保证打印函数关键字参数的顺序，和函数中调用中提供它们的顺序相一致。 可变参数最后，最不常用的指定参数的选项是可变数量的参数。这些参数将被组装成一个元组(参见 元组和序列) 。在可变参数之前，可能会出现零个或多个正常参数。 12def write_multiple_items(file, separator, *args): file.write(separator.join(args)) 通常，这些可变参数将在形式参数列表中排在最后，因为它们会对传递给函数的所有剩余输入参数进行辨识。 在 * args 参数之后出现的任何参数都是关键字参数，这意味着它们只能用作关键字参数而不是位置参数。 1234567&gt;&gt;&gt; def concat(*args, sep=\"/\"):... return sep.join(args)...&gt;&gt;&gt; concat(\"earth\", \"mars\", \"venus\")'earth/mars/venus'&gt;&gt;&gt; concat(\"earth\", \"mars\", \"venus\", sep=\".\")'earth.mars.venus' 分离参数列表当输入的参数已经是列表或元组形式而为了调用其中单独的位置参数时，将会出现与上面相反的情况。例如内置函数 range() 需要有独立的 start 和 stop 参数。如果输入的时候不是独立的参数，则需要用 * 操作符来将参数从列表或者元组里面提取出来： 12345&gt;&gt;&gt; list(range(3, 6)) # 正常利用参数调用函数[3, 4, 5]&gt;&gt;&gt; args = [3, 6]&gt;&gt;&gt; list(range(*args)) # 从列表中提取参数来调用函数[3, 4, 5] 以同样的方式，可以用 ** 操作符来将关键字参数从字典中提取出来： 12345678&gt;&gt;&gt; def parrot(voltage, state='a stiff', action='voom'):... print(\"-- This parrot wouldn't\", action, end=' ')... print(\"if you put\", voltage, \"volts through it.\", end=' ')... print(\"E's\", state, \"!\")...&gt;&gt;&gt; d = &#123;\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"&#125;&gt;&gt;&gt; parrot(**d)-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised ! Lambda 表达式我们可以使用lambda关键字来创建小型匿名函数。此函数会返回其两个参数的和：lambda a，b：a + b。可以在任何需要函数对象的场合使用 Lambda 函数。它们在语法上仅限于单个表达式。从语义上讲，它们只是普通函数定义的语法糖。与嵌套函数定义类似，lambda 函数可以从包含它的上下文中引用变量： 12345678&gt;&gt;&gt; def make_incrementor(n):... return lambda x: x + n...&gt;&gt;&gt; f = make_incrementor(42)&gt;&gt;&gt; f(0)42&gt;&gt;&gt; f(1)43 上面的例子使用 lambda 表达式返回了一个函数。另一个用途是传递一个小函数作为参数： 1234&gt;&gt;&gt; pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]&gt;&gt;&gt; pairs.sort(key=lambda pair: pair[1])&gt;&gt;&gt; pairs[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')] 文档字符串对于文档字符串的内容和格式，是有一定的约定的。 第一行应该始终是一个对对象目的的精简的总结。为简洁起见，它不该显式地声明对象的名称或类型，因为它们可以通过其他方式获得（除非函数名恰好是描述函数作用的动词）。这一行应该以大写字母开头并以句号结尾。 如果文档字符串不止一行，则第二行应为空白，从而能在视觉上将总结与其余的描述分开。接下来的几行应该是一个或多个段落，负责描述对象的调用约定以及其副作用等。 在 Python 中，Python 解析器并不会删除多行字符串文字的缩进，因此处理文档的工具必须在有必要之时删除缩进。这点是使用以下的约定完成的。在第一行之后的首个非空行决定了整个文档字符串的缩进数。（我们不能用第一行来决定，因为它通常与字符串开头的引号相邻，因此它的缩进在字符串中并不明显。）之后，我们把「等同于」这段缩进的空格从字符串的所有行的开头全部去除。不应出现少缩进的行，但如果出现了就把它们前面的空格全部去除。展开制表符后我们应当测试空格的等效性（通常为8个空格）。 以下是个多行文档字符串的例子： 1234567891011&gt;&gt;&gt; def my_function():... \"\"\"只要写文档，其他啥都别做。...... 确实，它也啥都不做。... \"\"\"... pass...&gt;&gt;&gt; print(my_function.__doc__)只要写文档，其他啥都别做。 确实，它也啥都不做。 函数注解函数注解 (Function annotations)应用于用户自定义的函数，可使用的类型是完全可选的元数据 (参考 PEP 3107和 PEP 484 获取更多信息)。 注解（Annotations）是以字典的形式存放在函数的 __annotations__ 属性中，并且不对函数有任何影响。参数注解 (Parameter annotations) 是由参数名称后面加上冒号来定义的，后面紧跟一个描述，来表示注解的值。 返回注解 (Return annotations) 的定义方式是：由 -&gt; 符号开始，在参数列表和表示函数def结束的冒号之间，加上你的描述。 接下来的例子，表示了位置参数、关键字参数和返回值的注解方法： 123456789&gt;&gt;&gt; def f(ham: str, eggs: str = 'eggs') -&gt; str:... print(\"Annotations:\", f.__annotations__)... print(\"Arguments:\", ham, eggs)... return ham + ' and ' + eggs...&gt;&gt;&gt; f('spam')Annotations: &#123;'ham': &lt;class 'str'&gt;, 'return': &lt;class 'str'&gt;, 'eggs': &lt;class 'str'&gt;&#125;Arguments: spam eggs'spam and eggs' 插曲: 代码风格现在你能够写更长更复杂的 Python 代码了。 是时候可以谈谈代码风格了。大多数编程语言可以使用不同的代码风格编写（就是格式化）； 有的可读性比其他的强。使用一种不错的代码风格可以帮助别人更好的阅读你的代码。 PEP 8 是大多数 Python 项目使用的代码风格指南。它提供了高可读性和养眼的代码风格。每一个 Python 开发者都应该阅读它，这里列出了其中的一些重点： 缩减使用四个空格而不是制表符 四个空格缩进比更少空格（运行跟多的嵌套深度）或者更多空格（更容易阅读）的缩进要好。 制表符会带来歧义，所以最好不要用它 每行不好超过79个字符 这可以帮助显示器较小的用户与帮助显示器较大的用户同屏显示多个文件。 使用空行分隔函数、类或者函数内较大的代码段。 尽量讲注释和代码放在一起。 用 docstrings。 用在操作符前后和逗号之后加空格，但是括号之内不需要： a= f(1, 2) + g(3, 4). 一致性的命名你的类与函数；惯例是用 CamelCase 命名类 ，用 lower_case_with_underscores 命名函数和方法。必须使用 self 作为方法的第一个参数（想了解更多请阅读 A First Look at Classes）。 如果你的代码将用于国际化的环境中，请不要使用任何花哨的编码。 Python 默认使用 UTF-8，甚至纯 ASCII 在任何情况下都能最好地工作。 即使说其他语言的人阅读或者维护你的代码的几率很小，也不要使用非 ASCII 字符。 参考资料 https://docs.python.org/3/tutorial/controlflow.html","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"Python CookBook(Data Structures)","date":"2018-09-02T12:27:45.272Z","path":"2018/09/02/Python-NoteBook/","text":"Python Data Structures 数据结构: 列表、字典、元组、集合。 数据结构（Data Structures）基本上人如其名——它们只是一种结构，能够将一些数据聚合在一起。换句话说，它们是用来存储一系列相关数据的集合。 Python 中有四种内置的数据结构——列表（List）、元组（Tuple）、字典（Dictionary）和集合（Set） 列表(List):List 数据类型包含更多的方法，下面是 List 对象包含的所有方法： 1list.append(*x*) 将一个元素添加到列表的末端。相当于 a[len(a):] = [x]。 1list.extend(*iterable*) 将一个 iterable 的对象中的所有元素添加到列表末端来拓展这个列表。相当于 a[len(a):] =iterable。 1list.insert(*i*, *x*) 在列表中给定的位置插入一个元素。第一个是要插入的元素的位置。所以 a.insert(0, x) 将元素插入列表最前面，a.insert(len(a), x) 相当于 a.append(x)。 1list.remove(*x*) 移除列表中第一个值为 x 的元素。如果没有找到这样的元素，抛出 ValueError。 1list.pop([*1*]) 移除并返回列表中给定位置的元素。如果没有指定索引，a.pop() 移除并返回列表的最后一个元素。（i 外的方括号表示这个参数是可选的，而不是要求你在这个位置输入方括号。你会经常在 Python Library Reference 中看到这种标记方式）。 1list.clear() 移除列表中所有的元素。相当于 del a[:]。 1list.index(*x*[, *start*[, *end*]]) 返回值为 x 的元素在列表中的索引，索引从 0 开始。如果不存在这样的元素，抛出 ValueError。 可选参数 start 和 end 被解释为切片表示法，用于将搜索范围限制在该列表的一个子序列内。返回的索引是该元素在相对于原列表的开端的位置而不是相对于 start 参数的位置。 1list.count(*x*) 返回列表中值为 x 的元素的数量。 1list.sort(*key=None*, *reverse=False*) 对列表中的元素进行原地排序（参数可以被用于自定义排序，参见sorted()） 1list.reverse() 原地翻转列表。 1list.copy() 返回该列表的一个浅拷贝。相当于 a[:]。 Go! Let‘s We Play!动手练习: 12345678910111213141516171819202122232425262728classmate = ['tom',13,'boy','student'] #以一个列表形式classmate #调用list使用len函数调用list元素个数len(classmate)用索引列出位置元素 注意索引是从0开始的0-n&gt;&gt;&gt; classmates[0]'Michael'&gt;&gt;&gt; classmates[1]'Bob'&gt;&gt;&gt; classmates[2]'Tracy'&gt;&gt;&gt; classmates[3]当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。 如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：也可以把元素插入到指定的位置，比如索引号为1的位置：&gt;&gt;&gt; classmates.insert(1, 'Jack')&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']要删除list末尾的元素，用pop()方法：默认pop删除最后一个元素，使用pop(i)数字删除指定的索引位置&gt;&gt;&gt; classmates.pop()'Adam'&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy']要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：&gt;&gt;&gt; classmates[1] = 'Sarah'&gt;&gt;&gt; classmates['Michael', 'Sarah', 'Tracy'] Example: 1234567891011121314151617181920&gt;&gt;&gt; fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']&gt;&gt;&gt; fruits.count('apple')2&gt;&gt;&gt; fruits.count('tangerine')0&gt;&gt;&gt; fruits.index('banana')3&gt;&gt;&gt; fruits.index('banana', 4) # 从索引 4 开始找 banana6&gt;&gt;&gt; fruits.reverse()&gt;&gt;&gt; fruits['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']&gt;&gt;&gt; fruits.append('grape')&gt;&gt;&gt; fruits['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']&gt;&gt;&gt; fruits.sort()&gt;&gt;&gt; fruits['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']&gt;&gt;&gt; fruits.pop()'pear' 使用列表作为堆栈:列表的方法使得可以把列表当成元素后进先出的堆栈来用。使用 append() 来把一个元素加到堆栈的顶部。使用不显示携带索引参数的 pop() 方法来把一个元素从堆栈顶部移除。比如： 123456789101112131415&gt;&gt;&gt; stack = [3, 4, 5]&gt;&gt;&gt; stack.append(6)&gt;&gt;&gt; stack.append(7)&gt;&gt;&gt; stack[3, 4, 5, 6, 7]&gt;&gt;&gt; stack.pop()7&gt;&gt;&gt; stack[3, 4, 5, 6]&gt;&gt;&gt; stack.pop()6&gt;&gt;&gt; stack.pop()5&gt;&gt;&gt; stack[3, 4] 使用列表作为队列:也可以使用列表作为队列，其中添加的第一个元素是检索的第一个元素（“先入，先出”）；然而，列表对于这一目的并不高效。虽然从列表末尾追加和弹出是高效的，但是从列表的开头开始插入或弹出就低效了（因为所有其他元素都必须移动一个位置）。 实现一个队列，使用 collections.deque 它被设计为从两端都具有快速追加和弹出的能力。例如： 12345678910&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; queue = deque([\"Eric\", \"John\", \"Michael\"])&gt;&gt;&gt; queue.append(\"Terry\") # Terry 进入&gt;&gt;&gt; queue.append(\"Graham\") # Graham 进入&gt;&gt;&gt; queue.popleft() # 现在弹出第一个进入的元素'Eric'&gt;&gt;&gt; queue.popleft() # 现在弹出第二个进入的元素'John'&gt;&gt;&gt; queue # 按进入顺序维护队列deque(['Michael', 'Terry', 'Graham']) 列表表达式/列表解析:列表推导式（又称列表解析式）提供了一种简明扼要的方法来创建列表。它的结构是在一个中括号里包含一个表达式，然后是一个for语句，然后是0个或多个for或者if语句。那个表达式可以是任意的，意思是你可以在列表中放入任意类型的对象。返回结果将是一个新的列表，在这个以if和for语句为上下文的表达式运行完成之后产生。 例如，我们可以通过以下方式产生一组平方数。 123456&gt;&gt;&gt; squares = []&gt;&gt;&gt; for x in range(10):... squares.append(x**2)...&gt;&gt;&gt; squares[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 注意到在整个过程中，我们创建并修改了一个 x 变量，并且在循环完成之后依然存在。使用以下方式，我们同样可以生成这个序列，且没有额外的变量生成。 更优的写法，意思更明确，也更具可读性。等价形式: 1squares = [x**2 for x in range(10)] 列表初始化表达式由方括号 [] 包含，括号内以 for 语句起始，后接任意个 for 语句或 if 语句。其结果是产生一个新的列表，列表内的元素为其中的 for 语句或 if 语句的执行结果。例如，以下表达式创建了一个列表，列表内的每个元素形如 (x, y)，其中 x 和 y 分别来自两个列表，且 x 与 y 不相等。 12&gt;&gt;&gt; [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y][(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)] 这种写法等价于： 12345678&gt;&gt;&gt; combs = []&gt;&gt;&gt; for x in [1,2,3]:... for y in [3,1,4]:... if x != y:... combs.append((x, y))...&gt;&gt;&gt; combs[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)] 在这两段代码中，for 语句和 if 语句的执行顺序是相同的。 如果要使生成列表中的每个元素都是一个元组，则必须给表达式加上圆括号 () 。 Do More Practice: 123456789101112131415161718192021222324252627&gt;&gt;&gt; vec = [-4, -2, 0, 2, 4]&gt;&gt;&gt; # 创建一个新列表，将原列表中的每个元素乘以 2&gt;&gt;&gt; [x*2 for x in vec][-8, -4, 0, 4, 8]&gt;&gt;&gt; # 去除原列表中的负数&gt;&gt;&gt; [x for x in vec if x &gt;= 0][0, 2, 4]&gt;&gt;&gt; # 对原列表中的每个元素调用函数&gt;&gt;&gt; [abs(x) for x in vec][4, 2, 0, 2, 4]&gt;&gt;&gt; # 调用每个元素的成员方法&gt;&gt;&gt; freshfruit = [' banana', ' loganberry ', 'passion fruit ']&gt;&gt;&gt; [weapon.strip() for weapon in freshfruit]['banana', 'loganberry', 'passion fruit']&gt;&gt;&gt; # 创建一个由二元组构成的列表，元素形如 (number, square)&gt;&gt;&gt; [(x, x**2) for x in range(6)][(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]&gt;&gt;&gt; # 元组必须以圆括号包含，否则将产生一个错误&gt;&gt;&gt; [x, x**2 for x in range(6)] File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; [x, x**2 for x in range(6)] ^SyntaxError: invalid syntax&gt;&gt;&gt; # 用一个含有两个 `for` 的列表初始化表达式将一个多维列表降维&gt;&gt;&gt; vec = [[1,2,3], [4,5,6], [7,8,9]]&gt;&gt;&gt; [num for elem in vec for num in elem][1, 2, 3, 4, 5, 6, 7, 8, 9] del 语句有一个方法可以根据索引而不是值从列表中删除一个元素： del 语句。 这和 pop() 方法不同，后者会返回一个值。 del 语句也可用于从列表中删除片段或清除整个列表 （之前我们通过将一个空列表赋值给这个片段来达到此目的）。 例如: 12345678910&gt;&gt;&gt; a = [-1, 1, 66.25, 333, 333, 1234.5]&gt;&gt;&gt; del a[0]&gt;&gt;&gt; a[1, 66.25, 333, 333, 1234.5]&gt;&gt;&gt; del a[2:4]&gt;&gt;&gt; a[1, 66.25, 1234.5]&gt;&gt;&gt; del a[:]&gt;&gt;&gt; a[] del 也可用于删除整个变量： 1&gt;&gt;&gt; del a 字典(Dict):字典是 Python 中另外一种常用的数据类型(参考 Mapping Types — dict). 字典就像一本地址簿，如果你知道了他或她的姓名，你就可以在这里找到其地址或是能够联系上对方的更多详细信息，换言之，我们将键值（Keys）（即姓名）与值（Values）（即地址等详细信息）联立到一起。在这里要注意到键值必须是唯一的，正如在现实中面对两个完全同名的人你没办法找出有关他们的正确信息。 另外要注意的是你只能使用不可变的对象（如字符串）作为字典的键值，但是你可以使用可变或不可变的对象作为字典中的值。基本上这段话也可以翻译为你只能使用简单对象作为键值。 在字典中，你可以通过使用符号构成 d = {key : value1 , key2 : value2} 这样的形式，来成对地指定键值与值。在这里要注意到成对的键值与值之间使用冒号分隔，而每一对键值与值则使用逗号进行区分，它们全都由一对花括号括起。 字典主要的操作符就是通过键来存储对应的数据，以及根据键来取出对应的数据。也可以通过 del 来删除一个键值对。如果在存储数据的时候使用了字典中已有的键，则该键对应的值会被更新为当前新赋给值。如果使用字典中不存在的键来获取值，则会产生 error ，提示不存在这样的键。 list(d) 操作会返回字典中所有键组成的列表，列表中的数据顺序按照这些键存入字典的顺序（如果想得到一个经过排序的键的列表，可以使用 sorted(d) ）。检查字典中是否有某个键，可以使用关键字 in 。 另外需要记住，字典中的成对的键值—值配对不会以任何方式进行排序。如果你希望为它们安排一个特别的次序，只能在使用它们之前自行进行排序。 你将要使用的字典是属于 dict 类下的实例或对象。 Example: 123456789101112131415161718&gt;&gt;&gt; tel = &#123;'jack': 4098, 'sape': 4139&#125;&gt;&gt;&gt; tel['guido'] = 4127&gt;&gt;&gt; tel&#123;'jack': 4098, 'sape': 4139, 'guido': 4127&#125;&gt;&gt;&gt; tel['jack']4098&gt;&gt;&gt; del tel['sape']&gt;&gt;&gt; tel['irv'] = 4127&gt;&gt;&gt; tel&#123;'jack': 4098, 'guido': 4127, 'irv': 4127&#125;&gt;&gt;&gt; list(tel)['jack', 'guido', 'irv']&gt;&gt;&gt; sorted(tel)['guido', 'irv', 'jack']&gt;&gt;&gt; 'guido' in telTrue&gt;&gt;&gt; 'jack' not in telFalse dict() 函数会直接通过一系列的 键值对产生一个字典： 12&gt;&gt;&gt; dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])&#123;'sape': 4139, 'guido': 4127, 'jack': 4098&#125; 另外，我们可以从任意的键和值得表达式来创建字典： 12&gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125;&#123;2: 4, 4: 16, 6: 36&#125; 当键是字符串的时候，使用参数赋值的方式来指定键值对更方便： 12&gt;&gt;&gt; dict(sape=4139, guido=4127, jack=4098)&#123;'sape': 4139, 'guido': 4127, 'jack': 4098&#125; 遍历的技巧:​ 鉴于字典可能包含大量的数据，Python支持对字典的遍历。字典可用于以各种方式存储信息，因此有多种遍历字典的方式:可遍历字典的所有键-值对、键或值(key-value)。 遍历字典时，键和对应的值可以用 items() 方法一次性全部得到。 123456&gt;&gt;&gt; knights = &#123;'gallahad': 'the pure', 'robin': 'the brave'&#125;&gt;&gt;&gt; for k, v in knights.items():... print(k, v)...gallahad the purerobin the brave 使用keys()方法可以遍历字典中的所有键 12345678favorite_languages= &#123; 'jen': 'python', 'sarah': 'c', 'edward': 'ruby', 'phil': 'python' &#125;for name in favorite_languages.keys(): print(name.title()) 使用values()方法可以遍历字典中的所有值 12345678favorite_languages= &#123; 'jen': 'python', 'sarah': 'c', 'edward': 'ruby', 'phil': 'python' &#125;for name in favorite_languages.values(): print(name.title()) 这种做法提取字典中的所有值，而没有考虑是否出现重复的问题。如果数据中含大量的重复项就需要使用集合(set) 12for name in set(favorite_languages.values()): print(name.title()) 遍历一个序列时，位置索引和对应的值可以用 enumerate() 方法一次性全部得到。 123456&gt;&gt;&gt; for i, v in enumerate(['tic', 'tac', 'toe']):... print(i, v)...0 tic1 tac2 toe 当需要同时遍历两个或多个序列时，可以使用 zip() 方法将他们合并在一起。 12345678&gt;&gt;&gt; questions = ['name', 'quest', 'favorite color']&gt;&gt;&gt; answers = ['lancelot', 'the holy grail', 'blue']&gt;&gt;&gt; for q, a in zip(questions, answers):... print('What is your &#123;0&#125;? It is &#123;1&#125;.'.format(q, a))...What is your name? It is lancelot.What is your quest? It is the holy grail.What is your favorite color? It is blue. 当需要反过来遍历一个序列的时候，使用 reversed() 方法来将一个正的序列倒序。 12345678&gt;&gt;&gt; for i in reversed(range(1, 10, 2)):... print(i)...97531 需要按顺序遍历一个序列，可以把未排序的序列传到 sorted() 方法中来获得一个新的排好序的列表。 12345678&gt;&gt;&gt; basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']&gt;&gt;&gt; for f in sorted(set(basket)):... print(f)...applebananaorangepear 元组(tuple)我们发现列表和字符串有许多共同点，例如可以用索引来访问，以及切割的操作。他们属于序列类型的公共特性。(参见 序列类型 — 列表，元组，区间)。Python 的日益发展，使得其他的序列类型会被逐渐地加入到语言特性中。其中就有另一种序列类型：元组。 列表非常适用于储存在程序运行期间可能变化的数据集。列表是可以修改的，这对处理网站的用户列表或游戏中的角色列表至关重要。然而，有时候你需要创建一系列不可修改的元素，元组可以满足这种需求。python将不能修改的值称为不可变的，而不可变的列表称为元组。元组通常用于保证某一语句或某一用户定义的函数可以安全地采用一组数值，意即元组内的数值不会改变。 元组由一系列被逗号分隔开的值组成，例如： 123456789101112131415161718&gt;&gt;&gt; t = 12345, 54321, 'hello!'&gt;&gt;&gt; t[0]12345&gt;&gt;&gt; t(12345, 54321, 'hello!')&gt;&gt;&gt; # 元组也可以嵌套：... u = t, (1, 2, 3, 4, 5)&gt;&gt;&gt; u((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))&gt;&gt;&gt; # 元组不可被修改：... t[0] = 88888Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment&gt;&gt;&gt; # 但是可以包含可以被修改的对象：... v = ([1, 2, 3], [3, 2, 1])&gt;&gt;&gt; v([1, 2, 3], [3, 2, 1]) 元组在输出时总是带有两侧的括号，这样一来，嵌套的元组可以被清楚地区分开；但是在输入时，并不一定要带上两侧的括号，尽管有时带上括号非常有必要（例如元组作为一个很长的表达式的一部分）。不能对元组中的项进行赋值，但在创建元组时，可以传入可修改的对象，例如列表。 虽然元组看起来和列表很像，但它们的使用场合和使用目的往往不同。元组是 不可修改的, 并且经常包含着不同类型的元素，总是通过解包（本章的后面会介绍）或索引（命名元组可以通过属性索引的方式）来访问。而列表是 可修改的，并且往往包含着同样类型的元素，通过遍历的方式来进行访问。 一个特别的问题是如何创建一个空的或只有一个元素的元组：语法上有一些小窍门。空的元组可以用一对空的括号来创建；只有一个元素的元组可以用一个后面跟着逗号的值来创建（只在括号里放一个元素可不行）。这些方法虽然有点丑陋，但挺好用的。例如： 12345678&gt;&gt;&gt; empty = ()&gt;&gt;&gt; singleton = 'hello', # &lt;-- 注意后面的逗号&gt;&gt;&gt; len(empty)0&gt;&gt;&gt; len(singleton)1&gt;&gt;&gt; singleton('hello',) 语句 t = 12345, 54321, &#39;hello!&#39;是一个 元组解包的例子：元素 12345， 54321 和 &#39;hello!&#39; 一起组成了一个元组。下面这样的操作也同样可以做到： 1&gt;&gt;&gt; x, y, z = t 这被称为 序列解包 ，所有右值的序列都可以使用这种语法。序列解包要求在等号的左边有着和序列内元素数量相同的变量。到这里也许你也发现了，多重赋值就是利用元组和序列解包来实现的。 集合(set)Python 内建集合的数据类型。一个集合是由多个无重复元素构成的无序整体。集合支持的基本功能包括成员检查以及重复元素的去除。集合同时支持求并集、交集、差集以及对称差集等操作。 集合可以通过大括号符号或者调用 set() 函数创建。注意：如果需要创建一个空的集合实例，需使用 set()而非 {} ，因为后者会创建一个空的字典实例。我们将在下一个章节介绍字典类型。 下面我们来看一个简单的示范代码： 12345678910111213141516171819202122&gt;&gt;&gt; basket = &#123;'apple', 'orange', 'apple', 'pear', 'orange', 'banana'&#125;&gt;&gt;&gt; print(basket) # 可以看到重复的元素被去除&#123;'orange', 'banana', 'pear', 'apple'&#125;&gt;&gt;&gt; 'orange' in basket # 快速成员检查True&gt;&gt;&gt; 'crabgrass' in basketFalse&gt;&gt;&gt; # 由两个单词中独特的字母构成的集合进行的集合间操作...&gt;&gt;&gt; a = set('abracadabra')&gt;&gt;&gt; b = set('alacazam')&gt;&gt;&gt; a # a 集合中独特的字母&#123;'a', 'r', 'b', 'c', 'd'&#125;&gt;&gt;&gt; a - b # 在 a 中但是不在 b 中的字母&#123;'r', 'd', 'b'&#125;&gt;&gt;&gt; a | b # 在 a 中或在 b 中的字母&#123;'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'&#125;&gt;&gt;&gt; a &amp; b # a 和 b 共有的字母&#123;'a', 'c'&#125;&gt;&gt;&gt; a ^ b # 在 a 中或在 b 中但两者不共有的字母&#123;'r', 'd', 'b', 'm', 'z', 'l'&#125; Python支持类似于 递推式构造列表 的递推式构造集合： 123&gt;&gt;&gt; a = &#123;x for x in 'abracadabra' if x not in 'abc'&#125;&gt;&gt;&gt; a&#123;'r', 'd'&#125; 判断条件进阶被用在 while 和 if 语句中的判断条件不仅仅可以包含比较运算，还可以包含任何的运算符。 比较运算符 in 和 not in 能够检查某个值是否在一个序列里出现（或不出现）。比较运算符 is 和 is not 比较两个对象是否是同一个对象；这只会影响如列表之类可修改的对象。所有的比较运算符的优先级都相同，比所有的算术运算法的优先级都要低。 比较运算符可以采用连写的方式。例如， a &lt; b == c 用来检查是否 a 小于 b 并且 b 等于 c 。 比较运算符可以用布尔运算符 and 和 or 进行组合，然后他们的结果（或者任何其他的布尔表达式）可以被 not 否定。这些布尔运算符的优先级又比比较运算符更低；而在他们之间， not 的优先级最高，而 or 的优先级最低，因此 A and not B or C 就等价于 (A and (not B)) or C。 当然，括号可以用来提升优先级。 布尔运算符 and 和 or 往往被称为 短路 运算符：它们的参数从左往右一个个被计算，而当最终结果已经能够确定时，就不再计算剩余的参数了。举个例子，如果 A 和 C 是真的，而 B 是假的，那么 A and B and C 不会计算表达式 C 的值。当不作为布尔值使用，而是作为普通的值来使用时，短路运算符的返回值将会是最后一个被计算的参数。 也可以把比较运算的结果或其他布尔表达式赋值给一个变量。例如， 1234&gt;&gt;&gt; string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'&gt;&gt;&gt; non_null = string1 or string2 or string3&gt;&gt;&gt; non_null'Trondheim' 注意， Python 和 C 不同，赋值不能在表达式内部进行。 C 程序员们可能会抱怨这一点，但这种特性有效地防止了 C 程序中那种常见的错误发生：把 == 不小心写成了 = 。 序列及其他类型的比较拥有相同序列类型的序列对象之间可以进行比较。序列间的比较基于字典排序：首先比较两序列的首项，如果它们不同，那么比较就有了结果；如果它们相同，接下来的两项将继续进行比较，以此类推，直到两者中任何一个序列被遍历完毕。如果比较的项所在的序列是同样的类型，那么可以按照字典排序的方法递归进行下去。如果两序列所有的项比较过后都是相同的，则认为这两个序列相等。如果其中一个序列是另一个序列从头开始的一个子序列，那么更短的一个被认为更小。字符串的字典排序对于单个字符按照 Unicode 的编码大小进行排序。 一些同类型序列的比较示例如下： 1234567(1, 2, 3) &lt; (1, 2, 4)[1, 2, 3] &lt; [1, 2, 4]'ABC' &lt; 'C' &lt; 'Pascal' &lt; 'Python'(1, 2, 3, 4) &lt; (1, 2, 4)(1, 2) &lt; (1, 2, -1)(1, 2, 3) == (1.0, 2.0, 3.0)(1, 2, ('aa', 'ab')) &lt; (1, 2, ('abc', 'a'), 4) 需要注意，如果有适当的比较方法，对于不同类型对象间的比较使用 &lt; 或者 &gt; 也是合法的。例如，混合数字类型可以根据它们的数值大小进行比较，如 0 等于 0.0 ，以此类推。否则，Python解释器会抛出一个TypeError 的异常，而非给出一个随机的排序。 参考资料 https://docs.python.org/3/tutorial/datastructures.html","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"从容器到容器云","date":"2018-07-22T13:09:46.079Z","path":"2018/07/22/从容器到容器云/","text":"2013年初，一个名字从云计算领域横空出世，并在整个IT行业激起千层浪。这就是Docker——一个孕育着新思想的“容器”。Docker选择容器作为核心和基础，依靠容器技术支撑的Docker迅速成为国内外各大云计算厂商以及开发者手中的至宝。在一片热火朝天之后，新的革命已经悄然来临。 云计算平台回首历史，云计算时代蕴育出了众多的云计算平台，虽然在服务类型或平台功能上有所差异，但它们的本质上如出一辙，都与NIST1对于云计算平台的定义有着密切的关系。 云计算是一种按使用量付费的模式，该模式提供可用的、便捷的、按需的网络访问， 纳入可配置的计算资源共享池（资源包括网络、服务器、存储、应用软件、服务），统一管理的资源能够被快速提供，大大减少了资源管理工作开销，你甚至可以再也不用理会那些令人头痛的传统服务供应商了。 经典云计算架构包括了IaaS（Infrastructure as a Service，基础设施即服务）、PaaS（Platform as a Service，平台即服务）、SaaS（Software as a Service，软件即服务）三层服务，如图1-1所示。 图1-1 云平台经典架构 IaaS层为基础设施运维人员服务，提供计算、存储、网络及其他基础资源，云平台使用者可以在上面部署和运行包括操作系统和应用程序在内的任意软件，无需再为基础设施的管理而分心。 PaaS层为应用开发人员服务，提供支撑应用运行所需的软件运行时环境、相关工具与服务，如数据库服务、日志服务、监控服务等，让应用开发者可以专注于核心业务的开发。 SaaS层为一般为用户服务，提供了一套完整可用的软件系统，让一般用户无需关注技术细节，只需通过浏览器、应用客户端等方式就能使用部署在云上的应用服务。 同时，随着计算机技术推陈出新，应用的规模愈发庞大，逻辑愈发复杂，迭代更新愈发频繁，应用开发所需的统一规范和原有开发模式杂乱无章成了追求进步的主要障碍。在尖锐的矛盾中，云时代应用生命周期管理机制（Application Lifecycle Management，ALM）和十二要素应用规范（The Twelve-Factor App）2应运而生。 所有理论设计和预想一定是美好的，只是对于一个新的理论而言，如何经受住实践的考验，并将美好的愿景转化为生产力才是重中之重。IaaS的发展主要以虚拟机为最小粒度的资源调度单位，出现了资源利用率低、调度分发缓慢、软件栈环境不统一等一堆问题。PaaS在IaaS基础上发展而来，众多PaaS已经意识到可以利用容器技术解决资源利用率问题，但是PaaS通常在应用架构选择、支持的软件环境服务方面有较大的限制，这带来了应用与平台无法解耦、应用运行时环境局限性强、运维人员控制力下降的问题。 可见，不论IaaS还是PaaS都有各自适用的场景，但依旧存在诸多缺陷，人们亟需一个真正可用的解决方案。 容器，新的革命每一场革命背后都有着深刻的历史背景和矛盾冲突，新陈代谢是历史的必然结果，新生取代陈旧得益于理念的飞跃和对时代发展需求的契合，很显然Docker抓住了这个契机。 Docker是什么？ 基于官方的定义，Docker是以Docker容器为资源分割和调度的基本单位，封装整个软件运行时环境，为开发者和系统管理员设计的，用于构建、发布和运行分布式应用的平台。它是一个跨平台、可移植并且简单易用的容器解决方案。Docker的源代码托管在GitHub上，基于Go语言开发并遵从Apache 2.0协议。Docker可在容器内部快速自动化地部署应用，并通过内核技术（namespaces、cgroups等）为容器提供资源隔离与安全保障。 我们应该看看Docker的发展历程。 每一个传奇都需要一个这样的开头，很久很久以前：Docker项目由Solomon Hykes所带领的团队发起，在Docker公司的前身dotCloud内部启动孕育，代码托管于GitHub。 2013年11月：REHL 6.5正式版发布，集成了对Docker的支持，拉开了业界各大厂商竞相支持Docker的序幕。 2014年4月到6月：云技术市场上的三大巨头Amazon、Google及MicroSoft Azure相继宣布支持Docker，并着手开发基于容器的全新产品。 2014年6月：DockerCon 2014大会召开，会上来自Google、IBM、Amazon、Red Hat、Facebook及Twitter等全球领先企业的演讲嘉宾组成了豪华的阵容。此时， Docker自开源版本后又经历了15个月左右的飞速发展，Docker 1.0版本正式发布。 2014年8月：VMware宣布与Docker建立合作关系，标志了虚拟化市场形成了新的格局。 2014年10月：微软宣布将整合Docker进入下一代的Windows Server中。 2014年10月15日：Azure和Docker共同举办了Docker全球开发者大会，并宣布双方建立战略合作伙伴关系。 2014年底：Google率先发布容器引擎Google Container Engine（GCE），整合了Docker、Google自有容器技术和在DockerCon 2014大会上发布的Kubernetes，致力于为用户提供完善的基于Docker应用打造的云计算平台；Amazon发布EC2 Container Service（ECS），它是一项高度可扩展、高性能、免费的容器管理服务，并能够在托管的Amazon EC2实例集群上轻松地发布、管理和扩展Docker容器，使得Amazon Web Services（AWS）用户能够使用AWS上的容器轻松地运行和管理分布式应用。 2015年4月：Docker公司宣布完成了9500万美元的D轮融资。此前，他们已完成三轮融资，包括1500万美元的B轮融资及4000万美元的C轮融资。 2015年6月：Linux基金会携手AWS、思科、Docker、EMC、富士通、高盛、Google、惠普、华为、IBM、Intel等公司在DockerCon上共同宣布成立容器标准化组织OCP（Open Container Project），旨在实现容器标准化，为Docker生态圈内成员的协作互通打下良好的基础。该组织后更名为OCI（Open Container Initiative）。 2016年2月：Docker公司发布商业版容器及服务平台DDC（Docker Datacenter），迈出了Docker商业化的重要一步。 截至2016年6月：GitHub中Docker的贡献者超过千人，被关注和喜爱（star）多达三万两千余次（相比之下，此时Linux源码多年来积累的被关注次数仅为两万两千余次），并有九千多个开发分支（fork），Docker成为了GitHub上排名前20的明星项目。 Docker官方存储应用镜像的容器仓库也获得了大量开发者支持，其镜像仓库里已有超过12万个不同应用功能的公共镜像。最受欢迎的Ubuntu、MySQL、Nginx、WordPress镜像，下载量已超过千万次。这些数字还在不断地增长！ 在国内一线城市，几乎每一两周就有一场关于Docker的讨论大会，Docker永远不会让你孤独。 在从此以后的未来，以Docker为代表的容器技术已经给云计算乃至整个IT界带来了深远的影响，这是一次真正的计算机技术革命，来吧，拥抱变化！ 一个软件项目成功与否的标志是看其是否能够带动一个生态系统的发展，以Docker为代表的容器技术显然做到了这一点。容器技术的快速普及促进了围绕容器技术的相关项目日臻丰富和完善，容器本身的功能和易用性也随之增加。反过来，容器技术的迅猛发展也与其强大的生态系统息息相关。 图1-3 容器技术生态系统（不完全统计 从图1-3可以看出，容器技术的生态系统自下而上分别覆盖了IaaS层和PaaS层所涉及的各类问题，包括资源调度、编排、部署、监控、配置管理、存储网络管理、安全、容器化应用支撑平台等。除了基于容器技术解决构建分布式平台无法回避的经典问题，容器技术主要带来了以下几点好处。 持续部署与测试。容器消除了线上线下的环境差异，保证了应用生命周期的环境一致性和标准化。开发人员使用镜像实现标准开发环境的构建，开发完成后通过封装着完整环境和应用的镜像进行迁移，由此，测试和运维人员可以直接部署软件镜像来进行测试和发布，大大简化了持续集成、测试和发布的过程。 跨云平台支持。容器带来的最大好处之一就是其适配性，越来越多的云平台都支持容器，用户再也无需担心受到云平台的捆绑，同时也让应用多平台混合部署成为可能。目前支持容器的IaaS云平台包括但不限于亚马逊云平台（AWS）、Google云平台（GCP）、微软云平台（Azure）、OpenStack等，还包括如Chef、Puppet、Ansible等配置管理工具。 环境标准化和版本控制。基于容器提供的环境一致性和标准化，你可以使用Git等工具对容器镜像进行版本控制，相比基于代码的版本控制来说，你还能够对整个应用运行环境实现版本控制，一旦出现故障可以快速回滚。相比以前的虚拟机镜像，容器压缩和备份速度更快，镜像启动也像启动一个普通进程一样快速。 高资源利用率与隔离。容器没有管理程序的额外开销，与底层共享操作系统，性能更加优良，系统负载更低，在同等条件下可以运行更多的应用实例，可以更充分地利用系统资源。同时，容器拥有不错的资源隔离与限制能力，可以精确地对应用分配CPU、内存等资源，保证了应用间不会相互影响。 容器便携性与镜像。Linux容器虽然早在Linux 2.6版本内核已经存在，但是缺少容器的便携性，难以推广。容器在原有Linux容器的基础上进行大胆革新，为容器设定了一整套标准化的配置方法，将应用及其依赖的运行环境打包成镜像，真正实现了“构建一次，到处运行”的理念，大大提高了容器的便携性。 易于理解且易用。Docker的英文原意是处理集装箱的码头工人，标志是鲸鱼运送一大堆集装箱，集装箱就是容器，生动好记，易于理解。一个开发者可以在15分钟之内入门Docker并进行安装和部署，这是容器使用史上的一次飞跃。因为它的易用性，有更多的人开始关注容器技术，加速了容器标准化的步伐。 应用镜像仓库。Docker官方构建了一个镜像仓库，组织和管理形式类似于GitHub，其上已累积了成千上万的镜像。因为Docker的跨平台适配性，相当于为用户提供了一个非常有用的应用商店，所有人都可以自由地下载微服务组件，这为开发者提供了巨大便利。 进化：从容器到容器云容器为用户打开了一扇通往新世界的大门，真正进入这个容器的世界后，却发现新的生态系统如此庞大。在生产使用中，不论是个人还是企业，都会提出更复杂的需求。这时，我们需要众多跨主机的容器协同工作，需要支持各种类型的工作负载，企业级应用开发更是需要基于容器技术，实现支持多人协作的持续集成、持续交付平台。即使Docker只需一条命令便可启动一个容器，一旦试图将其推广到软件开发和生产环境中，麻烦便层出不穷，容器相关的网络、存储、集群、高可用等就是不得不面对的问题。从容器到容器云的进化应运而生。 什么是容器云？ 容器云以容器为资源分割和调度的基本单位，封装整个软件运行时环境，为开发者和系统管理员提供用于构建、发布和运行分布式应用的平台。当容器云专注于资源共享与隔离、容器编排与部署时，它是一种IaaS；当容器云渗透到应用支撑与运行时环境时，它是一种PaaS。 容器云并不仅限于Docker，基于rkt容器的CoreOS项目也是容器云。Docker的出现让人们意识到了容器的价值，使得一直以来长期存在但并未被重视的轻量级虚拟化技术得到快速的发展和应用。鉴于Docker的里程碑意义，本书在讨论容器云时，都以分析Docker为支撑技术的容器云为主。 Docker公司本身的技术发展，亦是从一个容器管理工具一步步向容器云发展的历史过程。Docker最初发布时只是一个单机下的容器管理工具，随后Docker公司发布了Compose、Machine、Swarm等编排部署工具，并收购了Socketplane解决集群化后的网络问题。本书提及Docker时，一般指Docker容器核心，并不包含它向容器云迈进的一系列扩展工具，这些工具则将在本书第二部分进行分析。 除了Docker公司之外，业界许多云计算厂商也对基于Docker的容器云做了巨大的投入，以Docker容器为核心的第三方Docker容器云正在迎来春天。第6章将要介绍的Fleet、第7章将要介绍的Flynn和Deis以及第8章的Kubernetes，都是基于Docker技术构建的广为人知的容器云。 从容器到容器云是一种伟大的进化，并依旧在日积月累中不断前行，现在让我们一起进入Docker的世界，感受容器与容器云的魅力。 参考资料 Docker——容器与容器云（第2版）","tags":[]},{"title":"DevOps And AIOps","date":"2018-07-22T08:38:48.627Z","path":"2018/07/22/DevOps-And-AIOps/","text":"先论DevOpsDevOps 是一天实践方法，在保证高质量的前提下缩短系统变更从提交到部署。 DevOps 模式定义DevOps 集文化理念、实践和工具于一身，可以提高组织高速交付应用程序和服务的能力，与使用传统软件开发和基础设施管理流程相比，能够帮助组织更快地发展和改进产品。这种速度使组织能够更好地服务其客户，并在市场上更高效地参与竞争。 DevOps 的工作原理在 DevOps 模式下，开发团队和运营团队都不再是“孤立”的团队。有时，这两个团队会合为一个团队，他们的工程师会在应用程序的整个生命周期（从开发测试到部署再到运营）内相互协作，开发出一系列不限于单一职能的技能。 在一些 DevOps 模式下，质保和安全团队也会与开发和运营团队更紧密地结合在一起，贯穿应用程序的整个生命周期。当安全是所有 DevOps 团队成员的工作重心时，这有时被称为“DevSecOps”。这些团队会使用实践经验自动执行之前手动操作的缓慢流程。他们使用能够帮助其快速可靠地操作和发展应用程序的技术体系和工具。这些工具还可以帮助工程师独立完成通常需要其他团队协作才能完成的任务（例如部署代码或预置基础设施），从而进一步提高团队的工作速度。 DevOps 的优势速度高速运转，让您可以更快速地针对客户进行创新、更好地适应不断变化的市场，同时更有效地推动业务成果。DevOps 模式能够帮助您的开发人员和运营团队实现这些目标。例如，微服务和持续交付能够让团队充分掌控服务，然后更快速地发布更新。 快速交付提高发布的频率和速度，以便您能够更快速地进行创新并完善产品。您发布新功能和修复错误的速度越快，就越能快速地响应客户需求并建立竞争优势。持续集成和持续交付是自动执行软件发布流程（从构建到部署）的两项实践经验。 可靠性确保应用程序更新和基础设施变更的品质，以便您能够在保持最终用户优质体验的同时，更加快速可靠地进行交付。使用持续集成和持续交付等实践经验来测试每次变更是否安全以及能够正常运行。进行监控和记录实践经验能够帮助您实时了解当前的性能。 规模大规模运行和管理您的基础设施及开发流程。自动化和一致性可在降低风险的同时，帮助您有效管理复杂或不断变化的系统。例如，基础设施即代码能够帮助您以一种可重复且更有效的方式来管理部署、测试和生产环境。 增强合作建立一个适应 DevOps 文化模式的更高效的团队，强调主人翁精神和责任感。开发人员和运营团队密切合作，共同承担诸多责任，并将各自的工作流程相互融合。这有助于减少效率低下的工作，同时节约大家的时间（例如，缩短开发人员和运营团队之间的交接时间，编写将运行环境考虑在内的代码）。 安全性在快速运转的同时保持控制力和合规性。利用自动实施的合规性策略、精细控制和配置管理技术，您可以在不牺牲安全性的前提下采用 DevOps 模式。例如，利用基础设施即代码和策略即代码，您可以大规模定义并追踪合规性。 DevOps 实践经验以下列举了一些 DevOps 最佳实践： 持续集成 持续交付 微服务 基础设施即代码 监控和日志记录 沟通与合作 关键字:云平台，微服务，容器化，CI/CD，SRE，敏捷开发…. 关于DevOps实践的一个非常好的视频http://www.infoq.com/cn/presentations/experience-of-google-devops-landing-practice 参考资料","tags":[]},{"title":"深夜的口琴声","date":"2018-07-22T08:08:24.355Z","path":"2018/07/22/深夜的口琴声/","text":"深夜的口琴声","tags":[]},{"title":"关于云主机系统的初始化","date":"2018-07-02T07:21:19.688Z","path":"2018/07/02/关于云主机系统的初始化/","text":"在许多IaaS平台中新购买的机器资源并不是开箱即用，一般需根业务进行定制，又或者你作为一个强迫症患者想让自己的机器变得更加完美，所以在购买完机器后进行初始化流程是很有必要滴。 机器初始化完成可以打包为云平台的镜像，方便后续的集成。 云供应商：Ucloud系统版本号：Ubuntu 16.04 LTS。关于设置机器的数据盘视情况而操作禁用系统自动更新： sed -i '/Unattended-Upgrade/s/1/0/' /etc/apt/apt.conf.d/20auto-upgrades 设置别名： cat","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"许三观卖血记","date":"2018-06-25T14:32:47.833Z","path":"2018/06/25/许三观卖血记/","text":"《许三观卖血记》是余华1995年创作的一部长篇小说。小说讲述了一个名叫许三观的屁民通过卖血而活着的故事。 许三观是一名在城里丝厂的送蚕工，他从四叔的口中得知“没卖过血的人身子骨都不结实，娶不到女人”的规矩。 跟着根龙与啊方，许三观开始了他的卖血之路。他得知卖血前需要喝大量的水 阿方在下面说：“我们早晨什么都没吃，就喝了几碗水，现在又喝了几碗，到了城里还得再喝几碗，一直要喝到肚子又胀又疼，牙根一阵阵发酸……这水喝多了，人身上的血也会跟着多起来，水会浸到血里去的……” “这水浸到了血里，人身上的血是不是就淡了？” “淡是淡了，可身上的血就多了。” 卖血后便到胜利的饭店 然后，他们来到了那家名叫胜利的饭店，饭店是在一座石桥的桥堍，它的屋顶还没有桥高，屋顶上长满了杂草，在屋檐前伸出来像是脸上的眉毛。饭店看上去没有门，门和窗连成一片，中间只是隔了两根木条，许三观他们就是从旁边应该是窗户的地方走了进去，他们坐在了靠窗的桌子前，窗外是那条穿过城镇的小河，河面上漂过去了几片青菜叶子。 阿方对着跑堂的喊道：“一盘炒猪肝，二两黄酒，黄酒给我温一温。” 根龙也喊道：“一盘炒猪肝，二两黄酒，我的黄酒也温一温。” 许三观看着他们喊叫，觉得他们喊叫时手拍着桌子很神气，他也学他们的样子，手拍着桌子喊道： “一盘炒猪肝，二两黄酒，黄酒……温一温。” 黄血活血，猪肝补血这对许三观来说兴许是一剂良药。 每卖一次血可以赚35元，许三观感到颇为高兴便说： “四叔，我想找个女人去结婚了，四叔，这两天我一直在想这卖血挣来的三十五块钱怎么花？我想给爷爷几块钱，可是爷爷太老了，爷爷都老得不会花钱了。我还想给你几块钱，我爹的几个兄弟里，你对我最好，四叔，可我又舍不得给你，这是我卖血挣来的钱，不是我卖力气挣来的钱，我舍不得给。四叔，我刚才丫起来的时候突然想到娶女人了。四叔，我卖血挣来的钱总算是花对地方了……四叔，我吃了一肚子的瓜、怎么像是喝了一斤酒似的，四叔，我的脸，我的脖子我的脚底，我的手掌，都在一阵阵地发烧。 后面许三观便娶了城内出名的”油条西施“许玉兰为妻子。 文中有趣的摘抄(读到这里着实让人感到无比的滑稽:))： 第二天下午，许三观把许玉兰带到了那家胜利饭店，坐在靠窗的桌子旁，也就是他和阿方、根龙吃炒猪肝喝黄酒的桌前，他像阿方和根龙那样神气地拍着桌子，对跑堂的叫道： “来一客小笼包子。” 他请许玉兰吃了一客小笼包子，吃完小笼包子后，许玉兰说她还能吃一碗馄饨，许三观又拍起了桌子： “来一碗馄饨。” 许玉兰这天下午笑眯眯地还吃了话梅，吃了话梅以后说嘴咸，又吃了糖果，吃了糖果以后说口渴， 许三观就给她买了半个西瓜，她和许三观站在了那座木桥上，她笑眯眯地把半个西瓜全吃了下去，然后她笑眯眯地打起了嗝。当她的身体一抖一抖地打嗝时，许三观数着手指开始算一算这个下午花了多少钱。 “小笼包子两角四分，馄饨九分钱，话梅一角，糖果买了两次共计两角三分，西瓜半个有三斤四两花了一角七分，总共是八角三分钱……你什么时候嫁给我？” “啊呀，”许玉兰惊叫起来，“你凭什么要我嫁给你” 许三观说：“你花掉了我八角三分钱。” “是你自己请我吃的，”许玉兰打着嗝说，“我还以为是白吃的呢，你又没说吃了你的东西就要嫁给你……” “嫁给我有什么不好？”许三观说，“你嫁给我以后，我会疼你护着你，我会经常让你一个下午就吃掉八角三分钱。” “啊呀，”许玉兰叫了起来，“要是我嫁给了你，我就不会这么吃了，我嫁给你以后就是吃自己的了，我舍不得……早知道是这样，我就不吃了。” “你也不用后悔，”许三观安慰她，“你嫁给我就行了。” “我不能嫁给你，我有男朋友了，我爹也不会答应的，我爹喜欢何小勇……” 于是，许三观就提着一瓶黄酒一条大前门香烟，来到许玉兰家，他在许玉兰父亲的对面坐了下来，将黄酒和香烟推了过去，然后滔滔不绝地说了起来： “你知道我爹吧？我爹就是那个有名的许木匠，他老人家活着的时候专给城里大户人家做活，他做出来的桌于谁也比不上，伸手往桌面上一摸，就跟摸在绸缎上一样光滑。你知道我妈吧？我妈就是金花，你知道金花吗？就是那个城西的美人，从前别人都叫她城西美人，我爹死了以后她嫁给了一个国民党连长，后来跟着那个连长跑了。我爹只有我这么一个儿子，我妈和那个连长是不是生了我就不知道了。我叫许三观，我两个伯伯的儿子比我大，我在许家排行老三，所以我叫许三观，我是丝厂的工人，我比何小勇大两岁，比他早三年参加工作，我的钱肯定比他多，他想娶许玉兰还得筹几年钱，我结婚的钱都准备好了，我是万事皆备只欠东风了。” 许三观又说：“你只有许玉兰一个女儿，许玉兰要是嫁给了何小勇，你家就断后了，生出来的孩子不管是男是女，都得姓何。要是嫁给了我，我本来就姓许，生下来的孩子也不管是男是女，都姓许，你们许家后面的香火也就接上了，说起来我娶了许玉兰，其实我就和倒插门的女婿一样。许玉兰的父亲听到最后那几句话，嘿嘿笑了起来，他看着许三观，手指在桌上笃笃地敲着，他说：”这一瓶酒，这一条香烟，我收下了，你说得对，我女儿要是嫁给了何小勇，我许家就断后了。我女儿要是嫁给了你，我们两个许家的香火都接上了。” 不久，许三观便有了三个儿子，取名分别为：许一乐、许二乐、许三乐 许玉兰在五年时间里生下了三个儿子，许三观给他三个儿子取名为许一乐，许二乐，许三乐。 有一天，在许三乐一岁三个月的时候，许玉兰揪住许三观的耳朵问他： “我生孩子时，你是不是在外面哈哈大笑？” “我没有哈哈大笑，”许三观说，“我只是嘿嘿地笑，没有笑出声音。” “啊呀，”许玉兰叫道，“所以你让三个儿子叫一乐，二乐，三乐，我在产房里疼了一次，二次，三次；你在外面乐了一次，二次，三次，是不是？” 后续的故事，作者余华用诙谐幽默的方式来描写一个小人物许三观的家庭生活，阐释了这个社会的荒谬。 卖血是为了娶亲，是为了治重病的儿子，是为了郑重款待宾客，是为了生存，但最终还是为了爱和可笑的尊严。 再谈历史背景：从余华的《活着》、《许三观卖血记》故事的历史背景都是中国近代史。 1、1958年的人民公社、大跃进和大炼钢铁。2、接下来一两年的天灾人祸导致的全国性饥荒。3、文化大革命，知青下山。….. “你知道吗？为什么工厂停工了、商店关门了、学校不上课、你也用不着去炸抽条了？为什么有人被吊在了树上、有人被关进了牛棚、有人被活活打死？你知道吗？为什么毛主席一说话，就有人把他的话编成了歌，就有人把他的话刷到了墙上、刷到了地上、刷到了汽车上和轮船上、床单上和枕巾上、杯子上和锅上，连厕所的墙上和痰盂上都有。毛主席的名字为什么会这么长予你听着：伟大的领袖伟大的导师伟大的统帅伟大的舵手毛主席万岁万岁万万岁。一共有三十个字，这些都要一口气念下来，中间不能换气。你知道这是为什么？因为文化大革命来了。” 这样的一番阐释从许三观口中说出来，既符合人物的身份和层次，又启发读者自己的思考。许三观的逻辑和认识水平并不一定就是正确的，但那是真正身处其中的人物会说出的话，这样的话让读者信服的同时也给读者自己想象和思考的空间：文化大革命不只是发生在中国的那一场灾难，而是整个人类都会面临的一种变态与暴力的可能，因而许三观们面对的不仅仅是他个人的命运，而是有可能发生在每个人身上的命运。 韩国电影《许三观》正是根据余华的小说《许三观卖血记》而改编 再附上网友同样以诙谐幽默手法改编的《许三观卖码记》","tags":[{"name":"Books","slug":"Books","permalink":"https://yo42.github.io/tags/Books/"}]},{"title":"JumpServer 运维安全审计系统","date":"2018-06-23T10:31:43.211Z","path":"2018/06/23/JumpServer-运维安全审计系统/","text":"目前，使用的是SSHConfig+ansible的模式进行管控各开发&amp;运维人员的公钥，以及云主机的登录。 现阶段属于纯跳版机模式，并没有审计功能，存在安全隐患，对于人员离职权限的回收不够彻底，公钥的分发不够方便，开发&amp;运维人员都混用一个账号进行登录，没有审计功能，粗放式权限管理，外放了root密码。 综合上述缺点，需要一个审计系统。 目前业界比较良心的开源审计系统http://www.jumpserver.org/ 其实现在许多云供应商都在推自己的审计系统产品，有些也是基于jumpserver进行二次开发的。 堡垒机不仅集中管理和分配全部账号，更重要的是能对运维/开发人员的运维操作进行严格审计和权限控制，确保运维的安全合规和运维/开发人员的最小化权限管理。 从实际应用来看，堡垒机主要管控企业的服务器资源。 1、JumpServer的安装:略(参考官方文档),后续可能会进行Docker化的定制(coco-ssh server,jumpserver,luna web terminal插件)。 梳理权限与规则:JumpServer用户管理: 梳理各项目组的开发与运维人员的列表，以项目名创建组，通过手工的方式进行开发人员与运维人员的编制。 用户是授权和登陆的主体，将来为每个员工建立一个账户，用来登录跳板机，将资产授权给该用户，查看用户登陆记录命令历史等。创建用户，例如:以开发者张三的名称创建用户，后续张三将以dev的身份进行资产的登录如 web, sa, dba,dev,oc(ssh web@some-host) 管理用户是服务器的root，或拥有 NOPASSWD: ALL sudo权限的用户，Jumpserver使用该用户来 推送系统用户、获取资产硬件信息等，大概会使用root进行管理，采用密码管理的方式。 系统用户是服务器上建立的一些真实存在的可以ssh登陆的用户,如 dev,sa, dba等，系统用户可使用jumpserver推送到服务器上，也可以利用自己公司的工具进行推送，授权时将用户、资产、系统用户关联起来，则表明用户有权限登陆该资产的这个系统用户 如：用户 小明 以 dev 系统用户登录 172.16.1.1资产,简单理解就是 将某个资产上的某个系统用户映射给这个用户登录。 角色为用户的人员禁止授权su权限,不提供root密码就没有su权限，需要时再申请，sudo su。 创建系统用户如Dev和oc时需保存密钥。 JumpServer资产管理: 区分不同云供应商，每个节点对应每个云供应商、项目，节点下再区分正式服、辅助支撑服。 测试环境的部署: 选择一个云供应商和地区进行部署一台JumpServer服务器，以及一些测试服。 购买新资产进行自动添加还需参考JumpServer提供的API实现自动化。 测试使用REST API 进行资产的自动添加资产以及权限管理 jumpserver集成sdk 获取token curl -XPOST -d \"username=admin;password=xxxxx\" http://192.168.9.250/api/users/v1/token/ 查询用户可见资产 curl -X GET --header 'Content-Type: application/json' --header 'Accept: application/json' -H 'Authorization: Bearer b5abc7c5b5cf4be780370d607181c5fa' 'http://192.168.9.250/api/assets/v1/assets/' 示例: 1、用户登录 curl -XPOST -d 'username=admin;password=admin' http://192.168.188.40/api/users/v1/token/ {\"Token\":\"14a9f25397444abb8666c9fa00c294c9\",\"Keyword\":\"Bearer\"} 2、获取所有的用户 curl -H 'Authorization: Bearer 14a9f25397444abb8666c9fa00c294c9' -XGET http://192.168.188.84:8080/api/users/v1/users/ 3、创建用户组 curl -X POST --header 'Content-Type: application/json' --header 'Accept: application/json' -H 'Authorization: Bearer 14a9f25397444abb8666c9fa00c294c9' -d '{\"id\":\"1162e7a4-90f6-4e5e-b7cf-14581adb7621\",\"is_discard\": false,\"discard_time\": \"\",\"name\":\"epointgroup\",\"comment\":\"\",\"created_by\": \"administrator\",\"date_created\":\"2018-06-06 06:03:03 +0000\",\"discard_time\":\"2018-06-11 06:03:03 +0000\"}' 'http://192.168.188.84/api/users/v1/groups/' 4、创建用户并设置用户组 curl -X POST --header 'Content-Type: application/json' --header 'Accept: application/json' -H 'Authorization: Bearer 14a9f25397444abb8666c9fa00c294c9' 'http://192.168.188.84/api/users/v1/users/' -d '{\"id\": \"13f1432d-9a8c-4d83-aad9-c3177e3a387d\",\"groups\": [\"1162e7a4-90f6-4e5e-b7cf-14581adb7620\"],\"last_login\": \"2018-05-19 06:03:03 +0000\",\"is_active\": true,\"date_joined\": \"2018-06-06 06:03:03 +0000\",\"username\": \"ijarvis\",\"name\": \"ijarvis\",\"email\": \"ijarvis@sina.com\",\"role\": \"Admin\",\"avatar\": null,\"wechat\": \"\",\"phone\": \"\",\"otp_level\": 0,\"comment\": \"\",\"is_first_login\": true,\"date_expired\": \"2088-05-19 06:03:03 +0000\",\"created_by\": \"2018-05-19 06:03:03 +0000\"}' 5、 获取所有资产列表 curl -X GET --header 'Content-Type: application/json' --header 'Accept: application/json' -H 'Authorization: Bearer 14a9f25397444abb8666c9fa00c294c9' 'http://192.168.188.84/api/assets/v1/assets/' 6、创建用户资产 curl -X POST --header 'Content-Type: application/json' --header 'Accept: application/json' -H 'Authorization: Bearer 14a9f25397444abb8666c9fa00c294c9' -d '{\"id\": \"9f7a3cd5-b3be-4a4f-a7f6-0cbcb8529e71\",\"ip\": \"192.168.186.66\",\"hostname\": \"Hadoop_186_66\",\"port\": 22,\"platform\": \"Linux\",\"is_active\": true,\"public_ip\": null,\"created_by\": null,\"comment\": \"\",\"admin_user\": \"06fe163e-aacd-48ce-a7a7-a15800587b99\", \"nodes\": [\"7c0b0eda-8555-42e4-9205-992957c46d56\"]}' 'http://192.168.188.84/api/assets/v1/assets/' 逻辑图: 参考资料 https://www.zhihu.com/question/21036511 http://www.jumpserver.org/ https://github.com/jumpserver/jumpserver","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"[转载]程序员技术练级攻略","date":"2018-06-21T04:58:41.000Z","path":"2018/06/21/转载-程序员技术练级攻略/","text":"转载自左耳朵耗子的博文,感觉不错就记录下吧前言你是否觉得自己从学校毕业的时候只做过小玩具一样的程序？走入职场后哪怕没有什么经验也可以把以下这些课外练习走一遍（朋友的抱怨：学校课程总是从理论出发，作业项目都看不出有什么实际作用，不如从工作中的需求出发） 建议： 不要乱买书，不要乱追新技术新名词，基础的东西经过很长时间积累而且还会在未来至少10年通用。回顾一下历史，看看历史上时间线上技术的发展，你才能明白明天会是什么样。一定要动手，例子不管多么简单，建议至少自己手敲一遍看看是否理解了里头的细枝末节。一定要学会思考，思考为什么要这样，而不是那样。还要举一反三地思考。注：你也许会很奇怪为什么下面的东西很偏Unix/Linux，这是因为我觉得Windows下的编程可能会在未来很没有前途，原因如下： 现在的用户界面几乎被两个东西主宰了，1）Web，2）移动设备iOS或Android。Windows的图形界面不吃香了。越来越多的企业在用成本低性能高的Linux和各种开源技术来构架其系统，Windows的成本太高了。微软的东西变得太快了，很不持久，他们完全是在玩弄程序员。详情参见《Windows编程革命史》所以，我个人认为以后的趋势是前端是Web+移动，后端是Linux+开源。开发这边基本上没Windows什么事。 启蒙入门1、 学习一门脚本语言，例如Python/Ruby 可以让你摆脱对底层语言的恐惧感，脚本语言可以让你很快开发出能用得上的小程序。实践项目: 处理文本文件，或者csv (关键词 python csv, python open, python sys) 读一个本地文件，逐行处理（例如 word count，或者处理log）遍历本地文件系统 (sys, os, path)，例如写一个程序统计一个目录下所有文件大小并按各种条件排序并保存结果跟数据库打交道 (python sqlite)，写一个小脚本统计数据库里条目数量学会用各种print之类简单粗暴的方式进行调试学会用Google (phrase, domain, use reader to follow tech blogs)为什么要学脚本语言，因为他们实在是太方便了，很多时候我们需要写点小工具或是脚本来帮我们解决问题，你就会发现正规的编程语言太难用了。 2、 用熟一种程序员的编辑器(不是IDE) 和一些基本工具 Vim / Emacs / Notepad++，学会如何配置代码补全，外观，外部命令等。Source Insight (或 ctag)使用这些东西不是为了Cool，而是这些编辑器在查看、修改代码/配置文章/日志会更快更有效率。 3、 熟悉Unix/Linux Shell和常见的命令行 如果你用windows，至少学会用虚拟机里的linux， vmware player是免费的，装个Ubuntu吧一定要少用少用图形界面。学会使用man来查看帮助文件系统结构和基本操作 ls/chmod/chown/rm/find/ln/cat/mount/mkdir/tar/gzip …学会使用一些文本操作命令 sed/awk/grep/tail/less/more …学会使用一些管理命令 ps/top/lsof/netstat/kill/tcpdump/iptables/dd…了解/etc目录下的各种配置文章，学会查看/var/log下的系统日志，以及/proc下的系统运行信息了解正则表达式，使用正则表达式来查找文件。对于程序员来说Unix/Linux比Windows简单多了。（参看我四年前CSDN的博文《其实Unix很简单》）学会使用Unix/Linux你会发现图形界面在某些时候实在是太难用了，相当地相当地降低工作效率。 4、 学习Web基础（HTML/CSS/JS) + 服务器端技术 (LAMP) 未来必然是Web的世界，学习WEB基础的最佳网站是W3School。 学习HTML基本语法学习CSS如何选中HTML元素并应用一些基本样式（关键词：box model）学会用 Firefox + Firebug 或 chrome 查看你觉得很炫的网页结构，并动态修改。学习使用Javascript操纵HTML元件。理解DOM和动态网页（http://oreilly.com/catalog/9780596527402) 网上有免费的章节，足够用了。或参看 DOM 。学会用 Firefox + Firebug 或 chrome 调试Javascript代码（设置断点，查看变量，性能，控制台等）在一台机器上配置Apache 或 Nginx学习PHP，让后台PHP和前台HTML进行数据交互，对服务器相应浏览器请求形成初步认识。实现一个表单提交和反显的功能。把PHP连接本地或者远程数据库 MySQL（MySQL 和 SQL现学现用够了）跟完一个名校的网络编程课程（例如：http://www.stanford.edu/~ouster/cgi-bin/cs142-fall10/index.php ) 不要觉得需要多于一学期时间，大学生是全职一学期选3-5门课，你业余时间一定可以跟上学习一个javascript库（例如jQuery 或 ExtJS）+ Ajax (异步读入一个服务器端图片或者数据库内容）+JSON数据格式。HTTP: The Definitive Guide 读完前4章你就明白你每天上网用浏览器的时候发生的事情了(proxy, gateway, browsers)做个小网站（例如：一个小的留言板，支持用户登录，Cookie/Session，增、删、改、查，上传图片附件，分页显示）买个域名，租个空间，做个自己的网站。进阶加深1、 C语言和操作系统调用 重新学C语言，理解指针和内存模型，用C语言实现一下各种经典的算法和数据结构。推荐《计算机程序设计艺术》、《算法导论》和《编程珠玑》。学习（麻省理工免费课程）计算机科学和编程导论学习（麻省理工免费课程）C语言内存管理学习Unix/Linux系统调用（Unix高级环境编程），，了解系统层面的东西。用这些系统知识操作一下文件系统，用户（实现一个可以拷贝目录树的小程序）用fork/wait/waitpid写一个多进程的程序，用pthread写一个多线程带同步或互斥的程序。多进程多进程购票的程序。用signal/kill/raise/alarm/pause/sigprocmask实现一个多进程间的信号量通信的程序。学会使用gcc和gdb来编程和调试程序（参看我的《用gdb调试程序》）学会使用makefile来编译程序。（参看我的《跟我一起写makefile》）IPC和Socket的东西可以放到高级中来实践。学习Windows SDK编程（Windows 程序设计 ，MFC程序设计）写一个窗口，了解WinMain/WinProcedure，以及Windows的消息机制。写一些程序来操作Windows SDK中的资源文件或是各种图形控件，以及作图的编程。学习如何使用MSDN查看相关的SDK函数，各种WM_消息以及一些例程。这本书中有很多例程，在实践中请不要照抄，试着自己写一个自己的例程。不用太多于精通这些东西，因为GUI正在被Web取代，主要是了解一下Windows 图形界面的编程。@virushuo 说：“ 我觉得GUI确实不那么热门了，但充分理解GUI工作原理是很重要的。包括移动设备开发，如果没有基础知识仍然很吃力。或者说移动设备开发必须理解GUI工作，或者在win那边学，或者在mac/iOS上学”。2、学习Java Java 的学习主要是看经典的Core Java 《Java 核心技术编程》和《Java编程思想》（有两卷，我仅链了第一卷，足够了，因为Java的图形界面了解就可以了）学习JDK，学会查阅Java API Doc http://download.oracle.com/javase/6/docs/api/了解一下Java这种虚拟机语言和C和Python语言在编译和执行上的差别。从C、Java、Python思考一下“跨平台”这种技术。学会使用IDE Eclipse，使用Eclipse 编译，调试和开发Java程序。建一个Tomcat的网站，尝试一下JSP/Servlet/JDBC/MySQL的Web开发。把前面所说的那个PHP的小项目试着用JSP和Servlet实现一下。3、Web的安全与架构学习HTML5，网上有很多很多教程，以前酷壳也介绍过很多，我在这里就不罗列了。学习Web开发的安全问题（参考新浪微博被攻击的这个事，以及Ruby的这篇文章）学习HTTP Server的rewrite机制，Nginx的反向代理机制，fast-cgi（如：PHP-FPM）学习Web的静态页面缓存技术。学习Web的异步工作流处理，数据Cache，数据分区，负载均衡，水平扩展的构架。实践任务：使用HTML5的canvas 制作一些Web动画。尝试在前面开发过的那个Web应用中进行SQL注入，JS注入，以及XSS攻击。把前面开发过的那个Web应用改成构造在Nginx + PHP-FPM + 静态页面缓存的网站4、学习关系型数据库 你可以安装MSSQLServer或MySQL来学习数据库。学习教科书里数据库设计的那几个范式，1NF，2NF，3NF，……学习数据库的存过，触发器，视图，建索引，游标等。学习SQL语句，明白表连接的各种概念（参看《SQL Join的图示》）学习如何优化数据库查询（参看《MySQL的优化》）实践任务：设计一个论坛的数据库，至少满足3NF，使用SQL语句查询本周，本月的最新文章，评论最多的文章，最活跃用户。5、一些开发工具 学会使用SVN或Git来管理程序版本。学会使用JUnit来对Java进行单元测试。学习C语言和Java语言的coding standard 或 coding guideline。（我N年前写过一篇关C语言非常简单的文章——《编程修养》，这样的东西你可以上网查一下，一大堆）。推荐阅读《代码大全》《重构》《代码整洁之道》高级深入1、C++ / Java 和面向对象 我个人以为学好C++，Java也就是举手之劳。但是C++的学习曲线相当的陡。不过，我觉得C++是最需要学好的语言了。参看两篇趣文“C++学习信心图” 和“21天学好C++” 学习（麻省理工免费课程）C++面向对象编程读我的 “如何学好C++”中所推荐的那些书至少两遍以上（如果你对C++的理解能够深入到像我所写的《C++虚函数表解析》或是《C++对象内存存局》，或是《C/C++返回内部静态成员的陷阱》那就非常不错了）然后反思为什么C++要干成这样，Java则不是？你一定要学会对比C++和Java的不同。比如，Java中的初始化，垃圾回收，接口，异常，虚函数，等等。实践任务：用C++实现一个BigInt，支持128位的整形的加减乘除的操作。用C++封装一个数据结构的容量，比如hash table。用C++封装并实现一个智能指针（一定要使用模板）。《设计模式》必需一读，两遍以上，思考一下，这23个模式的应用场景。主要是两点：1）钟爱组合而不是继承，2）钟爱接口而不是实现。（也推荐《深入浅出设计模式》）实践任务：使用工厂模式实现一个内存池。使用策略模式制做一个类其可以把文本文件进行左对齐，右对齐和中对齐。使用命令模式实现一个命令行计算器，并支持undo和redo。使用修饰模式实现一个酒店的房间价格订价策略——旺季，服务，VIP、旅行团、等影响价格的因素。学习STL的用法和其设计概念 – 容器，算法，迭代器，函数子。如果可能，请读一下其源码。实践任务：尝试使用面向对象、STL，设计模式、和WindowsSDK图形编程的各种技能做一个贪吃蛇或是俄罗斯方块的游戏。支持不同的级别和难度。做一个文件浏览器，可以浏览目录下的文件，并可以对不同的文件有不同的操作，文本文件可以打开编辑，执行文件则执行之，mp3或avi文件可以播放，图片文件可以展示图片。学习C++的一些类库的设计，如： MFC（看看候捷老师的《深入浅出MFC》） ，Boost, ACE, CPPUnit，STL （STL可能会太难了，但是如果你能了解其中的设计模式和设计那就太好了，如果你能深入到我写的《STL string类的写时拷贝技术》那就非常不错了，ACE需要很强在的系统知识，参见后面的“加强对系统的了解”）Java是真正的面向对象的语言，Java的设计模式多得不能再多，也是用来学习面向对象的设计模式的最佳语言了（参看Java中的设计模式）。推荐阅读《Effective Java》 and 《Java解惑》学习Java的框架，Java的框架也是多，如Spring, Hibernate，Struts 等等，主要是学习Java的设计，如IoC等。Java的技术也是烂多，重点学习J2EE架构以及JMS， RMI, 等消息传递和远程调用的技术。学习使用Java做Web Service （官方教程在这里）实践任务： 尝试在Spring或Hibernate框架下构建一个有网络的Web Service的远程调用程序，并可以在两个Service中通过JMS传递消息。C++和Java都不是能在短时间内能学好的，C++玩是的深，Java玩的是广，我建议两者选一个。我个人的学习经历是： 深究C++（我深究C/C++了十来年了）学习Java的各种设计模式。2、加强系统了解 重要阅读下面的几本书： 《Unix编程艺术》了解Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验。你一定会有一种醍醐灌顶的感觉。《Unix网络编程卷1，套接字》这是一本看完你就明白网络编程的书。重要注意TCP、UDP，以及多路复用的系统调用select/poll/epoll的差别。《TCP/IP详解 卷1:协议》- 这是一本看完后你就可以当网络黑客的书。了解以太网的的运作原理，了解TCP/IP的协议，运作原理以及如何TCP的调优。实践任务：理解什么是阻塞（同步IO），非阻塞（异步IO），多路复用（select, poll, epoll）的IO技术。写一个网络聊天程序，有聊天服务器和多个聊天客户端（服务端用UDP对部分或所有的的聊天客户端进Multicast或Broadcast）。写一个简易的HTTP服务器。《Unix网络编程卷2，进程间通信》信号量，管道，共享内存，消息等各种IPC…… 这些技术好像有点老掉牙了，不过还是值得了解。实践任务：主要实践各种IPC进程序通信的方法。尝试写一个管道程序，父子进程通过管道交换数据。尝试写一个共享内存的程序，两个进程通过共享内存交换一个C的结构体数组。学习《Windows核心编程》一书。把CreateProcess，Windows线程、线程调度、线程同步（Event, 信号量，互斥量）、异步I/O，内存管理，DLL，这几大块搞精通。实践任务：使用CreateProcess启动一个记事本或IE，并监控该程序的运行。把前面写过的那个简易的HTTP服务用线程池实现一下。写一个DLL的钩子程序监控指定窗口的关闭事件，或是记录某个窗口的按键。有了多线程、多进程通信，TCP/IP，套接字，C++和设计模式的基本，你可以研究一下ACE了。使用ACE重写上述的聊天程序和HTTP服务器（带线程池）实践任务：通过以上的所有知识，尝试写一个服务端给客户端传大文件，要求把100M的带宽用到80%以上。（注意，磁盘I/O和网络I/O可能会很有问题，想一想怎么解决，另外，请注意网络传输最大单元MTU）了解BT下载的工作原理，用多进程的方式模拟BT下载的原理。3、系统架构 负载均衡。HASH式的，纯动态式的。（可以到Google学术里搜一些关于负载均衡的文章读读）多层分布式系统 – 客户端服务结点层、计算结点层、数据cache层，数据层。J2EE是经典的多层结构。CDN系统 – 就近访问，内容边缘化。P2P式系统，研究一下BT和电驴的算法。比如：DHT算法。服务器备份，双机备份系统（Live-Standby和Live-Live系统），两台机器如何通过心跳监测对方？集群主结点备份。虚拟化技术，使用这个技术，可以把操作系统当应用程序一下切换或重新配置和部署。学习Thrift，二进制的高性能的通讯中间件，支持数据(对象)序列化和多种类型的RPC服务。学习Hadoop。Hadoop框架中最核心的设计就是：MapReduce和HDFS。MapReduce的思想是由Google的一篇论文所提及而被广为流传的，简单的一句话解释MapReduce就是“任务的分解与结果的汇总”。HDFS是Hadoop分布式文件系统（Hadoop Distributed File System）的缩写，为分布式计算存储提供了底层支持。了解NoSQL数据库（有人说可能是一个过渡炒作的技术），不过因为超大规模以及高并发的纯动态型网站日渐成为主流，而SNS类网站在数据存取过程中有着实时性等刚性需求，这使得目前NoSQL数据库慢慢成了人们所关注的焦点，并大有成为取代关系型数据库而成为未来主流数据存储模式的趋势。当前NoSQL数据库很多，大部分都是开源的，其中比较知名的有：MemcacheDB、Redis、Tokyo Cabinet(升级版为Kyoto Cabinet)、Flare、MongoDB、CouchDB、Cassandra、Voldemort等。写了那么多，回顾一下，觉得自己相当的有成就感。希望大家不要吓着，我自己这十来年也在不断地学习，今天我也在学习中，人生本来就是一个不断学习和练级的过程。不过，一定有漏的，也有不对的，还希望大家补充和更正。（我会根据大家的反馈随时更新此文）欢迎大家通过我的微博（@左耳朵耗子）和twitter（@haoel）和我交流。 —– 更新 2011/07/19 —– 1）有朋友奇怪为什么我在这篇文章开头说了web+移动，却没有在后面提到iOS/Android的前端开发。因为我心里有一种感觉，移动设备上的UI最终也会被Javascript取代。大家可以用iPhone或Android看看google+，你就会明白了。 2）有朋友说我这里的东西太多了，不能为了学习而学习，我非常同意。我在文章的前面也说了要思考。另外，千万不要以为我说的这些东西是一些新的技术，这份攻略里95%以上的全是基础。而且都是久经考验的基础技术。即是可以让你一通百通的技术，也是可以让你找到一份不错工作的技术。 3）有朋友说学这些东西学完都40了，还不如想想怎么去挣钱。我想告诉大家，一是我今年还没有40岁，二是学无止境啊，三是我不觉得挣钱有多难，难的是怎么让你值那么多钱？无论是打工还是创业，是什么东西让你自己的价值，让你公司的价值更值钱？别的地方我不敢说，对于互联网或IT公司来说，技术实力绝对是其中之一。 4）有朋友说技术都是工具，不应该如此痴迷这句话没有错，有时候我们需要更多的是抬起头来看看技术以外的事情，或者是说我们在作技术的时候不去思考为什么会有这个技术，为什么不是别的，问题不在于技术，问题在于我们死读书，读死书，成了技术的书呆子。 5） 对于NoSQL，最近比较火，但我对其有点保守，所以，我只是说了解就可以。对于Hadoop，我觉得其在分布式系统上有巨大的潜力，所以需要学习。 对于关系型数据库，的确是很重要的东西，这点是我的疏忽，在原文里补充。 （全文完） 参考资料 https://coolshell.cn/articles/4990.html","tags":[]},{"title":"[转载]每个程序员都该知道的事","date":"2018-06-21T04:50:30.000Z","path":"2018/06/21/转载-每个程序员都该知道的事/","text":"在每个月月中，我会推荐一些有价值的内容，供你参考。这个月，我将为你推荐五篇阅读文章，这五篇文章我觉得都是比较不错的经验总结，是我们每一个技术人员都需要知道的东西。它们分别是： Stack Overflow 上开出来的一个经典书书单；美国某大学教授给计算机专业学生的一些建议，其中有很多的资源；LinkedIn 的高效代码复查实践，很不错的方法，值得你一读；一份关于程序语言和 bug 数相关的有趣的报告，可以让你对各种语言有所了解 每个程序员都应该要读的书在 Stack Overflow 上有一个问题 What is the single most influential book every programmer should read，网址为： https://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read 虽然这个问题被关闭了，但是这是一个非常热门的问题。排在第一个的人给了一大串书的列表，看上去着实吓人，不过都是一些相当经典相当有影响力的书，在这里我重罗列一些我觉得你必需要看的。 《代码大全》虽然这本书有点过时了，而且厚到可以垫显示器，但是这是一本绝对经典的书。《程序员修练之道》这本书也是相当的经典，我觉得就是你的指路明灯。《计算机的构造和解释》经典中的经典，必需读的书。《算法导论》美国的本科生教材，这本书应该也是中国计算机学生的教材。《设计模式》这本书是面向对象设计的经典书。《重构》代码坏味道和相应的代码的最佳实践。《人月神话》这本书可能也有点过时了。但还是经典书。《代码整洁之道》细节之处的效率，完美和简单。《Effective C++》/《More Effective C++》C++ 中两本经典得不能再经典的书。也许你觉得 C++ 复杂，但这两本书中带来对代码稳定性的探索方式让人非常受益，因为这种思维方式同样可以用在其它地方。以至于各种模仿者，比如《Effective Java》也是一本经典书。《Unix 编程艺术》、《Unix 高级环境编程》也是相关的经典。还有好多，我就不在这里一一列了。你可以看看其它的答案，我发现自己虽然读过好多书，但也有好些书没有读过，这个问答对我也很有用。 每个搞计算机专业的学生应有的知识What every computer science major should know，每个搞计算机专业的学生应有的知识，网址为：http://matt.might.net/articles/what-cs-majors-should-know/ 本文作者马修·迈特（Matthew Might）是美国犹他大学计算机学院的副教授，2007 年于佐治亚理工学院取得博士学位。计算机专业的课程繁多，而且随着时代的变化，科目的课程组成也在不断变化。如果不经过思考，直接套用现有的计算机专业课程列表，则有可能忽略一些将来可能变得重要的知识点。为此，马修力求从四个方面来总结，得出这篇文章的内容。 要获得一份好工作，学生需要知道什么？为了一辈子都有工作干，学生需要知道什么？学生需要知道什么，才能考进研究生院？学生需要知道什么，才能对社会有益？这篇文章不仅仅对刚毕业的学生有用，对有工作经验的人同样有用，这里我把这篇文章的内容摘要如下。 首先，对于我们每个人来说，作品集（Portfolio）会比简历（Resume）更有参考意义。所以，在自己的简历中应该放上自己的一些项目经历，或是一些开源软件的贡献，或是你完成的软件的网址等。最好有一个自己的个人网址，上面有一些你做的事，自己的技能，经历，以及你的一些文章和思考会比简历更好。 其次，计算机专业工作者也要学会与人交流的技巧，包括如何写演示文稿，以及面对质疑时如何与人辩论的能力。 最后，他就各个方面展开计算机专业人士所需要的硬技能：工程类数学、Unix 哲学和实践、系统管理、程序设计语言、离散数学、数据结构与算法、计算机体系结构、操作系统、网络、安全、密码学、软件测试、用户体验、可视化、并行计算、软件工程、形式化方法、图形学、机器人、人工智能、机器学习、数据库，等等。详读本文可以了解计算机专业知识的全貌。 这篇文章的第三部分简直就是一个知识资源向导库，给出了各个技能的方向和关键知识点，你可以跟随着这篇文章里的相关链接学到很多东西。 LinkedIn 高效的代码复查技巧LinkedIn’s Tips for Highly Effective Code Review，LinkedIn 的高效代码复查技巧，网址为：https://thenewstack.io/linkedin-code-review/ 对于 Code Review，我有一篇文章 《从 Code Review 谈如何做技术》，讲述了为什么 Code Review 是一件很重要事情。今天推荐的这篇文章是 LinkedIn 公司的相关实践。 这篇文章介绍了 LinkedIn 公司内部实践的 Code Review 形式。具体来说，LinkedIn 的代码复查有以下几个特点。 从 2011 年开始，强制要求在团队成员之间做代码复查。Code Review 带来的反馈意见让团队成员能够迅速提升自己的技能水平，这解决了 LinkedIn 各个团队近年来因迅速扩张带来的技能不足的问题。通过建立公司范围的 Code Review 工具，这就可以做跨团队的 Code Review。既有利于消除 bug，提升质量，也有利于大家对代码的学习和技能的传播。Code Review 的经验作为员工晋升的参考因素之一。Code Review 的一个难点是，Reviewer 可能不了解某个修改的背景和目的。所以 LinkedIn 要求代码签入版本管理系统前，就对其做清晰的说明，以便复查者了解其目的，促进 Review 的进行。我认为，这个方法实在在太赞了。因为，我看到很多时候，Reviewer 都会说不了解对方代码的背景或是代码量比较大而无法做 Code Review，然而，却没有找到相应的方法解决这个问题。 LinkedIn 对提交代码写说明文档这个方法是一个非常不错的方法，因为代码提交人写文档的过程其实也是重头梳理的过程。我的个人经验是，写文档的时候通常会发现自己把事儿干复杂了，应该把代码再简化一下，于是就会回头去改代码。是的，写文档就是在写代码。 有些 Code Review 工具所允许给出的反馈只是代码怎样修改以变得更好，但长此以往会让人觉得复查提出的意见都表示原先的代码不够好。为了提高员工积极性，LinkedIn 的代码复查工具允许提出“这段代码很棒”之类的话语，以便让好代码的作者得到鼓励。我认为，这个方法也很赞，正面鼓励的价值也不可小看。为 Code Review 的结果写出有目的性的注释。比如“消除重复代码”，“增加了测试覆盖率”，等等。长此以往也让团队的价值观得以明确。Code Review 中，不但要 Review 提交者的代码，还要 Reivew 提交者做过的测试。除了一些单元测试，还有一些可能是手动的测试。提交者最好列出所有测试过的案例。这样可以让 Reviewer 可以做出更多的测试建议，从而可以提高质量。对 Code Review 有明确的期望，不过分关注细枝末节，也不要炫技，而是对要 Review 的代码有一个明确的目标。编程语言和代码质量的研究报告A Large-Scale Study of Programming Languages and Code Quality in GitHub，编程语言和代码质量的研究报告，网址为： https://cacm.acm.org/magazines/2017/10/221326-a-large-scale-study-of-programming-languages-and-code-quality-in-github/ 这是一项有趣的研究。有四个人从 Github 上分析了 728 个项目，6300 万行代码，近 3 万个提交人，150 万个 commits，以及 17 种编程语言（如下图所示），然后，他们想找到编程语言对软件质量的影响。 然后，他们还对编程语言做了一个分类，想找到不同类型的编程语言的 bug 问题。如下图所示： 以及，他们还对这众多的开源软件做了个聚类，如下图： 对 bug 的类型也做了一个聚类，如下图： 其中分析的方法我不多说了。我们来看一下相关的结果。 首先，他们得出来的第一个结果是，从查看 bug fix 的 commits 的个数情况来看，C、C++、Objective-C、PHP 和 Python 中有很多很多的 commits 都是和 bug fix 相关的，而 Clojure、Haskell、Ruby、Scala 在 bug fix 的 commits 的数明显要少很多。 下图是各个语言出 bug 的情况。如果你看到是正数，说明高于平均水平，如果你看到是负数，则是低于平均水平。 第二个结论是，函数式编程语言的 bug 明显比大多数其它语言的要好很多。有隐式类型转换的语言明显产生的 bug 数要比强类型的语言要少很多。函数式的静态类型的语言要比函数式的动态类型语言的程序出 bug 的可能性要小很多。 第三，研究者想搞清是否 bug 数会和软件的领域相关。比如，业务型的，中间件型、框架、lib，或是数据库。研究表明，并没有什么相关性。下面这个图是各个语言在不同领域的 bug 率。 第四，研究人员想搞清楚 bug 的类型是否会和语言有关系。的确如此，bug 的类型和语言是强相关性的。下图是各个语言在不同的 bug 类型的情况。如果你看到的是正数，说明高于平均水平，如果你看到的是负数，则是低于平均水平。 也许，这份报告可以在你评估语言时有一定的借鉴作用。 电子书：《C++ 软件性能优化》 Optimizing Software in C++ - Agner Fog - PDF，C++ 软件性能优化，http://agner.org/optimize/optimizing_cpp.pdf 这本书是所有 C++ 程序员都应该要读的一本书。这本书从事无巨细地从语言层面，编译器层面，内存访问层面，多线程层面，CPU 层面……讲述了如果对软件性能的调优。实在是一本经典的电子书。 Agner Fog 还写了其它几本和性能调优相关的书（你可以到这个网址下载：http://www.agner.org/optimize/ ） Optimizing subroutines in assembly language: An optimization guide for x86 platformsThe microarchitecture of Intel, AMD and VIA CPUs: An optimization guide for assembly programmers and compiler makersInstruction tables: Lists of instruction latencies, throughputs and micro-operation breakdowns for Intel, AMD and VIA CPUsCalling conventions for different C++ compilers and operating systems我今天推荐的内容比较干，需要慢慢吸收体会，最好能借鉴到实践中用用，相信会有更多的感悟和收获。你还对哪些方面的内容感兴趣，欢迎留言给我。我后面收集推荐内容的时候，会有意识地关注整理。 参考资料 http://www.infoq.com/cn/articles/programer-knowledge?utm_source=infoq&amp;utm_medium=popular_widget&amp;utm_campaign=popular_content_list&amp;utm_content=homepage","tags":[]},{"title":"JVM性能调优监控工具","date":"2018-06-20T09:03:09.800Z","path":"2018/06/20/JVM性能调优监控工具/","text":"以下是一些JVM性能调优监控工具1jps、jstack、jmap、jhat、jstat、hprof.... 对于java程序,有时可能会碰到以下问题 OutOfMemoryError，内存不足 内存泄露 线程死锁 锁争用（Lock Contention） Java进程消耗CPU过高 …. 通过一些监控工具去对java程序进行调优以及监控,在发生问题时使用工具去进行定位问题为后续的排障、修复问题提到了很好的辅助作用。","tags":[]},{"title":"人间失格","date":"2018-06-11T08:20:56.293Z","path":"2018/06/11/人间失格/","text":"《人间失格》是日本作家太宰治的长篇小说。人间失格意为丧失了做人的资格。 由序、第一手札、第二手札、第三手札、后记共五个部分构成，其中序和后记以作者口吻叙说，三个手札则以主人公叶藏的口吻叙述。 小说的前半部分以大庭叶藏这位主人公的口吻,讲述了他奇特而悲催的人生经历叶藏自小仿佛便看穿了人世间的种种阴暗，遂以一种诡异的笑容面对他的人生，他时常在饰演一个小丑般的角色去对待人世间的事与物，病态且嬉戏的童年，至青年酗酒、沉溺女色、参加“非法”左翼团体，到中年与娼妓一起殉情(女死男生)，种种的经历让他饱受了人世间的情苦，这从一开始也埋下了伏笔，预示着叶藏最终走向毁灭之路。 《人间失格》可以说是太宰治本人的自传了，主角大庭叶藏就是他为原型的,在文中的”GoodBye” 章节写道”一位文坛大师辞世，告别仪式结束时，忽然下起了雨….”(太宰治留在人世间的一个彩蛋？) 21岁的太宰治和银座咖啡馆女侍投海自杀未遂…39岁与崇拜他的女读者山崎富荣跳玉川上水自杀… 以下是《人间失格的》的一些摘抄: 早晨，我睁眼醒来翻身下床，又变成了原来那个浅薄无知、善于伪装的滑稽角色。胆小鬼连幸福都会惧怕，碰到棉花都会受伤，有时也会被幸福所伤。趁着还没有受伤，我想就这样赶快分道扬镳。我又放出了惯用的逗笑烟幕弹。 而那些相互欺瞒却又过着单纯、明了生活的人，抑或相互欺瞒却又胸有成竹地面对生活的人，着实令人费解。人类终究未能让我明白其中真谛。若我能明了，或许就不必如此地畏惧人类，也不必竭力讨好众人，更不至于与人类的生活对立，夜夜遭受地狱般的苦难。 附上一张太宰治很”丧”的照片 太宰治君","tags":[{"name":"Books","slug":"Books","permalink":"https://yo42.github.io/tags/Books/"}]},{"title":"爱你就像爱生命","date":"2018-06-11T08:20:33.587Z","path":"2018/06/11/爱你就像爱生命/","text":"爱你就像爱生命,爱你要了我的命。(后半句我瞎编的，科科..)《爱你就像爱生命》是一本书信集,是王小波和李银河情书信集。(文人说起情话来真的是无法抗拒呀….) 关于王小波: 王小波在白话文叙述方面有很深的造诣，写作小说的同时他也创作过一些杂文与随笔文章。并且很多人都是由于精彩而睿智的杂文作品接触和认识到王小波。王小波的东西方生活与求学经历，使他成为一个富有自由人文精神和独立知识分子品格的写作者。 在他的作品中，贯穿着其特有的黑色幽默，这些也表明了王小波对于生命和生活的态度。王小波的一系列小说都以自己所经历过的生活作为蓝本，如下放到云南的知识青年，在某个医院或高等专科学校从事技术工种的工程师等等，作品的年代背景也与王小波的生活与成长时期相重叠，在这些作品中，他刻画了这样一种现实：“我看到一个无智的世界，但是智慧在混沌中存在；我看到一个无性的世界，但是性爱在混沌中存在；我看到一个无趣的世界，但是有趣在混沌中存在”。 从杂文作品中看，哲学家伯特兰·罗素对他思想影响很深，他推崇和提倡科学与理性，并且认为人的生活应该追求未知，他反对进行思想禁锢，主张人们思维应该保持多样化，使生活变得有意思有趣，去热爱智慧。 他的作品在他身后盛行于世，影响了众多青年，特别是二十世纪九十年代的大学生，他们至今还会常常引用王小波作品中的文字，来表明自己的激昂和犀利。其曾编写过电影剧本《东宫西宫》，并由此获得了阿根廷国际电影节最佳编剧。 下方是些摘抄: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849我现在已经养成了一种习惯，就是每三二天要找你说几句不想对别人说的话。当然还有更多的话没有说出口来，但是只要我把它带到了你面前，我走开的时候自己就满意了，这些念头就不会做再折磨我了。我现在不坏了，我有了良心。我的良心就是你。我的灵魂里有很多地方玩世不恭 ，对人傲慢无礼，但是它有一个核心，这个核心害怕黑暗，柔弱得像绵羊一样。只有顶平等的有爱才能使他得到安慰。你对我是属于这个核心的。我是爱你的，看见就爱上了。我爱你爱到不自私的地步。我会不爱你吗？不爱你？不会。爱你就像爱生命。我真不知怎么才能和你亲近起来，你好像是一个可望而不可及的目标，我琢磨不透，追也追不上，就坐下哭了起来。你要是喜欢别人我会哭，但是还是喜欢你。我把我整个的灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗， 一千八百种坏毛病。它真讨厌，只有一点好，爱你。你知道我在世界上最珍视的东西吗？那就是我自己的性格，也就是我自己思想的自由。在这个问题上我都放下刀枪了–也就是说，听任你的改造和影响。你为什么还要计较我一两次我无心的过失和对你的伤害呢？我对好多人怀有最深的感情，尤其是对你。我很想为别人做好事，尤其是对你。你是非常可爱的人，真应该遇到最好的人，我也真希望我就是。假如你愿意，你就恋爱吧，爱我。不一定要你爱我，但是我爱你，这是我的命运。你要是回来我就高兴了，马上我就要放个震动北京城的大炮仗。男孩子们都喜欢女孩子，可是谁也没有我喜欢你这么厉害。我现在就很高兴，因为你又好又喜欢我，希望我高兴，有什么事情也喜欢说给我听。比方说你对于我，主要是因为你可爱。我从来没有在男人或者女人中发现这么可爱的人。但愿我和你，是一支唱不完的歌。谁也管不住我爱你，真的，谁管谁就真傻，我和你谁也管不住呢。你别怕，真的你谁也不要怕，最亲爱的好银河，要爱就爱个够吧，世界上没有比爱情更好的东西了。你真好，我真爱你。可惜我不是诗人，说不出再动人一点的话了。有时候你难过了，这时候我更爱你。只要你不拒绝我就拥抱你，我会告诉你这是因为什么。就是我不知是为了什么。不，我对你什么要求也没有，什么要求也没有，只要你来看我。我也不知道为什么。你愿意要什么，就给什么。你知道吗？要，对我来说，就是给啊。你要什么就是给我什么。不管我本人多么平庸，我总觉得对你的爱很美。静下来想你，觉得一切都没好得不可思议。以前我不知道爱情这么美好，爱到深处这么美好。真不想让任何人来管我们。谁也管不着，和谁都无关。告诉你，一想到你，我这张丑脸上就泛起微笑。我只希望你和我好，互不猜忌，也互不称誉，安如平日，你和我说话就像对自己说话一样，我和你说话也像对自己说话一样。你说，和我好么？","tags":[{"name":"Books","slug":"Books","permalink":"https://yo42.github.io/tags/Books/"}]},{"title":"恶意","date":"2018-06-09T08:14:20.748Z","path":"2018/06/09/恶意/","text":"东野圭吾《恶意》花了大约三小时拜读了东野圭吾的《恶意》相较之前的《白夜行》,此次更令我倒吸一口凉气,依然是十分具有东野圭吾特色的推理、悬疑的小说。小说绝大部分以第一人称 “手记” 的特点更令人感觉真实,以及更具有代入感。 小说故事讲述了一个畅销作家在出国前一晚被杀害的故事,以及后续一系列让人们匪夷所思的情节。 以第一人称的方式写手记的凶手被逮捕了,但当警方盘问其杀人动机时却令人疑惑不解,而隐藏在故事背后令人不寒而栗的真相又会是什么呢？ 在故事的最后 真相之章来自加贺警官的阐述经过层层深挖,发现凶案背后的真相竟如此令人难以接受。 东野圭吾前期巧妙的铺垫,一开始就蒙蔽了读者的双眼,到故事的最后真相慢慢浮出水面,情节反转的巧妙性就不言而喻了。 人性中的恶意：贪婪、嫉妒…真是十分可怕的负面能量，让人寒毛凛凛。 我发现东野圭吾书的一些特点,善与恶的对立面双方都是智商极高的人无论是《嫌疑人X的献身》里的数学天才石神与神探伽利略汤川亦或是《恶意》中的野野口与加贺。 东野圭吾的书不仅仅在于情节故事的铺垫地精彩,剧情反转地极为巧妙,而且在每个悬疑故事背后的真相把人性的丑恶面刻画地淋漓尽致,以及所映射出来的社会问题令人感到窒息。","tags":[{"name":"Books","slug":"Books","permalink":"https://yo42.github.io/tags/Books/"}]},{"title":"Material.io","date":"2018-05-28T06:17:56.827Z","path":"2018/05/28/Material-io/","text":"关于Material.io&nbsp; &nbsp; &nbsp; Material.io 是谷歌的一套设计交互系统,是一种视觉语言，将优秀设计的经典原则与科技创新相结合。 &nbsp; &nbsp; &nbsp; 起初我并不知道有这东西,纯粹的觉得它好看,Google的原生安卓系统也是与此有关系,所以博客的主题就选择了这款indigo。 &nbsp; &nbsp; &nbsp; 我们都需要有善于发现美的眼睛,你说是么?","tags":[]},{"title":"关于Docker Build 目录与GIT库共存的一些技巧","date":"2018-05-27T02:48:18.000Z","path":"2018/05/27/关于Docker-Build-目录与GIT库共存的一些技巧/","text":"如下 echo .git/ > .dockerignore 这样操作后，能加快docker build的速度","tags":[]},{"title":"Hello World! Why Blogs?","date":"2018-05-13T06:24:27.852Z","path":"2018/05/13/hello-world/","text":"很久之前便有此念头，但迟迟却不见行动。 由于自己时常会有些天马行空的想法，以此为记。 博客大概会记录些关于学习上的东西&amp;技术上的文档，以及些杂谈吧。","tags":[]},{"title":"《白日梦想家》","date":"2018-05-13T06:24:27.852Z","path":"2018/05/13/Movie/","text":"《白日梦想家》献给对生活乏味的人们 经典台词To see the world, things dangerous to come to,To see behind walls, draw closer,To find each other, and To feel.That is the purpose of life 开拓视野, 冲破艰险.看见世界, 身临其境.贴近彼此, 感受生活. “Sometimes I don’t.If I like a moment, for me, personallyI don’t like to have the distraction of the camera.I just want to stay in it.” Sean O'Connell More info: This Movie","tags":[]}]
[{"title":"DevOps最全术语汇总","date":"2018-09-24T06:46:15.204Z","path":"2018/09/24/DevOps最全术语汇总/","text":"AA/B Testing A/B测试 使用A/B测试的技术将新功能或某项功能的不同变体推向不同组别的用户，这些功能可通过比较指标和用户行为进行评估。 Acceptance Testing 验收测试 通常对整个系统进行高级测试，以确定新功能和现有功能的整体质量是否足以让系统投入生产。 Agent 代理程序 代理程序是安装在特定物理服务器上的程序，用于在该服务器上处理不同进程的执行。 Agile 敏捷 是DevOps的前身；敏捷是一种软件开发方法，更广泛来说，是一种业务方法。敏捷强调短期迭代的规划和开发周期以提供更好的控制以及可预测性，并支持随着项目的发展而不断变化的需求。 ARA (Application Release Automation) ARA （应用程序发布自动化）/) 可以在目标环境中自动安装和正确配置给定应用程序版本并随时可用的工具、脚本或产品。 BBehavior-Driven Development (BDD) 行为驱动开发（BDD）/) 一种开发方法，强调软件应该根据应用程序的期望行为并以业务管理人员可读的语法来指定。 Black Box Testing 黑盒测试 一种测试或质量保证实践，它假设不知道被测系统内部的工作原理，因此尝试验证外部而不是内部行为或状态。 Build Agent Build Agent 一种用于持续集成的代理程序，可以本地或远程安装，跟持续集成服务器有关。它发送和接收跟处理软件构建有关的消息。 Build Artifact Repository 构建工件存储库 用于组织具有元数据构造的工件，并允许自动发布和使用这些工件的工具。 Build Automation 构建自动化 允许将源代码自动编译为可发布的二进制代码的工具或框架。通常包括代码级的单元测试，以确保代码的各个部分按预期运行。 CCanary Release 灰度发布（金丝雀发布） 一种上线策略，在该策略中，把新的应用程序版本发布到生产服务器的一小部分上，并严格监控以确定其是否按预期运行。如果一切看起来稳定，那么新版本将推广到整个生产环境。 Configuration Drift 配置漂移 由于手工的特殊更改（如热修复）没有引入到系统模版中而引起软件和硬件配置与系统模版版本漂移或不一致。 Configuration Management 配置管理 用于建立和维护系统一致的设置和功能属性的术语。它包括用于IT基础设施自动化等系统管理任务的工具。 Continuous Delivery 持续交付（CD) 持续交付是一套流程和实践，从根本上清除软件生产过程中的浪费，能更快地交付高质量的功能，并在业务和用户之间建立快速有效的反馈环。 Continuous Integration (CI) 持续集成（CI）/) 持续集成（CI）是一种开发实践，它要求开发人员每天多次把代码集成到共享存储库中。然后通过自动构建验证每次签入，使得团队能尽早发现问题。 DDark Launch 灰度上线 一种上线策略，其中实现新功能的代码被发布到生产环境的子集，但是不可见或只是部分激活。然而，该代码是在生产环境中运行，用户并不知晓。 Delivery Pipeline 交付管道 一系列为新应用程序版本实施软件交付过程的编排的、自动化的任务。该管道中的每个步骤旨在提高新版本的置信度，使其能够做出合格/不合格的决策。交付管道可以被看作是组织发布流程的优化结果。 DevOps DevOps DevOps（开发和运维）是一个软件开发短语，用于描述开发和IT运维之间的敏捷关系。DevOps的目标是改善在软件开发周期中不同角色之间的沟通、协作和流程，以改善和加速软件交付。 DevOps Intelligence DevOps智能 提供公司所需的洞察力，以更高效、更低风险和更好结果的方式交付软件， FFunctional Testing 功能测试 进行端到端系统的测试以验证（新）功能。使用可执行规范，通过运行针对应用程序的规范来进行功能测试。 IInfrastructure as a Service (IaaS) 基础/)设施/)即服务（IaaS）/) 云托管的虚拟机器通常根据“按需付费”收费。用户对机器有完全的控制，但是需要自己安装和配置所需的中间件和应用程序。 Infrastructure as Code 基础设施即代码（IaC) 一种系统配置管理技术，其中以完全自动化的形式指定机器、网络设备、操作系统、中间件等。规范或“蓝图”被认为是代码，由供应工具执行，保存在版本控制中，通常遵循用于应用程序代码开发的相同实践。 LLean 精益 “精益制造”或“精益生产”是一种方式或方法，旨在通过专注于保护价值来减少生产过程中的浪费。它很大程度上来源于丰田公司在汽车制造业中开发的实践，精益概念已经作为敏捷方法的部分被应用于软件开发。价值流程图（VSM）试图直观地识别有价值和有浪费的流程步骤，是个关键的精益工具。 MMicroservices 微服务 微服务是一种软件架构设计模式，其中复杂的应用程序由独立的小型进程构成，这些进程使用与语言无关的API进行通信。这些服务规模小，高度分离，专注于完成一个小任务。 NNon-functional Requirements (NFRs) 非功能性需求（NFRs）/) 系统质量的规范，诸如易用性，设计清晰度，延迟，速度，处理大量用户的能力等，描述了如何轻松或高效地使用某个功能，而不只是它是否存在。这些特性可以使用持续交付反馈环来解决和改善。 NoOps NoOps 在一个公司中，应用程序运行的系统管理要么是完全由外部一方（如PaaS 供应商）来处理，要么就是全自动化的。使用NoOps旨在尽量减少或不使用内部运维能力和员工。 OOrchestration Pipeline 编排管道 在适当的时间调用形成持续交付管道的不同自动化任务的工具或产品。它们通常也记录每个任务的状态和输出，并通过管道可视化特征流。 PPlatform as a Service (PaaS) 平台即服务（PaaS）/) 云托管的应用程序运行时间通常根据“按需支付”的原则计费。用户提供应用程序代码和有限的配置设置，中间件、数据库等都是提供的运行时的一部分。 Product Owner 产品负责人 开发团队中负责定义、确定优先级和维护未完成功能及其他工作的人或角色。产品负责人在敏捷软件开发方法中很常见，通常代表业务或客户组织。相比在更传统的软件开发过程中的同行，产品负责人需要在敏捷开发流程中扮演更积极的日常角色。 Provisioning 服务开通 为用户（在持续交付的场景下，通常是开发或测试团队）准备新系统的过程。该系统通常根据需要进行虚拟化和实例化。配置机器以安装操作系统、中间件等操作是由自动化的系统配置管理工具来处理，这些自动化工具还验证所需要的配置是否得到维护。 RRegression Testing 回归测试 对端到端系统的测试，以验证应用程序的更改没有对现有功能产生负面影响。 Release Coordination 发布协调 定义和执行从代码签入到生效的新功能（或功能集）所需的所有操作。在持续交付环境中，这在很大程度上是完全自动化的，并由管道执行。 Release Management 发布管理 发布管理是管理软件发布从开发阶段到实际软件发布阶段的流程。 Release Orchestration 发布编排 发布编排是使用诸如XL发布等工具管理软件发布（从开发阶段到实际软件发布阶段）。 TTest-Driven Development (TDD) 测试驱动开发（TDD）/) 一种开发实践，在该实践过程中，用于验证代码片段表现的小测试在编写代码前就已经写就。这些测试最初是失败的，但开发人员的目标是接着添加代码使这些测试成功。 UUnit Testing 单元测试 代码级（即无需安装完整的端到端系统以运行）测试以验证各个代码段的行为。TDD广泛使用单元测试以描述和验证预期的行为。 VValue Stream Mapping 价值流程图 一种过程可视化和改善技术，大量用于精益生产和工程方法中。价值流图用于识别必要的处理步骤，而不是逐渐清除流程中的“浪费”。 Virtualization 虚拟化 一种系统管理方法，用户和应用程序不需要使用物理机器，而是在实际的“真实”硬件上运行的模拟系统。这样的“虚拟机”能够在几秒钟内自动生成、启动、停运、克隆和丢弃，给操作带来了巨大的便利。 WWaterfall 瀑布式（开发） 一种基于分阶段项目方法的软件开发方法，从“需求收集”到“开发”，再到“发布”。如果项目中前面的阶段有延迟，整个过程中靠后的阶段（通常和测试及QA相关）会因此在时间上受到挤压。 White Box Testing 白盒测试 一种测试或质量保证实践，它通过系统运行时检查系统（内部）表现和状态以验证系统内部功能是否正确。 参考资料","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"持续集成CI/CD","date":"2018-09-24T06:08:38.669Z","path":"2018/09/24/持续集成CI-CD/","text":"持续集成（Continuous Integration）指的是，频繁地（一天多次）将代码集成到主干。 在保证质量的前提，通过持续集成使产品进行快速的迭代。 它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。 互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称CI）。 持续交付（Continuous delivery）**在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（production-like environments）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。 持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。 持续部署则是在持续交付的基础上，把部署到生产环境的过程自动化。 持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。 持续部署的前提是能自动化完成测试、构建、部署等步骤。 持续集成CI/CD工具:Jenkins、Travis CI、Drone、Wercker、Circle CI等等…. 工具上的话，jenkins使用的较多，插件多、社区文化活跃。 常见组合:jenkins+svn+maven+ant、jenkins+GitLab 持续集成的核心价值在于： 持续集成中的任何一个环节都是自动完成的，无需太多的人工干预，有利于减少重复过程以节省时间、费用和工作量； 持续集成保障了每个时间点上团队成员提交的代码是能成功集成的。换言之，任何时间点都能第一时间发现软件的集成问题，使任意时间发布可部署的软件成为了可能； 持续集成还能利于软件本身的发展趋势，这点在需求不明确或是频繁性变更的情景中尤其重要，持续集成的质量能帮助团队进行有效决策，同时建立团队对开发产品的信心。 为啥需要持续集成CI/CD？敏捷开发、快速交付是互联网行业的标准。一个产品、一个项目团队，通过高效的敏捷开发，以及快速交付产品的流程使其能从软件行业中脱颖而出。说白了就是为了应对快速变化需求的一个解决方案或者手段。 解放运维劳动力，提高效率，减少因发布、部署、交付更新带来的失误。 随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile） 在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。 持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。 持续集成CI/CD的好处快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。 防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。 持续集成的大致流程: 编码 -&gt; 构建 -&gt; 集成 -&gt; 测试 -&gt; 交付 -&gt; 部署 持续集成的原则业界普遍认同的持续集成的原则包括： 需要版本控制软件保障团队成员提交的代码不会导致集成失败。常用的版本控制软件有 git、svn 等； 开发人员必须及时向版本控制库中提交代码，也必须经常性地从版本控制库中更新代码到本地； 需要有专门的集成服务器来执行集成构建。根据项目的具体实际，集成构建可以被软件的修改来直接触发，也可以定时启动，如每半个小时构建一次； 必须保证构建的成功。如果构建失败，修复构建过程中的错误是优先级最高的工作。一旦修复，需要手动启动一次构建。 持续集成系统的组成由此可见，一个完整的构建系统必须包括： 一个自动构建过程，包括自动编译、分发、部署和测试等。 一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库。 一个持续集成服务器。 在实施CI/CD对整个团队文化的影响CICD是一个流程上的实践，我们把代码开发、到代码部署、到最后的交付，进行持续地迭代和交付，在这个过程中对原来的团队产生的影响是这样的：开发不再只关注他在开发这部分的实现，他需要保证从代码开发实现、到单测、到测试、到构建部署，到最后的分发发布，这样整个流程的覆盖。按照我的理解，CICD对整个团队文化的影响是，每个人对产品研发的整个流程都要全部参与进去，不再是只局限在自己的角色上。比如我是一个开发，我只做实现，我不再关注部署和测试；或者我是一个测试，我不关注开发实现，不关注部署，我只关注执行；或者我是一个运维，我对前面的所有流程都不了解，我只执行最后的运维步骤，而CICD就是把整个团队有效地集成在一起，通过一个流程持续地迭代发布验证，这样的话，整个团队就能更高效地展开合作。 多分支、多版本实施CI/CD的建议我们目前的确也遇到了多分支并行的情况，也就是说我们需要对不同的业务场景做不同的版本管理。在这种情况下，我们依然可以做CI的实施，但是要经过专门的设计，在每个分支所运行的软件，它的版本管理需要做统一的管理，比如需要规划每个分支的依赖是什么样的，要把整个路径都管理起来。如果没有这样的管理，从构建到部署到测试都是混乱的。在版本管理的基础上，我们还要把代码和测试有效地集成起来，也就是说，不光是代码到测试，是代码到配置、到测试、到部署，都要有效地集成起来。一份代码在这个分支上，它对应的配置在哪里，是什么版本，在这个分支上测试的版本在哪里，都需要管理起来；在这个分支上，代码部署的版本依赖也需要统一的管理。如果我们没有做好这些基础设施，是没有办法做CICD实施的。当我们把这些整理清楚之后，再针对每个分支做整体的实施，通过版本管理去理清楚我们实施的部署构建，到底依赖圈是什么样的，这样就可以做一个正确的实施。 参考资料","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"关于游戏客户端资源热更方式&流程","date":"2018-09-16T06:41:19.561Z","path":"2018/09/16/关于游戏客户端资源热更方式-流程/","text":"应用场景:客户端人员上传更新资源至内网FTP，运维人员操作将客户端资源外放至外网CDN源站。 实现技术方案:源站架设Nginx，通过GIT远程仓库模式进行资源的更新。 改进优化的方向:目前，还是通过手动外放资源的方式进行操作，可以优化为开放HTTP Web API接口实现调用GIT命令，进行资源更新的流程。 逻辑图: 架设部署gitolite克隆管理库修改 ./git2-gitolite/conf/gitolite.conf 配置客户端更新库，并提交即可完成创建操作。12repo cilugame/h5-client RW = @oc_users 创建本地库12cd /home/nucleus/client/data/h5git init ./ 忽略无关配置123456cat&lt;&lt;EOF &gt; .gitignore/*!/release!/release/*!/.gitignoreEOF 上传客户端资源提交更新12git add .git ci -minit 关联远程仓库12git remote add origin git@git2.cilugame.com:cilugame/h5-client.gitgit push -u origin master 登录CDN源站1cd /home/nucleus-h5/global/client/html 克隆1git clone git@git2.cilugame.com:cilugame/h5-client.git ./h5/ 安全加固12chmod 700 ./h5/.git/chmod 600 ./h5/.gitignore","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"关于Gitolite & SSH-Config联动","date":"2018-09-16T03:58:25.689Z","path":"2018/09/16/关于Gitolite-SSH-Config联动/","text":"Gitolite是一款Perl语言开发的Git服务管理工具，通过公钥对用户进行认证，并能够通过配置文件对写操作进行基于分支和路径的精细授权。仓库地址 SSH-Config:OpenSSH SSH Client config files;SSH config是SSH客户端的一个参数配置方案，可以将一些关于SSH命令的参数放到配置文件中去，执行ssh命令的时候从文件中读取，简化命令行的操作。 应用场景:开发团队，个人客户端本地通过GIT团队协作模式，实时更新服务器信息。通过配置个人ssh-config(～/.ssh/config)，结合ZSH 补全，可以实现方便、快捷的登录服务器。 效果图如下: 服务端部署gitolite:steps to installFirst, prepare the ssh key: login to “git” on the server make sure ~/.ssh/authorized_keys is empty or non-existent make sure your ssh public key from your workstation has been copied as $HOME/YourName.pub Next, install gitolite by running these commands: 123git clone https://github.com/sitaramc/gitolitemkdir -p $HOME/bingitolite/install -to $HOME/bin Finally, setup gitolite with yourself as the administrator: 1gitolite setup -pk YourName.pub If the last command doesn’t run perhaps “bin” is not in your “PATH”. You can either add it, or just run: 1$HOME/bin/gitolite setup -pk YourName.pub If you get any other errors please refer to the online documentation whose URL was given at the top of this file. 个人本地克隆管理库，实现维护git仓库1git clone git@host:gitolite-admin 新增仓库、以及日常修改权限配置文件1conf/gitolite.conf 新增个人公钥1在key/目录下新增个人公钥 Example：123456789@ops_users = mike jake@dev_users = tom jerryrepo cilu-h5 RW = @ops_users RW = get_host xxx R = tom R = jerry 新增仓库只需新增一个repo配置项 按需使用仓库: 1git clone git@git2.cilugame.com:cilu-h5.git ~/ssh-config/cilu-h5/ 合并本地.ssh/config脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/bin/bash# vim:set et ts=2 sw=2:#set -xcurrent_dir=$(dirname $0)cd $&#123;current_dir&#125; &amp;&amp; export current_dirold_ssh=~/.ssh/confignew_ssh=~/.ssh/config.newbak_dir=~/.ssh/backupbak_ssh=\"$&#123;bak_dir&#125;/$(date +'%F_%H%M%S')\"hostname=$(hostname)if [ ! -f $&#123;old_ssh&#125; ] ;then touch $&#123;old_ssh&#125; chmod 0644 $&#123;old_ssh&#125;fi[ -d ~/.ssh/ControlPath ] || mkdir -pv ~/.ssh/ControlPath# headercat&lt;&lt;\\EOF &gt; $&#123;new_ssh&#125;Host github.com Port 22Host cnc.cilugame.com Port 11932Host git2.cilugame.com ProxyCommand ssh -q h5@jump.cilugame.com socat - TCP:%h:%pHost * Port 932 SendEnv LANG LC_* SendEnv GIT_* ForwardAgent yes ServerAliveInterval 10 XAuthLocation /opt/X11/bin/xauth UseRoaming no ControlPersist 1h ControlMaster auto ControlPath ~/.ssh/ControlPath/%r@%h:%p Compression yesEOF# openssh 在7.2版本新增了AddKeysToAgent参数并废弃了AskPassGUI参数if ssh -V 2&gt;&amp;1 | grep -q \"OpenSSH_7.[2-9]\";then echo \" AddKeysToAgent yes\" &gt;&gt; $&#123;new_ssh&#125;fi# mergefor file in ../*/[0-9]*do file_name=$(basename $file) dir_name=$(dirname $file) dir_name=$(basename $dir_name) src_file=\"~/ssh-config/$&#123;dir_name&#125;/$&#123;file_name&#125;\" #echo \"#========== $src_file\" &gt;&amp;2 echo \"#========== $src_file ==========#\" cat $file echodone &gt;&gt; $&#123;new_ssh&#125;# compare and backupsystem=$(uname)if [ \"x$system\" == \"xDarwin\" ] ;then old_md5=$(md5 $old_ssh | awk '&#123;print $4&#125;') new_md5=$(md5 $new_ssh | awk '&#123;print $4&#125;')else old_md5=$(md5sum $old_ssh | awk '&#123;print $1&#125;') new_md5=$(md5sum $new_ssh | awk '&#123;print $1&#125;')fi#echo \"merge to ~/.ssh/config\" &gt;&amp;2if [ \"x$&#123;old_md5&#125;\" = \"x$&#123;new_md5&#125;\" ] ;then #echo \"Already up-to-date.\" &gt;&amp;2 rm -f $new_sshelse #echo \"Updating...\" &gt;&amp;2 [ -d \"$bak_dir\" ] || mkdir \"$bak_dir\" cp $old_ssh $bak_ssh mv $new_ssh $old_sshfichmod 0644 $&#123;old_ssh&#125;# 注释ControlPersistif [ \"$hostname\" == 'oc-dev-s73' ];then sed -i 's/ControlPersist 1h/#ControlPersist 1h/g' $&#123;old_ssh&#125;fi 配置GIT钩子，实现自动触发，更新配置文件1234567891011121314cd ~/ssh-config/for dir in *do if [ -d $dir ] ;then pushd $dir &gt; /dev/null [ -d \"./.git/hooks\" ] || continue echo '#!/bin/sh' &gt; .git/hooks/post-merge echo '[ -x ./merge.sh ] &amp;&amp; ./merge.sh' &gt;&gt; .git/hooks/post-merge chmod +x .git/hooks/post-merge popd &gt; /dev/null fidone 后续有更新时（成功后会自动调用勾子进行合并操作） 12cd ~/ssh-config/cilu-h5/git pull 通过使用Gitolite可以大大提高团队的协助效率，有时如果是需要提供第三方技术支持，也可以使用Gitolite进行一些简单的配置文件更新、及交付。","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"Hitchhiker's Guide to Python-学习资料&社区资讯","date":"2018-09-15T10:21:59.298Z","path":"2018/09/15/Hitchhiker-s-Guide-to-Python-学习资料-社区资讯/","text":"The Python Tutorial这个是官方教程。它包含了所有的基础，并提供了一个关于语言和标准库的教程。推荐给那些需要一份关于这门语言的快速开始指南的人们。 The Python Tutorial Python for Beginnersthepythonguru.com 是一个专注于新手程序员的教程网站。它涵盖了许多深度的 Python 概念。它也会教你一些像 lambda 表达式，正则表达式等 Python 的高级结构。 最后，它以『如何使用 Python 访问 MySQL 数据库』这篇教程结束。 Python for beginners 学习 Python 交互式数据科学如果你热衷于在线交互式环境来学习 Python 数据科学， this free python tutorial by DataCamp 是一个比较好的开始。如果你已经是一位对机器学习有提前了解和兴趣，并使用scikit-learn的核心开发人员，查看 course on Supervised Learning with scikit-learn 。 Python 数据科学 学习交互式 Python 教程Learnpython.org 是一个简单自由获取 Python 介绍的方式。这个网站采用与流行站点 Try Ruby 相同的方式，站点自带交互式 Python 解释器，这样你可以不用在本地安装 Python 就可以进行学习。 Learn Python 如果你想拥有传统纸质书籍，Python For You and Me 是一个学习这门语言各个方面的极佳资源。 Python for You and Me Learn Python Interactively with DataCamp! 渐进式学习 PythonTechbeamers.com 提供渐进式教程进行 Python 教学。每一个主题的教程都添加了逻辑性的代码片段，并设置了随堂测验。这里是一份关于 Python 面试问题 的章节来帮助求职者。你也可以阅读要点 Python tips 和学习 best coding practices 来撰写高质量的代码。通过下面这个链接，你将获得正确的平台来快速学习 Python 。 Python 从入门到高级 在线 Python 助教在线 Python 助教给你一个可视化的渐进步骤，来说明你的程序是如何运行的。Python 助教帮助人们理解电脑执行程序源代码每一行的方式来克服基础障碍。 在线 Python 助教 用 Python 创作一个属于你自己的电脑游戏这本书，正适合编程零经验的初学者。每一个章节都有一个小游戏的源代码，利用这些例证程序来解释程序设计概念，给读者一个「感性」的程序思想。 Invent Your Own Computer Games with Python Hacking Secret Ciphers with Python这本书教授完全初学者 Python 程序设计和基础密码学。章节提供各式各样的密码源代码，同时提供程序是如何破解它们的方法。 Hacking Secret Ciphers with Python Learn Python the Hard Way这是一份绝佳的 Python 初级程序员指南。包含了从 console 到 web 的「 hello world 」。 Learn Python the Hard Way Python速成这份指南和 Python for Programmers with 3 Hours 一样出名，它为使用其他开发语言的有经验的程序员提供了 Python 速成课。 Python 速成 Dive Into Python 3Dive Into Python 3 对于那些准备转投 Python 3 的程序员是一本好书。如果你正准备从 Python 2 过渡到 3 ，亦或者你已经具有其他语言的开发经验，这本书对你来说非常适合阅读。 Dive Into Python 3 Think Python: How to Think Like a Computer ScientistThink Python 尝试在使用 Python 语言时介绍一个基础的计算机科学的概念。它的目的是创造一本拥有大量练习、通俗易懂并且每个章节的每个片段都致力于解决项目问题的书。 在探索 Python 语言大量特性的可行性时，作者穿插了各式各样的设计模式和最优范例。 这本书也包含了几个案例研究，让读者将书本中讨论的主题应用到实际问题中来更好的学习。案例研究包含关于 GUI 和 Markov Analysis 的作业。 Think Python Python KoansPython Koans 是 Edgecase’s Ruby Koans 的一个端口。它使用测试驱动的方法，参阅 TEST DRIVEN DESIGN SECTION 来提供一个交互式教程来教学基础 Python 概念。通过修复在测试脚本中失败的断言语句，这提供了一个连续的步骤来学习 Python。 对于那些习惯于使用语言并自己搞清楚问题的人来说，将是一个富有欢乐和吸引力的选择。对于那些 Python 和程序设计初学者来说，拥有额外的资源和参考将非常有帮助。 Python Koans 更多关于测试驱动开发的资源请关注： Test Driven Development A Byte of PythonA Byte of Python 是一本学习 Python 的免费入门书籍，非常适合没有编程基础的人学习。 A Byte of Python for Python 2.x A Byte of Python for Python 3.x Learn to Program in Python with Codeacademy这是一个适合绝大多数 Python 初学者的 Codeacademy 课程。这个免费的交互式课程主要教授 Python 编程中基础和部分深入的知识，同时会有测试来检验学者对知识的掌握程度。 这门课程也包含很多功能可以反馈你学习的情况，帮助你更好的学习。 Learn to Program in Python with Codeacademy Code the blocksCode the blocks 为初学者提供免费交互式的 Python 教程。它将 Python 程序设计和 3D 环境下「 搭砖块 」建造建筑相互结合。此教程教授你如何使用 Python 一步步创造一个精细的 3D 建筑，让你学习 Python 的过程充满欢乐。 Code the blocks IntermediateEffective Python这本书包含了 59 种特定方法来提高编写 Pythonic 代码。总长度只有 227 页，列举了大量的晋升中等水平 Python 工程师必备的知识技能。 Effective Python 高级Pro Python这本书适用于中级到高级 Python 程序员，他们希望理解 Python 的工作原理以及怎样提升自己的代码水平。 Pro Python 《Expert Python Programming》《Expert Python Programming》专注于为高级工程师提供 Python 的最佳实践的建议。 它的话题包括装饰器（伴随缓存、代理、上下文管理器、案例研究）、方法解析顺序，使用 super() 和元编程，还有通用的 PEP 8 最佳实践。 它花了多个章节，详细地介绍了如何编写和发布一个扩展包甚至最终发布一个应用，包含了一个使用 zc.buildout 的章节。后面的章节详细讲述了最佳实践，比如编写文档、测试驱动开发、 版本控制、优化和分析。 Expert Python Programming 《A Guide to Python’s Magic Methods》这 是Rafe Kettler 发表博文的集合，解释了 Python 中的 “魔法方法”。魔法方法由双下划线包围 （比如 init），能够使类和对象表现出不同的、魔法的行为。 A Guide to Python’s Magic Methods 注意Rafekettler.com 目前已关闭，您可以直接访问他们的 Github 版本。 在这里您可以找到一个 PDF 版本: A Guide to Python’s Magic Methods (repo on GitHub) 工程师和科学家A Primer on Scientific Programming with Python《A Primer on Scientific Programming with Python》由 Hans Petter Langtangen 编写， 主要涵盖了 Python 在科学领域的使用。在这本书中，例子是从数学和自然科学中选出的。 A Primer on Scientific Programming with Python Numerical Methods in Engineering with Python《Numerical Methods in Engineering with Python》由 Jaan Kiusalaas 编写， 其重点是数值方法以及如何用 Python 来实现他们。 Numerical Methods in Engineering with Python 其他话题Problem Solving with Algorithms and Data Structures《Problem Solving with Algorithms and Data Structures》涵盖了一系列数据结构和算法。 所有概念都用 Python 代码说明，提供了可在浏览器中直接运行的交互式样例。 Problem Solving with Algorithms and Data Structures Programming Collective Intelligence《Programming Collective Intelligence》介绍了大量基础的机器学习和数据挖掘方法。 本书不会侧重于数据挖掘的数学原理，而是更侧重于解释底层的理论算法，以及展示如何使用 Python 来实现这些算法。 Programming Collective Intelligence Transforming Code into Beautiful, Idiomatic Python《Transforming Code into Beautiful, Idiomatic Python》 是由 Raymond Hettinger 制作的视频。 通过它可以学习到如何更好地利用 Python 最好的特性和如何通过代码转换来改进现有代码。 Transforming Code into Beautiful, Idiomatic Python Fullstack Python《Fullstack Python》为使用 Python 进行 Web 开发提供了完整的自上向下的资源。 技术话题范围涵盖从设置 Web 服务器到设计前端、选择数据库、优化/缩放等。 顾名思义，它涵盖了从头开始构建和运行完整的 Web 应用程序所需的所有内容。 Fullstack Python 参考资料Python in a Nutshell《Python in a Nutshell》 由 Alex Martelli编写，涵盖了 Python 跨平台的多数用法， 从它的语法到内建库，再到比如说编写 C 扩展的高级主题。 Python in a Nutshell The Python Language Reference这是 Python 的参考手册，它涵盖了这门语言的语法和核心语义。 The Python Language Reference Python Essential Reference《Python Essential Reference》，由 David Beazley 撰写，是 Python 的最终参考指南。 它简明扼要地解释了标准库的核心语言和最重要的部分。 它涵盖了 Python 3 和 2.6 版本。 Python Essential Reference Python Pocket Reference《Python Pocket Reference》由 Mark Lutz 编写，是一个了解核心语言的易于使用的参考， 介绍了常用的模块和工具集。它涵盖了 Python 3 和 Python 2。 Python Pocket Reference Python CookbookPython Cookbook 由 David Beazley 和 Brian K. Jones 编写，打包了许多具有实践意义的”食谱”。 这本书涵盖了核心 Python 语言，也涵盖了诸多不同应用的常见任务。 Python Cookbook Writing Idiomatic Python《Writing Idiomatic Python》由 Jeff Knupp 编写，包含了最常见和最重要的 Python 习语， 其形式尽可能地有辨识度和易于理解。每个习语都是编写一些常用代码片段的推荐方式， 其后会解释为什么这个习语是重要的。每个习语均有两个代码样例：”有害的” 方式和 “理想的” 方式。 For Python 2.7.3+ For Python 3.3+ Planet Python这是一个来自日益增长的开发者提供的 Python 资讯汇总。 Planet Python /r/python/r/python 是 Reddit Python 社区，在这里，用户对 Python 相关的资讯进行投稿和投票。 /r/python Talk Python Podcast头号以 Python 为重点的播客，涵盖了 Python 相关的人员和想法。 Talk Python To Me Python Bytes Podcast一个涵盖最近开发人员头条的简短形式的 Python 播客。 Python Bytes Pycoder’s WeeklyPycoder’s Weekly 是 Python开发者为 Python开发者们准备的免费的 Python 新闻周刊（包括项目，文章，资讯，工作）。 Pycoder’s Weekly Python WeeklyPython Weekly 是一个以策划 Python 相关的新闻，文章，新版发布，工作等为特色的周刊。 Python Weekly Python NewsPython News 是 Python 官网 的新闻板块。它简要地强调了 Python 社区的新闻。 Python News Import Python WeeklyWeekly Python Newsletter 包含 Python 的文章，项目，视频和你邮箱中的推文。让你的 Python 编程技巧处于更新状态。 Import Python Weekly Newsletter Awesome Python Newsletter每周对最受欢迎的 Python 新闻，文章和软件包进行总结。 Awesome Python Newsletter 参考资料 Python漫游指南","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"Docker Harbor镜像仓库","date":"2018-09-15T10:08:02.715Z","path":"2018/09/15/Docker-Harbor镜像仓库/","text":"场景架构:属于分布式集群的方式部署Dokcer镜像仓库，每个项目部署一个从仓库，所有从仓库共用连接一个主仓库，每次对镜像构建集成时将PUSH至主仓库，主仓库再分发至各项目的从仓库。 部署Harbor目录结构:123sudo mkdir /home/nucleus-oc/sudo mkdir /home/nucleus-oc/harbor/ # 数据目录sudo mkdir /home/nucleus-oc/2231/ # 控制目录 SSL证书12/home/nucleus-oc/harbor/ssl-key/chained.pem #证书/home/nucleus-oc/harbor/ssl-key/server.key # 密钥 下载并解压缩离线安装包：123cd /home/nucleus-oc/2231/wget https://github.com/vmware/harbor/releases/download/v1.1.2/harbor-offline-installer-v1.1.2.tgztar xf harbor-offline-installer-v1.1.2.tgz 修改配置文件docker-compose.yml1234cd /home/nucleus-oc/2231/harbor/sed -e &apos;s@ /data/@ /home/nucleus-oc/harbor/@&apos; \\ -e &apos;s@ /var/log/harbor/@ /home/nucleus-oc/harbor/logs/@&apos; \\ -i docker-compose.yml 修改harbor.cfg1234567895 hostname = oc-control-h9tc.mtiancity.com #仓库域名 9 ui_url_protocol = https12 db_password = wV6QRnTkX8SQNqxu24 ssl_cert = /home/nucleus-oc/harbor/ssl-key/chained.pem 25 ssl_cert_key = /home/nucleus-oc/harbor/ssl-key/server.key28 secretkey_path = /home/nucleus-oc/harbor55 harbor_admin_password = GLcvN2Ezrh5XT3Hx87 self_registration = off95 project_creation_restriction = adminonly 正式安装12cd /home/nucleus-oc/2231/harbor/ ./install.sh 解析域名参考资料 https://github.com/goharbor/harbor http://www.vmtocloud.com/remote-site-replicated-docker-registries-with-vmware-harbor/ http://www.cnblogs.com/jicki/p/5737369.html","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"Hitchhiker's Guide to Python-优雅的包管理","date":"2018-09-15T09:45:48.832Z","path":"2018/09/15/Hitchhiker-s-Guide-to-Python-优雅的包管理/","text":"打包Python项目本教程将指导您如何打包一个简单的Python项目。它将向您展示如何添加必要的文件和结构来创建包，如何构建包以及如何将其上载到Python包索引。 一个简单的项目本教程使用一个名为的简单项目example_pkg。如果您不熟悉Python的模块和导入包，请花几分钟时间阅读包含文件包和模块的Python文档。 要在本地创建此项目，请创建以下文件结构： 123/example_pkg /example_pkg __init__.py 创建此结构后，您将需要在顶级文件夹中运行本教程中的所有命令 - 所以一定要确保。cd example_pkg 您还应该编辑example_pkg/__init__.py并在其中放入以下代码： 1name = &quot;example_pkg&quot; 这只是为了您可以在本教程后面验证它是否正确安装。 创建包文件现在，您将创建一些文件来打包此项目并准备分发。创建下面列出的新文件 - 您将在以下步骤中向其添加内容。 123456/example_pkg /example_pkg __init__.py setup.py LICENSE README.md 创建的setup.pysetup.py是setuptools的构建脚本。它告诉setuptools你的包（例如名称和版本）以及要包含的代码文件。 打开setup.py并输入以下内容，您可以根据需要个性化值： 123456789101112131415161718192021import setuptoolswith open(&quot;README.md&quot;, &quot;r&quot;) as fh: long_description = fh.read()setuptools.setup( name=&quot;example_pkg&quot;, version=&quot;0.0.1&quot;, author=&quot;Example Author&quot;, author_email=&quot;author@example.com&quot;, description=&quot;A small example package&quot;, long_description=long_description, long_description_content_type=&quot;text/markdown&quot;, url=&quot;https://github.com/pypa/sampleproject&quot;, packages=setuptools.find_packages(), classifiers=[ &quot;Programming Language :: Python :: 3&quot;, &quot;License :: OSI Approved :: MIT License&quot;, &quot;Operating System :: OS Independent&quot;, ],) setup()有几个论点。此示例包使用相对最小的集： name是您的包的名称。只要包含字母，数字_和，就可以是任何名称-。它也不能在pypi.org上使用。 version 是包版本看 PEP 440有关版本的更多详细信息。 author并author_email用于识别包的作者。 description 是一个简短的，一句话的包的总结。 long_description是包的详细说明。这显示在Python Package Index的包详细信息包中。在这种情况下，加载长描述README.md是一种常见模式。 long_description_content_type告诉索引什么类型的标记用于长描述。在这种情况下，它是Markdown。 url是项目主页的URL。对于许多项目，这只是一个指向GitHub，GitLab，Bitbucket或类似代码托管服务的链接。 packages是应包含在分发包中的所有Python 导入包的列表。我们可以使用 自动发现所有包和子包，而不是手动列出每个包。在这种情况下，包列表将是example_pkg，因为它是唯一存在的包。find_packages() classifiers告诉索引并点一些关于你的包的其他元数据。在这种情况下，该软件包仅与Python 3兼容，根据MIT许可证进行许可，并且与操作系统无关。您应始终至少包含您的软件包所使用的Python版本，软件包可用的许可证以及您的软件包将使用的操作系统。有关分类器的完整列表，请参阅https://pypi.org/classifiers/。 除了这里提到的还有很多。有关详细信息，请参阅 打包和分发项目。 创建README.md打开README.md并输入以下内容。如果您愿意，可以自定义此项。 12345# Example PackageThis is a simple example package. You can use[Github-flavored Markdown](https://guides.github.com/features/mastering-markdown/)to write your content. 创建许可证上传到Python Package Index的每个包都包含许可证，这一点很重要。这告诉用户安装您的软件包可以使用您的软件包的条款。有关选择许可证的帮助，请参阅 https://choosealicense.com/。选择许可证后，打开 LICENSE并输入许可证文本。例如，如果您选择了MIT许可证： 12345678910111213141516171819Copyright (c) 2018 The Python Packaging AuthorityPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the &quot;Software&quot;), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE. 生成分发档案下一步是为包生成分发包。这些是上传到包索引的档案，可以通过pip安装。 确保您拥有setuptools并wheel 安装了最新版本： 1python3 -m pip install --user --upgrade setuptools wheel 小费 如果您在安装这些软件时遇到问题，请参阅 安装软件包教程 现在从setup.py位于的同一目录运行此命令： 1python3 setup.py sdist bdist_wheel 此命令应输出大量文本，一旦完成，应在dist目录中生成两个文件： 123dist/ example_pkg-0.0.1-py3-none-any.whl example_pkg-0.0.1.tar.gz 注意 如果您遇到麻烦，请复制输出并提出有关包装问题的问题，我们会尽力为您提供帮助！ 该tar.gz文件是源存档，而该.whl文件是 构建的分发。较新的pip版本优先安装构建的发行版，但如果需要，将回退到源代码存档。您应该始终上传源存档并为项目兼容的平台提供构建的存档。在这种情况下，我们的示例包在任何平台上都与Python兼容，因此只需要一个构建的发行版。 上传分发档案最后，是时候将您的包上传到Python Package Index了！ 您需要做的第一件事是在Test PyPI上注册一个帐户。Test PyPI是用于测试和实验的包索引的单独实例。这对于像我们不一定想要上传到真实索引的本教程那样很棒。要注册帐户，请访问https://test.pypi.org/account/register/并完成该页面上的步骤。在您上传任何软件包之前，您还需要验证您的电子邮件地址。有关Test PyPI的更多详细信息，请参阅 使用TestPyPI。 现在您已注册，您可以使用twine上传分发包。你需要安装Twine： 1python3 -m pip install --user --upgrade twine 安装完成后，运行Twine上传所有存档dist： 1twine upload --repository-url https://test.pypi.org/legacy/ dist/* 系统将提示您输入使用Test PyPI注册的用户名和密码。命令完成后，您应该看到与此类似的输出： 1234567Uploading distributions to https://test.pypi.org/legacy/Enter your username: [your username]Enter your password:Uploading example_pkg-0.0.1-py3-none-any.whl100%|█████████████████████| 4.65k/4.65k [00:01&lt;00:00, 2.88kB/s]Uploading example_pkg-0.0.1.tar.gz100%|█████████████████████| 4.25k/4.25k [00:01&lt;00:00, 3.05kB/s] 注意 如果您收到错误消息，则需要为您的包选择一个唯一的名称。一个不错的选择 。更新参数 ，删除文件夹，然后 重新生成存档。The user &#39;[your username]&#39; isn&#39;t allowed to upload to project&#39;example-pkg&#39;`example_pkg_your_usernamenamesetup.pydist` 上传后，您的包应该可以在TestPyPI上查看，例如，https： //test.pypi.org/project/example-pkg 安装新上传的软件包您可以使用pip来安装包并验证它是否有效。创建一个新的virtualenv（请参阅安装包以获取详细说明）并从TestPyPI安装包： 1python3 -m pip install --index-url https://test.pypi.org/simple/ example_pkg 注意 如果在预览步骤中使用了不同的包名称，请example_pkg在上面的命令中使用您的包名称替换 。 pip应该从Test PyPI安装包，输出应该如下所示： 1234Collecting example_pkg Downloading https://test-files.pythonhosted.org/packages/.../example_pkg-0.0.1-py3-none-any.whlInstalling collected packages: example-pkgSuccessfully installed example-pkg-0.0.1 您可以通过导入模块并引用先前name放置的属性来测试它是否已正确安装__init__.py。 运行Python解释器（确保你仍然在你的virtualenv中）： 1python 然后导入模块并打印出name属性。无论您给出的分发包名称是什么，这都应该是相同的 ，setup.py因为您的导入包是example_pkg。 >&gt;&gt; 123&gt;&gt;&gt; import example_pkg&gt;&gt;&gt; example_pkg.name&apos;example_pkg&apos; 后续步骤恭喜，您已经打包并分发了一个Python项目！ ✨🍰✨ 请记住，本教程向您展示了如何将软件包上传到Test PyPI，而测试PyPI是短暂的。偶尔删除包和帐户并不罕见。如果您想将软件包上传到真正的Python软件包索引，可以通过在https://pypi.org上注册帐户并按照相同的说明进行上传，但是，使用上传软件包并输入您的帐户凭据在真正的PyPI上注册。您可以使用真正的PyPI安装包 。twine upload dist/*`pip install your-package` 在这一点上，如果你想阅读更多关于包装的Python库，你可以做一些事情： 阅读有关使用setuptools在打包和分发项目中打包库的 更多信息。 阅读包装二进制扩展。 考虑诸如flit，hatch和poetry之类的setuptools的替代方案。 目录 Python的打包概述 教程 安装包 管理应用程序依赖项 打包Python项目 指南 讨论 PyPA规格 项目摘要 词汇表 如何获得支持 有助于本指南 新闻 上一主题管理应用程序依赖项 下一个主题指南 一些常见的包管理工具 distutils setuptools distribute disutils2 distlib pip ==创建纯 Python 或者平台 Wheels 的命令是：python setup.py bdist_wheel== 代码打包打包你的代码，将它共享出去，让其他的开发者使用。例如，将其打包成一个库分享给其他开发者，以便他们用在自己的应用中，或者共享给开发工具，比如 ‘py.test’。 这种代码发布方式具备的优势是其成熟的工具生态系统，例如 PyPI 和 pip，这些工具使得其他的开发者很容易下载和安装你的包，无论是用于偶然的实验，还是将其集成到大型专业的系统中。 Python 代码以这种方式发布共享是一个成熟的惯例。如果你的代码不是在 PyPI 上打包的，那么别的开发者很难找到它，也很难将它集成到他们现有的程序中。他们会严重质疑这些没有在 PyPI 上打包项目的槽糕管理，甚至认为这些项目已停止维护。 类似于这种发布代码的方式的缺点是，它依赖于开发者了解如何安装它所依赖的 Python 版本，并且能够和愿意使用类似 pip 这样的工具安装你的包所需要的其他依赖。这种做法适合发布代码给其他开发人员，但是不适合发布应用程序给终端用户使用。 Python 打包指南 提供了创建和维护 Pythond 包的一个延伸的指导。 打包的替代方案为了发布应用程序给终端用户使用，你应该 冻结你的应用程序。 在 Linux 平台，你可以考虑 创建一个Linux发行版软件包 (例如 Debian or Ubuntu 系统中是一个.deb 文件) 对于 Python 开发者如果你正在写一个开源的 Python 模块，PyPI 是一个适合它发布的地方，PyPI 的另一个名字 The Cheeseshop 更被人熟知。 Pip vs. easy_install使用 pip。 详情 点击这里 私人 PyPI如果你想要使用源码安装一个 Python 包，而不是使用 PyPI，(即, 你的包不对外公开)，你可以通过托管一个简单的 HTTP 服务器来完成，从那些包的安装路径下运行。 从一个例子入手是最好的 比如你想安装一个包，它的名字是 MyPackage.tar.gz，假设你的目录结构使这样： archive MyPackage MyPackage.tar.gz 代码冻结『冻结』你的代码是指创建单个可执行文件，文件里包含所有程序代码以及 Python 解释器。 像 Dropbox、星战前夜、文明 4 和 BitTorrent 客户端都是如此。 进行这种分发的好处是你的用户不需要安装所要求的 Python 版本（或其他）即可直接运行你的应用程序。 在 Windows 上，甚至许多 Linux发行版和 OS X，系统自带的 Python 版本总是不尽如人意，此时这种分发方式就会体现其价值。 此外，终端用户软件应始终是可执行的格式。 以 .py 结尾的文件一般适用于软件工程师和系统管理员。 冻结的一个缺点是它会增加大约 2-12 MB 的发行大小。另外，如果修补了 Python 的安全漏洞， 你将需要独立负责更新分发的应用程序。 冻结的替代方案打包你的代码 是指把你的库或工具分发给其他开发者。 Linux 下一个冻结的替代品是 Linux 分发包 （比如，对于 Debian 或 Ubuntu 是 .deb文件，而对于 Red Hat 与 SuSE 是 .rpm 文件） 冻结工具的比较解决方案还有平台/特性支持性： Solution Windows Linux OS X Python 3 License One-file mode Zipfile import Eggs pkg_resources support bbFreeze yes yes yes no MIT no yes yes yes py2exe yes no no yes MIT yes yes no no pyInstaller yes yes yes yes GPL yes no yes no cx_Freeze yes yes yes yes PSF no yes yes no py2app no no yes yes MIT no yes yes yes 注意在 Linux 下冻结 Windows 安装包，之前只有 PyInstaller 支持，不过后来也是 停止支持了。 注意所有解决方案都需要在 Windows 目标机器上安装了MS Visual C++ dll，除了 py2app 以外。只有 Pyinstaller 支持创建独立运行的绑定了dll 的 exe 文件，你需要在创建时传递参数 --onefile 到 Configure.py。 Windows 下的解决方案bbFreeze前置要求是安装 Python, Setuptools 以及 pywin32 的依赖项。 使用以下命令安装 bbfreeze: 1$ pip install bbfreeze 编写最简单的示例 bb_setup.py： 12345from bbfreeze import Freezerfreezer = Freezer(distdir='dist')freezer.addScript('foobar.py', gui_only=True)freezer() 注意这将适用于最基本的文件脚本。 有时候你需要高级的用法，如包含或者排除某些路径，如下：freezer = Freezer(distdir=&#39;dist&#39;, includes=[&#39;my_code&#39;], excludes=[&#39;docs&#39;]) (可选) 包含图标 1freezer.setIcon('my_awesome_icon.ico') 为冻结器（freezer）提供 Microsoft Visual C 运行时 DLL，我们有一般有两种方法，第一种是将Microsoft Visual Studio 路径 附加您的 sys.path 中，第二种是在脚本所在同一文件夹中放置 msvcp90.dll 文件。 开始冻结! 1$ python bb_setup.py py2exe前置要求是安装了 Python on Windows。 下载并且安装 http://sourceforge.net/projects/py2exe/files/py2exe/ 编写 setup.py (配置选项清单): 123456from distutils.core import setupimport py2exesetup( windows=[&#123;'script': 'foobar.py'&#125;],) (可选) 包含图标 (可选) 单文件模式 生成 :file: .exe 到 dist 目录: 1$ python setup.py py2exe 两种方式来提供 Microsoft Visual C 运行时 DLL。两个选项: 在目标机器全局安装 dll 或者 与 .exe 一起分发 dll。 PyInstaller前置条件是安装 Python, Setuptools 以及pywin32 依赖项. 更多的简单教程 官方手册 OS Xpy2appPyInstallerPyInstaller可用于在 Mac OS X 10.6（Snow Leopard）或更新版本上构建 Unix 可执行文件和窗口应用程序。 要安装 PyInstaller，使用 pip： 1$ pip install pyinstaller 要创建标准的 Unix 可执行文件，使用 script.py ： 1$ pyinstaller script.py 这会创建： script.spec 文件, 类似于 make 文件 build 文件夹, 存放日志文件 dist 文件夹, 存放主要的可执行文件 script ，和一些依赖的Python库 script.py 会把全部内容放在同一个文件夹中。PyInstaller 将所有 script.py 用到的 Python 库放到 dist 文件夹中。所以在分发可执行文件时，会分发整个 dist 文件夹。 script.spec 文件可以编辑成 自定义构建 ， 比如可以： 将数据文件与可执行文件绑定在一起 包含 PyInstaller 无法自动推断的运行时库（ .dll 或 .so 文件） 将 Python 运行时选项添加到可执行文件中 现在：代码 script.spec 可以用 pyinstaller （而不是再次使用 script.py ）运行。 1$ pyinstaller script.spec 要创建独立的 OS X 窗口应用程序，请使用 --windowed 选项： 1$ pyinstaller --windowed script.spec 这将在 dist 文件夹中创建一个 script.app 。请确保在 Python 代码中 使用 GUI 软件包，例如 PyQt 或 PySide来控制应用程序的图形部分。 script.spec 有几个与 Mac OS X 应用程序捆绑有关的 选项 。 例如，要指定应用程序的图标，请使用 icon=\\path\\to\\icon.icns 选项。 参考资料 Python官方文档 Python漫游指南 https://blog.zengrong.net/post/2169.html http://ju.outofmemory.cn/entry/106479","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"Hitchhiker's Guide to Python-关于项目License","date":"2018-09-15T04:40:43.334Z","path":"2018/09/15/Hitchhiker’s-Guide-to-Python-关于项目License/","text":"您的源码发布 需要 一个许可证。在美国，如果没有指定许可证，用户就没有合法的权利下载、修改或分发。此外，除非你告诉他们要遵循什么规则，否则人们不能对你的代码做出贡献。选择一个许可证是很复杂的，所以这里有一些建议: 开源许可。 这里有许多可以选择 开源许可 。 通常, 这些许可分为两类： 一类是让使用者能自由地使用软件 (像这种更加开发的开源许可有 MIT ， BSD &amp; Apache) 。 另一类是确保代码本身–无论发生任何修改或发布–该软件代码都应该是免费的 (像这种有一定限制的免费开源软件许可有 GPL 和 LGPL) 。 后者在某种意义上是不那么宽容开放的，因为他们不允许有人向软件中添加代码，并在不包括其更改的源代码的情况下发布代码。 为了帮助你为自己的项目选择一个许可证，请 使用 许可证选择器 。 更宽容的 PSFL (Python Software Foundation License) – 用于对 Python 本身作出贡献。 MIT / BSD / ISC MIT (X11) New BSD ISC Apache 参考资料 Python漫游指南","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"Hitchhiker's Guide to Python-常见陷阱","date":"2018-09-15T04:40:16.342Z","path":"2018/09/15/Hitchhiker’s-Guide-to-Python-常见陷阱/","text":"通常，Python 旨在成为一门简洁一致的语言，避免发生意外。然而，有些情况可能会给新手们造成困惑。 在这些情况中，有一些虽是有意为之，但还是有潜在风险。还有一些则可以说是语言设计缺陷了。总之，下面列出的这些情况都是些乍一看很不好理解的行为，不过一旦您了解了这些奇怪行为背后的机理，也就基本上能理解了。 可变默认参数似乎每个 Python 新手都会感到惊讶的一点是 Python 在函数定义中对待可变默认参数的方法。 您所写的123def append_to(element, to=[]): to.append(element) return to 您可能期待的结果12345my_list = append_to(12)print my_listmy_other_list = append_to(42)print my_other_list 函数每次被调用时，如果不提供第二个参数，就创建一个新的列表。所以结果就应该是： 12[12][42] 实际上的结果12[12][12, 42] 一旦 完成了函数定义，一个新的列表就创建出来了，而且在随后的每一次函数调用中被使用的都是这个列表。 一旦 完成了函数定义，Python 的默认参数就被赋值了，而且在随后的每一次函数调用中都不会再被默认值重复赋值（就像是在，嗯，Ruby 里那样）。这就意味着如果您使用了一个可变默认参数，并且改变了它，您也会且 将会 在未来的所有函数调用中改变这同一个参数对象。 您实际上应该做的使用一个默认值来表示我们并不想给这个参数赋值，从而每次在函数被调用时我们都创建一个新的对象。（None 作为默认值通常是个好选择）。 12345def append_to(element, to=None): if to is None: to = [] to.append(element) return to 可别忘了，您所传递的第二个参数仍应该是个 列表 对象。 利用好『缺陷』有时你可以专门 利用（或者说特地使用）这种行为来维护函数调用间的状态。这通常用于编写缓存函数。 延迟绑定闭包另一个常见的困惑是 Python 在闭包（或在周围全局作用域）中绑定变量的方式。 当你写下12def create_multipliers(): return [lambda x : i * x for i in range(5)] 你期望发生12for multiplier in create_multipliers(): print multiplier(2) 一个包含五个函数的列表，每个函数有它们自己的封闭变量 i 乘以它们的参数，得到: 1234502468 而事实是：1234588888 五个函数被创建了，它们全都用 4 乘以 x 。 Python 的闭包是 延迟绑定的 。 这意味着闭包中用到的变量的值，是在内部函数被调用时查询得到的。 这里，不论 任何 返回的函数是如何被调用的， i 取的是调用时周围作用域里的值。 当循环完成时， i 的值最终变成了 4。 关于这个陷阱有一个普遍严重的误解，它被认为只针对 Python 的 闭包 lambda 定义方式。 事实上，由 lambda 表达式创建的函数并没什么特别，同样的问题也出现在使用普通的 def 上： 123456789def create_multipliers(): multipliers = [] for i in range(5): def multiplier(x): return i * x multipliers.append(multiplier) return multipliers 以上正确的做法应该是：最简单通用的解决方案可以说是有点取巧（hack）。由于 Python 拥有在前文提到的『为函数默认参数赋值』的行为（参见 可变默认参数 ），你可以创建一个立即绑定参数的闭包，像下面这样： 12def create_multipliers(): return [lambda x, i=i : i * x for i in range(5)] 或者，使用 functools.partial 函数： 12345from functools import partialfrom operator import muldef create_multipliers(): return [partial(mul, i) for i in range(5)] 缺陷并不可怕有时你就想要闭包有如此表现，延迟绑定在很多情况下是一个很赞的特性。不幸的是，循环创建独立函数是一种会使它们出差错的情况。 字节码（.pyc）文件无处不在！默认情况下，当你直接执行 Python 脚本文件时，Python 解释器会自动将该文件的字节码版本写入同目录下。 比如， module.pyc。 这些 .pyc 文件不应该被纳入源代码仓库。 理论上，出于性能原因，此行为默认为开启。 没有这些字节码文件， Python 会在每次加载文件时重新生成字节码文件。 禁用字节码（.pyc）文件幸运的是，生成字节码的过程非常快，在开发代码时不需要担心。 那些文件很讨厌，所以让我们摆脱他们吧！ 1$ export PYTHONDONTWRITEBYTECODE=1 使用 $PYTHONDONTWRITEBYTECODE 环境变量来命令 Python 不将这些文件写入磁盘， 开发环境将会保持整洁和干净。 我建议在你的 ~/.profile 里设置这个环境变量。 删除字节码（.pyc）文件以下是删除所有已存在字节码文件的好方法: 1$ find . -type f -name \"*.py[co]\" -delete -or -type d -name \"__pycache__\" -delete 从项目根目录运行，所有 .pyc 文件会瞬间消失。 版本控制忽略如果由于性能原因仍然需要 .pyc 文件，你可以随时将它们添加到版本控制存储库的忽略文件中。 流行的版本控制系统能够使用文件中定义的通配符来应用特殊规则。 一份忽略文件将确保匹配的文件未被检入存储库。 Git 使用 .gitignore，而 Mercurial 使用 .hgignore。 忽略文件里至少应该具备以下内容： 123syntax:glob # This line is not needed for .gitignore files.*.py[cod] # Will match .pyc, .pyo and .pyd files.__pycache__/ # Exclude the whole folder 可按需添加更多文件和目录。下次提交到存储库时，这些文件将不被包括。 参考资料 Python漫游指南","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"Hitchhiker's Guide to Python-日志记录","date":"2018-09-15T04:39:54.022Z","path":"2018/09/15/Hitchhiker’s-Guide-to-Python-日志记录/","text":"logging 模块自 2.3 版以来一直是 Python 标准库的一部分。在 PEP 282 中有对它的简洁描述。除了 基础日志教程之外，这些文档是非常难以阅读的。 日志记录一般有两个目的： 诊断日志 记录与应用程序操作相关的日志。例如，当用户遇到程序报错时， 可通过搜索诊断日志以获得上下文信息。 审计日志 为商业分析而记录的日志。从审计日志中，可提取用户的交易信息， 并结合其他用户资料构成用户报告，或者用来作为优化商业目标的数据支撑。 … 或者使用打印（print）?当需要在命令行应用中显示帮助文档时， print 是一个相对于日志更好的选择。 而在其他时候，日志总能优于 print ，理由如下： 日志事件产生的 日志记录 ，包含清晰可用的诊断信息，如文件名称、路径、函数名和行号等。 包含日志模块的应用，默认可通过根记录器对应用的日志流进行访问，除非你做了日志过滤。 可通过 logging.Logger.setLevel() 方法有选择地记录日志， 或可通过设置 logging.Logger.disabled 属性为 True 来禁用日志记录。 在库中记录日志官方的 日志指南 里有相关的 库日志配置 的说明。由于是 用户 ，而非库来指定如何响应日志事件， 因此这里有一个值得反复说明的忠告： 注意强烈建议不要向您的库日志中加入除 NullHandler 外的其它处理程序。 在库中，声明日志的最佳方式是通过 __name__ 全局变量： logging 模块通过点（.）运算符创建层级排列的日志，因此，用 __name__ 可以避免名字冲突。 以下是一个来自 requests 资源 的最佳实践的例子 —— 请将它放置在 __init__.py 文件中： 12import logginglogging.getLogger(__name__).addHandler(logging.NullHandler()) 在应用程序中记录日志应用程序开发的权威指南 《twelve factor app》 也在其中一节描述了 日志的作用 。它特别强调将日志视为事件流， 并将其发送至取决于应用环境配置的标准输出中。 至少有以下三种配置日志方式： 使用 INI 格式文件： 优点：使用 logging.config.listen() 函数监听 socket，可在运行过程中更新配置 缺点：相比代码里控制，可控性要弱（ 例如 子类化定制的 filters 或 loggers）。 使用字典或 JSON 格式文件： 优点：除了可在运行时动态更新，在 Python 2.6 之后，还可通过 json 模块从其它文件中导入配置。 缺点：相比代码里控制，可控性要弱 使用代码控制： 优点：相比配置来讲，有绝对的控制。 缺点：需要对源码进行修改。 参考资料 Python漫游指南","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"Hitchhiker's Guide to Python-代码测试","date":"2018-09-15T04:39:30.430Z","path":"2018/09/15/Hitchhiker’s-Guide-to-Python-代码测试/","text":"测试你的代码是非常重要的。 习惯于同时写测试用例和运行代码，现在被视为一个好的习惯。如果使用得当，这种方式将帮助你更加明确自己代码的功能，以及拥有更加可解耦的结构。 你应对自己编写的函数和类进行测试。这样你就能够更加确定自己所做的工作不会破坏项目的其他部分，你就能够随心所欲地改进既有的代码了。 如果你在项目中包含了初步测试用例，其他程序猿更敬佩你，更愿意work with you together ，他们将能够更得心应手地尝试使用你编写的代码，也更愿意与你合作开发项目。 测试的通用规则： 测试单元应该集中于最小部分功能，并且证明它是正确的。 每个测试单元必须完全独立。他们都能够单独运行，也可以在测试套件中运行，而不用考虑被调用的顺序。 要想实现这个规则，测试单元应该加载最新的数据集，之后再做一些清理。 这通常用方法 setUp() 和 tearDown() 处理。 尽量使测试单元快速运行。如果一个单独的测试单元需要较长的时间去运行，开发进度将会延迟， 测试单元将不能如期常态性运行。有时候，因为测试单元需要复杂的数据结构， 并且当它运行时每次都要加载，所以其运行时间较长。请把运行速度较慢的测试单元放在单独的测试组件中， 并且按照需要运行其它测试单元。 学习使用工具，学习如何运行一个单独的测试或者测试用例。当为某个模块开发了一个新功能时， 我们需要经常运行这个功能的测试用例，理想情况下需配置工具让其在保存代码文件时自动触发运行测试。 在编码工作开始前后，请运行完整的测试组件。只有这样，你才会坚信现有的代码不会出现错误。 使用钩子（hook）是一个非常推荐的做法，一旦把代码提交到共享的代码仓库时（译者注：很多时候你会选择 Github）， 即可触发钩子运行所有的测试。 如果你在开发期间不得不打断自己的工作，请先为你下一步要开发的功能写一个未通过的测试，这样当你回到工作时，将可以很快地回到原先被打断的地方，并且步入正轨。 当你调试代码的时候，首先需要写一个精确定位 Bug 的测试单元。尽管这样做很难， 但是捕捉 Bug 的单元测试在项目中很重要。 测试函数需使用长且描述性的名字。测试的编码规范与代码编码规范有点不一样，代码更倾向于使用短的名字， 而测试函数不会直接被调用。在运行代码中，square() 或者甚至 sqr() 这样的命名都是可以的， 但是在测试代码中，您应该这样取名 test_square_of_number_2()，test_square_negative_number()。 当测试单元失败时，函数名会被直接显示出来，此时函数名称的描述性将变得重要。 当业务逻辑不得不变更时，如果代码中有一套不错的测试单元， 维护者将很大一部分依靠测试组件解决问题，或者确保改动不会影响到其他代码。此时测试代码会经常被阅读， 阅读的频率甚至多于业务逻辑代码。目的不明确的测试单元在这种情况下没有多少用处，因此请尽量避免书写目的不明确的测试代码。 测试代码的另外一个用处是作为新开发人员的入门介绍。当有人需要基于现有的代码库工作时， 运行并且阅读相关的测试代码是最好的做法。他们会或者应该发现业务代码的重点、难点、以及边界场景。 如果他们必须添加一些功能，第一步应该是添加一个测试，以确保新功能开发能保持测试的传统。 入门Unittest 单元测试unittest 是 Python 标准库中自带的测试模块。任何一个使用过 Junit，nUnit, 或 CppUnit 工具的人对它的 API 都会比较熟悉。 我们可以通过继承 unittest.TestCase 来创建测试用例： 12345678import unittestdef fun(x): return x + 1class MyTest(unittest.TestCase): def test(self): self.assertEqual(fun(3), 4) Python 2.7 以后，unittest 已支持测试自动发现机制。 关于 unittest 的标准库文档 Doctestdoctest 模块会在代码的 Docstrings 中寻找类似于 Python 交互会话的字串（译者注：&gt;&gt;&gt;），并会将其执行，以证实工作正常。 Doctest 模块的使用场景与单元测试有所不同：它们通常不是很详细，并且不会用特别的用例或者处理复杂的 Bug。Doctest 主要是作为模块和其部件主要用例的表述性文档，因此，Doctest 需在每一次完整测试 套件运行时自动运行。 函数中的一个简单 Doctest 例子： 1234567891011121314def square(x): \"\"\"Return the square of x. &gt;&gt;&gt; square(2) 4 &gt;&gt;&gt; square(-2) 4 \"\"\" return x * xif __name__ == '__main__': import doctest doctest.testmod() 当使用 python module.py 这样的命令行运行这个模块时，Doctest 将会运行，并会在结果与文档字符串的描述不一致时报错。 其他工具py.test相比于 Python 标准库里的 unittest 模块，py.test 也是一个没有模板（no-boilerplate）的备选方案： 1$ pip install pytest 尽管这个测试工具功能完备，并且可扩展，它仍然能保持语法很简单。创建一个测试组件和写一个带有诸多函数的模块一样容易： 123456# content of test_sample.pydef func(x): return x + 1def test_answer(): assert func(3) == 5 运行命令 py.test ： 1234567891011121314151617$ py.test=========================== test session starts ============================platform darwin -- Python 2.7.1 -- pytest-2.2.1collecting ... collected 1 itemstest_sample.py F================================= FAILURES =================================_______________________________ test_answer ________________________________ def test_answer():&gt; assert func(3) == 5E assert 4 == 5E + where 4 = func(3)test_sample.py:5: AssertionError========================= 1 failed in 0.02 seconds ========================= 可以看出，这要比 unittest 模块中实现相同功能所要求的工作量少得多。 py.test HypothesisHypothesis 让你编写被示例源码参数化的测试库。它会生成简单易懂的例子，使你的测试失败， 让你花更少的力气找到更多的错误。 1$ pip install hypothesis 例如，测试浮动列表要尝试很多例子，但是会报告每个错误的最小例子（区分异常类型和位置）： 1234567@given(lists(floats(allow_nan=False, allow_infinity=False), min_size=1))def test_mean(xs): mean = sum(xs) / len(xs) assert min(xs) &lt;= mean(xs) &lt;= max(xs)Falsifying example: test_mean( xs=[1.7976321109618856e+308, 6.102390043022755e+303]) Hypothesis 是实用且强大的工具，很多时候它都会找出被其他测试工具所遗漏的错误。 它能与 py.test 很好地集成，无论是简单亦或者是高级场景中，你都会觉得它很趁手。 hypothesis toxtox 是一个自动化测试环境管理，并能针对多版本解释器配置进行测试的工具。 1$ pip install tox tox 允许你通过简单的配置文件，来设置复杂的多参数测试矩阵。 tox Unittest2Unittest2 是 Python 2.7 中 unittest 模块的向后兼容补丁，对比 Python 2.7 之前的版本提供了更好的 API 和断言语法。 如果使用 Python 2.6 版本或者以下，你可以使用 pip 安装 unittest2： 1$ pip install unittest2 推荐你使用 unittest 之名导入模块，目的是更容易地把代码移植到新的版本中： 1234import unittest2 as unittestclass MyTest(unittest.TestCase): ... 如果切换到新的 Python 版本，并且不再需要 unittest2 模块，你只需要在测试模块中改变 import 内容，而不必改变其它代码。 unittest2 mockunittest.mock 是 Python 中用于测试的一个库。 Python 3.3 版本中，将存在于自带的标准库中 —— 标准库中的 unittest.mock。 对于 Python 相对早的版本，如下操作： 1$ pip install mock 在测试环境下，使用 mock 对象能够替换部分系统，并且对它们的使用进行断言。 例如，你可以对一个方法打猴子补丁： 123456from mock import MagicMockthing = ProductionClass()thing.method = MagicMock(return_value=3)thing.method(3, 4, 5, key='value')thing.method.assert_called_with(3, 4, 5, key='value') 在测试环境下，你可以使用 patch 修饰器来 mock 某个模块中的类或对象。在下面这个例子中，一直返回相同结果的外部查询系统使用 mock 替换（但仅用在测试期间）。 123456789101112def mock_search(self): class MockSearchQuerySet(SearchQuerySet): def __iter__(self): return iter([\"foo\", \"bar\", \"baz\"]) return MockSearchQuerySet()# 这里的 SearchForm 指的是 myapp 引入的类,# 而不是类 SearchForm 本身自己@mock.patch('myapp.SearchForm.search', mock_search)def test_new_watchlist_activities(self): # get_search_results 运行一次搜索并对结果进行迭代 self.assertEqual(len(myapp.get_search_results(q=\"fish\")), 3) Mock 还提供许多其它方法，你可以很轻松地配置和控制它的行为。 Mock 的文档 参考资料 Python漫游指南","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"Hitchhiker's Guide to Python-项目文档","date":"2018-09-15T04:39:18.634Z","path":"2018/09/15/Hitchhiker’s-Guide-to-Python-项目文档/","text":"可读性是 Python 开发人员在项目和代码文档中的主要关注点。遵循一些简单的最佳实践可以为您和其他人节省大量时间。 项目文档在根目录下 README 文件应该对用户和项目维护者提供概述信息。它应该是原始文本或非常容易阅读的标记写成，如 reStructuredText 或 Markdown。 它应该包含几行对项目或库的作用的解释（假设用户不知道项目的任何内容），软件源站点的 URL 和一些基本的信用信息。这个文件应该是代码阅读者的主要入口点。 INSTALL 文件对 Python 来说不是必需的。安装指令通常被简化为一个命令，如 pip install module 或 python setup.py install 并且添加到 README 文件中。 LICENSE 文件应该 始终 存在并且详细说明软件在什么许可证下对公众可用。 TODO 文件或 README 文件中的 TODO 部分应该列出代码的开发计划。 CHANGELOG 文件或在 README 对应的部分应该基于最新版本编写一个代码变更概述。 其他文档根据项目的不同，文档中最好能包含下列部分或所有的内容： 一份 简短介绍 ，应该包含几个简化的用例，简要概述该产品能够用来做什么。 一份 教程 ，应该展示一些主要的用例以及更多的使用细节。读者能够跟着一步步成功搭建工作原型。 一份 API 文档，通常从代码中产生（参见 docstrings）。它会列出所有的可供公共访问的接口、参数和返回值。 一份 贡献文档 适用于潜在贡献者。这可以包括项目的代码规范和通用设计的策略讲解。 SphinxSphinx 无疑是最流行的 Python 文档工具。我们推荐在项目中使用 Sphinx。 它能把 reStructuredText 标记语言转换为流行的输出格式，包括 HTML、LaTeX (可打印 PDF 版本)、手册和纯文本。 Read The Docs 是一个 超棒的 并且 免费的 文档托管平台，可以托管您的 Sphinx 文档。您可以为它配置提交钩子到您的代码库中，这样文档的重新构建即可自动进行。 运行 Sphinx 时首先导入你的代码，它会使用 Python 的内省功能来提取所有函数，方法和类签名，同时提取附带的文档字符串，并将其全部编译成结构良好且易于阅读的文档。 Sphinx 因生成 API 文档而著名，但它也适用于普通的文档。本指南（译者注：原始文档）使用 Sphinx 进行构建， 并托管在 Read The Docs 上。 reStructuredText大多数 Python 文档是用 reStructuredText 编写的。它是一个内建了所有可选扩展的 Markdown 解析器。 reStructuredText Primer 和 reStructuredText Quick Reference 这两个文档应该能帮助你快速熟悉它的语法。 源码文档建议注释能使代码清晰，将其加入到代码中是为了理解代码起来更容易。注释在 Python 中以一个 hash 开始（数字符号）（”#”）。 在 Python 中我们使用 文档字符串（docstrings） 用来描述模块、类和函数： 123def square_and_rooter(x): \"\"\"Return the square root of self times self.\"\"\" ... 一般来说，我们要遵循 PEP 8#comments （” Python 风格指南”）的注释部分。 更多关于 docstrings 的内容可以在 PEP 0257#specification （docstrings 约定指南） 上找到。 注释代码块请不要使用三引号去注释代码。 这不是好的实践，因为面向行的命令行处理工具， 比如说 grep，将会很难判断注释掉的代码是否是激活的。对每一个注释行，最好使用带有合适缩进的井号。您的编辑器可能很容易做到这一点，并能使用快捷键就切换 注释 / 取消注释。 Docstrings 的魔法一些工具使用 Docstrings 来嵌入不止是文档的行为， 比如说单元测试逻辑等。接下来会给你讲解 Docstrings 的一些奇特的用法，不过话说回来，如果你只是使用 Docstrings 来做函数文档也是完全合理的。 像 Sphinx 这样的工具会将 Docstrings 解析为 reStructuredText，并以 HTML 格式正确呈现。 这使得将示例代码片段嵌入到项目文档成为可能。 此外， Doctest 能够读取所有内嵌的看起来像 Python 命令行输入（以 &gt;&gt;&gt; 为前缀）的 Docstrings 并对其进行运行，以检查命令输出是否匹配其下行内容。这允许开发人员在源码中嵌入真实的示例和函数的用法。 此外，它还能确保代码运行过测试并且正常工作。 12345678def my_function(a, b): \"\"\" &gt;&gt;&gt; my_function(2, 3) 6 &gt;&gt;&gt; my_function('a', 3) 'aaa' \"\"\" return a * b Docstrings 与块注释的比较他们俩是不可互换。对于函数或类，开头的注释区是程序员的注解。而Docstrings 描述了函数或类的 操作性文档 ： 1234# 出于某种原因此函数用来减慢程序执行的def square_and_rooter(x): \"\"\"返回自己乘以自己的平方根。\"\"\" ... 块注释会在脚本执行时被优化掉，与块注释不同，Docstrings 内置于 Python 语言本身。这意味着你可以使用 Python 强大的内省功能以在运行时获得 Docstrings 。对于几乎每个 Python 对象，我们都可以通过其 *doc* 属性或使用内置的 help() 函数来访问 Docstrings。 块注释通常用于解释一段代码是 做什么 ，或是算法的细节。而 Docstrings 更适合于向其他用户（或是写完代码 6 个月以后的你）解释代码中的特定功能是 如何 使用， 或是方法、类和模块的作用。 编写 Docstrings取决于函数、方法或类的复杂度，使用单行的 Docstrings 可能十分合适。 以下通常用于非常明显的情况，例如: 123def add(a, b): \"\"\"两个数字相加，并返回结果。\"\"\" return a + b Docstrings 应该以易于理解的方式来描述函数。另一方面，对于简单的函数和类， 将函数的签名（即 add(a, b) -&gt; result ）嵌入到 Docstrings 中是没有必要的。这是因为使用 Python 的 “inspect” 模块可以很容易地找到这些信息。 此外，这些信息也可以简单地通过阅读源代码来获得。 在更大或更复杂的项目中，我们建议提供相关函数的更多信息，包括它是做什么的， 所抛的任何异常，返回的内容或参数的相关细节。 对于更详细的代码文档，用于 Numpy 项目上的 Docstrings 风格会更为流行，通常称为 Numpy style Docstrings。因为可以占用更多的行，所以它允许开发人员写入更多的信息。 12345678910111213141516171819def random_number_generator(arg1, arg2): \"\"\" 摘要行。 扩展功能描述。 参数 ---------- arg1：int arg1的描述 arg2：str arg2的描述 返回 ------- int 返回值说明 \"\"\" return 42 Sphinx 下使用 sphinx.ext.napoleon 插件即可解析这种风格的 Docstrings， 使您可以轻松地将 NumPy 风格文档植入到你的项目中。 最后，编写 Docstrings 的风格并没那么重要，它们的目的是为任何可能需要阅读或更改代码的人提供文档。 只要它是正确的，可以理解的，切中相关点，那么它就很完美地完成了它的使命。 要进一步阅读 Docstrings，请随时参见 PEP 257 其他工具你可能在其他场景看到过这些，不过没有特殊情况的话，请尽量使用 Sphinx。 Pycco Pycco是一个 “文学编程风格的文档生成器”，它是 node.js Docco 的移植版本。它将代码生成为一个并排的 HTML 代码区块和对应的文档。 Ronn Ronn 用来构建 Unix 手册。它将人可读的文本文件转换成用于终端显示的 roff 文件, 以及用于 web 的 HTML 文件。 Epydoc Epydoc 已经停止维护。请使用 Sphinx 来替代。 MkDocs MkDocs 是一个快速简单的静态网站生成器，它适合于构建使用 Markdown 编写的项目文档。 参考资料 Python漫游指南","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"Hitchhiker's Guide to Python-Reading Great Code","date":"2018-09-15T04:38:30.150Z","path":"2018/09/15/Hitchhiker’s-Guide-to-Python-Reading-Great-Code/","text":"Python 设计背后的核心原则之一就是创建可读的代码。这个设计背后的动机很简单： Python 程序员所做的第一件事就是阅读代码。 成为一个著名的 Python 程序猿的秘诀之一就是阅读，理解和理解优秀的代码。 优秀的代码通常遵循 Code Style 中概述的指导方针，并想读者表达清晰简洁的意图。 下面是一些推荐的 Python 项目供读者参阅。这些项目中每一项都是 Python 编码的一个典范。 Howdoi Howdoi 使用 Python 实现的代码搜索工具。 Flask Flask 是基于 Werkzeug and Jinja2 的 Python 微框架。 它的目的是快速入门并开发实现你头脑中的好主意。 Diamond Diamond 是使用 python 实现的用于收集监控数据的工具，主要收集 metrics 类型的数据，并将其发布到 Graphite 或其他后台。它能够收集 cpu ， 内存， 网络， i/o ，负载和磁盘 metrics 数据。此外，它还提供 API 用以实现自定义收集器从任意来源中收集指标数据。 Werkzeug Werkzeug 最初是 WSGI 应用程序的各种实用工具的简单集合，并已成为最先进的 WSGI 实用程序模块之一。它包括强大的调试器、功能齐全的请求和响应对象、处理实体标记的 HTTP 实用程序、缓存控制头、HTTP 日期、cookie 处理、文件上传、强大的 URL 路由系统和一群社区贡献的插件模块。 Requests Requests 是一个用 Python 实现的 Apache2 授权的 HTTP 库供大家使用。 Tablib Tablib 是用 Python 实现的无格式的表格数据集库。 参考资料 Python漫游指南","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"Hitchhiker's Guide to Python-Code Style","date":"2018-09-15T04:38:05.984Z","path":"2018/09/15/Hitchhiker’s-Guide-to-Python-Code-Style/","text":"如果有人问起 Python 程序员他们最喜欢 Python 哪一点，他们一定会提到 Python 的高可读性。确实，对于 Python 来说，其高可读性一直是 Python 这门语言设计的核心。一个不争的事实是，相对于写代码而言，读代码才是更加平常的事情。 Python 代码有高可读性的一个原因就是其有着相对而言更加完善的编码风格准则和 「Python化」习语。 当 Python 老手（Pythonista）认为一段代码不「Python化」，他们通常的意思是这段代码没有遵循一般准则，同时亦没有以最佳的（最具可读性的）方式表达出代码的意图。 在一些极端的情况下，没有公认最佳的方式来表达 Python 代码的意图，不过这种极端情况非常罕见。 一般概念明确代码意义尽管 Python 可以写出从各种意义上来说都像是黑魔法的代码，但最简单直白的表达才是正道。 不好 123def make_complex(*args): x, y = args return dict(**locals()) 好 12def make_complex(x, y): return &#123;'x': x, 'y': y&#125; 在上述好的代码中，x 和 y 清晰明了的从参数中获取值，并清晰明了的返回了一个字典。当开发者看到这个函数后就可以明了这个函数的用途，而不好的代码则不行。 一行一个声明语句虽然在 Python 中我们推崇使用形如列表生成式这种简洁明了的复合语句，但是除此以外，我们应该尽量避免将两句独立分割的代码写在同一行。 不好的风格 123456print 'one'; print 'two'if x == 1: print 'one'if &lt;complex comparison&gt; and &lt;other complex comparison&gt;: # do something 好的风格 12345678910print 'one'print 'two'if x == 1: print 'one'cond1 = &lt;complex comparison&gt;cond2 = &lt;other complex comparison&gt;if cond1 and cond2: # do something 函数的参数函数的参数可以使用四种不同的方式传递给函数。 必选参数 是没有默认值的必填的参数。 必选参数是最简单的参数构成，用于参数较少的函数的构成，是该函数意义的一部分，使用他们的顺序是按照定义自然排序的。举个例子，对于 send(message, recipient) 和 point(x, y) 这两个函数，使用函数的人需要知道这个函数需要两个参数，并且记住两个参数的顺序。 在调用函数的时候，我们也可以使用参数的名称调用。使用参数的名称的方式可以调换参数的顺序，就像 send(recipient=&#39;World&#39;,message=&#39;Hello&#39;) 和 point(y=2, x=1) 这样。但这样的做法会降低代码的可读性，并且使代码冗长，因此更建议使用 send(&#39;Hello&#39;, &#39;World&#39;) 和point(1,2) 这样的方式调用。 关键字参数 是非强制的，且有默认值。它们经常被用在传递给函数的可选参数中。 当一个函数有超过两个或三个位置参数时，函数签名会变得难以记忆，使用带有默认参数的关键字参数有时候会给你带来便利。比如，一个更完整的 send 函数可以被定义为send(message, to, cc=None, bcc=None)。这里的 cc 和 bcc 是可选的， 当没有传递给它们其他值的时候，它们的值就是 None。 Python 中有多种方式调用带关键字参数的函数。比如说，我们可以按照定义时的参数顺序而无需明确的命名参数来调用函数，就像 send(&#39;Hello&#39;, &#39;World&#39;, &#39;Cthulhu&#39;, &#39;God&#39;) 是将密件发送给上帝。我们也可以使用命名参数而无需遵循参数顺序来调用函数，就像send(&#39;Hello again&#39;, &#39;World&#39;, bcc=&#39;God&#39;, cc=&#39;Cthulhu&#39;) 。没有特殊情况的话，这两种方式都需要尽力避免，最优的调用方式是与定义方式一致：send(&#39;Hello&#39;, &#39;World&#39;, cc=&#39;Cthulhu&#39;,bcc=&#39;God&#39;) 。 作为附注，请遵循 YAGNI 原则。 通常，移除一个用作『以防万一』但从未使用的可选参数（以及它在函数中的逻辑），比添加一个所需的新的可选参数和它的逻辑要来的困难。 任意参数列表 是第三种给函数传参的方式。如果函数的参数数量是动态的，该函数可以被定义成 *args 的结构。在这个函数体中， args 是一个元组，它包含所有剩余的位置参数。举个例子， 我们可以用任何容器作为参数去调用 send(message, *args) ，比如 send(&#39;Hello&#39;, &#39;God&#39;, &#39;Mom&#39;,&#39;Cthulhu&#39;)。 在此函数体中， args 相当于 (&#39;God&#39;,&#39;Mom&#39;, &#39;Cthulhu&#39;)。 然而，这种结构有一些缺点，使用时应该特别注意。如果一个函数接受的参数列表具有相同的性质，通常把它定义成一个参数，这个参数是一个列表或者其他任何序列会更清晰。 在这里，如果 send 参数有多个容器（recipients），将之定义成 send(message,recipients) 会更明确，调用它时就使用 send(&#39;Hello&#39;, [&#39;God&#39;, &#39;Mom&#39;, &#39;Cthulhu&#39;])。这样的话， 函数的使用者可以事先将容器列表维护成列表（list）形式，这为传递各种不能被转变成其他序列的序列（包括迭代器）带来了可能。 任意关键字参数字典 是最后一种给函数传参的方式。如果函数要求一系列待定的命名参数，我们可以使用 **kwargs 的结构。在函数体中， kwargs 是一个字典，它包含所有传递给函数但没有被其他关键字参数捕捉的命名参数。 和 任意参数列表 中所需注意的一样，相似的原因是：这些强大的技术在非特殊情况下，都要尽量避免使用，因为其缺乏简单和明确的结构来足够表达函数意图。 编写函数的时候采用何种参数形式，是用位置参数，还是可选关键字参数，是否使用形如任意参数 的高级技术，这些都由程序员自己决定。如果能明智地遵循上述建议，即可轻松写出这样的 Python 函数： 易读（名字和参数无需解释） 易改（添加新的关键字参数不会破坏代码的其他部分） 避免魔法方法Python 对骇客来说是一个强有力的工具，它拥有非常丰富的钩子（hook）和工具，允许你施展几乎任何形式的技巧。比如说，它能够做以下： 改变对象创建和实例化的方式； 改变 Python 解释器导入模块的方式； 甚至可能（如果需要的话也是被推荐的）在 Python 中嵌入 C 程序。 尽管如此，所有的这些选择都有许多缺点。使用最直接的方式来达成目标通常是最好的方法。它们最主要的缺点是可读性不高。许多代码分析工具，比如说 pylint 或者 pyflakes，将无法解析这种『魔法』代码。 我们认为 Python 开发者应该知道这些近乎无限的可能性，因为它为我们灌输了没有不可能完成的任务的信心。然而，知道何时 不能 使用它们也是非常重要的。 就像一位功夫大师，一个 Pythonista 知道如何用一个手指杀死对方，但从不会那么去做。 我们都是负责任的用户如前所述，Python 允许很多技巧，其中一些具有潜在的危险。一个好的例子是：任何客户端代码能够重写一个对象的属性和方法（Python 中没有 private 关键字）。这种哲学是在说：『我们都是负责任的用户』，它和高度防御性的语言（如 Java，拥有很多机制来预防错误操作）有着非常大的不同。 这并不意味着，比如说，Python 中没有属性是私有的，也不意味着没有合适的封装方法。 与其依赖在开发者的代码之间树立起的一道道隔墙，Python 社区更愿意依靠一组约定，来表明这些元素不应该被直接访问。 私有属性的主要约定和实现细节是在所有的 内部 变量前加一个下划线。如果客户端代码打破了这条规则并访问了带有下划线的变量，那么因内部代码的改变而出现的任何不当的行为或问题，都是客户端代码的责任。 鼓励大方地使用此约定：任何不开放给客户端代码使用的方法或属性，应该有一个下划线前缀。这将保证更好的职责划分以及更容易对已有代码进行修改。将一个私有属性公开化总是可能的，但是把一个公共属性私有化可能是一个更难的选择。 返回值当一个函数变得复杂，在函数体中使用多返回值的语句并不少见。然而，为了保持函数的可读性，建议在函数体中避免使用返回多个有意义的值。 在函数中返回结果主要有两种情况：函数正常运行并返回它的结果，以及错误的情况，要么因为一个错误的输入参数，要么因为其他导致函数无法完成计算或任务的原因。 如果你在面对第二种情况时不想抛出异常，返回一个值（比如说 None 或 False ）来表明函数无法正确运行，可能是需要的。在这种情况下，越早返回所发现的不正确上下文越好。 这将帮助扁平化函数的结构：我们假定在『因为错误而返回』的语句后的所有代码都能够满足函数主要结果运算。这种类型的多发挥结果，是有必要的。 然而，当一个函数在其正常运行过程中有多个主要出口点时，它会变得难以调试其返回结果，所以保持单个出口点可能会更好。这也将有助于提取某些代码路径，而且多个出口点很有可能意味着这里需要重构： 1234567891011def complex_function(a, b, c): if not a: return None # 抛出一个异常可能会更好 if not b: return None # 抛出一个异常可能会更好 # 一些复杂的代码试着用 a,b,c 来计算x # 如果成功了，抵制住返回 x 的诱惑 if not x: # 使用其他的方法来计算出 x return x # 返回值 x 只有一个出口点有利于维护代码 习语（Idiom）编程习语，说得简单些，就是写代码的 方式。编程习语的概念在 c2 和 Stack Overflow 上有详尽的讨论。 符合习语的 Python 代码通常被称为 Pythonic。 通常只有一种、而且最好只有一种明显的方式去编写代码。对 Python 初学者来说，无意识的情况下很少能写出习语式 Python 代码，所以应该有意识地去获取习语的书写方式。 如下有一些常见的Python习语： 解包（Unpacking）如果你知道一个列表或者元组的长度，你可以将其解包并为它的元素取名。比如，enumerate() 会对 list 中的每个项提供包含两个元素的元组： 12for index, item in enumerate(some_list): # do something with index and item 你也能通过这种方式交换变量： 1a, b = b, a 嵌套解包也能工作： 1a, (b, c) = 1, (2, 3) Python 3 提供了扩展解包的新方法在 PEP 3132 有介绍： 1234a, *rest = [1, 2, 3]# a = 1, rest = [2, 3]a, *middle, c = [1, 2, 3, 4]# a = 1, middle = [2, 3], c = 4 创建一个被忽略的变量如果你需要赋值（比如，在 解包（Unpacking） ）但不需要这个变量，请使用 __: 12filename = 'foobar.txt'basename, __, ext = filename.rpartition('.') 注意许多 Python 风格指南建议使用单下划线的 _ 而不是这里推荐的双下划线 __ 来标记废弃变量。问题是， _ 常用在作为 gettext() 函数的别名，也被用在交互式命令行中记录最后一次操作的值。相反，使用双下划线 十分清晰和方便，而且能够消除使用其他这些用例所带来的意外干扰的风险。 创建一个含 N 个对象的列表使用 Python 列表中的 * 操作符： 1four_nones = [None] * 4 创建一个含 N 个列表的列表因为列表是可变的，所以 * 操作符（如上）将会创建一个包含 N 个且指向 同一个 列表的列表，这可能不是你想用的。取而代之，请使用列表解析： 1four_lists = [[] for __ in xrange(4)] 注意：在 Python 3 中使用 range() 而不是 xrange()。 根据列表来创建字符串创建字符串的一个常见习语是在空的字符串上使用 str.join() ： 12letters = ['s', 'p', 'a', 'm']word = ''.join(letters) 这会将 word 变量赋值为 spam。这个习语可以用在列表和元组中。 在集合体（collection）中查找一个项有时我们需要在集合体中查找。让我们看看这两个选择，列表和集合（set），用如下代码举个例子： 12345678s = set(['s', 'p', 'a', 'm'])l = ['s', 'p', 'a', 'm']def lookup_set(s): return 's' in sdef lookup_list(l): return 's' in l 即使两个函数看起来完全一样，但因为 查找集合 是利用了 Python 中的『集合是可哈希』的特性，两者的查询性能是非常不同的。为了判断一个项是否在列表中，Python 将会查看每个项直到它找到匹配的项。这是耗时的任务，尤其是对长列表而言。另一方面，在集合中， 项的哈希值将会告诉 Python 在集合的哪里去查找匹配的项。结果是，即使集合很大，查询的速度也很快。在字典中查询也是同样的原理。想了解更多内容，请见 StackOverflow 。想了解在每种数据结构上的多种常见操作的花费时间的详细内容， 请见 此页面。 因为这些性能上的差异，在下列场景中，使用集合或者字典而不是列表，通常会是个好主意： 集合体中包含大量的项； 你将在集合体中重复地查找项； 你没有重复的项。 对于小的集合体、或者你不会频繁查找的集合体，建立哈希带来的额外时间和内存的开销经常会大过改进搜索速度所节省的时间。 Python之禅又名 PEP 20, 是 Python 设计的指导原则。 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those!Python之禅 by Tim Peters优美胜于丑陋（Python 以编写优美的代码为目标）明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）可读性很重要（优美的代码是具备高可读性的）即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）不要包容所有错误，除非您确定需要这样做（精准地捕获异常，不写 `except:pass` 风格的代码）当存在多种可能，不要尝试去猜测而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）虽然这并不容易，因为您不是 Python 之父（这里的 Dutch 是指 Guido ）做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）如果您无法向人描述您的方案，那肯定不是一个好方案；反之亦然（方案测评标准）命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召） 想要了解一些 Python 优雅风格的例子，请见 这些来自于 Python 用户的幻灯片。 PEP 8PEP 8 是 Python 实际意义上的代码风格指南，我们可以在 pep8.org 上获得高质量的、可读性更高的 PEP 8 版本。 强烈推荐阅读这部分。整个 Python 社区都尽力遵循本文档中规定的准则。这其中，一些项目可能受其影响， 而其他项目可能 修改其建议。 也就是说，让你的 Python 代码遵循 PEP 8 通常是个好主意，这也有助于在与其他开发人员 一起工作时使代码更加具一致性。命令行程序 pycodestyle https://github.com/PyCQA/pycodestyle （以前叫做pep8），可以检查代码一致性。在你的终端上运行以下命令来安装它： 1$ pip install pycodestyle 然后，对一个文件或者一系列的文件运行它，来获得任何违规行为的报告： 123456789$ pycodestyle optparse.pyoptparse.py:69:11: E401 multiple imports on one lineoptparse.py:77:1: E302 expected 2 blank lines, found 1optparse.py:88:5: E301 expected 1 blank line, found 0optparse.py:222:34: W602 deprecated form of raising exceptionoptparse.py:347:31: E211 whitespace before '('optparse.py:357:17: E201 whitespace after '&#123;'optparse.py:472:29: E221 multiple spaces before operatoroptparse.py:544:21: W601 .has_key() is deprecated, use 'in' 程序 autopep8 能自动将代码格式化成 PEP 8 风格。用以下指令安装此程序： 1$ pip install autopep8 用以下指令格式化一个文件： 1$ autopep8 --in-place optparse.py 不包含 --in-place 标志将会使得程序直接将更改的代码输出到控制台，以供审查。 --aggressive 标志则会执行更多实质性的变化，而且可以多次使用以达到更佳的效果。 约定这里有一些你应该遵循的约定，以让你的代码更加易读。 检查变量是否等于常量你不需要明确地比较一个值是 True，或者 None，或者 0 - 你可以仅仅把它放在 if 语句中。 参阅 真值测试 来了解什么被认为是 false： 糟糕: 12345if attr == True: print 'True!'if attr == None: print 'attr is None!' 优雅: 1234567891011# 检查值if attr: print 'attr is truthy!'# 或者做相反的检查if not attr: print 'attr is falsey!'# 或者，None 等于 false，你可以直接相较它进行匹配if attr is None: print 'attr is None!' 访问字典元素不要使用 dict.has_key()方法。 相反，使用 x in d 语法，或者将默认参数传递给 dict.get() 方法。 坏的示例： 12345d = &#123;'hello': 'world'&#125;if d.has_key('hello'): print d['hello'] # prints 'world'else: print 'default_value' 推荐的示例: 12345678d = &#123;'hello': 'world'&#125;print d.get('hello', 'default_value') # prints 'world'print d.get('thingy', 'default_value') # prints 'default_value'# 或者:if 'hello' in d: print d['hello'] 操作列表的简便方法列表推导式 提供了一个强大并且简洁的方法来对列表价进行操作。除此之外，map() 和 filter() 函数在列表的操作上也是非常简洁的。 坏: 123456# Filter elements greater than 4a = [3, 4, 5]b = []for i in a: if i &gt; 4: b.append(i) 好: 1234a = [3, 4, 5]b = [i for i in a if i &gt; 4]# Or:b = filter(lambda x: x &gt; 4, a) 坏: 1234# Add three to all list members.a = [3, 4, 5]for i in range(len(a)): a[i] += 3 好: 1234a = [3, 4, 5]a = [i + 3 for i in a]# Or:a = map(lambda i: i + 3, a) 使用 enumerate() 来跟踪正在被处理的元素索引。 1234567a = [3, 4, 5]for i, item in enumerate(a): print i, item# prints# 0 3# 1 4# 2 5 比起手动计数，使用enumerate() 函数有更好的可读性，而且，他更加适合在迭代器中使用。 读文件使用 with open 语法来读文件，它能够为你自动关闭文件。 坏: 1234f = open('file.txt')a = f.read()print af.close() 好: 123with open('file.txt') as f: for line in f: print line 即使在 with 控制块中出现了异常，它也能确保你关闭了文件，因此，使用 with 语法是更加优雅的。 行的延续当一个代码逻辑行的长度超过可接受的限度时，你需要将之分为多个物理行。如果行的结尾是一个反斜杠，Python 解释器会把这些连续行拼接在一起。这在某些情况下很有帮助， 但我们总是应该避免使用，因为它的脆弱性：如果在行的结尾，在反斜杠后加了空格，这会破坏代码，而且可能有意想不到的结果。 一个更好的解决方案是在元素周围使用括号。左边以一个未闭合的括号开头，Python 解释器会把行的结尾和下一行连接起来直到遇到闭合的括号。同样的行为适用中括号和大括号。 糟糕： 123456my_very_big_string = \"\"\"For a long time I used to go to bed early. Sometimes,\\ when I had put out my candle, my eyes would close so quickly that I had not even\\ time to say \"I'm going to sleep.\"\"\"\"from some.deep.module.inside.a.module import a_nice_function, another_nice_function,\\ yet_another_nice_function 优雅： 12345678my_very_big_string = ( \"For a long time I used to go to bed early. Sometimes, \" \"when I had put out my candle, my eyes would close so quickly \" \"that I had not even time to say \"I'm going to sleep.\"\")from some.deep.module.inside.a.module import ( a_nice_function, another_nice_function, yet_another_nice_function) 尽管如此，通常情况下，必须去分割一个长逻辑行意味着你同时想做太多的事，这可能影响可读性。 参考资料 Python漫游指南","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"Hitchhiker's Guide to Python-代码结构","date":"2018-09-15T04:28:12.303Z","path":"2018/09/15/Hitchhiker’s-Guide-to-Python-代码结构/","text":"这里我们所说的「结构」就是关于如何让项目达到预期的目标。我们需要考虑的是如何更好的利用 Python 的特性创造出干净、有效的代码。实际上，「结构」意味着代码的结构、依赖非常的清晰，像文件系统中的文件和文件夹一样。 哪些函数应该放在哪个模块中？项目中的数据流是怎样的？哪些函数应该组织在一起或者分离开？从广义上讲，通过回答这些问题，你就可以开始规划你的项目长什么样子。 在本节中，我们将深入研究 Python 的模块和导入系统，因为它们是项目结构中的核心元素。然后我们将探讨如何构建可扩展易测试的代码结构的各种观点。 仓库结构That is important!就像代码风格，API 设计和自动化对于健康的开发周期是必不可少的，仓库结构也是项目体系结构中的重要组成部分。 当一个潜在用户或贡献者打开你的仓库页面，他们将看到： 项目名称 项目描述 大堆的文件 只有当他们在下滑滚动时，才能看到项目里的自述文档。 如果你的仓库包含了大量的垃圾文件或者混乱嵌套的目录结构，即使有漂亮的自述文档，用户也可能尚未看到就前往查看其他项目了。 为你想要的工作而装扮，而不是你现在做的工作而装扮。 当然，第一印象并不代表全部。你和你的同事可能花费数个小时在这个仓库中，最终对每个细节都非常熟悉。它的布局很重要。 简单的仓库简述: 这个仓库是 Kenneth Reitz 的建议。 可以在 GitHub 上看到。 1234567891011README.rstLICENSEsetup.pyrequirements.txtsample/__init__.pysample/core.pysample/helpers.pydocs/conf.pydocs/index.rsttests/test_basic.pytests/test_advanced.py 让我们深入了解一些细节。 具体模块 位置 ./sample/ 或 ./sample.py 目的 具体代码 模块包是仓库的核心。它不应该被藏起来： 1./sample/ 如果你的模块内只有一个文件，你可以直接把这个文件放在仓库的根目录下： 1./sample.py 你的模块不应属于一个模糊的 src 目录或 python 的子目录。 授权 位置 ./LICENSE 目的 法律相关 除了源码本身外，这可以说是仓库中最重要的部分。在这个文件中应该包含完整的许可证文本和版权声明。 如果你不确定项目中应该使用哪种授权，请参考 choosealicense.com 。 当然，你也可以发布不包含授权的代码，但这可能会让很多人不去使用你的代码。 Setup.py 位置 ./setup.py 目的 包安装和分发管理 如果你的模块包在仓库的根目录下，这个文件也应该位于根目录。 依赖文件 位置 ./requirements.txt 目的 开发中的依赖 pip requirements file 应该放置在仓库的根目录下。它应指出项目所需的依赖关系，包括测试、构建和生成文档过程中的。 如果该项目开发不需要依赖，或者你喜欢通过 setup.py 安装开发环境，这个文件可能不是必须的。 文档 位置 ./docs/ 目的 项目的参考文档 没有理由把它放在其他地方。 测试套件有关编写测试的建议，请参考 Testing Your Code 。 位置 ./test_sample.py 或 ./tests 目的 软件包集成和单元测试 开始时，一个小的测试套件经常在一个文件中： 1./test_sample.py 一旦测试套件多起来时，可以像这样把各套件放在一个文件夹中： 12tests/test_basic.pytests/test_advanced.py 显然，这些测试套件需要你导入包模块才能运行测试。你可以通过这些方法来做： 将包安装在 site-packages 中。 使用一个简单（但是明确）的路径去修正解决它。 我强烈推荐后者。需要开发者在修改代码后主动运行 setup.py develop 去测试，也需要为每个代码库实例设置独立的运行环境。 要给单个测试导入上下文，请创建一个 tests/context.py 文件： 12345import osimport syssys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))import sample 然后，在各个测试模块中导入这个上下文模块： 1from .context import sample 无论安装方式如何，这通常都会像预期那样工作。 有的人会建议你应该把测试放在你自己的代码模块内，我不同意这个观点。这通常会增加用户的复杂性，而且许多的测试套件往往需要额外的依赖和运行时上下文。 Makefile 位置 ./Makefile 目的 通用的管理任务。 如果你看过我的大部分项目或任何 Pocoo 项目，你都会注意到有一个 Makefile 文件。 为什么？ 这些项目不是用 C 语言编写的… 简而言之， make 是一个定义项目通用任务的非常有用的工具。 一个简单的 Makefile： 1234567init: pip install -r requirements.txttest: py.test tests.PHONY: init test 其他通用的管理脚本（例如 manage.py 或 fabfile.py ）也应放在仓库的根目录。 关于 Django 应用程序自从 Django 1.4发布以来，我注意到了 Django 应用程序的一个新趋势。 由于新的捆绑应用程序模板，许多开发人员构建其仓库的效果很差。 怎样做的呢？他们总是在一个新的仓库中运行以下内容： 1$ django-admin.py startproject samplesite 这样生成的仓库结构如下： 12345README.rstsamplesite/manage.pysamplesite/samplesite/settings.pysamplesite/samplesite/wsgi.pysamplesite/samplesite/sampleapp/models.py 不要这样做。 重复的路径会让你的工具和开发人员感到困惑。不必要的嵌套对任何人都没有帮助（除非他们怀念单一的 SVN 仓库）。 让我们正确的做到这一点： 1$ django-admin.py startproject samplesite . 注意那个 . 。 由此生成的仓库结构如下： 12345README.rstmanage.pysamplesite/settings.pysamplesite/wsgi.pysamplesite/sampleapp/models.py 代码结构是关键Python 处理了导入和模块，因此构建 Python 项目相对容易。容易是指没有太多的约束，并且模块导入模型很容易掌握。因此，您所剩的是纯架构方面的任务，比如设计项目的不同点及其交互。 一个项目的结构简单意味着它也很容易做得不好。结构不佳的项目包括以下一些特征： 多个杂乱的循环依赖关系：假如 furn.py 中 Table (桌子) 和 Chair （椅子）类需要从 workers.py 导入 Carpenter （木匠） 来回答诸如 table.isdoneby() 的问题；相反地，假如 Carpenter 类需要导入 Table 和 Chair 来回答诸如 carpenter.whatdo() 的问题。这样，就产生了一个循环依赖关系。在这种情况下，你不得不凭借脆弱的技巧，例如在方法或函数内使用导入语句。 隐藏的耦合关系： Table 实现中的每一次更改会在不相关的测试用例中中断20次测试，因为它破坏了 Carpenter 的代码，需要非常仔细的处理来适应此次更改。这意味着在 Carpenter 中有较多关于 Table 的假设，或在 Table 中有较多关于 Carpenter 的假设。 对全局状态或上下文的大量使用： Table 和 Carpenter 依赖于可修改的全局变量（可由不同的代理进行修改），而不是显式传递 (高度、宽度、类型、木材) 。你需要检查对这些全局变量的所有访问，以了解为什么长方形桌子变成了正方形，然后发现远程模板代码也在修改此上下文，从而弄乱了桌子的尺寸。 “意大利面条”式代码: 代码有多页嵌套 if 子句、 for 循环，有大量的复制粘贴程序代码，并没有适当的分块称为“意大利面条”式代码。 Python 的有意义的缩进 (最具争议性的特征之一) 使得维护这种代码变得非常困难。好消息是你可能看不到太多这种情况。 在 Python 中更有可能看到的是“意大利饺子”式代码：它由数百个类似的小逻辑片段组成，通常是类或对象，没有适当的结构。如果你不记得是否应该使用 FurnitureTable 、 AssetTable ，还是 TableNew 来完成手头上的任务，那么你可能会在“意大利饺子”式代码中漫无目的地游着。 模块Python 模块是可用的主要抽象层之一，也是最自然的一个。抽象层允许将代码分成包含相关数据和功能的多个部分。 例如，项目的一层可以处理用户操作的接口，而另一层可以处理数据的底层操作。将这两层分离最自然的方法是：将所有接口功能组合在一个文件中，而在另一个文件中组合数据底层操作。在这种情况下，接口文件需要导入数据底层操作文件，这是通过 import 和 from... import 语句完成的。 一旦使用 import 语句，就会使用模块。这些模块可以是内置的模块，如 os 和 sys、环境中安装的第三方模块，或项目中的内部模块。 要与样式指南保持一致，需保持模块名称简短、小写，并确保避免使用特殊符号，如点（.）或问号（？）。所以应该避免像 my.spam.py 这样的文件名！以这种方式命名会影响 Python 查找模块的方式。 在这个 my.spam.py 情况下， Python 希望在名为 my 的文件夹中找到一个 spam.py 文件，但不应该这样命名。在 Python 文档中有一个应该如何使用点表示法的 例子 。 如果你希望将模块命名为 my_spam.py ，但其实下划线也不应该在模块名称中经常出现。在模块名称中使用其他字符（空格或连字符）将会阻止导入（- 是减操作符），因此请尽量保持模块名称的简短，这样就不需要将单词分开了。而且，最重要的是，不要使用带下划线的名称空间，应该使用子模块。 1234# 可以import library.plugin.foo# 不行import library.foo_plugin 除了一些命名限制之外， Python 文件并不是一个特殊的模块，但你需要了解导入机制才能正确使用这个概念并避免一些问题。 具体地说， import modu 语句会去查找正确的文件，首先会在调用者所在的目录中查找 modu.py 。如果找不到，Python 解释器将递归搜索 “path” 中的 modu.py 。如果未找到，则引发 ImportError 异常。 一旦找到 modu.py ，Python 解释器将在一个隔离的空间内执行该模块。 modu.py 中的任何顶级语句都将被执行，包括其他导入（如果有的话）。 函数和类的定义存储在模块的字典中。 然后，模块的变量，函数和类将通过模块的名称空间提供给调用者，这是编程中的一个核心理念，在 Python 中特别有用而且功能强大。 在许多语言中，预处理器使用 include file 指令来获取文件中的所有代码，并将其复制到调用者的代码中。 这在 Python 中有所不同：导入的代码会被隔离在模块的命名空间内，这意味着你通常不必担心导入代码可能会产生不需要的效果，例如导入模块中有用相同的名称不会覆盖已有的函数。 通过使用 import 语句的特殊语法可以模拟更标准的行为：from modu import *。 这通常被认为是不好的做法。 使用 import * 会使代码更难阅读，并使得依赖更少的分块。 使用 from modu import func 是一种精确定位您想要导入的函数并将其放入全局命名空间的方法。 它比 import * 危害更小，因为它显式地显示了在全局命名空间中要导入的内容，它比简单的 import modu 的唯一优点是它可以节省一些输入。 非常槽糕 1234[...]from modu import *[...]x = sqrt(4) # sqrt是modu的一部分吗? 内置的? 上面定义了? 好一点的 123from modu import sqrt[...]x = sqrt(4) # sqrt 可能是modu的一部分, 如果不在之间重新定义的话 最佳 123import modu[...]x = modu.sqrt(4) # sqrt显然是modu的命名空间的一部分 如 Code Style 部分所述, 可读性是 Python 的主要特性之一。可读性意味着避免无用的样板文字和混乱，因此有必要花费一些努力来达到一定程度的简洁性上。但简洁不是简短和晦涩难懂。如 modu.func 的习惯用法，就能够立即判断类或函数来自何处。 除了最简单的单个文件项目之外，这样写可以大大提高了代码的可读性和可理解性。 包系统Python 提供了一个非常简单的封装系统，它只是模块机制到目录的扩展。 任何一个带有 __init__.py 文件的目录都被认为是 Python 包。包中的不同模块以类似于普通模块的方式导入，但 __init__.py 文件具有特殊的行为，该文件用于收集所有包范围的定义。 一个在目录 pack/ 中的 modu.py 文件通过语句 import pack.modu 来导入。这个语句将在 pack 目录中查找 __init__.py 文件，并执行其所有顶级语句。接着它将查找一个叫 pack/modu.py 的文件并执行其所有顶级语句。在这些操作时候定义在 modu.py 中的任何变量，函数或类都在 pack.modu 命名空间中可用。 一个常见的问题是添加太多的代码到 __init__.py 文件中。当项目的复杂度增长时，在深层目录结构中可能由子包和子子包。在这种情况下，从子子包中导入单个项时遍历目录树时将需要执行所有 __init__.py 文件。 如果一个包的模块和子包不需要共享任何代码，那么让 __init__.py 文件保持为空是正常的，甚至是一个好的实践。 最后，一个简便的语法可以用来导入深度嵌套的包：import very.deep.module as mod 这允许你使用 mod 来代替冗长罗嗦的 very.deep.module。 面向对象编程Python 有时被描述为一种面向对象的编程语言。这可能对大家有些误导，需要加以澄清。 在 Python 中，所有东西都视为一个对象，并且可以按对象处理。当我们说，函数是“一级”对象，就是将函数视为对象的意思。函数、类、字符串，甚至类型都是 Python 中的对象：像任何对象一样，它们有一个类型，可以作为函数参数传递，并且它们可能有方法和属性。按这种理解， Python 是一种面向对象的语言。 但是，与 Java 不同， Python 并没有将面向对象的编程作为主要的编程范例来实施。 Python 项目不采用面向对象的方式是完全可行的，即不使用或很少使用类定义、类继承或特定于面向对象编程的任何其他机制。 此外，从 模块 部分可以看出， Python 处理模块和名称空间的方式为开发人员提供了一种自然的方法来确保抽象层的封装和分离，这两者都是使用面向对象的最常见原因。因此，当业务模型不需要面向对象时， Python 程序员有更大的自由来不使用面向对象编程。 基于一些因素的考虑，我们应避免不必要的面向对象编程。当我们想将一些状态和功能粘合在一起时，定义自定义类是很有用的。在函数编程的讨论中，我们指出，“不必要的面向对象编程”这个问题出自方程的“状态”部分。 在某些体系结构中，例如典型的 web 应用程序，会生成多个 Python 进程实例，以响应可能同时发生的外部请求。在这种情况下，将一些状态保存到实例对象中，意味着保留一些关于世界的静态信息，这很容易出现并发或竞争问题。有时，在对象的初始化（通常用 __init__() 方法来完成）状态和实际使用对象方法的状态之间，世界信息可能已经改变，保持的状态可能已经过时。例如，一个请求加载了内存中的某一项，并将其标记为由用户读取。而另一个请求同时要求删除该项，这可能发生在第一个进程加载该项之后，然后我们必须将其标记为已删除对象。 上述以及其他问题引出了这样的想法：使用无状态函数是一种更好的编程范例。 另一种说法是建议尽可能少的使用具有隐式上下文和副作用的函数和程序。函数的隐式上下文由全局变量和持久层中的数据项（使用方法访问）组成。副作用是指函数对其隐式上下文所做的更改。如果函数会保存或删除全局变量或持久层中的数据，则称它有副作用。 将有上下文和副作用的函数与逻辑函数（称为纯函数）隔离开来，可以获得以下好处： 纯函数是确定性的：给定一个固定的输入，输出始终是相同的。 纯函数需要重构或优化时，更容易更改或替换。 纯函数更易于使用单元测试进行测试：对于复杂的上下文设置和事后的数据清理的需求更少。 纯函数更容易操作、修饰和传递。 总之，针对某些体系结构，由于没有上下文或副作用，纯函数是比类和对象更有效的构建块。 显然，面向对象编程在许多情况下是有用的，甚至是必要的，例如在开发图形化桌面应用程序或游戏时，被操作的东西（窗口、按钮、化身、车辆）在计算机内存中具有相对较长的寿命。 装饰器Python 语言提供了一种简单而强大的语法，称为“装饰器”。装饰器是一个函数或类，它包装（或装饰）了函数或方法。装饰器函数或方法将替换原来“未装饰”的函数或方法。因为函数是 Python 中的一级对象，所以可以“手动”完成（参见下述示例），但是使用 @decorator 语法则更清晰，也更受青睐。 12345678910111213def foo(): # 一些操作def decorator(func): # 处理 func return funcfoo = decorator(foo) # 手动装饰@decoratordef bar(): # 一些操作# bar() 被装饰了 此机制对于分离关注点和避免外部非相关逻辑“污染”函数或方法的核心逻辑很有用。最好采用装饰器来处理的一个功能示例是 备注 或缓存：你希望将计算非常耗时/耗空间的函数的结果存储在表中，并直接使用这些结果，而不是在已经计算过以后重新调用并计算。这显然不是函数逻辑的一部分。 上下文管理器上下文管理器是一个 Python 对象，为操作提供了额外的上下文信息。 这种额外的信息， 在使用 with 语句初始化上下文，以及完成 with 块中的所有代码时，采用可调用的形式。 这里展示了使用上下文管理器的为人熟知的示例，打开文件： 12with open('file.txt') as f: contents = f.read() 任何熟悉这种模式的人都知道以这种形式调用 open 能确保 f 的 close 方法会在某个时候被调用。 这样可以减少开发人员的认知负担，并使代码更容易阅读。 实现这个功能有两种简单的方法：使用类或使用生成器。 让我们自己实现上面的功能，以使用类方式开始： 123456789101112class CustomOpen(object): def __init__(self, filename): self.file = open(filename) def __enter__(self): return self.file def __exit__(self, ctx_type, ctx_value, ctx_traceback): self.file.close()with CustomOpen('file') as f: contents = f.read() 这只是一个常规的 Python 对象，它有两个由 with 语句使用的额外方法。 CustomOpen 首先被实例化，然后调用它的 __enter__ 方法，而且 __enter__ 的返回值在 as f 语句中被赋给 f 。 当 with 块中的内容执行完后，会调用 __exit__ 方法。 现在我们演示生成器方式，我们将使用了 Python 自带的 contextlib: 123456789101112from contextlib import contextmanager@contextmanagerdef custom_open(filename): f = open(filename) try: yield f finally: f.close()with custom_open('file') as f: contents = f.read() 这与上面的类示例道理相通，尽管它更简洁。custom_open 函数一直运行到 yield 语句。 然后它将控制权返回给 with 语句，然后在 as f 部分将 yield 的 f 赋值给 f。 finally 确保不论 with 中是否发生异常， close() 都会被调用。 由于这两种方法都是一样的，所以我们应该遵循 Python 之禅来决定何时使用哪种。 如果封装的逻辑量很大，则类的方法可能会更好。 而对于处理简单操作的情况，函数方法可能会更好。 动态类型Python 是动态类型语言，这意味着变量并没有固定的类型。实际上，Python 中的变量和其他语言有很大的不同，特别是静态类型语言。变量并不是计算机内存中被写入的某个值，它们只是指向内存的『标签』或『名称』。因此可能存在这样的情况，变量 a 先代表值 1，然后变成 字符串 a string , 然后又变为指向一个函数。 Python 的动态类型常被认为是它的缺点，的确这个特性会导致复杂度提升和难以调试的代码。 命名为 a 的变量可能是各种类型，开发人员或维护人员需要在代码中追踪命名，以保证它 没有被设置到毫不相关的对象上。 这里有些避免发生类似问题的参考方法： 避免对不同类型的对象使用同一个变量名 不推荐 1234a = 1a = 'a string'def a(): pass # Do something 推荐 1234count = 1msg = 'a string'def func(): pass # Do something 使用简短的函数或方法能降低对不相关对象使用同一个名称的风险。 即使是相关的不同 类型的对象，也更建议使用不同命名： 不推荐 123items = 'a b c d' # This is a string...items = items.split(' ') # ...becoming a listitems = set(items) # ...and then a set 重复使用命名对效率并没有提升：赋值时无论如何都要创建新的对象。然而随着复杂度的提升，赋值语句被其他代码包括 if 分支和循环分开，使得更难查明指定变量的类型。 在某些代码的做法中，例如函数编程，推荐的是从不重复对同一个变量命名赋值。Java 内的实现方式是使用 final 关键字。Python 并没有 final 关键字而且这与它的哲学 相悖。尽管如此，避免给同一个变量命名重复赋值仍是是个好的做法，并且有助于掌握 可变与不可变类型的概念。 可变和不可变类型Python提供两种内置或用户定义的类型。 可变类型允许内容的内部修改。典型的动态类型 包括列表与字典：列表都有可变方法，如 list.append() 和 list.pop()， 并且能就地修改。字典也是一样。 不可变类型没有修改自身内容的方法。比如，赋值为整数 6 的变量 x 并没有 “自增” 方法，如果需要计算 x + 1，必须创建另一个整数变量并给其命名。 123456my_list = [1, 2, 3]my_list[0] = 4print my_list # [4, 2, 3] &lt;- The same list has changedx = 6x = x + 1 # The new x is another object 这种差异导致的一个后果就是，可变类型是不 ‘稳定 ‘的，因而不能作为字典的键使用。 合理地使用可变类型与不可变类型有助于阐明代码的意图。 例如与列表相似的不可变类型是元组， 创建方式为 (1, 2)。元组是不可修改的，并能作为字典的键使用。 Python 中一个可能会让初学者惊讶的特性是：字符串是不可变类型。这意味着当需要组合一个 字符串时，将每一部分放到一个可变列表里，使用字符串时再组合 (join) 起来的做法更高效。 值得注意的是，使用列表推导的构造方式比在循环中调用 append() 来构造列表更好也更快。 还有一个选项是使用 map 函数，它可以 map 一个函数 str 到可序列化对象上 ( 例如 range(20))。 结果会产生一个集合，你可以对结果进行 join 在一起，就如其他的例子一样。map 函数在一些场景下速度会更快。 差 12345# 从 0 到 19 创建一个连续的字符串（例如「012..1819」）nums = \"\"for n in range(20): nums += str(n) # slow and inefficientprint nums 好 12345# 从 0 到 19 创建一个连续的字符串（例如「012..1819」）nums = []for n in range(20): nums.append(str(n))print \"\".join(nums) # much more efficient 较好 123# 从 0 到 19 创建一个连续的字符串（例如「012..1819」）nums = [str(n) for n in range(20)]print \"\".join(nums) 最好 123# 从 0 到 19 创建一个连续的字符串（例如「012..1819」）nums = map(str, range(20))print \"\".join(nums) 最后关于字符串的说明的一点是，使用 join() 并不总是最好的选择。比如当用预先确定数量的字符串创建一个新的字符串时，使用加法操作符确实更快，但在上文提到的情况 下或添加到已存在字符串的情况下，使用 join() 是更好的选择。 123456foo = 'foo'bar = 'bar'foobar = foo + bar # This is goodfoo += 'ooo' # This is bad, instead you should do:foo = ''.join([foo, 'ooo']) 注意除了 str.join() 和 +，您也可以使用 % 格式运算符来连接确定数量的字符串，但 PEP 3101 建议使用 str.format() 替代 % 操作符。 123456foo = 'foo'bar = 'bar'foobar = '%s%s' % (foo, bar) # It is OKfoobar = '&#123;0&#125;&#123;1&#125;'.format(foo, bar) # It is betterfoobar = '&#123;foo&#125;&#123;bar&#125;'.format(foo=foo, bar=bar) # It is best 参考资料 Python漫游指南 http://www.diveintopython.net/toc/index.html","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"部署postgresql","date":"2018-09-11T06:55:29.804Z","path":"2018/09/11/部署postgresql/","text":"部署postgres数据库(Docker)使用sameersbn/postgresql工作目录:/home/postgres1234567891011121314postgresql: restart: always image: sameersbn/postgresql:9.6-2 volumes: - $PWD:/var/lib/postgresql - /var/run/postgresql/:/var/run/postgresql/ - /home/nucleus-d1/rsyncd/data/:/home/nucleus-d1/rsyncd/data/ - /home/postgres/zhangxiaohao/:/home/postgres/zhangxiaohao/ environment: - DB_USER=postgres - DB_PASS=xxxxx - DB_EXTENSION= ports: - &quot;0.0.0.0:5432:5432&quot; 9.6/main/pg_hba.conf # 权限配置12345678910# &quot;local&quot; is for Unix domain socket connections onlylocal all all trusthost all all 112.94.5.240/28 md5host all all 192.168.0.0/16 md5host all all 0.0.0.0/0 md5# IPv4 local connections:host all all 127.0.0.1/32 trusthost all all 112.94.5.240/28 md5host all all 192.168.0.0/16 md5host all all 0.0.0.0/0 md5 开放办公室ssh通道连接pgsql数据库 centos 安装postgresql-client1yum -y install postgresql 修改默认密码1alter user postgres with password xxx 配置java应用连接pgsql数据库123- data_center_jdbc_url=jdbc:postgresql://192.168.8.143:5432/d1_statistics?autoReconnect=true&amp;useUnicode=true&amp;rewriteBatchedStatements=true&amp;useSSL=false- data_center_jdbc_username=postgres- data_center_jdbc_password=xxx","tags":[]},{"title":"游戏服内外网穿透","date":"2018-09-11T06:14:35.348Z","path":"2018/09/11/游戏服内外网穿透/","text":"关于游戏服内外网穿透大致一个场景:公司网络区分了内外网，游戏服务器架设在内网，而手机连接wifi是属于外网，需要满足个需求，外网环境(公司wifi、或个人办工电脑机器)实现正常访问内网游戏服。 涉及HTTP七层的转发以及TCP四层的转发 大致原理:部署转发代理服(包含外网网卡)，通过NGinx代理转发请求，内外网DNS劫持，实现。因为Nginx从1.9版本开始支持了TCP四层的转发，故使用Nginx的Stream模块进行实现，此外使用开源的HAproxy也是一个解决方案。 逻辑图: 内外网穿透 内外网穿透 Nginx配置nginx.conf: 12345stream &#123; include /etc/nginx/vhost.d/01-proxy.conf;&#125; TCP转发: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 server &#123; listen 7011; proxy_pass 192.168.8.137:7011; &#125; server &#123; listen 7012; proxy_pass 192.168.8.137:7012; &#125;server &#123; listen 27011; proxy_pass 192.168.8.137:27011;&#125;server &#123; listen 27012; proxy_pass 192.168.8.137:27012;&#125; server &#123; listen 27013; proxy_pass 192.168.8.137:27013;&#125;server &#123; listen 10004; proxy_pass 192.168.8.137:10004;&#125;server &#123; listen 10005; proxy_pass 192.168.8.137:10005;&#125;server &#123; listen 10006; proxy_pass 192.168.8.137:10006;&#125;server &#123; listen 10007; proxy_pass 192.168.8.137:10007;&#125;server &#123; listen 10008; proxy_pass 192.168.8.137:10008;&#125;server &#123; listen 10009; proxy_pass 192.168.8.137:10009;&#125;server &#123; listen 8111; proxy_pass 192.168.8.137:8111;&#125; HTTP转发: 123456789101112131415161718192021222324252627282930server &#123; listen 8080; listen 8443 ssl; server_name proxydevh7d.demigame.com; proxy_set_header Host $host; proxy_set_header X-Real-IP $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-For2 $proxy_add_x_forwarded_for; server_name_in_redirect off; include /home/nucleus-h7/global/nginx-137/conf/ssl.cfg; include /home/nucleus-h7/global/nginx-137/conf/vhost.d/games-out.cfg; error_log /home/nucleus-h7/global/nginx-137/logs/games_errors_log notice; access_log /home/nucleus-h7/global/nginx-137/logs/games_access_log combined; location ~* ^/ &#123; proxy_pass http://192.168.8.137; &#125; location ~* ^/h7d/download/ &#123; autoindex on; autoindex_localtime on; rewrite /h7d/(.*) /$1 break; proxy_pass http://192.168.8.137; &#125;&#125; PS:在内外网网关机器使用的是centos7 dnsmasq 1、在内网网关机器添加hosts劫持DNS，指向内网服务器的ip地址 2、在外网网关机器添加hosts劫持DNS，指向外网服务器的ip地址 3、测试解析 TODO: 1、目前H7的代理服h7-proxy-s189只有一个外网接口，所以采用新增虚接口的形式实现多网卡。 2、缺点:机器一重启虚拟接口就消失，需要手动执行命令 1ip a a 192.168.1.54/22 dev eth1","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"Docker 远程API调用启用TLS加密","date":"2018-09-11T05:06:02.930Z","path":"2018/09/11/Docker-远程API调用启用TLS加密/","text":"普通的HTTP模式（非常不安全）：服务端（CentOS 7，IP地址192.168.9.7）： sed -i 's/\\(OPTIONS=\"\\)/\\1-H 0.0.0.0:1699 /' /etc/sysconfig/docker # 也就是加入 -H 0.0.0.0:1699参数 ## 重启docker。 ## 客户端配置： echo 'export DOCKER_HOST=\"tcp://192.168.9.7:1699\"' >> ~/.bashrc source ~/.bashrc ## 测试： docker version ### 生成脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/bin/bash# vim:set et ts=4 sw=4:# 切换到当前目录current_dir=`dirname $0`current_dir=`readlink -f $current_dir`cd $&#123;current_dir&#125; &amp;&amp; export current_dir# headerexec 6&gt;&amp;1exec &gt; $&#123;0&#125;.stdoutexec 2&gt; $&#123;0&#125;.stderr_usage() &#123; exec 1&gt;&amp;6 6&gt;&amp;- echo '&#123; \"Action\": \"GenerateDockerTLSKey\", \"RetCode\": 1, \"Message\": \"Usage: ./docker-server-tlskey.sh IP1 IP2 PW\" &#125;' exit 1&#125;IP1=\"$1\"IP2=\"$2\"PW=\"$3\"# check input[ \"x$IP1\" == \"x\" ] || [ \"x$IP2\" == \"x\" ] || [ \"x$PW\" == \"x\" ] &amp;&amp; _usage# check IP1 or IP2if ! /sbin/ip a | egrep -q \"$&#123;IP1&#125;|$&#123;IP2&#125;\" ;then exec 1&gt;&amp;6 6&gt;&amp;- echo '&#123; \"Action\": \"GenerateDockerTLSKey\", \"RetCode\": 2, \"Message\": \"Error: IP1 or IP2 not fount\" &#125;' exit 2fi# check ca pem fileif [ ! -f ./ca.pem ] || [ ! -f ./ca-key.pem ] ;then exec 1&gt;&amp;6 6&gt;&amp;- echo '&#123; \"Action\": \"GenerateDockerTLSKey\", \"RetCode\": 3, \"Message\": \"ca.pem or ca-key.pem not fount\" &#125;' exit 3fiif [ -f /etc/docker/cert.pem ] ;then ips=$(openssl x509 \\ -certopt no_subject,no_header,no_version,no_serial,no_signame,no_validity,no_subject,no_issuer,no_pubkey,no_sigdump,no_aux \\ -noout -text -in /etc/docker/cert.pem ) i=0 if echo $ips | grep -q $IP1 ;then let i+=1 fi if echo $ips | grep -q $IP2 ;then let i+=1 fi if [ $i -eq 2 ];then exec 1&gt;&amp;6 6&gt;&amp;- echo '&#123; \"Action\": \"GenerateDockerTLSKey\", \"RetCode\": 0, \"Message\": \"NotChange\" &#125;' exit 0 fifi[ -d /etc/docker ] || mkdir -pv /etc/docker# 生成openssl genrsa -out server-key.pem 4096 \\ &amp;&amp; openssl req -subj \"/CN=$&#123;IP1&#125;\" -sha256 -new -key server-key.pem -out ./server.csr \\ &amp;&amp; echo subjectAltName = IP:$&#123;IP1&#125;,IP:$&#123;IP2&#125;,IP:127.0.0.1 &gt; ./extfile.cnf \\ &amp;&amp; openssl x509 -req -days 3650 -sha256 -passin pass:$PW \\ -in ./server.csr -CA ./ca.pem -CAkey ./ca-key.pem \\ -CAcreateserial -extfile ./extfile.cnf \\ -out /etc/docker/cert.pem \\ &amp;&amp; chmod 0444 /etc/docker/cert.pem \\ &amp;&amp; rm -f server.csr extfile.cnf ca.srl \\ &amp;&amp; cp ca.pem /etc/docker/ca.pem \\ &amp;&amp; cp server-key.pem /etc/docker/key.pem \\ &amp;&amp; systemctl enable dockerretvar=$?## 有时会遇到如下报错:#Warning! D-Bus connection terminated.#Failed to wait for response: Connection reset by peersystemctl start docker# footerexec 1&gt;&amp;6 6&gt;&amp;-if [ $retvar -eq 0 ] ;then echo '&#123; \"Action\": \"GenerateDockerTLSKey\", \"RetCode\": 0 &#125;' exit 0else echo '&#123; \"Action\": \"GenerateDockerTLSKey\", \"RetCode\": 1, \"Message\": \"openssl error\" &#125;' exit 1fi ### 手动生成脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/bin/bash# vim:set et ts=2 sw=2:# 切换到当前目录current_dir=`dirname $0`current_dir=`readlink -f $current_dir`cd $&#123;current_dir&#125; &amp;&amp; export current_dirIP1=\"$1\"IP2=\"$2\"_usage() &#123; echo \"Usage: $0 IP1 IP2\" exit 127&#125;# check input[ \"x$IP1\" == \"x\" ] || [ \"x$IP2\" == \"x\" ] &amp;&amp; _usage# check IP1 or IP2if ! /sbin/ip a | egrep -q \"$&#123;IP1&#125;|$&#123;IP2&#125;\" ;then echo \"ERROR: $&#123;IP1&#125; or $&#123;IP2&#125; not fount\" exit 126fiif [ -f /etc/docker/cert.pem ] ;then ips=$(openssl x509 \\ -certopt no_subject,no_header,no_version,no_serial,no_signame,no_validity,no_subject,no_issuer,no_pubkey,no_sigdump,no_aux \\ -noout -text -in /etc/docker/cert.pem ) i=0 if echo $ips | grep -q $IP1 ;then let i+=1 fi if echo $ips | grep -q $IP2 ;then let i+=1 fi if [ $i -eq 2 ];then echo \"not change, skip\" exit 0 else echo \"ip change\" fifiopenssl req -subj \"/CN=$&#123;IP1&#125;\" -sha256 -new -key server-key.pem -out ./server.csrecho subjectAltName = IP:$&#123;IP1&#125;,IP:$&#123;IP2&#125;,IP:127.0.0.1 &gt; ./extfile.cnfopenssl x509 -req -days 3650 -sha256 \\ -in ./server.csr -CA ./ca.pem -CAkey ./ca-key.pem \\ -CAcreateserial -extfile ./extfile.cnf \\ -out /etc/docker/cert.pem &amp;&amp; echo \"OK\"chmod 0444 /etc/docker/cert.pemrm -f server.csr extfile.cnf ca.srlcp ca.pem /etc/docker/ca.pemcp server-key.pem /etc/docker/key.pem # 启用HTTPS模式： ## 文档： https://docs.docker.com/engine/articles/https/ ## CA证书 ### 私钥（使用xlands做为密码）： openssl genrsa -aes256 -out ca-key.pem 4096 chmod 0400 ca-key.pem ### 签发申请（10年）： openssl req -new -x509 -days 3650 \\ -subj \"/C=CN/ST=GD/L=GZ/O=baoyugame/OU=baoyugame/CN=*.baoyugame.com\" \\ -sha256 -key ca-key.pem -out ca.pem chmod 0444 ca.pem ## 服务端证书： ### 私钥： openssl genrsa -out server-key.pem 4096 chmod 0400 server-key.pem ### 请求证书（设置HOST为不同IP地址就可以给其他主机签发证书）： HOST=192.168.9.7 openssl req -subj \"/CN=$HOST\" -sha256 -new -key server-key.pem -out server-$HOST.csr ### 需允许服务器的网卡IP地址： echo subjectAltName = IP:$HOST,IP:127.0.0.1 > extfile.cnf ### 签署 -（不带-extfile extfile.cnf参数）- ： openssl x509 -req -days 3650 -sha256 \\ -in server-$HOST.csr -CA ca.pem -CAkey ca-key.pem \\ -CAcreateserial -extfile extfile.cnf \\ -out server-cert-$HOST.pem chmod 0444 server-cert-$HOST.pem 删除请求证书： rm server-$HOST.csr ### 部署证书（复制到各自主机上）： #echo 'DOCKER_CERT_PATH=/etc/docker' | sudo tee -a /etc/sysconfig/docker #sed -i 's/\\(OPTIONS=\"\\)/\\1 --tlsverify ' /etc/sysconfig/docker cat extfile.cnf ### 签署： openssl x509 -req -days 3650 -sha256 -in client.csr -CA ../ca.pem -CAkey ../ca-key.pem \\ -CAcreateserial -extfile extfile.cnf \\ -out cert.pem chmod 0444 cert.pem cp ../ca.pem . ### 删除请求证书： rm client.csr extfile.cnf .srl ### 部署证书： mkdir ~/.docker/ cp ca.pem ~/.docker/ cp client-key.pem ~/.docker/key.pem cp client-cert.pem ~/.docker/cert.pem 客户端配置（默认启用TLS）： cat ~/.bashrc export DOCKER_HOST=\"tcp://192.168.9.7:1699\" export DOCKER_TLS_VERIFY=1 export DOCKER_CERT_PATH=/path/to/dir/tls-key/client EOF source ~/.bashrc 测试： docker version","tags":[]},{"title":"Docker 学习笔记","date":"2018-09-09T09:52:13.149Z","path":"2018/09/09/Docker-学习笔记/","text":"Docker有两个概念需要搞清楚,镜像与容器。 12镜像是从网上docker pub上拉取下来的镜像，拉取下来后可以使用docker run命令进行运行。# dockerhub 是官方构建的一个镜像仓库,类似github一样,上面累积了许多人上传制作的镜像,有官方,有的是用户上传的,任何人都可自由下载。 1容器是将镜像运行在一个容器中 Registry 123用户可以在自己的数据中心搭建私有的registry,也可以从官方使用docker官方的registry也就是docker hub.它是一个公共的镜像仓库，供用户下载和使用，dockerhub中有两种库。用户仓库和顶层库，用户仓库是有私人创建的，顶层使用docker公司负责维护的。 常用操作命令 12345678910111213141516171819docker images #查看从docker hub上下载到本地的镜像docker search #镜像名#从docker hub上搜索镜像docker pull #从docker registry中拉取镜像docker push #将本地制作好的镜像推送到docker hubdocker rm 容器id #删除容器命令docker rmi 镜像id #删除镜像 docker stop $(docker ps -a) #批量停止容器docker rm $(docker ps -a) # 批量删除容器docker rm $(docker ps -a|awk &apos;&#123;print $1&#125;&apos;|cut -f 1 -d &quot;C&quot;) # 批量删除容器docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq) #both###ps:docker rm 与docker rmi 都可以加 -f强制删除,需要注意的是如果删除镜像报错,如果基于镜像启动的容器存在,则无法直接删除,需要先删除容器再删除镜像。docker inspect # 查看镜像和容器的详细信息docker ps # 查看容器相关的信息，状态 选项 -a 列出所有容器的的状态 -l 列出最新的状态docker commit &lt;container_id&gt; &lt;some_name&gt; # 可以将一个容器固化为一个新的镜像,通过commit将镜像保存起来，也就是可以将一个环境配配置好的容器，保存，以后用到在拿出来使用。docker run -it -v --volumes-from --name --rm --privileged 镜像名字 # 以交互式运行容器 --name 只是一个名称，可以不加 --rm docker容器退出时将自动删除，注意如果容器运行在后台模式是不能带--rm的.需要映射多个端口使用多个-p 选项docker run 镜像名字 echo “hello world” # 在容器的shell中输出helloworlddocker logs 容器id #显示容器的标准输出docker attach 容器id #重新进入关闭的容器docker network inspect bridge docker命令结构: 首先有两个方面，一个是docker镜像制作端，一个是用户使用端类似C/S 架构。 使用docker build命令结合dockerfile可以创建管理镜像,创建完后可以push到docker hub。 用户可以通过从网上拉取制作好的镜像,拉取到本地,运行容器。 使用docker pull时,可以从官方docker hub中的官方镜像库,其他公共库,私人仓库,拉取镜像资源,同时也可以拉取私有服务器中获取镜像资源，只需指定特定的库名,或服务器地址即可。 如何临时退出一个正在交互的容器，而不是终止 1按ctrl-p+ctrl-q #ctrl -c 是终止停止进程 构建docker镜像应该遵循的原则,请参考官方文档，dockerfile最佳实践: 尽量选取满足需求但较小的基础系统镜像，例如大部分时候可以选择 debian:wheezy 或 debian:jessie 镜像，仅有不足百兆大小; 清理编译生成文件、安装包的缓存等临时文件; 安装各个软件时候要指定准确的版本号，并避免引入不需要的依赖; 从安全角度考虑，应用要尽量使用系统的库和依赖; 如果安装应用时候需要配置一些特殊的环境变量， 在安装后要还原不需要保持 的变量值; 使用 Dockerfile 创建镜像时候要添加 .dockerignore 文件或使用干净的工作目 录。 在构建docker容器时可以控制容器占用系统资源，调整系统硬件资源，例如cpu，内存，io等。 查看容器映射出来的端口。 1docker ps -f name=nginx 查看容器内应用监听的端口： 1docker exec -ti global_nginx_1 ss -lntp 制作镜像 两种办法:1.使用Dockerfile,使用docker commit 将容器提交保存为镜像.##最好使用Dockerfile来构建镜像,不推荐docker commit方法。 12345678910111213141516首先编辑一个空白的文本文件命名为DockerfIle，每一个指令的前缀都必须是大写的。FROM centos #从centos 这个镜像文件中构建,from字段必须是第一个，可以有多个from在文件中可以写入运行命令使其在docker容器中运行RUN echo ’hello world‘ ##在容器中运行的指令CMD ##ENV ##后续的指令可以调用变量 $&#123;variable_name&#125;WORKDIR ##MAINTAINER ## dockerfile会根据上下文执行的命令，使用缓存，如果修改了使用者名称，将刷新缓存EXPOSE ## 端口宣告ADD ##COPY ##docker build -t 给镜像一个名称 . #注意，最后有个点，这条命令会读取当前目录下的所有文件以及目录和Dockerfile文件，建议创建新目录来build之后使用 docker images 就可以看到自己建立的镜像了，使用docker history 镜像id 就可以查看到刚刚容器的输出结果了。注意这个创建的镜像是不可以开启新的容器的 官方的解释 &quot;Notice the new changed-ubuntu image does not have its own copies of every layer. As can be seen in the diagram below, the new image is sharing its four underlying layers with the ubuntu:15.04 image.&quot;并且使用 docker history 可以看到刚刚通过文件输出镜像的大小只有11b，这种只是个共享图像层。一旦你构建或创建了一个新的镜像，你可以使用 docker push 命令将镜像推送到 Docker Hub 。这样你就可以分享你的镜像了，镜像可以是公开的，或者你可以把镜像添加到你的私有仓库中。 Docker Volumes 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152docker volumes 是一个存储卷,它可以使宿主机与容器里面共享数据,这个数据卷可以是系统文件上的任何一个目录,你可以挂在任意个Volumes 到容器里,多个容器也可以共享一个或多个数据量。docker run --volumes-from 如果你有一些持久化的数据， 并且想在不同的container之间共享这些数据， 或者想在一些没有持久化的container中使用， 最好的方法就是使用 Data Volumn Container, 在把数据mount到你的container里.(译者：如开篇译者提到的docker的container是无状态的， 也就是说标记状态的数据，例如：数据库数据， 应用程序的log 等等， 是不应该放到container里的， 而是放到 Data Volume Container里, 这点和funcational programming很像， 所以我喜欢把一般的docker container 叫做 functional container用来区分 data volume container ）这里的意思相当于有个最简洁的容器来专门跑存储容器，之后的启动的容器都可以使用 docker run --volumes-from 从存储数据容器中来实现数据的共享。$ docker run -d -v /dbdata --name dbdata training/postgres 这样做之后就可以通过 --volumes-from 把 /dbdata mount到其他的container里了$ docker run -d --volumes-from dbdata --name db1 training/postgres 还可以继续共享到另外一个container里$ docker run -d --volumes-from dbdata --name db2 training/postgres -volumes-from 可以多次使用来 mount 多个conatainer里的多个volumes。这个操作是链式的， 我们在db1 中通过 --volumes-from mount进来的 volume可以继续被其他container使用$ docker run -d --name db3 --volumes-from db1 training/postgres (译者: 这里我们不是直接使用 volume container， 而是使用db1 这个functional container 把volume 挂载到另外一个 funcational container上的，所谓的链式就是 dbdata -&gt; db1 -&gt; db3)如果你把所有mount volumes的container都移除掉， 包括初始化的那个 dbdata container， volume才会被移除掉。通过这个属性可以方便的升级升级数据或者在不同container间migrate数据.备份、恢复和移植数据卷Volume的另外一个用处就是备份、恢复和migrate数据。 具体的做法如下，使用 --volumes-from 来创建一个新的container mount这个volume$ sudo docker run --volumes-from dbdata -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata &gt; 这里我们启动了一个新的container， 从 dbdata 挂载了一个volume。同时挂载了一个本地目录到这个container里。最后我们通过一个 tar命令把 dbdata 里的数据备份到了 /backup 里。命令结束并且停止这个container后我们就在本地得到了一个备份的数据.(译者: 这里使用的 ubuntu container， 就是为了把volume中的数据打包备份到host的某一个目录里。)备份的数据可以恢复到这个container， 或者其他使用这个volume的container。首先创建一个container$ sudo docker run -v /dbdata --name dbdata2 ubuntu &gt; 之后un-tar备份文件到 data volume 里$ sudo docker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar 你可以使用你喜欢的工具加上上面的技术来自动备份，迁移和恢复数据 实践:在Docker容器中运行web应用 1234首先docker pull nginx 或者制作好web应用的镜像.docker run -idt -p 80:80 -v /docker/download/:/data/ download:1 #以后台进程运行docker exec 容器id nginx #使用docker exec执行nginx 启动命令docker top #查看容器内的进程运行状态 开启动一个长时间运行的后台进程 123a=$(docker run -d centos /bin/bash -c &quot;while true; do echo hello world; sleep 1; done&quot;)docker logs $a ##将会看到有hello world 删除Docker镜像首先要保证有权限对Docker镜像或者容器进行操作，具体做法参见进入前文安装部分。 1234567891011# 停止所有容器$ docker stop $(docker ps -a -q)# 删除指定镜像$ docker rmi $image# 删除无标示镜像，即id为&lt;None&gt;的镜像$ docker rmi $(docker images | grep &quot;^&lt;none&gt;&quot; | awk &quot;&#123;print $3&#125;&quot;)# 删除所有镜像$ docker rmi $(docker images -q) 在Docker构建nginx容器 #在构建Dockerfile时应在空目录下构建构建dockerfile1234567891011cat&lt;&lt;\\EOF &gt; Dockerfile # Nginx## Version 1.0FROM centosMAINTAINER djluo &lt;dj.luo@baoyugame.com&gt;RUN rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpmRUN yum -y install nginx; yum clean allEOF#通过Dockerfile在容器中安装nginxdocker build -t nginx:1.0 . #-t 只是个版本名称 进入容器修改配置文件:1234567891011121314151617bash-4.2# bash-4.2# rm conf.d/&#123;default.conf,example_ssl.conf&#125;bash-4.2# rm -f /etc/nginx/&#123;koi-utf,koi-win,scgi_params,uwsgi_params,win-utf&#125;bash-4.2# cat&lt;&lt;\\EOF &gt; /etc/nginx/conf.d/download.conf server &#123; listen 80; server_name localhost; root /data/html; access_log /data/logs/download.log; location / &#123; autoindex on; &#125;&#125;EOFbash-4.2# mkdir -p /data/&#123;html,logs&#125;bash-4.2# /usr/sbin/nginx -t bash-4.2# exit 制作成镜像commit:123docker ps -l # 获取最新的一个容器信息，通常就是上面操作的了。docker commit -a &quot;djluo &lt;dj.luo@baoyugame.com&gt;&quot; -m &quot;用于docker build的下载环境&quot; 07d7a871cf32 download:1docker rm 07d7a871cf32 # 删除容器 构建Nginx的主目录和日志目录:12mkdir -p ~/docker/download/&#123;html,logs&#125;echo &quot;Hi&quot; &gt; ~/docker/download/html/index.html 正式运行下载环境的容器：需要映射端口，公网访问12docker run -d -p 80:80 --name download -v /docker/download/:/data/ download:1 /usr/sbin/nginx#将docker容器里的80端口映射到宿主机的80，好让外网访问，-v共享存储卷，将宿主机的目录数据挂载到容器里 并且启动nginx 12345正确的用法：应该是分为2个容器，应用容器和管理容器。应用容器：跑具体的应用，如nginx、java、php等。将应用数据放到VOULME中。管理容器：跑SSHD，并挂载上应用容器的数据VOULME。随心所欲的操作吧。不过有些应用的重启、重新导入配置等，可能需要到容器外操作docker守护进进程(服务端)默认以unixsocket方式启动，如果需要用到远程调用需要使用remoteapi 12345678910111213141516171819以下是一个RUN格式正确的指导，显示所有apt-get 建议。RUN apt-get update &amp;&amp; apt-get install -y \\ aufs-tools \\ automake \\ build-essential \\ curl \\ dpkg-sig \\ libcap-dev \\ libsqlite3-dev \\ mercurial \\ reprepro \\ ruby1.9.1 \\ ruby1.9.1-dev \\ s3cmd=1.1.* \\ &amp;&amp; rm -rf /var/lib/apt/lists/*####################ENTRYPOINT###############################ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] （exec表格，首选） docker 默认本地的仓库目录，存储着push的镜像。 这个目录默认是100g，超过了将会push失败，所以建议定时清理。 从容器内拷贝文件到主机上1docker cp &lt;containerId&gt;:/file/path/within/container /host/path/target 12345docker 镜像导入和导出导出镜像docker save -o centos7.tar centos导入本地镜像sudo docker load --input centos7.tar","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"我的 Python 开发环境","date":"2018-09-09T09:45:16.827Z","path":"2018/09/09/你的-Python-开发者环境/","text":"文本编辑器任何可以做纯文本编辑的工具都可以用来写Python代码，但是用功能更加强大的文本编辑器可以使你的编程工作更加轻松。 VimVim 是一个用键盘快捷键代替菜单和图标来操作的文本编辑器。对于 Vim 编辑器，有几个插件和设置可以用来辅助 Python 开发。如果你只用 Python 开发，一个好的开始就是把缩进和换行的默认设置设置成兼容 PEP 8 的值。 在你的主目录里，打开一个叫作 .vimrc 的文件并且把下面这些代码添加进去： 1234567set textwidth=79 \" 行宽超过 79 会被截断set shiftwidth=4 \" 操作符 &gt;&gt; 缩进 4 列；&lt;&lt; 减少缩进 4 列set tabstop=4 \" 一个 TAB 显示为 4 列set expandtab \" 用空格代替 TABset softtabstop=4 \" 敲击 TAB/BACKSPACE 插入 / 删除 4 个空格 set shiftround \" 缩进为 'shiftwidth' 的倍数set autoindent \" 新行缩进与上一行对齐 使用这些设置，行宽超过 79 个字符会自动换行，并且缩进设置为用 4 个空格代替一个制表符。如果你还用 Vim 写其它的语言，有一个很方便的插件 indent ，用来处理 Python 源文件的缩进设置。 还有一个很方便的语法插件 syntax，对 Vim 6.1 里自带的语法文件做了一些增强。 这些插件为你用 Python 开发提供了一个基本环境。你应该充分利用 Vim 去持续检查你的代码是否有语法错误并且是否符合 PEP8 规范。幸运的是有 pycodestyle 和 Pyflakes 来帮你做这些事。如果你的 Vim 编译时附带了 +python ，你也可以使用一些自带的插件非常方便的来做这些检查。 对于 PEP8 和 Pyflakes ，你可以安装 vim-flake8。然后你就可以在 Vim 里把 Flake8 功能映射到任何快捷键或操作上了。这个插件会在屏幕下方显示错误信息，并且提供一个简单的方式来跳转到对应的行。设置成每当你保存文件的时候就调用这个功能会很方便。如果想这样做，添加这行代码到你的 .vimrc ： 1autocmd BufWritePost *.py call Flake8() 如果你已经使用了 syntastic ，你可以把它设置成在写入的时候自动运行 Pyflakes 并且在 quickfix 窗口里显示错误和警告信息。下面是一个在状态栏里显示检查状态和警告信息的示例配置： 12345set statusline+=%#warningmsg#set statusline+=%&#123;SyntasticStatuslineFlag()&#125;set statusline+=%*let g:syntastic_auto_loc_list=1let g:syntastic_loc_list_height=5 Python-modePython-mode 是 Vim 编辑器中一个复杂的编写 Python 代码的解决方案。有以下功能： 让任意的 Python 代码检查工具(pylint, pyflakes, pycodestyle, mccabe) 都能协同工作 使用 Rope 进行代码重构以及自动填写 快速折叠 Python 代码 虚拟环境支持 全文搜索 Python 文档，运行 Python代码 自动使用 pycodestyle 修正错误 等等。 SuperTabSuperTab 是一个小型的 Vim 插件，可以用 &lt;Tab&gt; 键或者其他的自定义键来方便的完成代码自动填写。 EmacsEmacs 是另一个强大的文本编辑器。它是完全可编程的（lisp），但学习曲线有点陡。 如果您已经是一名 Emacs 的用户了，推荐阅读 EmacsWiki 上的 Python Programming in Emacs 。 Emacs 本身支持Python模式。 TextMateTextMate 是一个带有苹果操作系统气质的文本编辑器。 巧取了 UNIX 和 GUI 的各自优点，TextMate 将两者中最好的部分带给了脚本专家和新手用户。 Sublime Text Sublime Text 是一个设计精良的编辑器，你可以用来编写脚本代码、标记代码和一般的文字编辑。您将会爱上其漂亮的用户界面、非凡的特性和惊人的运行速度。 Sublime Text has excellent support for editing Python code and uses Python for its plugin API. It also has a diverse variety of plugins, some of which allow for in-editor PEP8 checking and code “linting”. Sublime Text 对 Python 代码提供了非常棒的支持，而且其插件系统的 API 也是有 Python 语言编写的。它拥有大量各式各样的插件， 其中一些 允许编辑器内的 PEP8 检查和代码错误提示。 Atom Atom 是一款 21 世纪的可定制性极高的文本编辑器。构建于atom-shell上，它拥有我们所喜欢的编辑器的所有优秀特性。 Atom 是 Web 原生的（HTML、CSS、JS），编辑器核心专注于模块化的设计和插件开发的便捷性。它自带本地包管理和大量的扩展包。Atom 下从事 Python 开发所推荐的插件是 Linter 和 linter-flake8 的组合。 IDEsPyCharm / IntelliJ IDEAPyCharm 由 JetBrains 公司开发，此公司还以 IntelliJ IDEA 闻名。它们都共享着相同的基础代码，PyCharm 中大多数特性能通过免费的 Python 插件带入到 IntelliJ 中。PyCharm 由两个版本：专业版（Professional Edition）（30天试用）和拥有功能相对较少的社区版（Community Edition）（Apache 2.0 License）。 使用 Visual Studio Code 来编辑 PythonPython for Visual Studio 是一款基于 Visual Studio Code IDE 的扩展。 它是一个免费的、轻量的、开源的 IDE，支持 Mac、Windows 和 Linux 等主流平台。它以诸如 Node.js 和 Python 等开源技术构建，具有如智能自动补全、本地和远程调试、linting（代码检查）等 引人注目的特性。 MIT licensed. Enthought CanopyEnthought Canopy 是一款专门面向科学家 和工程师的 Python IDE，它预装了为数据分析而用的库。 EclipseEclipse 中进行 Python 开发最流行的插件是 Aptana 的 PyDev。 Komodo IDEKomodo IDE 由 ActiveState 开发，并且是能运行在 Windows、Mac 和 Linux 平台上的商业 IDE。KomodoEdit 是其开源版本。 SpyderSpyder 是一款专门面向 Python科学库（即 Scipy）的 IDE。它集成了 pyflakes 、 pylint 和 rope 。 Spyder 是免费开源的，功能包括代码补全、语法高亮、类和函数浏览器，以及对象检查等。 WingIDEWingIDE 是一个专门面向 Python 的 IDE。它能运行在 Linux、Windows 和 Mac 上（作为一款 X11 应用程序，某些 Mac 用户可能会无法使用）。 WingIDE 提供了代码补全、语法高亮、源代码浏览器、图形化调试器的功能，还支持版本控制系统。 NINJA-IDENINJA-IDE 的名称来自递归缩写：”Ninja-IDE Is Not Just Another IDE”， 是一款跨平台的IDE，专为构建 Python 应用而打造，并能运行于 Linux/X11、Mac OS X 和 Windows 桌面操作系统上。从网上可以下载到这些平台的安装包。 NINJA-IDE 是一款开源软件（GPLv3许可），是使用 Python 和 Qt 开发。在 GitHub 能下载到源文件。 Eric (The Eric Python IDE)Eric 是一款功能齐全的Python IDE， 提供源代码自动补全、语法高亮、对版本控制系统的支持、对Python 3 的支持、集成的 Web 浏览器、 Python Shell、集成调试器和灵活的插件系统等功能。它基于 Qt GUI 工具集，使用 Python 编写， 集成了 Scintilla 编辑器控制。Eric 是一款超过 10 年仍活跃开发的开源软件（GPLv3许可）。 解释器工具虚拟环境虚拟环境完整隔离项目包依赖，这意味着您无须全局（系统范围内）安装 Python 工程特定的包， 因此就能避免潜在的版本冲突。 使用时请参阅 Virtual Environments 文档。 pyenvpyenv 是一个允许多个 Python 解释器版本同时安装于一台机器的工具。这解决了不同的项目需要不同版本的 Python 的问题。比如，为了兼容性， 可以很容易地为一个项目安装 Python 2.7，而继续使用 Python 3.4 作为默认的解释器。 pyenv 不止限于 CPython 版本——它还能安装 PyPy、anaconda、miniconda、stackless、jython 和 ironpython 解释器。 pyenv 的工作原理是在一个叫做 shims 目录中创建 Python 解释器（以及其他工具像 pip 和 2to3 等）的伪造应用。当系统寻找名为 python 的应用时，它会先在 shims 目录中寻找并使用对应假版本的应用，然后会传递命令到 pyenv 中。 pyenv 再根据环境变量、.python-version 文件和全局默认设置的信息来判断该运行哪个版本的 Python。 pyenv 不是管理虚拟环境的工具，但是有一个叫做 pyenv-virtualenv 的插件可以自动化不同环境的创建，而且也能够直接集成到现有的 pyenv 工具中，基于环境变量或者 .python-version 文件，来切换不同的环境。 其他工具IDLEIDLE 是一个集成的开发环境，它是 Python 标准库的一部分。 它完全由 Python 编写，并使用 Tkinter GUI 工具集。尽管 IDLE 不适用于作为成熟的 Python 开发工具，很多时候我们用来尝试运行简单的 Python 代码片段，或者对 Python 不同特性做一些小实验。 它提供以下特性： Python Shell 窗口（解释器） 多窗口文本编辑器，支持 Python 代码高亮 最小的调试工具 IPythonIPython 提供一个丰富的工具集来帮助您最大限度地和 Python 交互。 它主要的组件有： 强大的 Python shell（基于终端和 Qt ）。 一个基于网络的笔记本，拥有相同的核心特性，但是支持富媒体、文本、代码、数学表达式和内联绘图。 支持交互式的数据可视化和 GUI 工具集的使用。 灵活、嵌入的解释器载入到您的工程工程中。 支持高级可交互的并行计算的工具。 1$ pip install ipython 使用以下命令下载和安装带有所有可选依赖（notebook、qtconsol、tests 和其他功能）的 IPython： 1$ pip install ipython[all] BPythonbpython 在类 Unix 操作系统中可替代 Python 解释器的接口。 它有以下特性： 内建的语法高亮。 行内输入时的自动补全建议。 Python 函数预期选项提供。 “倒带” 功能 —— 从内存中 pop 出代码的最后一行并重新运行。 将输入的代码发送到 pastebin。 将输入的代码保存到一个文件中。 自动缩进。 支持 Python 3。 1$ pip install bpython ptpythonptpython 是一个构建在 prompt_toolkit 库之上的 REPL。它被视作是 BPython 的替代。特性包括： 语法高亮 自动补全 多行编辑 Emacs 和 VIM 模式 代码中嵌入的 REPL 语法合法性检测 支持 Tab 页 通过 pip install ipython 安装后运行 ptipython，即可支持集成 IPython 的 shell： 1$ pip install ptpython 参考资料 python漫游指南","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"python 底层虚拟环境 virtualenv","date":"2018-09-09T09:41:57.899Z","path":"2018/09/09/python-底层虚拟环境-virtualenv/","text":"virtualenv 是一个创建独立的 Python 环境。 virtualenv 会创建一个文件夹，其中包含使用 Python 项目所有所需的可执行文件。 它可以单独使用，用于代替 Pipenv 。 通过 pip 安装 virtualenv ： 1$ pip install virtualenv 测试下是否安装完成 1$ virtualenv --version 为项目创建一个虚拟环境： 12$ cd my_project_folder$ virtualenv my_project virtualenv my_project 将会在当前目录创建一个文件夹来存放 Python 的可执行文件以及拷贝一份 pip库，这样就能安装其他包了。虚拟环境名字（ 这里是 myproject ）可以随意，若省略名字将会把文件均放在当前目录。 这将在你运行此命令的文件目录下创建一个 Python 的副本，并将其放入名为 my_project 的文件夹中 你也可以选择 Python 解释器（如 python2.7 ） 。 1$ virtualenv -p /usr/bin/python2.7 my_project 或者改变 ~/.bashrc 中的解释器的全局环境变量： 1$ export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python2.7 开始使用虚拟环境前，需要先激活： 1$ source my_project/bin/activate 当前虚拟环境的名称将出现在提示符的左侧 (e.g. (my_project)Your-Computer:your_project UserName$) ，这样你就能了解当前激活的虚拟环境是什么。 自此，你使用 pip 安装的任何包都会放在 my_project 文件夹，与全局 Python 安装的包相互独立。 安装包的话就与往常一样，如： 1$ pip install requests 如果你在虚拟环境中暂时完成了工作，可以这样停用它： 1$ deactivate 这样你就回到了系统默认的 Python 解释器，包括安装的库页会回到默认的。 要删除一个虚拟环境，只需要删除对应文件夹。( 以当前示例来说，执行 rm -rfmy_project) 。 然而 virtualenv 也有些不便之处，因为一段时间后你的系统中可能会有很多虚拟环境散落在各处，这样会让你忘记它们的名字或位置 运行 virtualenv 带上选项 --no-site-packages 将不会包含已经全局安装的包。这样有助于保持包列表的整洁以防万一之后需要访问它。[ 这在 virtualenv 1.7 是默认的哦。 ] 为了保持环境的一致性，“冻结”当前环境包的状态是正确的选择。冻结环境可以运行下面的命令： 1$ pip freeze &gt; requirements.txt 该命令将创建一个 requirements.txt 文件，里面包含有当前环境所有包的简单列表及对应的版本。你可以使用 “pip list” 查看没有安装格式的已安装包列表。之后，对于开发人员（或你需要重新安装环境）来说就可以很容易的安装相同的版本一致的包，这样就能完全搭建出与之前一致的环境了： 1$ pip install -r requirements.txt 这样有助于在跨设备，跨部署，跨人员的情况下保证环境的一致性。 最后，记得将虚拟环境文件夹从源代码控制中排除，也就是将其添加到 ignore 列表中 ( 详见 Version Control Ignores). virtualenvwrappervirtualenvwrapper 提供一系列命令让你更加愉快地操作虚拟环境。它还将所有虚拟环境放在一块。 安装方法如下 ( 请确保 virtualenv 已安装 ) ： 123$ pip install virtualenvwrapper$ export WORKON_HOME=~/Envs$ source /usr/local/bin/virtualenvwrapper.sh (virtualenvwrapper 安装说明 .) 对于 Windows 用户，你可以使用 virtualenvwrapper-win. 安装方式如下 ( 请确保 virtualenv 已安装 ) ： 1$ pip install virtualenvwrapper-win 在 Windows 中，设置环境变量 WORKON_HOME ，内容为 %USERPROFILE%Envs 基本用法 创建虚拟环境 1$ mkvirtualenv my_project 该指令将在 ~/Envs 创建 my_project 文件夹。 在虚拟环境下工作： 1$ workon my_project 或者，你可以通过创建项目来创建虚拟环境，该项目目录要在 $WORKON_HOME 下，当你在 workon myproject 时可以 cd 进入。 1$ mkproject myproject virtualenvwrapper 为环境名称提供 tab 键补全功能。当你有很多环境又很难记住它们的名字时，该功能很有帮助。 workon 也会使你当前所在的环境失效，这样你就可以在不同地环境间快速切换。 停止虚拟环境： 1$ deactivate 删除虚拟环境： 1$ rmvirtualenv venv 其他有用的命令1lsvirtualenv 列出所有虚拟环境 1cdvirtualenv 进入当前的虚拟环境目录，这样你就可以浏览它的 site-packages ，如： 1cdsitepackages 上述命令将进入虚拟环境的 site-packages 目录. 1lssitepackages 列出 site-packages 目录下所有软件包. virtualenvwrapper 的全部命令列表 . virtualenv-burrito使用 virtualenv-burrito ，你可以只要使用一条命令就将 virtualenv + virtualenvwrapper 环境搭建起来。 autoenv当你 cd 进一个含有 .env 的目录， autoenv 将自动激活虚拟环境。 Mac OS X 使用 brew 安装 autoenv 的方式如下： 1$ brew install autoenv Linux 安装方式如下： 12$ git clone git://github.com/kennethreitz/autoenv.git ~/.autoenv$ echo 'source ~/.autoenv/activate.sh' &gt;&gt; ~/.bashrc 参考资料 python漫游指南","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"python next step","date":"2018-09-09T09:34:05.479Z","path":"2018/09/09/python-next-step/","text":"迈出下一步如果到现在你已经阅读过本书并且编写了许多程序，那么你一定已经开始熟悉并且习惯 Python 了。或许你已经创建了一些 Python 程序来尝试完成一些工作，同时锻炼你自己的 Python 技能。如果你尚未至此，你也应该作出努力。现在我们面临的问题是“下一步该做什么？”。 我会建议你试图解决这个问题： 编写一款你自己的命令行地址簿程序，你可以用它浏览、添加、编辑、删除或搜索你的联系人，例如你的朋友、家人、同事，还有他们诸如邮件地址、电话号码等多种信息。这些详细信息必须被妥善储存以备稍后的检索。 如果你回想至今我们学过、讨论过、遇见过的所有东西，你会发现这其实非常简单。如果你仍想要有关如何进行的提示，这儿倒是有一些。 如果你觉得上面的程序太容易了，这还有另一个： 实现替换命令。这个命令能将一串字符串替换为另外提供的文件或列表中的另一串。 只要你想，替换命令可以或简单或复杂地实现，从简单的字符串替换到搜寻搭配的样式（正则表达式）。 下一个项目如果你发现上面的程序都能很容易地编写出来，那么看看下面这个完整的项目列表，并尝试编写你自己的程序：https://github.com/thekarangoel/Projects#numbers (这一列表与 Martyr2 的超级项目列表相同)。 你还可以看看： Exercises for Programmers: 57 Challenges to Develop Your Coding Skills Intermediate Python Projects 示例代码学习一门编程语言的最好方式就是编写大量代码，并阅读大量代码： Python Cookbook 是一本极具价值的“烹饪法”与提示的集合，它介绍了如何通过 Python 解决某些特定类型的问题。 Python Module of the Week 是另一本优秀的标准库必读指南。 建议 The Hitchhiker’s Guide to Python! The Elements of Python Style Python Big Picture “Writing Idiomatic Python” ebook （付费） 视频 Full Stack Web Development with Flask PyVideo 问与答 Official Python Dos and Don’ts Official Python FAQ Norvig’s list of Infrequently Asked Questions Python Interview Q &amp; A StackOverflow questions tagged with python 教程 Hidden features of Python What’s the one code snippet/python trick/etc did you wish you knew when you learned python? Awaretek’s comprehensive list of Python tutorials 讨论如果你遇到了一个 Python 问题，但不知道该问谁，那么 python-tutor list 是你提问的最佳场所。 请确保你会自己做你的家庭作业，你会首先尝试自己解决问题，同时，还要会问聪明的问题。 新闻如果你希望了解 Python 世界的最新动态，那就跟随 Official Python Planet 的脚步吧。 安装库Python 库索引中包含了大量开源的库，你可以在你自己的程序中使用它们。 要想了解如何安装并使用这些库，你可以使用 pip。 创建一个网站学习使用 Flask 来创建你自己的网站。下面这些资源有助于你开始学习： Flask Official Quickstart The Flask Mega-Tutorial Example Flask Projects 图形软件假设你希望使用 Python 来创建你自己的图形程序。这可以通过采用一个 GUI（Graphical User Interface，图形用户界面）库和它们的 Python 绑定来实现。绑定是允许你用 Python 编写你自己的程序，然后使用它们在 C 或 C++ 或其它语言写编写的库。 使用 Python 的 GUI 有许多选择： Kivy http://kivy.org PyGTK 这是 GTK+ 工具包的 Python 绑定，它是构建 GNOME 的基础。GTK+ 有许多奇怪的用法，但是你一旦习惯了使用它，就能很快的创建出你的 GUI 应用。Glade 图形界面设计工具是不可或缺的。它的文档至今仍在不断改进。GTK+ 在 GNU/Linux 下能够良好工作，但是它针对 Windows 平台的移植工作尚未完成。你可以使用 GTK+ 创建免费或专有的软件。要想开始使用，请阅读 PyGTK 教程。 PyQt 这是 Qt 工具包的 Python 绑定，它是构建 KDE 的基础。 受益于 Qt Designer 与令人惊讶的 Qt 文档，Qt 十分容易使用也十分强大。如果你希望创建一款开源（GPL）软件，你可以免费使用 PyQt，不过如果你想创建专有的闭源软件，你需要购买它。从 Qt 4.5 开始你可以使用它来创建不采用 GPL 授权的软件。要想开始使用，请阅读 PySide。 wxPython 这是 wxWidgets 工具包的 Python 绑定。wxPython 有一个与之相关的学习曲线。不过，它非常便携，并且可以运行在 GNU/Linux、Windwos、Mac、甚至是嵌入式平台中。有许多 IDE 可以采用 wxPython，并且包含了 GUI 设计工具，例如 SPE (Stani’s Python Editor) 还有 wxGlade GUI 构建工具。你可以使用 wxPython 来创建免费或专有的软件。要想开始使用，请阅读wxPython 教程。 GUI 工具总结想要了解更多的选择，可以参阅 GuiProgramming wiki page at the official python website。 不幸的是，Python 没有一款标准 GUI 工具。我建议你根据你的实际情况从上面列出的工具中进行挑选。第一个因素是你是否愿意为使用任何 GUI 工具付费。第二个因素是你希望你的程序只在 Windwos 上运行，还是在 Mac 和 GNU/Linux 上运行，还是在它们三者之上都能运行。第三个因素，如果 GNU/Linux 是目标平台，那你是要做 KDE 用户还是 GNOME 用户。 有关更详尽且更全面的分析，请参阅 ‘The Python Papers, Volume 3, Issue 1’ (PDF) 的第 26 页。 各种实现编程语言主要有两部分——语言与软件。语言是你如何编写，软件是你怎样实际运行我们的程序。 我们一直在使用 CPython 软件来运行我们的程序。它被成为 CPython 是因为它是使用 C 语言编写的，同时它也是经典的（Classical） Python 解释器。 还有其他软件可以运行你的 Python 程序： Jython 在 Java 平台上运行的 Python 实现。这意味着你可以在 Python 语言中使用 Java 的库与类，反之亦然。 IronPython 在 .NET 平台上运行的 Python 实现。这意味着你可以在 Python 语言中使用 .NET 的库与类，反之亦然 PyPy 用 Python 编写的 Python 实现！这是一项研究项目，旨在于使其能快速且方便的改进解释器，因为解释器本身就是用动态语言编写的了（而不是采用上述三种 C、Java、C# 等动态语言来编写）。 还有其它诸如 CLPython——采用 Common Lisp 编写的 Python 实现，和Brython ，它在 JavaScript 解释器之上实现，意味着你可以使用 Python（而非 JavaScript）编写你的 Web 浏览器（“Ajax”）程序。 上述这些实现每一种都有其大有作为的专门领域。 函数式编程（面向高阶读者）当你开始编写更加庞大的程序时，你应该清楚了解更多关于使用函数的方式来进行编程，而不是我们在《面向对象编程》章节中所学习的基于类的方式进行编程： Functional Programming Howto by A.M. Kuchling Functional programming chapter in ‘Dive Into Python’ book Functional Programming with Python presentation Funcy library PyToolz library 阅读此教程可以加强你与 Python 的兴趣 — — 也许你更渴望用 Python 去解决你现实中的问题。从哪里去提升呢？ 本教程只是 Python 众多文档中的一页。更多的文档你可以从这里获取： Python 的标准库: 你需要完整地浏览本指南，它（简洁地）阐述了语言中的类型、函数和标准库中的模型。本 Python 基础发行手册包括了 大量 额外的代码。它们是 Unix 的邮箱、通过 HTTP 检索文档、创建随机数、解析命令行选项、创建 CGI 程序、压缩数据等等项目。参考过这些项目可以让你在遇到类似的问题知道什么能用得上。 安装 Python 的模块 解释了如何去安装一些其他 Python 用户完成的模块。 Python 语言的参考资料: 一些关于 Python 的语法和语义的详细解释。它也许生涩难懂，但对你详细地了解到该语言的本体非常有用。 关于 Python 的更多学习资源: https://www.python.org: Python 主网站，它包含了代码、文档和 Python相关网站的链接。这个网站在全世界各地有很多镜像，比如欧洲、日本和澳大利亚，你可以访问镜像网站来获取更快速的体验，当然这取决于你的地理位置。 https://docs.python.org: 可以快速访问 Python 文档。 https://pypi.org: Python Package Index 也被叫做 Cheese Shop，提供了一个Python模块下载列表，这些模块都是由 Python 用户所创建的。如果你想发布的你代码，并期望别人也能找到，你可以在这里注册。 https://code.activestate.com/recipes/langs/python/: Python Cookbook 包含了大量的代码示例、模块用法和实用的脚本。特别值得注意的是，有一本书名字也叫 Python Cookbook (O’Reilly &amp; Associates, ISBN 0-596-00797-3.) http://www.pyvideo.org 收集了来自会议和用户组讨论的 Python 相关的视频。 https://scipy.org: Python 的科学项目包括用于快速阵列计算和操作的模块，再加上诸如线性代数、傅立叶变换、非线性解算器、随机数分布、统计分析等诸如此类的软件包。 对于 Python 的相关问题，你可以发布到新闻组 comp.lang.python ，或者投稿到 python-list@python.org. 新闻组和投稿都是自动转发的，因此你提交到一个那里，就会自动转发给其他人。每天都会有上百个提交，包括问问题（和回答问题）、提出建议的新特性和发布新模块等等。投稿地址在 https://mail.python.org/pipermail/. 在提交问题前，一定要先检查 Frequently Asked Questions (也被称为FAQ)。FAQ回答了很多问题，而且有的问题会反复出现。所以里面很可能已经包含了你问题的解决方法。 参考资料 简明python python官方文档","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"python面向对象编程 ","date":"2018-09-09T06:09:14.543Z","path":"2018/09/09/python面向对象编程/","text":"类就是一组数据和函数的集合。创建了一个新的类意味着创建了一个全新的对象 类型，也就允许我们创建新的此类型的 实例。每个类实例都带有属性以维护其状态。同样也有方法（在它自己的类中定义）来修改这些状态。 相比其他编程语言，使用 Python 的类机制创建类是最方便简洁的。Python 的类机制结合了 C++ 和 Modua-3 的机制，同时也符合所有面向对象编程的标准：类继承机制允许有多个基类，一个派生的类可以覆盖基类的任意方法，每个方法也可以调用基类的同名方法。每个对象都可以包含任意数量和类型的数据。与模块一样，类也具有 Python 动态的特性：即时创建，创建后仍可修改。 在 C++ 的概念中，常规的类成员都是 公共（public） 的（例外的情况请看 Private Variables 这一节）成员函数都是 虚（virtual） 的。 到了 Modula-3 中，我们没有从其自身的方法中引用对象成员的快速写法：方法函数声明时要在第一参数中标明对象，这样就会在调用时隐式的调用。在 Smalltalk 中，类本身就是对象。同时还有导入和重命名语法。但不同于 C++ 和 Modula-3，它的内置类型可以直接作为基类由用户进行扩展。同样，它也有类似 C++ 的地方，大部分有特殊语法的内置操作符（算术运算符，下标等等）都可以被类实例重定义。 面向对象技术简介 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重载：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重载。 实例变量：定义在方法中的变量，只作用于当前实例的类。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 方法：类中定义的函数。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 Python 作用域与命名空间介绍类之前，我必须先向你介绍一下 Python 的作用域规则。类定义在命名空间中有一些非常聪明的技巧，而且你需要知道作用域和命名空间是如何工作的这样才能完全理解它做了什么。顺便一提，本节的知识对任何高级的 Python 编程都很！有！用！ 让我们先从几个定义开始。 namespace（命名空间） 是一个从名字到对象的映射。大部分命名空间当前都由 Python 字典实现，但一般情况下基本不会去关注它们（除了要面对性能问题时），而且也有可能在将来更改。下面是几个命名空间的例子：存放内置函数的集合（里面含有 abs() 这样的函数，和其他的内置名称）；模块中的全局名称；函数调用中的本地名称。从某种意义上说，某对象的的属性集合也是一种命名空间的形式；比如，两个不同的模块都可能定义了一个 maximize 的函数，为了不引起混乱用户必须用模块名作为前缀修饰一下。 顺便一提， 接下来所有跟在 . 后面的单词我都称其为 attribute（属性），比如， z.real 中的 real 就是对象 z 的一个属性。严格来说，引用模块中的名称就是属性引用： modname.funcname 中的 modname 是一个模块对象，funcname 自然就是它的一个属性了。还有一种在模块的属性与本模块的全局名称之间恰好发生了一个直接的映射的情况：它们共享了同一个命名空间！[1]。 属性可以是只读的，也可以是可写的。在后一种情况中，可以指定某个属性某些内容。如果模块属性可写：你可以用 modname.the_answer = 42 来指定。可写的属性也同样可以被 del 语句删除。 例如， del modname.the_answer 将会删除掉 modname 的 the_answer 属性。 命名空间会在不同时刻被创建，也会拥有不同的命名空间。命名空间中包含着在 Python 解释器启动之初创建的内置名称，并且永远不会被删除。模块中的全局命名空间也会在模块被读入时创建，一般情况下也会持续到解释器退出。声明的执行由上层解释器调用，不管是从文件中读入还是交互式的，模块中包含最多的是一个叫 __main__ 的东西，每个模块都有自己的全局命名空间（实际上内置名称也在模块中存在，它们被称为 builtins.) ）。 函数的本地命名空间在函数被调用时创建，函数返回或抛出异常时但没在函数内处理时删除。（实际上，忘记处理可能是描述实际所发生的了什么的更好的方式..）当然，递归调用每一次都有自己的本地命名空间。 scope (作用域) 是一段 Python 程序的文本区域，处于其中的命名空间是可直接访问的。「可直接访问」在这里的意思是非限定性引用的某名称会尝试在此命名空间中查找。 尽管作用域一般都是静态的，不过也常常被动态的用。在任何执行的时候，每段代码都至少有3个嵌套的作用域可直接访问。 最内层的作用域，会被首先搜索，里面放的是本地名称。 任何处于函数内的作用域，会从在最接近它的作用域中开始寻找，这层的命名空间中放的是非本地但也非全局的名称。 倒数第二层作用域是包含着当前模块的全局名称。 最外层作用域（最后搜索的一层）是包含内置名称的命名空间。 如果某名称是在全局进行的声明，那么所有的引用和分配都会直接导向中间的这层包含模块的全局名称的作用域中。要想让最内层的作用域重新绑定一个在外层出现过的变量，我们可以用 nonlocal 声明来完成；如果不声明 nonlocal (非本地)，这些变量则都是只读的（任何尝试写入这种变量的行为都将会创建一个 全新 的本地变量，不会对最外层的那个有丝毫影响。） 通常情况下，本地作用域引用着当前函数的本地名称。外层的函数引用的是和全局作用域一样的命名空间：模块的命名空间。类定义放置在本地作用域的另一个命名空间中。 意识到作用域取决于文本是很重要的：某个模块中所定义的函数的全局作用域是它所在的模块的命名空间，不管这函数来自什么地方或以什么别名被调用。换句话说，实际的名称搜索是在动态的情况下完成的，也就是运行时 — 但，语言定义的发展是朝着静态命名去的，在 「编译」阶段完成，所以不要试图依赖任何动态的命名！（实际上，本地变量已经是静态定义的了。） Python 中也有皮一下的地方 – 如果不用 global 声明，那么所分配的变量总是在它所处位置的最内层。分配不会复制数据 – 它们只是把名字绑定到对象上。对删除来讲也是一样： del x 声明会把 x 从本地作用域所引用的命名空间中移除绑定。实际上，所有引入新名称的操作都会使用本地作用域：尤其是 import 声明和绑定在模块中的函数定义或者在本地作用域的函数名称。 global 声明被用在要指定某个特殊的变量要在全局作用域中存活且应该在这重新被绑定的情况下；nonlocal声明则是用在指示某变量存在于某封闭的作用域且应该在这被重新绑定的情况下。 作用域和命名空间例子用个小例子来演示下如何引用不同的作用域和命名空间，以及 global 和 nonlocal 是如何影响变量绑定的： 12345678910111213141516171819202122def scope_test(): def do_local(): spam = \"local spam\" def do_nonlocal(): nonlocal spam spam = \"nonlocal spam\" def do_global(): global spam spam = \"global spam\" spam = \"test spam\" do_local() print(\"After local assignment:\", spam) do_nonlocal() print(\"After nonlocal assignment:\", spam) do_global() print(\"After global assignment:\", spam)scope_test()print(\"In global scope:\", spam) 输出如下： 1234After local assignment: test spamAfter nonlocal assignment: nonlocal spamAfter global assignment: nonlocal spamIn global scope: global spam 注意 本地 的分配并未改变 scope_test 中绑定的 spam，而 nonlocal 标明过的分配则改变了 scope_test 绑定的 spam，global 则更改的是模块层面的绑定。 不知道你有没有注意到，我们在 global 之前是没有绑定 spam 的。 类对象类定义语法类定义的形式很简单像这样既可： 123456class ClassName: &lt;statement-1&gt; . . . &lt;statement-N&gt; 类的定义与函数定义（def statements）差不多，在它们生效前我们需要预先执行这些定义（你也可以在 if分支或函数内部声明类）。 在实践中，类定义内的声明通常是函数定义，不过也有其他的声明，而且还挺有用 – 我们之后再谈这个。在类中定义的函数通常有一个特有的参数列表，指代是作为方法调用的 — 同样我们稍后再解释。 进入到类定义后，会创建一个新的命名空间作为本地作用域 — 也因此，所有的本地变量的指定都会进到这个新的作用域里。尤其是定义函数所绑定的是此函数的名字。 类定义正常结束时，一个新的 类对象 就被创建出来了。这是类定义在命名空间中最基本的一层包装；我们在下一节中详细讨论这个。原始的本地作用域（在进入类定义前生效的那个）会被重新安装，然后将类名字（就是上例中的 ClassName）绑定到这个类对象上。 类编码风格类名应采用驼峰命名法，即类名中的每个单词首字母都大写，而不使用下划线。实例名和模块名都采用小写的格式，并且在单词之间加上下划线。 类对象类对象支持两种操作：属性引用和实例化。 Attribute references （属性引用） 使用的是 Python 中标准的属性引用语法： obj.name。有效的属性名都会在此类创建时被塞入的命名空间中。所以，如果一个类定义看起来像这样： 123456class MyClass: \"\"\"简单的例子\"\"\" i = 12345 def f(self): return 'hello world' MyClass.i 和 MyClass.f 都是有效的属性引用，分别返回的是一个整数和一个函数对象。类属性同样是可分配的，所以你可以更改 MyClass.i 的值。__doc__ 同样也是一个有效属性，返回的是此类的文档字符串： &quot;简单的例子&quot;。 类的 实例化 类似函数的形式。把它假装成一个无参数且返回的是此类实例的函数就行。看代码（用的上面那个类）： 1x = MyClass() 这样就创建一个新的类 实例 并把它分配给了本地变量 x。 实例化操作（「调用」类对象）创建的是一个空对象。大多数类都想在创建时自定义初始化状态。所以类通常也会定义一个名为 __init__() 的方法： 12def __init__(self): self.data = [] 当某类定义了 __init__() 方法，类实例化时就会为新的类实例自动调用 __init__() 方法。所以，我们不需要做任何改变： 1x = MyClass() 当然，__init__() 方法也可以有参数变得更加易用。需要参数时，在参数实例化时给定的参数会传递到 __init__() 上： 12345678&gt;&gt;&gt; class Complex:... def __init__(self, realpart, imagpart):... self.r = realpart... self.i = imagpart...&gt;&gt;&gt; x = Complex(3.0, -4.5)&gt;&gt;&gt; x.r, x.i(3.0, -4.5) 实例对象那么..我们要用这个实例对象干什么呢？最基本的操作时属性引用。我们现在有两种有效的属性名：数据属性和方法。 data attributes（数据属性） 等同于 Smalltalk 中的「实例变量」，以及 C++ 中的 「数据成员」。数据属性不需要提前声明；就像本地变量一样，它们会在第一次分配时传播到已有的命名空间中。举个例子，假设我们已经创建了 MyClass 的实例 x，下面的代码会打印出 16且不留下痕迹： 12345x.counter = 1while x.counter &lt; 10: x.counter = x.counter * 2print(x.counter)del x.counter 另一种实例属性引用是 method (方法)。一个方法也就是一个 「属于」某个对象的函数。（在 Python 中，方法一词并不被类实例独占：其他对象属性也同样具有方法。比如，列表对象也有如 append, insert, remove, sort 的方法。不过，接下来的讨论中我们所说的方法只指代类实例对象中的方法，除非特别指明。） 实例对象的有效方法名依赖于它的类。基于定义，所有是函数对象的类属性定义都会等同于它所实例化后的方法。所以在我们的例子中，x.f 是一个有效的方法引用，因为 MyClass.f 就是一个函数，但 x.i 则不是，因为 MyClass.i 就不是。但 x.f 并不是 MyClass.f – 在这里它变成了 方法对象 而不是函数对象。 方法对象通常，绑定后可以立即调用方法： 1x.f() 在 MyClass 例子中，会返回一个字符串 &quot;hello world&quot;。不过，我们并不需要立即调用：x.f 是一个方法对象，可以被存储下来并且在任何其他时间调用： 123xf = x.fwhile True: print(xf()) 将会一直打印 hello world。 调用方法时到底发生了什么？你可能注意到了，上面的 x.f() 调用并没有写参数，即使我们定义 f() 时指定了一个参数。那个函数呢？没错，如果没有足够的函数所需的参数 Python 会抛出一个异常 – 即使这参数可能实际并没有用到。 聪明的你，可能已经猜到了答案：关于方法最特殊的一件事就是实例对象会传递第一个参数到函数中。在我们的例子中， x.f() 实际上等同于 MyClass.f(x)。通俗点讲，调用一个有 n 个参数的方法等同于调用在这些参数前插入了一个方法的实例作为第一个参数的函数。 如果仍然不明白方法是怎么工作的，我们了解下实现过程可能会有些帮助。当一个引用一个实例的非数据属性时，实例对象类会首先被搜索。如果这个名字指代的是一个有些的类属性而且还是一个函数对象，那方法对象就会被创建用于包装（指针指向）实例对象和函数对象在同一个抽象对象中：这就是方法对象的形成。当带着参数调用方法对象时，会结合实例对象和参数列表创建一个新的参数列表，方法对象所调用的就是这个新的参数列表。 类和实例变量通俗来讲，实例变量是每个实例独有的数据，而类变量则是会让所有此类的实例所共享的方法和属性： 1234567891011121314151617class Dog: kind = 'canine' # 类变量会在所有实例里共享 def __init__(self, name): self.name = name # 每个实例都有独立的实例变量&gt;&gt;&gt; d = Dog('Fido')&gt;&gt;&gt; e = Dog('Buddy')&gt;&gt;&gt; d.kind # 所有 dog 都会共享'canine'&gt;&gt;&gt; e.kind # 同上'canine'&gt;&gt;&gt; d.name # d 所独有的'Fido'&gt;&gt;&gt; e.name # e 所独有的'Buddy' 在 A Word About Names and Objects 的讨论中，共享的数据可能在调用 mutable 可变对象（比如列表和字典）时有意料之外的效果。举个例子， 下面写的 tricks 列表就不应该作为一个类变量存在，因为同一个列表会在所有的 Dog实例中共享： 12345678910111213141516class Dog: tricks = [] # 不要作为类变量误用。 def __init__(self, name): self.name = name def add_trick(self, trick): self.tricks.append(trick)&gt;&gt;&gt; d = Dog('Fido')&gt;&gt;&gt; e = Dog('Buddy')&gt;&gt;&gt; d.add_trick('roll over')&gt;&gt;&gt; e.add_trick('play dead')&gt;&gt;&gt; d.tricks # 我们不希望它在所有 dog 中共享。['roll over', 'play dead'] 正确的设计应该是用实例变量代替： 1234567891011121314151617class Dog: def __init__(self, name): self.name = name self.tricks = [] # 每只 dog 都有一个全新的列表 def add_trick(self, trick): self.tricks.append(trick)&gt;&gt;&gt; d = Dog('Fido')&gt;&gt;&gt; e = Dog('Buddy')&gt;&gt;&gt; d.add_trick('roll over')&gt;&gt;&gt; e.add_trick('play dead')&gt;&gt;&gt; d.tricks['roll over']&gt;&gt;&gt; e.tricks['play dead'] 补充说明数据属性会覆盖同名的方法属性；为了避免命名冲突（冲突的话在大型程序中往往会引起很难查找的 bug），用一些大家都遵守的约定来最小化冲突的机会是非常明智的。一般有大写方法名字，使用独特的短字符串来给数据属性加上前缀（也可以是仅仅一个下划线），或者使用动词命名方法，而使用名词命名数据属性。 数据属性不光可以被此对象的用户（「客户」）一方使用，我们在方法内同样可以使用。换句话说，类不能用于实现纯粹的抽象数据类型。实际上，在 Python 中强制数据隐藏起来也是不可能的 — 它们只是在约定。（换..换句话说， Python 中实现于 C 的部分可以做到完全的隐藏实现细节，也可以控制一个对象的访问；这一点可以用在用 C 写 Python 的扩展上）。 客户一方（就是创建了实例后再用）也应该小心地使用数据属性 — 因为有可能弄乱方法们维护的数据属性一致性。不过客户一方也可以添加自己的数据属性进去，只要避免影响到方法的有效性就行，也就是说避免命名冲突 — 再说一遍！避免命名冲突很！重！要！ Python 中并无在方法内快捷访问数据熟悉的途径（方法的也没有！）。因为这样可以提高可读性：这样就可以快速弄清楚本地变量和实例变量。 通常我们把方法的第一个参数命名为 self. 这只是一个约定： self 这个名字对 Python 来讲并无特殊含义。不过要注意，如果不遵守的话~，其他的 Python 程序猿可能会不知道你写的啥呦~，而且还可依据此来写一个 class browser 的程序 任何作为类属性定义的函数对象都会作为实例或类的方法。把相关的函数定义在类的文本域内并不是必须的：指定一个函数对象到类的本地变量中同样是 Ok 的： 1234567891011# 定义在类外了...def f1(self, x, y): return min(x, x+y)class C: f = f1 def g(self): return 'hello world' h = g f，g， h 都是类 C 的属性，全都是属性对象，同时也都是 C 实例的方法 — h 等同于 g。要注意，这里这种写法一般是为了让程序变得混乱。 使用 self 参数可以在方法内调用其他的方法： 12345678910class Bag: def __init__(self): self.data = [] def add(self, x): self.data.append(x) def addtwice(self, x): self.add(x) self.add(x) 方法也可以像引用普通函数一样引用全局名称。与方法关联的全局作用域是包含着它的模块。（类永远不能作为全局作用域使用）若是有一个在方法中必须要用到全局数据的理由，那要遵守以下几点：其实只有一件事，全局作用域中引入的函数和模块可以使用，在全局作用域中的函数和类也可以使用。通常，全局作用域中的类所包含的方法都是它自己定义的，我们将在下一节找到几个合理的理由来解释为什么一个方法需要引用它自己的类。 每个值都是一个对象，也因此都有 class (也被称为 type)。这些东西都被放在了 object.__class__ 中。 使用 @property在使用 @property 之前，让我们先来看一个简单的例子： 123456789101112131415161718192021class Exam(object): def __init__(self, score): self._score = score def get_score(self): return self._score def set_score(self, val): if val &lt; 0: self._score = 0 elif val &gt; 100: self._score = 100 else: self._score = val&gt;&gt;&gt; e = Exam(60)&gt;&gt;&gt; e.get_score()60&gt;&gt;&gt; e.set_score(70)&gt;&gt;&gt; e.get_score()70 在上面，我们定义了一个 Exam 类，为了避免直接对 _score 属性操作，我们提供了 get_score 和 set_score 方法，这样起到了封装的作用，把一些不想对外公开的属性隐蔽起来，而只是提供方法给用户操作，在方法里面，我们可以检查参数的合理性等。 这样做没什么问题，但是我们有更简单的方式来做这件事，Python 提供了 property 装饰器，被装饰的方法，我们可以将其『当作』属性来用，看下面的例子： 1234567891011121314151617181920212223242526class Exam(object): def __init__(self, score): self._score = score @property def score(self): return self._score @score.setter def score(self, val): if val &lt; 0: self._score = 0 elif val &gt; 100: self._score = 100 else: self._score = val&gt;&gt;&gt; e = Exam(60)&gt;&gt;&gt; e.score60&gt;&gt;&gt; e.score = 90&gt;&gt;&gt; e.score90&gt;&gt;&gt; e.score = 200&gt;&gt;&gt; e.score100 在上面，我们给方法 score 加上了 @property，于是我们可以把 score 当成一个属性来用，此时，又会创建一个新的装饰器 score.setter，它可以把被装饰的方法变成属性来赋值。 另外，我们也不一定要使用 score.setter 这个装饰器，这时 score 就变成一个只读属性了： 123456789101112131415161718class Exam(object): def __init__(self, score): self._score = score @property def score(self): return self._score&gt;&gt;&gt; e = Exam(60)&gt;&gt;&gt; e.score60&gt;&gt;&gt; e.score = 200 # score 是只读属性，不能设置值---------------------------------------------------------------------------AttributeError Traceback (most recent call last)&lt;ipython-input-676-b0515304f6e0&gt; in &lt;module&gt;()----&gt; 1 e.score = 200AttributeError: can't set attribute @property 把方法『变成』了属性。 继承在面向对象编程中，当我们已经创建了一个类，而又想再创建一个与之相似的类，比如添加几个方法，或者修改原来的方法，这时我们不必从头开始，可以从原来的类派生出一个新的类，我们把原来的类称为父类或基类，而派生出的类称为子类，子类继承了父类的所有数据和方法。 继承可以拿到父类的所有数据和方法，子类可以重写父类的方法，也可以新增自己特有的方法。 有了继承，才有了多态，不同类的对象对同一消息会作出不同的相应。 当然，一个不支持继承的「类」不足以被称为类。在类的定义中，继承的语法是这样的： 123456class DerivedClassName(BaseClassName): &lt;statement-1&gt; . . . &lt;statement-N&gt; 类名 BaseClassName 必须被定义在一个包含派生类 DerivedClassName 定义的作用域下。相较于直接使用基类名，任何其它表达式也是可以被填入的。这个特性经常被用到，比如，当基类被定义在其它模块中时： 1class DerivedClassName(modname.BaseClassName): 派生类定义时的执行流程和基类相同。当一个类对象被创建，它会记录它的基类。这将被用于解析对象的属性：如果一个需要的属性不存在于当前类中，紧接着就会去基类中寻找。如果该基类也是从其他类派生出来的，那么相同的过程也会递归地被应用到这些类中。 实例化派生类也没有什么特别的： DerivedClassName() 就会创建类的一个新的实例。方法引用则按如下的方式被解析：首先在当前类中搜索对应的属性，然后沿着继承链往下搜索，如果找到了一个函数对象，那么这个方法引用就是可用的。 派生类可以重写基类的方法。因为方法在调用同一对象其它方法的时候没有什么特权，所以当派生类的实例调用某个基类的方法后，该基类的方法可能会再次调用派生类覆写的另一个基类方法。（对于 C++ 程序员而言， Python 中所有的方法都是 virtual 函数。） 派生类中重写的方法一般用于扩展同名的基类方法，而非简单的替换。 Python 中有一种简单的直接调用基类方法的方案：调用 BaseClassName.methodname(self, arguments) 即可。这在某些情景下也是有用的。（注意这个方法只有在基类 BaseClassName 在全局作用域下可以访问才能使用。） Python 提供了两个判断继承关系的内建函数： 使用 isinstance() 检查一个实例的类型：当且仅当 obj.__class__ 是 int 或其它从 int 派生的类时， isinstance(obj, int) 才会返回 True 。 使用 issubclass() 检查类之间的继承关系：因为 bool 是 int 的一个子类，所以 issubclass(bool, int) 返回 True 。然而，因为 float 不是 int 的派生类，所以 issubclass(float, int) 返回 False 。 多重继承Python 也支持多重继承。一个具有多个基类的类定义如下所示： 123456class DerivedClassName(Base1, Base2, Base3): &lt;statement-1&gt; . . . &lt;statement-N&gt; 对于多数目的，在最简单的情况下，你可以认为搜索父类中继承的属性是深度优先，从左到右，而不是在继承结构中重叠的同一个类中搜索两次。因此，如果一个属性在 DerivedClassName 中没有找到，则在 Base1 中查找，再在 Base1 的基类中（递归地）查找，如果未能找到，则在 Base2 中查找，以此类推。 事实上，这个过程要稍稍更复杂一些；方法解析顺序是动态变化的，以支持合作调用 super() 。这种方法在其他多继承语言中被称为调用下一方法，比单继承语言中的 super 调用更加强大。 动态排序是必要的，因为所有多重继承的情况都表现出一个或多个菱形关系（其中至少有一个父类可以通过最底层的多个路径访问）。例如，所有的类都继承自 object ，所以任何情况的多重继承都提供了不止一条的路径到达 object 。 为了避免基类被多次访问，动态算法保证在每个类中进行从左到右特定顺序的线性搜索，因此每个父类只被调用一次，并且这个方法是单调的（意味着类可以被子类化而不影响其的优先顺序）。 总之，这些特性使得设计具有多重继承的可靠的且可扩展的类成为可能。 更多细节请参考 https://www.python.org/download/releases/2.3/mro/. 你不知道的 super在类的继承中，如果重定义某个方法，该方法会覆盖父类的同名方法，但有时，我们希望能同时实现父类的功能，这时，我们就需要调用父类的方法了，可通过使用 super 来实现，比如： 12345678910class Animal(object): def __init__(self, name): self.name = name def greet(self): print 'Hello, I am %s.' % self.nameclass Dog(Animal): def greet(self): super(Dog, self).greet() # Python3 可使用 super().greet() print 'WangWang...' 在上面，Animal 是父类，Dog 是子类，我们在 Dog 类重定义了 greet 方法，为了能同时实现父类的功能，我们又调用了父类的方法，看下面的使用： 1234&gt;&gt;&gt; dog = Dog('dog')&gt;&gt;&gt; dog.greet()Hello, I am dog.WangWang.. super 的一个最常见用法可以说是在子类中调用父类的初始化方法了，比如： 123456789class Base(object): def __init__(self, a, b): self.a = a self.b = bclass A(Base): def __init__(self, a, b, c): super(A, self).__init__(a, b) # Python3 可使用 super().__init__(a, b) self.c = c 深入 super()看了上面的使用，你可能会觉得 super 的使用很简单，无非就是获取了父类，并调用父类的方法。其实，在上面的情况下，super 获得的类刚好是父类，但在其他情况就不一定了，super 其实和父类没有实质性的关联。 让我们看一个稍微复杂的例子，涉及到多重继承，代码如下： 12345678910111213141516171819202122class Base(object): def __init__(self): print \"enter Base\" print \"leave Base\"class A(Base): def __init__(self): print \"enter A\" super(A, self).__init__() print \"leave A\"class B(Base): def __init__(self): print \"enter B\" super(B, self).__init__() print \"leave B\"class C(A, B): def __init__(self): print \"enter C\" super(C, self).__init__() print \"leave C\" 其中，Base 是父类，A, B 继承自 Base, C 继承自 A, B，它们的继承关系是一个典型的『菱形继承』，如下： 1234567 Base / \\ / \\A B \\ / \\ / C 现在，让我们看一下使用： 123456789&gt;&gt;&gt; c = C()enter Center Aenter Benter Baseleave Baseleave Bleave Aleave C 如果你认为 super 代表『调用父类的方法』，那你很可能会疑惑为什么 enter A 的下一句不是 enter Base 而是 enter B。原因是，super 和父类没有实质性的关联，现在让我们搞清 super 是怎么运作的。 MRO 列表事实上，对于你定义的每一个类，Python 会计算出一个方法解析顺序（Method Resolution Order, MRO）列表，它代表了类继承的顺序，我们可以使用下面的方式获得某个类的 MRO 列表： 12&gt;&gt;&gt; C.mro() # or C.__mro__ or C().__class__.mro()[__main__.C, __main__.A, __main__.B, __main__.Base, object] 那这个 MRO 列表的顺序是怎么定的呢，它是通过一个 C3 线性化算法来实现的，这里我们就不去深究这个算法了，感兴趣的读者可以自己去了解一下，总的来说，一个类的 MRO 列表就是合并所有父类的 MRO 列表，并遵循以下三条原则： 子类永远在父类前面 如果有多个父类，会根据它们在列表中的顺序被检查 如果对下一个类存在两个合法的选择，选择第一个父类 super 原理123def super(cls, inst): mro = inst.__class__.mro() return mro[mro.index(cls) + 1] 其中，cls 代表类，inst 代表实例，上面的代码做了两件事： 获取 inst 的 MRO 列表 查找 cls 在当前 MRO 列表中的 index, 并返回它的下一个类，即 mro[index + 1] 当你使用 super(cls, inst) 时，Python 会在 inst 的 MRO 列表上搜索 cls 的下一个类。 现在，让我们回到前面的例子。 首先看类 C 的 __init__ 方法： 1super(C, self).__init__() 这里的 self 是当前 C 的实例，self.class.mro() 结果是： 1[__main__.C, __main__.A, __main__.B, __main__.Base, object] 可以看到，C 的下一个类是 A，于是，跳到了 A 的 __init__，这时会打印出 enter A，并执行下面一行代码： 1super(A, self).__init__() 注意，这里的 self 也是当前 C 的实例，MRO 列表跟上面是一样的，搜索 A 在 MRO 中的下一个类，发现是 B，于是，跳到了 B 的 __init__，这时会打印出 enter B，而不是 enter Base。 整个过程还是比较清晰的，关键是要理解 super 的工作方式，而不是想当然地认为 super 调用了父类的方法。 小结 事实上，super 和父类没有实质性的关联。 super(cls, inst) 获得的是 cls 在 inst 的 MRO 列表中的下一个类。 私有变量只能从对像内部访问的『私有』实例变量，在 Python 中不存在。然而，在大多数 Python 代码中存在一个这样的约定：以一个下划线开头的命名（例如 _spam ）会被处理为 API 的非公开部分（无论它是一个函数、方法或数据成员）。它会被视为一个实现细节，无需公开。 因为有一个正当的类私有成员用途（即避免子类里定义的命名与之冲突），Python 提供了对这种结构的有限支持，称为 name mangling （命名编码） 。任何形如 __spam 的标识（前面至少两个下划线，后面至多一个下划线），被替代为 _classname__spam ，去掉前导下划线的 classname 即当前的类名。此语法不关注标识的位置，只要求在类定义内。 名称重整是有助于子类重写方法，而不会打破组内的方法调用。例如: 123456789101112131415161718class Mapping: def __init__(self, iterable): self.items_list = [] self.__update(iterable) def update(self, iterable): for item in iterable: self.items_list.append(item) __update = update # private copy of original update() methodclass MappingSubclass(Mapping): def update(self, keys, values): # provides new signature for update() # but does not break __init__() for item in zip(keys, values): self.items_list.append(item) 需要注意的是编码规则设计为尽可能的避免冲突，被认作为私有的变量仍然有可能被访问或修改。在特定的场合它也是有用的，比如调试的时候。 要注意的是代码传入 exec()， eval() 时不考虑所调用的类的类名，视其为当前类，这类似于 global 语句的效应，已经按字节编译的部分也有同样的限制。这也同样作用于 getattr()， setattr() 和 delattr()，像直接引用 __dict__ 一样。 零碎知识点有时候，有一个类似于 Pascal 「记录」或者 C 「结构体」的数据类型是非常有用的，它能够将一些命名数据项捆绑在一起： 123456789class Employee: passjohn = Employee() # 创建一个新的 employee 记录# 给记录的各个字段赋值john.name = 'John Doe'john.dept = 'computer lab'john.salary = 1000 一块 Python 代码通常希望能够传递特定抽象数据类型 ，而一个类则会模拟该数据类型的方法。例如，如果你有一个函数，可以格式化文件对象当中的一些数据；那么，你就可以定义一个带有 read() 方法和 readline() 方法的类，这两个方法可以从数据缓冲区中读取数据没并且将其作为参数传递出去。 实例方法对象也有属性： m.__self__ 是带有方法 m() 的实例对象，并且 m.__func__ 是和方法相对应的函数对象。 类是具有相同属性和方法的一组对象的集合，实例是一个个具体的对象。 方法是与实例绑定的函数。 获取对象信息可使用下面方法： type(obj)：来获取对象的相应类型； isinstance(obj, type)：判断对象是否为指定的 type 类型的实例； hasattr(obj, attr)：判断对象是否具有指定属性/方法； getattr(obj, attr[, default]) 获取属性/方法的值, 要是没有对应的属性则返回 default 值（前提是设置了 default），否则会抛出 AttributeError 异常； setattr(obj, attr, value)：设定该属性/方法的值，类似于 obj.attr=value； dir(obj)：可以获取相应对象的所有属性和方法名的列表： __new__ 在 __init__ 之前被调用，用来创建实例。 __str__ 是用 print 和 str 显示的结果，__repr__ 是直接显示的结果。 __getitem__ 用类似 obj[key] 的方式对对象进行取值 __getattr__ 用于获取不存在的属性 obj.attr __call__ 使得可以对实例进行调用 迭代器目前为止，你可能发现了，大部分容器对象都能被 for 所循环： 12345678910for element in [1, 2, 3]: print(element)for element in (1, 2, 3): print(element)for key in &#123;'one':1, 'two':2&#125;: print(key)for char in \"123\": print(char)for line in open(\"myfile.txt\"): print(line, end='') 这种形式的访问很清晰，简洁，方便。其背后是迭代器在起作用，for声明会调用容器对象的 iter() 函数，这个函数则返回一个迭代器对象，迭代器对象有 __next__() 方法，它会让容器中的元素一次返回一个。 __next__() 会抛出 StopIteration 异常来让 for 结束。你也可以用 next() 函数来调用它的 __next__() 方法；下面的例子显示了迭代器是如何工作的： 123456789101112131415&gt;&gt;&gt; s = 'abc'&gt;&gt;&gt; it = iter(s)&gt;&gt;&gt; it&lt;iterator object at 0x00A1DB50&gt;&gt;&gt;&gt; next(it)'a'&gt;&gt;&gt; next(it)'b'&gt;&gt;&gt; next(it)'c'&gt;&gt;&gt; next(it)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; next(it)StopIteration 了解了迭代器协议背后的机制，我们就可以很容易得在我们自己的类中添加迭代器行为。__iter__() 方法需要返回一个带有 __next__() 方法的对象。如果类仅仅定义了__next__()， __iter__() 那么返回的对象就是它自己 self。 1234567891011121314class Reverse: &quot;&quot;&quot;从后向前的迭代器&quot;&quot;&quot; def __init__(self, data): self.data = data self.index = len(data) def __iter__(self): return self def __next__(self): if self.index == 0: raise StopIteration self.index = self.index - 1 return self.data[self.index] 12345678910&gt;&gt;&gt; rev = Reverse('spam')&gt;&gt;&gt; iter(rev)&lt;__main__.Reverse object at 0x00A1DB50&gt;&gt;&gt;&gt; for char in rev:... print(char)...maps 生成器Generator 是一个简单又强大的创建迭代器的工具。写它们只要像常规函数一样就可以，只不过用的是 yield 代替 return 返回数据。 每次 next() 调用生成器时，生成器就会从它断开的地方恢复（它会记录所有的数据和最后执行的声明）。下面写个例子来展示下生成器并不神秘难写。 123def reverse(data): for index in range(len(data)-1, -1, -1): yield data[index] 1234567&gt;&gt;&gt; for char in reverse('golf'):... print(char)...flog 所以生成器能做的事情，我们之前介绍过的以类为基础的迭代器也可以做。生成器之所以显得更加紧凑，是因为 __iter__() 和 __next__() 方法都被自动隐式的创建了。 生成器的另一个特色是本地变量和执行条件都会被自动保存。这就让我们很容易写出生成器函数，同时也比使用实例属性像是 self.index，self.data 来的简洁。 除了自动创建的方法和保存的程序状态，当生成器结束时，还会自动抛出 StopIteration. 这些东西组合起来，就变成了一个让我们非常容易书写的迭代器形式。 生成器表达式一些简单的生成器我们可以用类似列表表达式的代码做出来，只要把方括号换成圆括号就行了。生成器表达式用来一般用在在函数内需要写即用即删的数据的时候。生成器表达式比起完整的生成器要更加紧凑但并不如它功能强大，不过比起列表表达式来内存占用更少。 例子: 123456789101112131415161718&gt;&gt;&gt; sum(i*i for i in range(10)) # 平方之和285&gt;&gt;&gt; xvec = [10, 20, 30]&gt;&gt;&gt; yvec = [7, 5, 3]&gt;&gt;&gt; sum(x*y for x,y in zip(xvec, yvec)) # 乘积260&gt;&gt;&gt; from math import pi, sin&gt;&gt;&gt; sine_table = &#123;x: sin(x*pi/180) for x in range(0, 91)&#125;&gt;&gt;&gt; unique_words = set(word for line in page for word in line.split())&gt;&gt;&gt; valedictorian = max((student.gpa, student.name) for student in graduates)&gt;&gt;&gt; data = 'golf'&gt;&gt;&gt; list(data[i] for i in range(len(data)-1, -1, -1))['f', 'l', 'o', 'g'] 参考资料 python官方文档 python之旅 简明python https://wizardforcel.gitbooks.io/w3school-python/content/24.html http://yangcongchufang.com/%E9%AB%98%E7%BA%A7python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/python-object-class.html https://mrlongx.com/index.php/2017/09/27/core-python-ch13/","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"python错误和异常","date":"2018-09-08T13:51:01.289Z","path":"2018/09/08/python错误和异常/","text":"Python使用名为”异常”的特殊对象来管理程序执行期间发生的错误。 语法错误语法错误，也叫作解析错误，这可能是你在学习Python的过程中，最容易碰到的错误： 12345&gt;&gt;&gt; while True print('Hello world') File \"&lt;stdin&gt;\", line 1 while True print('Hello world') ^SyntaxError: invalid syntax 解析结果显示出错的行代码，并用小箭头指明解析到错误的具体位置。这个错误是在箭头所指向的位置：在本例中，错误是在这个函数中检测到的 print()，因为print函数之前应该存在的冒号缺失。文件名称和行号都被打印出来，这样你就可以知道这行有错误的代码是在哪个位置了。 异常一条语句或表达式即便是语法正确也有可能在运行的时候报错。程序执行过程中遇到的错误被称为异常。这种错误并不一定是致命错误，我们一会儿来看如何在程序中处理异常。大多数的异常并非由程序自身处理，而是会显示类似下面列举的错误信息。 123456789101112&gt;&gt;&gt; 10 * (1/0)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;ZeroDivisionError: division by zero&gt;&gt;&gt; 4 + spam*3Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: name 'spam' is not defined&gt;&gt;&gt; '2' + 2Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: Can't convert 'int' object to str implicitly 错误信息的最后一行告诉我们程序遇到了什么类型的错误。异常有不同的类型，而其类型名称将会在错误信息中输出出来。上述样例中的异常类型依次是： ZeroDivisionError 、 NameError 以及 TypeError 。错误信息中的异常类型是执行时抛出的内建异常类型。所有的内建类型都会如此，而虽然这是一个有用的惯例，但是用户自定义的异常并非一定如此。标准的异常类型是内建的标识符而非预留关键词。 这一行剩下的部分能告诉我们此处抛出异常的具体信息及触发的原因。 错误信息的前面部分能够通过栈调用信息告诉我们抛出异常时的上下文。一般情况下栈调用信息会包含函数调用所在的源代码行，但是不会包含从标准输入读入的信息。 Built-in Exceptions 列举了内建异常类型以及各自的含义。 捕捉异常Python 允许编程处理特定的异常。在下面这个例子中，程序要求用户进行输入，直到接收到一个合法的整数，同时也允许用户中断程序 （使用 Control-C 或操作系统支持的其他方式）；注意，由用户引起的中断通过抛出 KeyboardInterrupt 异常来实现。 1234567&gt;&gt;&gt; while True:... try:... x = int(input(\"Please enter a number: \"))... break... except ValueError:... print(\"Oops! That was no valid number. Try again...\")... try声明的工作原理如下： 程序首先执行 try 子句 （位于 try 和 except 关键字之间的内容)。 如果没有异常产生，则 except 子句被跳过，并且 try 声明的部分运行结束 如果在执行 try 子句的过程中产生了一个异常，那么这个子句范围内产生异常位置之后的代码不会被执行，如果产生的异常位于 except 关键字后提到的若干异常之中，那么except 子句的内容将会接着 try 中刚被中止的位置继续执行。 如果产生的异常并不在 exception 后面包含的若干异常中，该异常将会被抛给上一层的 try 语句；如果一个异常没有被任何一层 try-exception 语句捕捉，它就成为一个 未处理异常 ，程序执行将因此停止并显示如上所示的消息。一个 try 声明可以包含多个 except 子句来针对不同的异常做出不同的处理，但最多只有一个 except 子句（即错误处理器）会被执行。错误处理器只处理出现在对应 try 子句中产生的异常，而不会处理同一 try 语句中其他错误处理器中的异常。一个 except 子句可以指定多个异常，这些异常用一个元组包含起来，例如： 12... except (RuntimeError, TypeError, NameError):... pass 捕获所有异常想要捕获所有的异常，可以直接捕获 Exception 即可： 12345try: ...except Exception as e: ... log('Reason:', e) # Important! 这个将会捕获除了 SystemExit 、 KeyboardInterrupt 和 GeneratorExit 之外的所有异常。 如果你还想捕获这三个异常，将 Exception 改成 BaseException 即可。 讨论捕获所有异常通常是由于程序员在某些复杂操作中并不能记住所有可能的异常。 如果你不是很细心的人，这也是编写不易调试代码的一个简单方法。 正因如此，如果你选择捕获所有异常，那么在某个地方（比如日志文件、打印异常到屏幕）打印确切原因就比较重要了。 如果你没有这样做，有时候你看到异常打印时可能摸不着头脑，就像下面这样： 12345def parse_int(s): try: n = int(v) except Exception: print(\"Couldn't parse\") 试着运行这个函数，结果如下： 12345&gt;&gt;&gt; parse_int('n/a')Couldn't parse&gt;&gt;&gt; parse_int('42')Couldn't parse&gt;&gt;&gt; 这时候你就会挠头想：“这咋回事啊？” 假如你像下面这样重写这个函数： 123456def parse_int(s): try: n = int(v) except Exception as e: print(\"Couldn't parse\") print('Reason:', e) 这时候你能获取如下输出，指明了有个编程错误： 1234&gt;&gt;&gt; parse_int('42')Couldn't parseReason: global name 'v' is not defined&gt;&gt;&gt; 很明显，你应该尽可能将异常处理器定义的精准一些。 不过，要是你必须捕获所有异常，确保打印正确的诊断信息或将异常传播出去，这样不会丢失掉异常。 练习题:python实现tmp目录下匹配文件，并打包压缩至系统另一个目录，关键模块:tarfile、fnmatch 1234567891011121314151617181920212223242526272829#!/usr/bin/env python# vim:set et ts=4 sw=4 fileencoding=utf-8:# -*- coding: utf-8 -*-# @Author: yoimport osimport tarfileimport fnmatchsrc_dir = '/tmp'def tar_file(): try: if os.getcwd() not in src_dir: os.chdir(src_dir) print (os.getcwd()) with tarfile.open(\"/tmp/tmp-bak/bak.tar.gz\", \"w:gz\") as tar_package: for files in os.listdir(os.getcwd()): if fnmatch.fnmatch(files, '*_*.jpg'): tar_package.add(files) tar_package.close() except: print (\"Tar Archive Error..\") raiseif __name__ == '__main__': tar_file() 直接使用raise也能正常抛出异常。 如果两个异常是同一类或者具有同一个父类，那它们可以在一个 except 子句中同时存在（但是另一种情况并不成立——如果一个类是另一个类的派生类，那么这两个类不能在一个 except 子句中同时存在）。例如，下面的这段代码中，将按照顺序输出 B, C, D： 123456789101112131415161718class B(Exception): passclass C(B): passclass D(C): passfor cls in [B, C, D]: try: raise cls() except D: print(\"D\") except C: print(\"C\") except B: print(\"B\") 注意：如果这些 except 子句按照相反的顺序排列（except B在最前面），则输出会变成 B，B，B。——和异常匹配的第一个 except 子句会被触发。 最后一个 except 子句可以省略异常名用作通配符。使用这个方法要特别谨慎，因为这个方法可能掩盖一个真正的编程错误！它还可以用于打印错误后，重新引发异常（也允许调用者处理异常）： 12345678910111213import systry: f = open('myfile.txt') s = f.readline() i = int(s.strip())except OSError as err: print(\"OS error: &#123;0&#125;\".format(err))except ValueError: print(\"Could not convert data to an integer.\")except: print(\"Unexpected error:\", sys.exc_info()[0]) raise try … except 语句有一个可选的 else 子句， 当它出现时，必须在所有l except 子句之后。在执行 try 子句之后没有引发异常因此时，它可以用于必须执行的代码。例如： 12345678for arg in sys.argv[1:]: try: f = open(arg, 'r') except OSError: print('cannot open', arg) else: print(arg, 'has', len(f.readlines()), 'lines') f.close() else 子句的使用比在 try 子句中增加而外的代码更好，因为他可以避免意外地捕获不被 try …except 语句包含的异常。 当一个异常发生时，它可能有相关的值，或者是异常的 参数。尝试的有无和参数的类型取决于异常的类型。 except 子句可以在异常名之后指定变量。这些变量被绑定到一个异常实例中，实例中的参数储存在 instance.args 中。为了方便，异常实例定义了 __str__() ，所以参数可以被直接打印出来，而不需要引用 .args 。还可以在引发异常之前先实例化异常并根据需要添加任何属性。 12345678910111213141516&gt;&gt;&gt; try:... raise Exception('spam', 'eggs')... except Exception as inst:... print(type(inst)) # 异常实例... print(inst.args) # 储存在 .args 中的参数... print(inst) # __str__ 允许参数被直接打印，... # 但是方法可能会被异常子类复写... x, y = inst.args # 提取参数... print('x =', x)... print('y =', y)...&lt;class 'Exception'&gt;('spam', 'eggs')('spam', 'eggs')x = spamy = eggs 如果异常带有参数，他们会作为未处理异常的信息中的最后一部分（’detail’）被打印出来。 异常处理程序不仅仅立刻处理 try 子句中的产生的异常，同时也包括 try 子句中调用函数（即使是间接地）中产生的异常。例如： 123456789&gt;&gt;&gt; def this_fails():... x = 1/0...&gt;&gt;&gt; try:... this_fails()... except ZeroDivisionError as err:... print('Handling run-time error:', err)...Handling run-time error: division by zero 抛出异常raise 语句允许开发者显式地引发异常。例如： 1234&gt;&gt;&gt; raise NameError('HiThere')Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: HiThere raise 关键字后跟随表示被抛出异常的单一变量，该变量可以是一个异常实例，或者一个异常类（继承自 Exception）。如果被传递的变量是一个异常类，它会隐式地无参数调用其构造方法进行实例化： 1raise ValueError # 'raise ValueError()' 的简写 如果你只需要知道一个异常被抛出了，但并需要处理它，可以通过一个简单的 raise 语句重新抛出这个异常： 12345678910&gt;&gt;&gt; try:... raise NameError('HiThere')... except NameError:... print('An exception flew by!')... raise...An exception flew by!Traceback (most recent call last): File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;NameError: HiThere 用户定义的异常程序可以通过创建一个新的异常类来命名其专属的异常 (参考 Classes 以获得更多有关Python类的信息)。 异常通常应该派生自 Exception 类，无论是直接地还是间接地。 异常类可以以如通常类一样进行定义，但是通常会保持简洁，一般仅仅提供数个用于异常处理时可以解析异常信息的属性。在创建一个可以能引起多个不同异常的模块时，通常的做法是创建一个由模块定义的异常基类，并为不同的异常条件创建特定的异常子类： 1234567891011121314151617181920212223242526272829class Error(Exception): \"\"\"本模块的异常基类\"\"\" passclass InputError(Error): \"\"\"输入中错误引发的异常 属性： expression -- 产生错误输入表达 message -- 错误解释 \"\"\" def __init__(self, expression, message): self.expression = expression self.message = messageclass TransitionError(Error): \"\"\"尝试不允许状态转换的操作时引发的异常 属性： previous -- 转换前的状态 next -- 尝试转换的状态 message -- 解释为什么特定的转换操作不允许 \"\"\" def __init__(self, previous, next, message): self.previous = previous self.next = next self.message = message 大多数的异常定义都以「错误（Error）」结尾，和标准异常的命名类似。 很多标准模块定义了它们自己的异常，用于报告它们定义的函数中可能产生的错误。有关类的更多信息在章节 Classes 中有介绍. 定义清理操作 try 语句有另一个可选的子语句，用于定义必须在所有情况下都执行的清理操作。例如： 123456789&gt;&gt;&gt; try:... raise KeyboardInterrupt... finally:... print('Goodbye, world!')...Goodbye, world!KeyboardInterruptTraceback (most recent call last): File \"&lt;stdin&gt;\", line 2, in &lt;module&gt; finally 子句 总是在结束 try 语句之前执行，无论是否有异常产生。当异常产生在When an exception try 子句中产生并未被 except 子句捕获（或异常在 except 或 else 子句中产生）时，异常将在 finally子句被执行后再引发。 finally 子句也在「离开的路上」被执行，即当其他子句通过 break, continue or return 等语句离开 try 语句时。以下为一个更加复杂的例子： 12345678910111213141516171819202122&gt;&gt;&gt; def divide(x, y):... try:... result = x / y... except ZeroDivisionError:... print(\"division by zero!\")... else:... print(\"result is\", result)... finally:... print(\"executing finally clause\")...&gt;&gt;&gt; divide(2, 1)result is 2.0executing finally clause&gt;&gt;&gt; divide(2, 0)division by zero!executing finally clause&gt;&gt;&gt; divide(\"2\", \"1\")executing finally clauseTraceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; File \"&lt;stdin&gt;\", line 3, in divideTypeError: unsupported operand type(s) for /: 'str' and 'str' 如你所见， finally 子句在任一事件中都被执行。 TypeError 异常因进行字符串除法引发，而且未被 except 子句捕获，并因此在 finally 子句被执行后之后才产生。 在实际的应用中， finally 子句在释放外部资源（如文件或者网络连接）时非常非常有用，无论资源是否被成功使用。 预定义的清理操作某些对象定义了在不再需要该对象时需要执行的标准清理操作，无论在该对象上进行的操作是成功还是失败。 查看以下示例，该示例尝试打开文件并将其内容打印到屏幕上。 12for line in open(\"myfile.txt\"): print(line, end=\"\") 此代码的问题在于，在部分代码执行完毕后，它会使文件保持打开一段不确定的时间。 这在简单脚本中不是问题，但对于较大的应用可能是一个问题。 with 语句使用允许文件之类的对象是，以保证始终及时正确的清理的方式进行。 123with open(\"myfile.txt\") as f: for line in f: print(line, end=\"\") 在语句执行后，文件 f 总是被关闭，即使在处理每行时遇到错误。 与文件相同，提供预定义清理操作的对象将在其文档中指出这一点。 参考资料 https://docs.python.org/3/tutorial/errors.html","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"python输入和输出","date":"2018-09-08T13:26:51.456Z","path":"2018/09/08/python输入和输出/","text":"程序的输出可以有多种形式：我们可以将数据以人类可读的形式打印到屏幕上，或者将其写入到文件中以供后续使用。本章将讨论其中的几种实现方式。 格式化输出迄今为止，在 Python 中存在两种输出值的方法：表达式语句以及 print() 函数。（第三种方法是使用文件对象的 write() 方法；标准文件输出可以参考 sys.stdout 方法，其详细内容请查阅库参考手册。） 通常，相较于简单地打印以空格为分隔符的值，你会想要对程序的输出结果进行更多的格式控制。在 Python 中，存在如下几种格式化输出的方法： 使用 f-strings 字符串。这类字符串需要在引号标记之前，以 f 或者 F 作为字符串的开头。你可以使用 { 和 } 包裹想要嵌入到字符串中的 Python 表达式。该表达式可以是某个变量或字面值 。 123&gt;&gt;&gt; year = 2016 ; event = 'Referendum'&gt;&gt;&gt; f'Results of the &#123;year&#125; &#123;event&#125;''Results of the 2016 Referendum' str.format() 是格式化字符串的第二种方法。相较于第一种方法，该方法需要你进行更多的操作。你仍然可以在字符串中使用 { 和 } 来内嵌变量，也可以进行详细的格式化设计。但这要求你提供与之对应的被格式化的内容。 1234&gt;&gt;&gt; yes_votes = 42_572_654 ; no_votes = 43_132_495&gt;&gt;&gt; percentage = yes_votes/(yes_votes+no_votes)&gt;&gt;&gt; '&#123;:-9&#125; YES votes &#123;:2.2%&#125;'.format(yes_votes, percentage)' 42572654 YES votes 49.67%' 当然，你也可以通过字符串的切片操作和连接操作来完成字符串的格式化处理。这种方法可以创建任何你想要的格式化形式。在 string 类型中，包含了一些能够将字符串按指定列宽填充的方法。 如果你仅仅想要在调试时打印某些变量，而不进行格式化输出，那么你也可以使用 repr() 函数或者 str() 函数将任意值转化成字符串。 str() 函数能够将值以人类可读的形式呈现，而 repr() 函数则是将值以解释器可读的形式呈现（如果没有与之对应的转换语法，则会产生 SyntaxError 异常）。若某个对象没有适用于人类可读的形式，则 str() 函数的返回值与 repr() 函数相同。在 Python 中，诸如数值、或者是链表、字典这样的结构，上述两种函数各自有统一的呈现方式。但是对于字符串，上述两种函数各自有独特的呈现方式。 如下示例： 1234567891011121314151617181920&gt;&gt;&gt; s = 'Hello, world.'&gt;&gt;&gt; str(s)'Hello, world.'&gt;&gt;&gt; repr(s)\"'Hello, world.'\"&gt;&gt;&gt; str(1/7)'0.14285714285714285'&gt;&gt;&gt; x = 10 * 3.25&gt;&gt;&gt; y = 200 * 200&gt;&gt;&gt; s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'&gt;&gt;&gt; print(s)The value of x is 32.5, and y is 40000...&gt;&gt;&gt; # 对于字符串，repr() 函数会添加引号以及反斜杠：... hello = 'hello, world\\n'&gt;&gt;&gt; hellos = repr(hello)&gt;&gt;&gt; print(hellos)'hello, world\\n'&gt;&gt;&gt; # repr() 函数的参数也可以是某个 Python 对象：... repr((x, y, ('spam', 'eggs')))\"(32.5, 40000, ('spam', 'eggs'))\" 格式化字符串文字格式化字符串文字 （简称 f-strings ）允许你在字符串中包含Python表达式的值，方法是在字符串前面加上 f 或者 F ，并将表达式写成 {expression} 格式。 在表达式后面可以加上格式说明符。这样能够更好地控制表达式值的输出格式。下面的例子将 PI 舍入到小数位数后三位。 12&gt;&gt;&gt; import math&gt;&gt;&gt; print(f'The value of pi is approximately &#123;math.pi:.3f&#125;.') 在 &#39;:&#39; 之后加上一个整数表示该字段的最小字符数，这对于列排序很有用。 1234567&gt;&gt;&gt; table = &#123;'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678&#125;&gt;&gt;&gt; for name, phone in table.items():... print(f'&#123;name:10&#125; ==&gt; &#123;phone:10d&#125;')...Sjoerd ==&gt; 4127Jack ==&gt; 4098Dcab ==&gt; 7678 也可用其他修饰符来转换要格式化的值。 &#39;!a&#39; 表示应用 ascii()函数 ， &#39;!s&#39; 表示应用 str() 函数， 另外 &#39;!r&#39; 表示应用 repr() 函数： 12345&gt;&gt;&gt; animals = 'eels'&gt;&gt;&gt; print(f'My hovercraft is full of &#123;animals&#125;.')My hovercraft is full of eels.&gt;&gt;&gt; print('My hovercraft is full of &#123;animals !r&#125;.')My hovercraft is full of 'eels'. 有关这些格式规范的参考，请参阅参考指南 最小字符串格式化。 format() 字符串格式化方法str.format() 的基本使用方法如下： 12&gt;&gt;&gt; print('We are the &#123;&#125; who say \"&#123;&#125;!\"'.format('knights', 'Ni'))We are the knights who say \"Ni!\" 其中的括号和字符（称为格式字段）将用传入 str.format() 方法中的对象来替换。括号中的数字可用于表示传递给 str.format() 方法的对象的位置。 1234&gt;&gt;&gt; print('&#123;0&#125; and &#123;1&#125;'.format('spam', 'eggs'))spam and eggs&gt;&gt;&gt; print('&#123;1&#125; and &#123;0&#125;'.format('spam', 'eggs'))eggs and spam 如果在 str.format() 方法中使用关键字参数，其值等于参数名称对应的值。 123&gt;&gt;&gt; print('This &#123;food&#125; is &#123;adjective&#125;.'.format(... food='spam', adjective='absolutely horrible'))This spam is absolutely horrible. 位置和关键字参数可以任意组合： 123&gt;&gt;&gt; print('The story of &#123;0&#125;, &#123;1&#125;, and &#123;other&#125;.'.format('Bill', 'Manfred', other='Georg'))The story of Bill, Manfred, and Georg. 如果你有一个不想拆分的长字符，使用名称而不是位置来进行格式化将会是一个更好的方法。这可以简单的使用 &#39;[]&#39; 符号来获取字典中的键 1234&gt;&gt;&gt; table = &#123;'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678&#125;&gt;&gt;&gt; print('Jack: &#123;0[Jack]:d&#125;; Sjoerd: &#123;0[Sjoerd]:d&#125;; '... 'Dcab: &#123;0[Dcab]:d&#125;'.format(table))Jack: 4098; Sjoerd: 4127; Dcab: 8637678 上面的方法也可以使用 ‘**’ 将字典中的信息进行传递。 123&gt;&gt;&gt; table = &#123;'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678&#125;&gt;&gt;&gt; print('Jack: &#123;Jack:d&#125;; Sjoerd: &#123;Sjoerd:d&#125;; Dcab: &#123;Dcab:d&#125;'.format(**table))Jack: 4098; Sjoerd: 4127; Dcab: 8637678 这与内置函数 vars() 的结合非常有用，这个内置函数能够能够返回包含所有局部变量的字典。 例如，下面的代码生成了将数字本身与其平方、立方整齐对齐的数列： 12345678910111213&gt;&gt;&gt; for x in range(1, 11):... print('&#123;0:2d&#125; &#123;1:3d&#125; &#123;2:4d&#125;'.format(x, x*x, x*x*x))... 1 1 1 2 4 8 3 9 27 4 16 64 5 25 125 6 36 216 7 49 343 8 64 512 9 81 72910 100 1000 有关字符串格式的完整概述 str.format() ，请参阅 格式字符串语法 。 手动格式化字符串这是一些相同的平方和立方的表，手动格式化： 123456789101112131415&gt;&gt;&gt; for x in range(1, 11):... print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')... # 注意在前一行中使用 'end'... print(repr(x*x*x).rjust(4))... 1 1 1 2 4 8 3 9 27 4 16 64 5 25 125 6 36 216 7 49 343 8 64 512 9 81 72910 100 1000 （注意 print() 函数在每一列中添加了一个空格 print() ：它经常在参数之间添加空格。） 字符串对象的 str.rjust() 方法在某一栏以给定的宽度会在左边填充空格来对一个字符串进行右对齐。 str.ljust() 和 str.center() 等这些方法相似。 这些方法不写入任何东西，它们只会返回一个新的字符串。如果输入的字符串太长，它们不会截断它，但是会原样返回它。它们会搞乱你的列的排序，但这通常比替代方案更好，它们会通过值来排布。（如果你真的想截断字符串，通常你可以添加一个切片操作，像 x.ljust(n)[:n] 。） 有另外一个方法， str.zfill()， 它会在一个数字型的字符串的左边添加0。它了解正负号： 123456&gt;&gt;&gt; '12'.zfill(5)'00012'&gt;&gt;&gt; '-3.14'.zfill(7)'-003.14'&gt;&gt;&gt; '3.14159265359'.zfill(5)'3.14159265359' 传统字符串格式化方法操作符 ‘%’ 同样可以被用来格式化字符串。它将该操作符左侧参数解释为 ‘sprintf()’ 样式的字符串应用到操作符右侧参数，并且返回字符串。例如： 123&gt;&gt;&gt; import math&gt;&gt;&gt; print('The value of pi is approximately %5.3f.' % math.pi)The value of pi is approximately 3.142. 更多信息请参考文档 printf-style String Formatting。 读写文件open() 将返回一个文件对象，它使用两个参数作为输入：open(filename,mode)，例如： 1&gt;&gt;&gt; f = open('workfile', 'w') 第一个参数 filename 是一个包含文件名的字符串。第二个参数 mode 是包含几个单独字母的字符串，用于解释该文件将被用何种方式处理。 mode 参数可以使用 &#39;r&#39; 表示只读模式；&#39;w&#39; 表示只写入模式（同时，同名文件的文件内容将会被抹掉）； &#39;a&#39; 表示在文件末尾追加写入，在该模式下，任何数据都会被自动追加到该文件末尾；&#39;r+&#39; 表示读写操作。 mode 是可选的，未指定的情况下将会默认为 &#39;r&#39; 模式进行读文件。 正常情况下，文件以 text mode 打开， 这就意味着，我们使用字符串数据对文件进行读写操作，这些都是按照某种指定的编码格式进行读写。如果编码格式未被指定，默认编码格式是与平台相关（详情见 open()）。 &#39;b&#39; 表示以 二进制模式 打开文件并且追加数据， 数据以字节的形式读写到文件中，但是这种模式应该被用来打开不包含文本的文件中。 在 text mode 中，默认读操作的行尾 \\n 同样是依据指定平台进行选择的。（Unix系统中使用\\n ， Windows系统中使用 \\r\\n）。在 text mode 模式下写入文件，默认情况下会将\\n转换成对应的平台的行尾字符。这种对文件修改的操作仅适用于文本文件，但是在操作 JPEG 或者 EXE 二进制数据文件过程中，要非常小心的使用二进制模式对他们进行读写操作。 关键字 with 是非常适合用于处理文件对象。它的优势在于，即使发生了 exception，文件操作序列结束后也可以自动关闭。使用关键字 with 处理的代码要远少于 try-finally 块进行处理的代码，例如： 1234&gt;&gt;&gt; with open('workfile') as f:... read_data = f.read()&gt;&gt;&gt; f.closedTrue 如果未使用关键字 with 操作文件，那么必须要调用 f.close() 来结束文件和释放系统资源。未结束一个文件时，Python 的垃圾回收机制将会最终关闭并销毁这个文件对象，但是这个文件将在一段时间内仍然处于打开状态。不同的 Python 实现方式将会在不同的时间对文件进行释放，这将会带来其他的风险。 当文件对象被关闭后，使用 with 或者调用 f.close() 对文件对象的操作都会失效。例如： 12345&gt;&gt;&gt; f.close()&gt;&gt;&gt; f.read()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;ValueError: I/O operation on closed file. 文件对象的方法该例子的剩下部分将会继续使用上文所建立的文件 f 进行介绍。 读取文件内容的方法为 f.read(size) ，可以读取指定大小的文件内容，可以得到一个字符串（文本模式）或者字节对象（二进制模式）。 size 是一个可选的数值参数，如果 size 省略或为负，可以读取并返回整个文件；要注意的是，文件的大小有可能超出设备内存的上限。否则，最多读取并返回 size 的字节内容。当读取到文件的结尾时，f.read() 会返回一个空字符串（&#39;&#39;） 1234&gt;&gt;&gt; f.read()'This is the entire file.\\n'&gt;&gt;&gt; f.read()'' f.readline() 可以仅仅从文件里读取一行；读取的字符串中，结尾会有一个换行符（\\n），唯一的例外时在最后一行文件不以换行符结束。这个结果是明确的。如果 f.readline() 返回一个空字符串，那么已经读取到文件的结尾，因为空白行只有一个 &#39;\\n&#39;，一个仅仅包含换行符的字符串。 123456&gt;&gt;&gt; f.readline()'This is the first line of the file.\\n'&gt;&gt;&gt; f.readline()'Second line of the file\\n'&gt;&gt;&gt; f.readline()'' 要读取多行内容，你可以借助循环遍历整个文档类型。这是一种内存复杂度优先，快速而编码简单的方法： 12345&gt;&gt;&gt; for line in f:... print(line, end='')...This is the first line of the file.Second line of the file 如果你想一行行读取整个文件，你同样可以使用 list(f) 或f.readlines()，你可以得到一个各行字符串的列表。 f.write(string) 可以写入字符串 string 内容到文件内，返回写入的字符数量。 12&gt;&gt;&gt; f.write('This is a test\\n')15 其他类型需要转换才能写入文件中，或者转成字符串（文本模式）或者字节类型（二进制模式）： 1234&gt;&gt;&gt; value = ('the answer', 42)&gt;&gt;&gt; s = str(value) # convert the tuple to string&gt;&gt;&gt; f.write(s)18 f.tell() 返回一个整数，给出当前在文件中的位置；在二进制模式中，用字节数表示，在文本模式中，用不透明数表示。 要改变当前的位置，可以使用 f.seek(offset, from_what) 。新位置从参考点出发，由参数 offset 值计算得出；参考点位置由 from_what 参数给出。 from_what 为 0 时，从文件开头出发；为 1 时，从当前位置出发；为 2 时从文件结尾出发。 from_what 缺省值为 0 ，采用文件开头作为参考点。 1234567891011&gt;&gt;&gt; f = open('workfile', 'rb+')&gt;&gt;&gt; f.write(b'0123456789abcdef')16&gt;&gt;&gt; f.seek(5) # Go to the 6th byte in the file5&gt;&gt;&gt; f.read(1)b'5'&gt;&gt;&gt; f.seek(-3, 2) # Go to the 3rd byte before the end13&gt;&gt;&gt; f.read(1)b'd' 在文本文件（即那些没有使用 b 参数打开的字符串模式文件），只能从文件的开头或是 f.tell() 返回值出发（从文件末尾的定位 seek(0, 2) 为异常）。任何其他的 offset 将产生不可预知的表现。 文件对象有一些附加的方法，比如 isatty() 和 truncate()，它们的使用频率较低；有关文件对象的完整指南，请参阅「参考文档」。 利用 json结构保存数据字符串可以轻松地从文件读写。但是数值要花费上更多的功夫，因为 read() 方法可以仅仅返回字符串，这将必须经过一些函数处理，例如 int()，将 &#39;123&#39; 字符串转化为数值 123 。 当你希望保存更复杂的数据类型像嵌套列表或字典时，手动解析和序列化复杂程度难以接受。 Python 提供了被称为 JSON (JavaScript Object Notation) 的流行数据交换格式，而不希望用户不断自行编写和调试代码以储存复杂的数据类型。标准库 json 可以采用 Python 式的数据层级，并且转换成字符串的形式； 这个进程称为 序列化 。反之，从字符串转化成数据类型被称作 反序列化 。得到的字符串对象可以储存在文件或数据中，也可以通过网络连接发送到某个远程主机。 注意JSON 格式通常被现代应用程序用于数据交换，为许多程序员所熟悉，使其成为交互数据的较优选择。 如果你有一个对象 x ，你能够通过如下的代码访问其 JSON 字符串： 123&gt;&gt;&gt; import json&gt;&gt;&gt; json.dumps([1, 'simple', 'list'])'[1, \"simple\", \"list\"]' dumps() 另一个变体函数，叫作 dump() ，只将对象序列化成一个 文本文件 。 所以，如果 f 是一个 文本文件 已打开的可写入文件对象，我们能够利用如下代码： 1json.dump(x, f) 要重新解码对象，当 f 是一个 文本文件 已打开的读取用文件对象： 1x = json.load(f) 这种简单的序列化技术可以处理列表和字典，但是不足以在 JSON 中序列化任意类的实例。 参考文档 json 包含对此的解释. 也可以看pickle - Pickle 模块 与 JSON 相反， pickle 是一个允许对任意复杂的 Python 对象进行序列化的协议。因此，它仅仅适配 Python ，不能用于与其他语言编写的应用程序通信。默认情况下，它也是不安全的：如果有人特地设计用于注入攻击的数据，这些不受信任的 Pickle 数据可能会在序列化中被 Python 运行。 参考资料 https://docs.python.org/3/tutorial/inputoutput.html","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"python模块","date":"2018-09-06T11:25:23.588Z","path":"2018/09/06/python模块/","text":"如果你从 Python 解释器退出然后再进入它，你所做的定义（函数和变量）都会消失。因此，如果你想写某些更长的程序，你最好使用一个文本编辑器来为解释器准备输入，然后以这个文件作为输入来运行程序。这也被称为创建一个 脚本。当你的程序变得更长，你也许会想将它分成几个文件方便管理。你也许还想在几个程序中直接使用函数而不用在每个程序中拷贝函数定义。 为了支持这种特性，Python 可以把定义放入一个文件中然后在一个脚本或交互式解释器实例中使用它。这个文件被叫做 模块 （module），模块中的定义可以通过 导入 进入到其他模块或者 主 模块（你在顶层和计算器模式下执行的脚本中可以访问的变量集合）。 一个模块是一个包含 Python 定义和声明的文件。文件是模块名加上 .py 后缀。在一个模块中，模块名（字符串类型）可以通过全局变量 __name__ 获取。例如，使用你最喜欢的文本编辑器在当前目录下创建一个叫 fibo.py 的文件，这个文件包含以下内容 12345678910111213141516# 斐波那契数模块def fib(n): # 打印斐波那契数直到 n a, b = 0, 1 while a &lt; n: print(a, end=' ') a, b = b, a+b print()def fib2(n): # 返回到 n 的斐波那契数 result = [] a, b = 0, 1 while a &lt; n: result.append(a) a, b = b, a+b return result 现在进入 Python解释器然后通过下面的命令导入这个模块 1&gt;&gt;&gt; import fibo 这样做不会直接在当前环境中导入 fibo 中定义的函数名，只会导入名为 fibo 的模块。使用模块名可以获取模块中定义的函数： 123456&gt;&gt;&gt; fibo.fib(1000)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987&gt;&gt;&gt; fibo.fib2(100)[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]&gt;&gt;&gt; fibo.__name__'fibo' 如果你打算经常使用一个函数，你可以把它赋值给一个局部变量 123&gt;&gt;&gt; fib = fibo.fib&gt;&gt;&gt; fib(500)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 模块进阶一个模块可以包含可执行声明包括函数定义。这些声明被用于初始化模块。它们只在模块被 第一 次导入时执行。 [1]（如果文件被作为脚本运行它们也会被执行） 每个模块都有其私有的符号表，模块中定义的所有函数将这个符号表作为全局符号表。因此，一个模块的作者可以在模块中使用全局变量而无需担心与其他模块的全部变量冲突。另一方面，如果你知道你在干什么，你同样可以使用 模块.变量 的方式来获取一个模块的全局变量。 模块可以导入其他模块。将所有 import 语句放在模块（或者脚本，如果这个问题重要的话）的开头不是必须的，但习惯如此。被导入的模块名被放置于当前模块的全局符号表中。 import 声明的一种变体可以把一个模块中的变量直接导入当前模块的符号表中。例如： 123&gt;&gt;&gt; from fibo import fib, fib2&gt;&gt;&gt; fib(500)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 这样做不会把模块名引入本地符号表中（因此上面的例子里，fibo 没有被定义） 还有一种导入声明的变体可以导入一个模块中定义的所有变量： 123&gt;&gt;&gt; from fibo import *&gt;&gt;&gt; fib(500)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 这会导入模块中除了以下划线（_）开头的所有名称。大多数情况下 Python 程序员不使用这个机制，因为它会为解释器引入一系列位置未知变量，从而有可能覆盖你已经定义的某些变量。 请注意，一般来说，使用 import * 导入模块或包是不受欢迎的，因为这通常会降低代码可读性。但在使用交互型解释器为了减少打字而使用它是允许的。 如果模块名后紧跟 as, 那么 as 后的变量名会与被导入的模块名绑定。 123&gt;&gt;&gt; import fibo as fib&gt;&gt;&gt; fib.fib(500)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 这与 import fibo 的方式导入相同，除了模块现在被命名为 fib 而不是 fibo。 使用 from 时可以使用这个机制达到相同的效果： 123&gt;&gt;&gt; from fibo import fib as fibonacci&gt;&gt;&gt; fibonacci(500)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 注意由于性能原因，每个模块在每个解释器会话中只会被导入一次。因此，如果你改变了你的模块，你必须重启解释器 – 或者你只想交互式地测试一个模块，你可以使用 importlib.reload()，例如，import importlib;importlib.reload(modulename)。 将可执行模块当做脚本当你这样使用一个 Python 模块 1python fibo.py &lt;arguments&gt; 模块中的代码会被执行，就如你导入这个模块一样，除了 __name__ 变量被赋值为 &quot;__main__&quot;。这意味着在模块的末尾添加下面的代码： 123if __name__ == \"__main__\": import sys fib(int(sys.argv[1])) 你可以让一个文件当成脚本来使用同时也可以将其作为一个可导入模块，因为代码会解析命令行，并只在模块作为 “main” 文件时才会执行。 12$ python fibo.py 500 1 1 2 3 5 8 13 21 34 如果模块被导入，代码不会运行： 12&gt;&gt;&gt; import fibo&gt;&gt;&gt; 这经常被用于提供模块的用户接口或测试（以脚本的形式运行模块来执行某个测试集） 模块搜索路径 当一个名为 spam 的模块被导入时，解释器首先寻找同名的内建模块。如果没有发现同名内建模块，解释器会根据 sys.path 提供的一系列路径下寻找名为 spam.py 的文件。sys.path 根据下面这些位置进行初始化： 包含输入脚本的目录（如果没有指明文件则为当前目录） PYTHONPATH 一个目录的列表，语法与 shell 的 PATH 变量相同。 安装依赖默认路径 注意在支持符号链接的文件系统上，包含输入脚本的目录在符号链接被跟随之后才被计算。换句话说，包含符号链接的目录 不会 被添加到模块搜索路径。 初始化后，Python 程序会修改 sys.path。包含当前运行脚本的目录会被放在搜索路径的首位，位于标准库之前。这意味着该目录中与标准库同名的文件将会被导入，而相应的标准库则不会被导入。这将导致错误，除非你有意替换。参考 Standard Modules 获取更多信息。 “编译的” Python 文件为了加快模块载入速度，Python 将每个模块的编译版本以 module.*version*.pyc 的名称缓存在 __pycache__ 目录下，”version” 编码编译文件的格式，它通常包含 Python 版本号。例如，在 CPython 3.3 编译的 spam.py 文件缓存在 __pycache__/spam.cpython-33.py 中。这种命名方式允许不同发行版本和不同版本的 Python 编译文件共存。 Python 检查源文件修改日期并与编译的文件进行比较以确认编译文件是否过时，需要重新编译。这是一个全自动过程。同样的，编译的模块不依赖于操作系统，所以相同的库可以在不同架构的系统之间分享。 Python 在两种情况下不检查缓存。首先，Python 总会重新编译且不会缓存从命令行直接导入模块。其次，如果没有源模块，Python 也不会检查缓存。为了支持无源文件（只有编译文件）发布，编译的模块必须位于源目录，且不能有一个源模块。 对于高阶玩家的提醒： 你可以使用 -O 或 -OO Python 命令开关来减少一个编译模块的大小. -O 选项会去除断言声明，-OO 选项会去除断言声明和 __doc__ 字符串。由于一些程序依赖于这些变量，请只有在你明确知道自己在干嘛时使用这两个选项。“优化” 过的模块有一个 opt- 标签通常会更小。以后的版本也许会改版优化的效果。 从 .pyc 文件读取的程序不会比从 .py 文件读取的程序快；.pyc 只在载入时更快。 模块 compileall 可以在一个目录下创建所有模块的 .pyc 文件。 编译过程还有更多细节，包括一个决策流程图，它可以在 PEP 3147 找到。 标准模块Python 带有一个标准模块库，并发布有独立的文档，名为 Python 库参考手册（此后称其为”库参考手册”）。有一些模块内置于解释器之中，这些操作的访问接口不是语言内核的一部分，但是已经内置于解释器了。这既是为了提高效率，也是为了给系统调用等操作系统原生访问提供接口。这类模块集合是一个依赖于底层平台的配置选项。例如，winreg 模块只提供在 Windows 系统上才有。有一个具体的模块值得注意： sys ，这个模块内置于所有的 Python 解释器。变量 sys.ps1 和 sys.ps2定义了主提示符和辅助提示符字符串： 123456789&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.ps1'&gt;&gt;&gt; '&gt;&gt;&gt; sys.ps2'... '&gt;&gt;&gt; sys.ps1 = 'C&gt; 'C&gt; print('Yuck!')Yuck!C&gt; 这两个变量只在解释器的交互模式下有意义。 变量 sys.path 是解释器模块搜索路径的字符串列表。它由环境变量 PYTHONPATH 初始化，如果没有设定 PYTHONPATH ，就由内置的默认值初始化。你可以用标准的字符串操作修改它： 12&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append('/ufs/guido/lib/python') dir() 函数内置函数 dir() 用于按模块名搜索模块定义，它返回一个字符串类型的存储列表： 123456789101112131415161718192021&gt;&gt;&gt; import fibo, sys&gt;&gt;&gt; dir(fibo)['__name__', 'fib', 'fib2']&gt;&gt;&gt; dir(sys)['__displayhook__', '__doc__', '__excepthook__', '__loader__', '__name__', '__package__', '__stderr__', '__stdin__', '__stdout__', '_clear_type_cache', '_current_frames', '_debugmallocstats', '_getframe', '_home', '_mercurial', '_xoptions', 'abiflags', 'api_version', 'argv', 'base_exec_prefix', 'base_prefix', 'builtin_module_names', 'byteorder', 'call_tracing', 'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info', 'float_repr_style', 'getcheckinterval', 'getdefaultencoding', 'getdlopenflags', 'getfilesystemencoding', 'getobjects', 'getprofile', 'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval', 'gettotalrefcount', 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info', 'intern', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'ps1', 'setcheckinterval', 'setdlopenflags', 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout', 'thread_info', 'version', 'version_info', 'warnoptions'] 无参数调用时，dir() 函数返回当前定义的命名： 12345&gt;&gt;&gt; a = [1, 2, 3, 4, 5]&gt;&gt;&gt; import fibo&gt;&gt;&gt; fib = fibo.fib&gt;&gt;&gt; dir()['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys'] 注意该列表列出了所有类型的名称：变量，模块，函数，等等。 dir() 不会列出内置函数和变量名。如果你想列出这些内容，它们在标准模块 builtins 中定义： 12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; import builtins&gt;&gt;&gt; dir(builtins)['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__', '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip'] 包包通常是使用『圆点模块名』的结构化模块命名空间。例如，名为 A.B 的模块表示了名为 A 的包中名为 B 的子模块。正如同用模块来保存不同的模块架构可以避免全局变量之间的相互冲突，使用圆点模块名保存像 NumPy 或 Python Imaging Library 之类的不同类库架构可以避免模块之间的命名冲突。 现在，你必须开始遵守用以组织你的程序的层次结构。变量通常位于函数内部，函数与全局变量通常位于模块内部。如果你希望组织起这些模块的话，应该怎么办？这便是包（Packages）应当登场的时刻。 包是指一个包含模块与一个特殊的 __init__.py 文件的文件夹，后者向 Python 表明这一文件夹是特别的，因为其包含了 Python 模块。 让我们这样设想：你想创建一个名为“world”的包，其中还包含着 “asia”、“africa”等其它子包，同时这些子包都包含了诸如“india”、 “madagascar”等模块。 假设你现在想要设计一个模块集（一个”包”）来统一处理声音文件和声音数据。存在几种不同的声音格式（通常由它们的扩展名来标识，例如：.wav， .aiff，.au ），于是，为了在不同类型的文件格式之间转换，你需要维护一个不断增长的包集合。可能你还想要对声音数据做很多不同的操作（例如混音，添加回声，应用平衡 功能，创建一个人造效果），所以你要加入一个无限流模块来执行这些操作。你的包可能会是这个样子（通过分级的文件体系来进行分组）： 1234567891011121314151617181920212223sound/ Top-level package __init__.py Initialize the sound package formats/ Subpackage for file format conversions __init__.py wavread.py wavwrite.py aiffread.py aiffwrite.py auread.py auwrite.py ... effects/ Subpackage for sound effects __init__.py echo.py surround.py reverse.py ... filters/ Subpackage for filters __init__.py equalizer.py vocoder.py karaoke.py ... 当导入这个包时，Python 通过 sys.path 搜索路径查找包含这个包的子目录。 为了让 Python 将目录当做内容包，目录中必须包含 __init__.py 文件。这是为了避免一个含有烂俗名字的目录无意中隐藏了稍后在模块搜索路径中出现的有效模块，比如 string。最简单的情况下，只需要一个空的 __init__.py 文件即可。当然它也可以执行包的初始化代码，或者定义稍后介绍的 __all__ 变量。 用户可以每次只导入包里的特定模块，例如： 1import sound.effects.echo 这样就导入了 sound.effects.echo 子模块。它必需通过完整的名称来引用： 1sound.effects.echo.echofilter(input, output, delay=0.7, atten=4) 导入包时有一个可以选择的方式： 1from sound.effects import echo 这样就加载了 echo 子模块，并且使得它在没有包前缀的情况下也可以使用，所以它可以如下方式调用： 1echo.echofilter(input, output, delay=0.7, atten=4) 还有另一种变体用于直接导入函数或变量： 1from sound.effects.echo import echofilter 这样就又一次加载了 echo 子模块，但这样就可以直接调用它的 echofilter() 函数： 1echofilter(input, output, delay=0.7, atten=4) 需要注意的是使用 from package import item 方式导入包时，这个子项（item）既可以是包中的一个子模块（或一个子包），也可以是包中定义的其它命名，像函数、类或变量。import 语句首先核对是否包中有这个子项，如果没有，它假定这是一个模块，并尝试加载它。如果没有找到它，会引发一个 ImportError 异常。 相反，使用类似 import item.subitem.subsubitem 这样的语法时，这些子项必须是包，最后的子项可以是包或模块，但不能是前面子项中定义的类、函数或变量。 核心风格：import语句的模块顺序我们推荐所有的模块在Python模块的开头部分导入。而且最好按照这样的顺序： Python标准库模块 Python第三方模块 应用程序自定义模块 然后使用一个空行分割这三类模块的导入语句。这将确保模块使用固定的习惯导入，有助于减少每个模块需要的import语句数目。其他的提示请参考“Python’s Style Guide”, PEP8。 解释器执行到这条语句，如果在搜索路径中找到了指定的模块，就会加载它。该过程遵循作用域原则，如果在一个模块的顶层导入，那么它的作用域就是全局的；如果在函数中导入，那么它的作用域是局部的。 如果模块是被第一次导入，它将被加载并执行。 使用 * 导入包那么当用户写下 from sound.effects import * 时会发生什么事？理想中，总是希望在文件系统中找出包中所有的子模块，然后导入它们。这可能会花掉很长时间，并且出现期待之外的边界效应，导出了希望只能显式导入的包。 对于包的作者来说唯一的解决方案就是给提供一个明确的包索引。import 语句按如下条件进行转换：执行 from package import * 时，如果包中的 __init__.py 代码定义了一个名为 __all__ 的列表，就会按照列表中给出的模块名进行导入。新版本的包发布时作者可以任意更新这个列表。如果包作者不想 import *的时候导入他们的包中所有模块，那么也可能会决定不支持它（ import * ）。例如， sound/effects/__init__.py 这个文件可能包括如下代码： 1__all__ = [\"echo\", \"surround\", \"reverse\"] 这意味着 from sound.effects import * 语句会从 sound 包中导入以上三个已命名的子模块。 如果没有定义 __all__ ， from sound.effects import * 语句 不会 从 sound.effects 包中导入所有的子模块。无论包中定义多少命名，只能确定的是导入了 sound.effects 包（可能会运行 __init__.py 中的初始化代码）以及包中定义的所有命名会随之导入。这样就从 __init__.py 中导入了每一个命名（以及明确导入的子模块）。同样也包括了前述的 import 语句从包中明确导入的子模块，考虑以下代码： 123import sound.effects.echoimport sound.effects.surroundfrom sound.effects import * 在这个例子中，echo 和 surround 模块导入了当前的命名空间，这是因为执行 from...import 语句时它们已经定义在 sound.effects 包中了（定义了 __all__ 时也会同样工作）。 尽管某些模块设计为使用 import * 时它只导出符合某种规范/模式的命名，仍然不建议在生产代码中使用这种写法。 记住，from Package import specific_submodule 没有错误！事实上，除非导入的模块需要使用其它包中的同名子模块，否则这是推荐的写法。 包内引用如果包中使用了子包结构（就像示例中的 sound 包），可以按绝对位置从相邻的包中引入子模块。例如，如果 sound.filters.vocoder 包需要使用 sound.effects 包中的 echo 模块，它可以 from sound.Effects import echo。 你可以用这样的形式 from module import name 来写显式的相对位置导入。那些显式相对导入用点号标明关联导入当前和上级包。以 surround 模块为例，你可以这样用： 123from . import echofrom .. import formatsfrom ..filters import equalizer 需要注意的是显式或隐式相对位置导入都基于当前模块的命名。因为主模块的名字总是 &quot;__main__&quot;，Python 应用程序的主模块应该总是用绝对导入。 多重目录中的包包支持一个更为特殊的特性， path。 在包的 __init__.py 文件代码执行之前，该变量初始化一个目录名列表。该变量可以修改，它作用于包中的子包和模块的搜索功能。 这个功能可以用于扩展包中的模块集，不过它不常用。 参考资料 https://docs.python.org/3/tutorial/modules.html python核心编程","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"深入Python 流程控制","date":"2018-09-04T11:54:15.449Z","path":"2018/09/04/深入Python-流程控制/","text":"if 语句Example: 12345678910111213&gt;&gt;&gt; x = int(input(\"Please enter an integer: \"))Please enter an integer: 42&gt;&gt;&gt; if x &lt; 0:... x = 0... print('Negative changed to zero')... elif x == 0:... print('Zero')... elif x == 1:... print('Single')... else:... print('More')...More 这边可以v 有 0 个或者多个 elif 部分，并且 else 部分是可选的。关键字 elif 是 ‘else if’ 的缩写，它有助于避免过度缩进。 一个 if… elif … elif … 序列可以替代其他语言中的 switch 或 case 语句。 for 语句Python 中for 语句有点不同于 C 和 Pascal 中的 for 语句。Python 的 for 语句按照项目在序列中出现的顺序迭代任何序列（列表或字符串），而不是总是迭代数学的算术级数（如 Pascal 中），或者让用户能够定义迭代步骤和停止条件（如 C），例如（没有双关语）： 12345678&gt;&gt;&gt; # 测量字符串：... words = ['cat', 'window', 'defenestrate']&gt;&gt;&gt; for w in words:... print(w, len(w))...cat 3window 6defenestrate 12 如果你需要修改序列在循环内的迭代（例如复制所选项目），建议你先复制。迭代序列操作并不会隐式地复制。切片方法使这一操作特别方便： 123456&gt;&gt;&gt; for w in words[:]: # 循环遍历整个列表的切片副本。... if len(w) &gt; 6:... words.insert(0, w)...&gt;&gt;&gt; words['defenestrate', 'cat', 'window', 'defenestrate'] 使用 for w in words:，该示例将尝试创建一个无穷列表，反复的插入 defenestrate 。 range() 函数如果你需要迭代一系列的数字，内建的函数 range() 会非常有用。如，生成等差数列： 12345678&gt;&gt;&gt; for i in range(5):... print(i)...01234 给定的停止位是不会出现在生成的序列中的； range(10) 生成 10 个值，是长度为 10 的序列的项的合法指数。可以让区间开始于其他的数字，或者指定不同的增量（甚至是负数；有时候这被叫做 ‘步长’）： 12345678range(5, 10) 5, 6, 7, 8, 9range(0, 10, 3) 0, 3, 6, 9range(-10, -100, -30) -10, -40, -70 要遍历一个序列的索引，你可以像下面这样组合 range() 和 len() ： 123456789&gt;&gt;&gt; a = ['Mary', 'had', 'a', 'little', 'lamb']&gt;&gt;&gt; for i in range(len(a)):... print(i, a[i])...0 Mary1 had2 a3 little4 lamb 然而，在大多数情况下，使用 enumerate() 函数更方便，可以看 循环技术. 如果你直接打印一个区间的话，会发生奇怪的事情： 12&gt;&gt;&gt; print(range(10))range(0, 10) 在很多方面， range() 返回的对象的行为像列表，但实际上它不是。它是一个对象，当你迭代它的时候，会连续的返回整个序列的项目，但不会真的创建列表，从而节省空间。 我们称这样的对象为 可迭代的 ，也就是说，它很适合于当作函数或者构造函数的目标，它们期望从这里可以获得连续的项目直到耗尽。我们已经看到 for 语句是一个 迭代器 。list() 函数是另一个；它可从可迭代对象中创建列表： 12&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4] 稍后，我们会看到更多返回可迭代对象和将可迭代对象当作参数的函数。 break 和 continue 语句，以及循环上的 else 子句break 语句，类似于 C ，会打破 for 或 while 循环的最内层。 循环语句可能有 else 子句；它会在列表耗尽（用 for ）从而终止循环或者条件为假（用 while ）的时候被执行，而不是循环被 break 语句终止的时候；这被下面的这个查找素数的循环例证了： 1234567891011121314151617&gt;&gt;&gt; for n in range(2, 10):... for x in range(2, n):... if n % x == 0:... print(n, 'equals', x, '*', n//x)... break... else:... # 没有找到一个因数导致的循环失败... print(n, 'is a prime number')...2 is a prime number3 is a prime number4 equals 2 * 25 is a prime number6 equals 2 * 37 is a prime number8 equals 2 * 49 equals 3 * 3 （是的，这是正确的代码。密切关注： for 循环的 else 子句，不是 if 语句。） 当在循环使中使用 else 子句时，与其说很类似于if 语句，不如说更类似于 try 语句中的 else 子句：一个 try 语句的 else 子句会在没有异常发生的时候执行，而一个循环的 else 子句会在没有 break 发生的时候执行。要了解更多 try 语句和异常，请看 异常处理. continue 语句，也是从 C 借来的，用于继续循环的下一次迭代： 12345678910111213&gt;&gt;&gt; for num in range(2, 10):... if num % 2 == 0:... print(\"Found an even number\", num)... continue... print(\"Found a number\", num)Found an even number 2Found a number 3Found an even number 4Found a number 5Found an even number 6Found a number 7Found an even number 8Found a number 9 pass 语句pass 语句什么也不做。它可以用于语法上需要，但程序不需要做什么的时候。例如： 123&gt;&gt;&gt; while True:... pass # 等待键盘中断（Ctrl+C）... 通常也用于创建小类的时候： 123&gt;&gt;&gt; class MyEmptyClass:... pass... 其他地方， pass 可以在你处理新代码的时候，用作函数或者条件体的占位符，从而让你继续思考更抽象层级的事情。 pass 被默默地忽略了： 123&gt;&gt;&gt; def initlog(*args):... pass # 记住实现它！... 定义函数我们可以创建一个能打印出任意项的斐波那契数列的函数： 1234567891011&gt;&gt;&gt; def fib(n): # 将斐波那契数列打印到第 n 项... \"\"\"将斐波那契数列打印到第 n 项\"\"\"... a, b = 0, 1... while a &lt; n:... print(a, end=' ')... a, b = b, a+b... print()...&gt;&gt;&gt; # 调用上面定义的函数... fib(2000)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 关键字 def 引入了一个函数 定义 。其后面必须跟随有函数的名称以及用括号包起来的一系列参数。构成函数体的语句从下一行开始，并且必须缩进。 函数体的第一个语句可以是一个字符串常量，这个字符串常量就是这个函数的文档字符串，或者说是 docstring。（更多关于文档字符串的内容可参考章节 Documentation Strings 。）有很多工具可以用于在线或者可打印文档的自动化生成，或者可以让用户交互地在代码中浏览文档；在代码中写文档字符串是比较好的实践，所以请养成写文档字符串的习惯。 函数的 执行 引入了一个新的符号表用于存储函数的局部变量。更准确地说，在函数内的所有变量赋值都会被存储到这张局部符号表中；所以在查找一个变量的引用时，会先查找局部符号表，然后查找闭包函数的局部符号表，接着是全局符号表，最后才是内置名称表。因此，尽管可能在函数中引用全局变量，但在函数中无法对全局变量直接进行赋值（除非用 global 语句来定义一个变量） 当一个函数被调用时，函数参数被引入到局部符号表中；因此，参数是通过 按值传递 的方式来传递的（这个值表示一个对象的 引用 ，而不是该对象的值）。[1] 当在一个函数中调用另外一个函数时，将会为这次调用创建一个新的局部符号表。 一个函数定义将会在当前符号表中引入函数的名称。这个函数的名称对应的值的类型会被解释器解释为用户定义的函数。这个值可以被赋值给另外一个名称，并且将这名称可以当作一个函数来使用。这是一种常用的重命名机制： 12345&gt;&gt;&gt; fib&lt;function fib at 10042ed0&gt;&gt;&gt;&gt; f = fib&gt;&gt;&gt; f(100)0 1 1 2 3 5 8 13 21 34 55 89 如果你学习了别的编程语言，你可能认为 fib 不是一个函数而是一个过程，因为它没有返回值。事实上，一个不包含 return 语句的函数也是会返回一个值的。这个值是 None （这是一个内置名称）。 一般来说解释器不会打印出单独的返回值 None ，如果你真的想打印出 None ，你可以使用 print() ： 123&gt;&gt;&gt; fib(0)&gt;&gt;&gt; print(fib(0))None 写一个返回包含斐波那契数列的列表的函数比写一个打印斐波那契数列的函数要简单： 123456789101112&gt;&gt;&gt; def fib2(n): # 返回斐波那契数列的前 n 项... \"\"\"返回包含斐波那契数列前 n 项的列表的函数\"\"\"... result = []... a, b = 0, 1... while a &lt; n:... result.append(a) # 看上面的解释... a, b = b, a+b... return result...&gt;&gt;&gt; f100 = fib2(100) # 调用函数&gt;&gt;&gt; f100 # 输出结果[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89] 这个例子和之前一样阐述了一些 Python 的新特性： 函数通过 return 语句来返回结果值。不包含参数表达式的 return 语句返回表示函数返回 None。函数执行到末端的时候也返回 None result.append(a) 语句调用了列表 result 的 方法。方法是 “属于” 一个对象的函数，被命名为 obj.methodname, obj 表示这个对象（也可以是一个表达式），methodname 表示该对象类型定义中方法的名字。不同的类型定义了不同的方法。不同类型的方法的名字可以是相同的且不会产生歧义。（你可以使用 classes 来定一个你自己的对象类型和方法，参见 Classes）例子中的 append() 方法是列表对象定义的。它添加了一个新的元素到列表的末端，相当于 result =result + [a]，但是更高效。 更多关于定义函数的内容也可以使用可变数量的参数定义函数。 一共有三种方式，并且它们可以组合使用。 默认参数值最常用的形式是为一个或多个参数指定默认值。这样，函数可以以少于其定义的参数被调用。比如： 1234567891011def ask_ok(prompt, retries=4, reminder='Please try again!'): while True: ok = input(prompt) if ok in ('y', 'ye', 'yes'): return True if ok in ('n', 'no', 'nop', 'nope'): return False retries = retries - 1 if retries &lt; 0: raise ValueError('invalid user response') print(reminder) 该函数可以有几种不同的调用方式： 只指定强制的参数参数: ask_ok(&#39;Do you really want to quit?&#39;) 提供一个可选参数参数: ask_ok(&#39;OK to overwrite the file?&#39;, 2) 或者给定全部的参数参数: ask_ok(&#39;OK to overwrite the file?&#39;, 2, &#39;Come on, onlyyes or no!&#39;) 上述例子顺便也提及了 in 关键字。它是用来测试某个特定值是否在一个序列中。 默认值是在定义函数时的“定义过程中” （defining ）的范围内评估的， 所以， 1234567i = 5def f(arg=i): print(arg)i = 6f() 会打印 5. 重要提示： 默认值只被评估一次。 这个特性会导致当默认值是列表，字典，或者大多数类的实例时，默认值会是一个可变对象。比如，以下函数会累积在一系列的调用过程中所提供的参数： 1234567def f(a, L=[]): L.append(a) return Lprint(f(1))print(f(2))print(f(3)) 会打印出： 123[1][1, 2][1, 2, 3] 你可以把上面的函数写成以下的形式，以避免默认值被不同的函数调用所共享： 12345def f(a, L=None): if L is None: L = [] L.append(a) return L 关键字参数函数 关键字参数 同样可以使用 kwarg=value 的形式。例如，以下函数： 12345def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'): print(\"-- This parrot wouldn't\", action, end=' ') print(\"if you put\", voltage, \"volts through it.\") print(\"-- Lovely plumage, the\", type) print(\"-- It's\", state, \"!\") 接收一个必选参数 （voltage ） 和三个可选参数（ state，action， 和 type ）。这个函数下方式调用： 123456parrot(1000) # 一个位置参数parrot(voltage=1000) # 一个关键字参数parrot(voltage=1000000, action='VOOOOOM') # 2个关键字参数parrot(action='VOOOOOM', voltage=1000000) # 2个关键字参数parrot('a million', 'bereft of life', 'jump') # 3个位置参数parrot('a thousand', state='pushing up the daisies') # 一个位置参数，一个关键字参数 但是下列的所有调用方式是无效的： 1234parrot() # 必选参数缺失parrot(voltage=5.0, 'dead') # 非关键字参数在关键字参数后面parrot(110, voltage=220) # 同一参数重复赋值parrot(actor='John Cleese') # 未知关键字参数 在函数调用中，关键字参数必须遵循参数位置。传递的所有关键字参数必须跟函数接受的其中一个参数匹配。（例如： actor 在函数 parrot 中不是一个有效的参数），并且它们的顺序并不重要。这同样也包括那些非必选参数 （例如 parrot(voltage=1000) 同样有效）。没有参数可能多次获取一个值。下例就是因此而失败的： 1234567&gt;&gt;&gt; def function(a):... pass...&gt;&gt;&gt; function(0, a=0)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: function() got multiple values for keyword argument 'a' 当最后存在 **name 形式的参数时，它最后会接收一个字典, (参见 Mapping Types — dict) 包含所有除了和形式参数相对应的关键字参数。这可以与 * name 形式的形式参数（在下一小节中描述）结合，该参数接收包含正式参数列表之外的位置参数的元组。 (*name 必须出现在 **name 之前。) 例如，我们如果定义一个如下函数： 12345678def cheeseshop(kind, *arguments, **keywords): print(\"-- Do you have any\", kind, \"?\") print(\"-- I'm sorry, we're all out of\", kind) for arg in arguments: print(arg) print(\"-\" * 40) for kw in keywords: print(kw, \":\", keywords[kw]) 它可以像这样调用： 12345cheeseshop(\"Limburger\", \"It's very runny, sir.\", \"It's really very, VERY runny, sir.\", shopkeeper=\"Michael Palin\", client=\"John Cleese\", sketch=\"Cheese Shop Sketch\") 最终它会打印如下： 12345678-- Do you have any Limburger ?-- I'm sorry, we're all out of LimburgerIt's very runny, sir.It's really very, VERY runny, sir.----------------------------------------shopkeeper : Michael Palinclient : John Cleesesketch : Cheese Shop Sketch 请注意，保证打印函数关键字参数的顺序，和函数中调用中提供它们的顺序相一致。 可变参数最后，最不常用的指定参数的选项是可变数量的参数。这些参数将被组装成一个元组(参见 元组和序列) 。在可变参数之前，可能会出现零个或多个正常参数。 12def write_multiple_items(file, separator, *args): file.write(separator.join(args)) 通常，这些可变参数将在形式参数列表中排在最后，因为它们会对传递给函数的所有剩余输入参数进行辨识。 在 * args 参数之后出现的任何参数都是关键字参数，这意味着它们只能用作关键字参数而不是位置参数。 1234567&gt;&gt;&gt; def concat(*args, sep=\"/\"):... return sep.join(args)...&gt;&gt;&gt; concat(\"earth\", \"mars\", \"venus\")'earth/mars/venus'&gt;&gt;&gt; concat(\"earth\", \"mars\", \"venus\", sep=\".\")'earth.mars.venus' 分离参数列表当输入的参数已经是列表或元组形式而为了调用其中单独的位置参数时，将会出现与上面相反的情况。例如内置函数 range() 需要有独立的 start 和 stop 参数。如果输入的时候不是独立的参数，则需要用 * 操作符来将参数从列表或者元组里面提取出来： 12345&gt;&gt;&gt; list(range(3, 6)) # 正常利用参数调用函数[3, 4, 5]&gt;&gt;&gt; args = [3, 6]&gt;&gt;&gt; list(range(*args)) # 从列表中提取参数来调用函数[3, 4, 5] 以同样的方式，可以用 ** 操作符来将关键字参数从字典中提取出来： 12345678&gt;&gt;&gt; def parrot(voltage, state='a stiff', action='voom'):... print(\"-- This parrot wouldn't\", action, end=' ')... print(\"if you put\", voltage, \"volts through it.\", end=' ')... print(\"E's\", state, \"!\")...&gt;&gt;&gt; d = &#123;\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"&#125;&gt;&gt;&gt; parrot(**d)-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised ! Lambda 表达式我们可以使用lambda关键字来创建小型匿名函数。此函数会返回其两个参数的和：lambda a，b：a + b。可以在任何需要函数对象的场合使用 Lambda 函数。它们在语法上仅限于单个表达式。从语义上讲，它们只是普通函数定义的语法糖。与嵌套函数定义类似，lambda 函数可以从包含它的上下文中引用变量： 12345678&gt;&gt;&gt; def make_incrementor(n):... return lambda x: x + n...&gt;&gt;&gt; f = make_incrementor(42)&gt;&gt;&gt; f(0)42&gt;&gt;&gt; f(1)43 上面的例子使用 lambda 表达式返回了一个函数。另一个用途是传递一个小函数作为参数： 1234&gt;&gt;&gt; pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]&gt;&gt;&gt; pairs.sort(key=lambda pair: pair[1])&gt;&gt;&gt; pairs[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')] 文档字符串对于文档字符串的内容和格式，是有一定的约定的。 第一行应该始终是一个对对象目的的精简的总结。为简洁起见，它不该显式地声明对象的名称或类型，因为它们可以通过其他方式获得（除非函数名恰好是描述函数作用的动词）。这一行应该以大写字母开头并以句号结尾。 如果文档字符串不止一行，则第二行应为空白，从而能在视觉上将总结与其余的描述分开。接下来的几行应该是一个或多个段落，负责描述对象的调用约定以及其副作用等。 在 Python 中，Python 解析器并不会删除多行字符串文字的缩进，因此处理文档的工具必须在有必要之时删除缩进。这点是使用以下的约定完成的。在第一行之后的首个非空行决定了整个文档字符串的缩进数。（我们不能用第一行来决定，因为它通常与字符串开头的引号相邻，因此它的缩进在字符串中并不明显。）之后，我们把「等同于」这段缩进的空格从字符串的所有行的开头全部去除。不应出现少缩进的行，但如果出现了就把它们前面的空格全部去除。展开制表符后我们应当测试空格的等效性（通常为8个空格）。 以下是个多行文档字符串的例子： 1234567891011&gt;&gt;&gt; def my_function():... \"\"\"只要写文档，其他啥都别做。...... 确实，它也啥都不做。... \"\"\"... pass...&gt;&gt;&gt; print(my_function.__doc__)只要写文档，其他啥都别做。 确实，它也啥都不做。 函数注解函数注解 (Function annotations)应用于用户自定义的函数，可使用的类型是完全可选的元数据 (参考 PEP 3107和 PEP 484 获取更多信息)。 注解（Annotations）是以字典的形式存放在函数的 __annotations__ 属性中，并且不对函数有任何影响。参数注解 (Parameter annotations) 是由参数名称后面加上冒号来定义的，后面紧跟一个描述，来表示注解的值。 返回注解 (Return annotations) 的定义方式是：由 -&gt; 符号开始，在参数列表和表示函数def结束的冒号之间，加上你的描述。 接下来的例子，表示了位置参数、关键字参数和返回值的注解方法： 123456789&gt;&gt;&gt; def f(ham: str, eggs: str = 'eggs') -&gt; str:... print(\"Annotations:\", f.__annotations__)... print(\"Arguments:\", ham, eggs)... return ham + ' and ' + eggs...&gt;&gt;&gt; f('spam')Annotations: &#123;'ham': &lt;class 'str'&gt;, 'return': &lt;class 'str'&gt;, 'eggs': &lt;class 'str'&gt;&#125;Arguments: spam eggs'spam and eggs' 插曲: 代码风格现在你能够写更长更复杂的 Python 代码了。 是时候可以谈谈代码风格了。大多数编程语言可以使用不同的代码风格编写（就是格式化）； 有的可读性比其他的强。使用一种不错的代码风格可以帮助别人更好的阅读你的代码。 PEP 8 是大多数 Python 项目使用的代码风格指南。它提供了高可读性和养眼的代码风格。每一个 Python 开发者都应该阅读它，这里列出了其中的一些重点： 缩减使用四个空格而不是制表符 四个空格缩进比更少空格（运行跟多的嵌套深度）或者更多空格（更容易阅读）的缩进要好。 制表符会带来歧义，所以最好不要用它 每行不好超过79个字符 这可以帮助显示器较小的用户与帮助显示器较大的用户同屏显示多个文件。 使用空行分隔函数、类或者函数内较大的代码段。 尽量讲注释和代码放在一起。 用 docstrings。 用在操作符前后和逗号之后加空格，但是括号之内不需要： a= f(1, 2) + g(3, 4). 一致性的命名你的类与函数；惯例是用 CamelCase 命名类 ，用 lower_case_with_underscores 命名函数和方法。必须使用 self 作为方法的第一个参数（想了解更多请阅读 A First Look at Classes）。 如果你的代码将用于国际化的环境中，请不要使用任何花哨的编码。 Python 默认使用 UTF-8，甚至纯 ASCII 在任何情况下都能最好地工作。 即使说其他语言的人阅读或者维护你的代码的几率很小，也不要使用非 ASCII 字符。 参考资料 https://docs.python.org/3/tutorial/controlflow.html","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"Python CookBook(Data Structures)","date":"2018-09-02T12:27:45.272Z","path":"2018/09/02/Python-NoteBook/","text":"Python Data Structures 数据结构: 列表、字典、元组、集合。 数据结构（Data Structures）基本上人如其名——它们只是一种结构，能够将一些数据聚合在一起。换句话说，它们是用来存储一系列相关数据的集合。 Python 中有四种内置的数据结构——列表（List）、元组（Tuple）、字典（Dictionary）和集合（Set） 列表(List):List 数据类型包含更多的方法，下面是 List 对象包含的所有方法： 1list.append(*x*) 将一个元素添加到列表的末端。相当于 a[len(a):] = [x]。 1list.extend(*iterable*) 将一个 iterable 的对象中的所有元素添加到列表末端来拓展这个列表。相当于 a[len(a):] =iterable。 1list.insert(*i*, *x*) 在列表中给定的位置插入一个元素。第一个是要插入的元素的位置。所以 a.insert(0, x) 将元素插入列表最前面，a.insert(len(a), x) 相当于 a.append(x)。 1list.remove(*x*) 移除列表中第一个值为 x 的元素。如果没有找到这样的元素，抛出 ValueError。 1list.pop([*1*]) 移除并返回列表中给定位置的元素。如果没有指定索引，a.pop() 移除并返回列表的最后一个元素。（i 外的方括号表示这个参数是可选的，而不是要求你在这个位置输入方括号。你会经常在 Python Library Reference 中看到这种标记方式）。 1list.clear() 移除列表中所有的元素。相当于 del a[:]。 1list.index(*x*[, *start*[, *end*]]) 返回值为 x 的元素在列表中的索引，索引从 0 开始。如果不存在这样的元素，抛出 ValueError。 可选参数 start 和 end 被解释为切片表示法，用于将搜索范围限制在该列表的一个子序列内。返回的索引是该元素在相对于原列表的开端的位置而不是相对于 start 参数的位置。 1list.count(*x*) 返回列表中值为 x 的元素的数量。 1list.sort(*key=None*, *reverse=False*) 对列表中的元素进行原地排序（参数可以被用于自定义排序，参见sorted()） 1list.reverse() 原地翻转列表。 1list.copy() 返回该列表的一个浅拷贝。相当于 a[:]。 Go! Let‘s We Play!动手练习: 12345678910111213141516171819202122232425262728classmate = ['tom',13,'boy','student'] #以一个列表形式classmate #调用list使用len函数调用list元素个数len(classmate)用索引列出位置元素 注意索引是从0开始的0-n&gt;&gt;&gt; classmates[0]'Michael'&gt;&gt;&gt; classmates[1]'Bob'&gt;&gt;&gt; classmates[2]'Tracy'&gt;&gt;&gt; classmates[3]当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。 如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：也可以把元素插入到指定的位置，比如索引号为1的位置：&gt;&gt;&gt; classmates.insert(1, 'Jack')&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']要删除list末尾的元素，用pop()方法：默认pop删除最后一个元素，使用pop(i)数字删除指定的索引位置&gt;&gt;&gt; classmates.pop()'Adam'&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy']要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：&gt;&gt;&gt; classmates[1] = 'Sarah'&gt;&gt;&gt; classmates['Michael', 'Sarah', 'Tracy'] Example: 1234567891011121314151617181920&gt;&gt;&gt; fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']&gt;&gt;&gt; fruits.count('apple')2&gt;&gt;&gt; fruits.count('tangerine')0&gt;&gt;&gt; fruits.index('banana')3&gt;&gt;&gt; fruits.index('banana', 4) # 从索引 4 开始找 banana6&gt;&gt;&gt; fruits.reverse()&gt;&gt;&gt; fruits['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']&gt;&gt;&gt; fruits.append('grape')&gt;&gt;&gt; fruits['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']&gt;&gt;&gt; fruits.sort()&gt;&gt;&gt; fruits['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']&gt;&gt;&gt; fruits.pop()'pear' 使用列表作为堆栈:列表的方法使得可以把列表当成元素后进先出的堆栈来用。使用 append() 来把一个元素加到堆栈的顶部。使用不显示携带索引参数的 pop() 方法来把一个元素从堆栈顶部移除。比如： 123456789101112131415&gt;&gt;&gt; stack = [3, 4, 5]&gt;&gt;&gt; stack.append(6)&gt;&gt;&gt; stack.append(7)&gt;&gt;&gt; stack[3, 4, 5, 6, 7]&gt;&gt;&gt; stack.pop()7&gt;&gt;&gt; stack[3, 4, 5, 6]&gt;&gt;&gt; stack.pop()6&gt;&gt;&gt; stack.pop()5&gt;&gt;&gt; stack[3, 4] 使用列表作为队列:也可以使用列表作为队列，其中添加的第一个元素是检索的第一个元素（“先入，先出”）；然而，列表对于这一目的并不高效。虽然从列表末尾追加和弹出是高效的，但是从列表的开头开始插入或弹出就低效了（因为所有其他元素都必须移动一个位置）。 实现一个队列，使用 collections.deque 它被设计为从两端都具有快速追加和弹出的能力。例如： 12345678910&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; queue = deque([\"Eric\", \"John\", \"Michael\"])&gt;&gt;&gt; queue.append(\"Terry\") # Terry 进入&gt;&gt;&gt; queue.append(\"Graham\") # Graham 进入&gt;&gt;&gt; queue.popleft() # 现在弹出第一个进入的元素'Eric'&gt;&gt;&gt; queue.popleft() # 现在弹出第二个进入的元素'John'&gt;&gt;&gt; queue # 按进入顺序维护队列deque(['Michael', 'Terry', 'Graham']) 列表表达式/列表解析:列表推导式（又称列表解析式）提供了一种简明扼要的方法来创建列表。它的结构是在一个中括号里包含一个表达式，然后是一个for语句，然后是0个或多个for或者if语句。那个表达式可以是任意的，意思是你可以在列表中放入任意类型的对象。返回结果将是一个新的列表，在这个以if和for语句为上下文的表达式运行完成之后产生。 例如，我们可以通过以下方式产生一组平方数。 123456&gt;&gt;&gt; squares = []&gt;&gt;&gt; for x in range(10):... squares.append(x**2)...&gt;&gt;&gt; squares[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 注意到在整个过程中，我们创建并修改了一个 x 变量，并且在循环完成之后依然存在。使用以下方式，我们同样可以生成这个序列，且没有额外的变量生成。 更优的写法，意思更明确，也更具可读性。等价形式: 1squares = [x**2 for x in range(10)] 列表初始化表达式由方括号 [] 包含，括号内以 for 语句起始，后接任意个 for 语句或 if 语句。其结果是产生一个新的列表，列表内的元素为其中的 for 语句或 if 语句的执行结果。例如，以下表达式创建了一个列表，列表内的每个元素形如 (x, y)，其中 x 和 y 分别来自两个列表，且 x 与 y 不相等。 12&gt;&gt;&gt; [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y][(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)] 这种写法等价于： 12345678&gt;&gt;&gt; combs = []&gt;&gt;&gt; for x in [1,2,3]:... for y in [3,1,4]:... if x != y:... combs.append((x, y))...&gt;&gt;&gt; combs[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)] 在这两段代码中，for 语句和 if 语句的执行顺序是相同的。 如果要使生成列表中的每个元素都是一个元组，则必须给表达式加上圆括号 () 。 Do More Practice: 123456789101112131415161718192021222324252627&gt;&gt;&gt; vec = [-4, -2, 0, 2, 4]&gt;&gt;&gt; # 创建一个新列表，将原列表中的每个元素乘以 2&gt;&gt;&gt; [x*2 for x in vec][-8, -4, 0, 4, 8]&gt;&gt;&gt; # 去除原列表中的负数&gt;&gt;&gt; [x for x in vec if x &gt;= 0][0, 2, 4]&gt;&gt;&gt; # 对原列表中的每个元素调用函数&gt;&gt;&gt; [abs(x) for x in vec][4, 2, 0, 2, 4]&gt;&gt;&gt; # 调用每个元素的成员方法&gt;&gt;&gt; freshfruit = [' banana', ' loganberry ', 'passion fruit ']&gt;&gt;&gt; [weapon.strip() for weapon in freshfruit]['banana', 'loganberry', 'passion fruit']&gt;&gt;&gt; # 创建一个由二元组构成的列表，元素形如 (number, square)&gt;&gt;&gt; [(x, x**2) for x in range(6)][(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]&gt;&gt;&gt; # 元组必须以圆括号包含，否则将产生一个错误&gt;&gt;&gt; [x, x**2 for x in range(6)] File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; [x, x**2 for x in range(6)] ^SyntaxError: invalid syntax&gt;&gt;&gt; # 用一个含有两个 `for` 的列表初始化表达式将一个多维列表降维&gt;&gt;&gt; vec = [[1,2,3], [4,5,6], [7,8,9]]&gt;&gt;&gt; [num for elem in vec for num in elem][1, 2, 3, 4, 5, 6, 7, 8, 9] del 语句有一个方法可以根据索引而不是值从列表中删除一个元素： del 语句。 这和 pop() 方法不同，后者会返回一个值。 del 语句也可用于从列表中删除片段或清除整个列表 （之前我们通过将一个空列表赋值给这个片段来达到此目的）。 例如: 12345678910&gt;&gt;&gt; a = [-1, 1, 66.25, 333, 333, 1234.5]&gt;&gt;&gt; del a[0]&gt;&gt;&gt; a[1, 66.25, 333, 333, 1234.5]&gt;&gt;&gt; del a[2:4]&gt;&gt;&gt; a[1, 66.25, 1234.5]&gt;&gt;&gt; del a[:]&gt;&gt;&gt; a[] del 也可用于删除整个变量： 1&gt;&gt;&gt; del a 字典(Dict):字典是 Python 中另外一种常用的数据类型(参考 Mapping Types — dict). 字典就像一本地址簿，如果你知道了他或她的姓名，你就可以在这里找到其地址或是能够联系上对方的更多详细信息，换言之，我们将键值（Keys）（即姓名）与值（Values）（即地址等详细信息）联立到一起。在这里要注意到键值必须是唯一的，正如在现实中面对两个完全同名的人你没办法找出有关他们的正确信息。 另外要注意的是你只能使用不可变的对象（如字符串）作为字典的键值，但是你可以使用可变或不可变的对象作为字典中的值。基本上这段话也可以翻译为你只能使用简单对象作为键值。 在字典中，你可以通过使用符号构成 d = {key : value1 , key2 : value2} 这样的形式，来成对地指定键值与值。在这里要注意到成对的键值与值之间使用冒号分隔，而每一对键值与值则使用逗号进行区分，它们全都由一对花括号括起。 字典主要的操作符就是通过键来存储对应的数据，以及根据键来取出对应的数据。也可以通过 del 来删除一个键值对。如果在存储数据的时候使用了字典中已有的键，则该键对应的值会被更新为当前新赋给值。如果使用字典中不存在的键来获取值，则会产生 error ，提示不存在这样的键。 list(d) 操作会返回字典中所有键组成的列表，列表中的数据顺序按照这些键存入字典的顺序（如果想得到一个经过排序的键的列表，可以使用 sorted(d) ）。检查字典中是否有某个键，可以使用关键字 in 。 另外需要记住，字典中的成对的键值—值配对不会以任何方式进行排序。如果你希望为它们安排一个特别的次序，只能在使用它们之前自行进行排序。 你将要使用的字典是属于 dict 类下的实例或对象。 Example: 123456789101112131415161718&gt;&gt;&gt; tel = &#123;'jack': 4098, 'sape': 4139&#125;&gt;&gt;&gt; tel['guido'] = 4127&gt;&gt;&gt; tel&#123;'jack': 4098, 'sape': 4139, 'guido': 4127&#125;&gt;&gt;&gt; tel['jack']4098&gt;&gt;&gt; del tel['sape']&gt;&gt;&gt; tel['irv'] = 4127&gt;&gt;&gt; tel&#123;'jack': 4098, 'guido': 4127, 'irv': 4127&#125;&gt;&gt;&gt; list(tel)['jack', 'guido', 'irv']&gt;&gt;&gt; sorted(tel)['guido', 'irv', 'jack']&gt;&gt;&gt; 'guido' in telTrue&gt;&gt;&gt; 'jack' not in telFalse dict() 函数会直接通过一系列的 键值对产生一个字典： 12&gt;&gt;&gt; dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])&#123;'sape': 4139, 'guido': 4127, 'jack': 4098&#125; 另外，我们可以从任意的键和值得表达式来创建字典： 12&gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125;&#123;2: 4, 4: 16, 6: 36&#125; 当键是字符串的时候，使用参数赋值的方式来指定键值对更方便： 12&gt;&gt;&gt; dict(sape=4139, guido=4127, jack=4098)&#123;'sape': 4139, 'guido': 4127, 'jack': 4098&#125; 遍历的技巧:鉴于字典可能包含大量的数据，Python支持对字典的遍历。字典可用于以各种方式存储信息，因此有多种遍历字典的方式:可遍历字典的所有键-值对、键或值(key-value)。 遍历字典时，键和对应的值可以用 items() 方法一次性全部得到。 123456&gt;&gt;&gt; knights = &#123;'gallahad': 'the pure', 'robin': 'the brave'&#125;&gt;&gt;&gt; for k, v in knights.items():... print(k, v)...gallahad the purerobin the brave 使用keys()方法可以遍历字典中的所有键 12345678favorite_languages= &#123; 'jen': 'python', 'sarah': 'c', 'edward': 'ruby', 'phil': 'python' &#125;for name in favorite_languages.keys(): print(name.title()) 使用values()方法可以遍历字典中的所有值 12345678favorite_languages= &#123; 'jen': 'python', 'sarah': 'c', 'edward': 'ruby', 'phil': 'python' &#125;for name in favorite_languages.values(): print(name.title()) 这种做法提取字典中的所有值，而没有考虑是否出现重复的问题。如果数据中含大量的重复项就需要使用集合(set) 12for name in set(favorite_languages.values()): print(name.title()) 遍历一个序列时，位置索引和对应的值可以用 enumerate() 方法一次性全部得到。 123456&gt;&gt;&gt; for i, v in enumerate(['tic', 'tac', 'toe']):... print(i, v)...0 tic1 tac2 toe 当需要同时遍历两个或多个序列时，可以使用 zip() 方法将他们合并在一起。 12345678&gt;&gt;&gt; questions = ['name', 'quest', 'favorite color']&gt;&gt;&gt; answers = ['lancelot', 'the holy grail', 'blue']&gt;&gt;&gt; for q, a in zip(questions, answers):... print('What is your &#123;0&#125;? It is &#123;1&#125;.'.format(q, a))...What is your name? It is lancelot.What is your quest? It is the holy grail.What is your favorite color? It is blue. 当需要反过来遍历一个序列的时候，使用 reversed() 方法来将一个正的序列倒序。 12345678&gt;&gt;&gt; for i in reversed(range(1, 10, 2)):... print(i)...97531 需要按顺序遍历一个序列，可以把未排序的序列传到 sorted() 方法中来获得一个新的排好序的列表。 12345678&gt;&gt;&gt; basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']&gt;&gt;&gt; for f in sorted(set(basket)):... print(f)...applebananaorangepear 元组(tuple)我们发现列表和字符串有许多共同点，例如可以用索引来访问，以及切割的操作。他们属于序列类型的公共特性。(参见 序列类型 — 列表，元组，区间)。Python 的日益发展，使得其他的序列类型会被逐渐地加入到语言特性中。其中就有另一种序列类型：元组。 列表非常适用于储存在程序运行期间可能变化的数据集。列表是可以修改的，这对处理网站的用户列表或游戏中的角色列表至关重要。然而，有时候你需要创建一系列不可修改的元素，元组可以满足这种需求。python将不能修改的值称为不可变的，而不可变的列表称为元组。元组通常用于保证某一语句或某一用户定义的函数可以安全地采用一组数值，意即元组内的数值不会改变。 元组由一系列被逗号分隔开的值组成，例如： 123456789101112131415161718&gt;&gt;&gt; t = 12345, 54321, 'hello!'&gt;&gt;&gt; t[0]12345&gt;&gt;&gt; t(12345, 54321, 'hello!')&gt;&gt;&gt; # 元组也可以嵌套：... u = t, (1, 2, 3, 4, 5)&gt;&gt;&gt; u((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))&gt;&gt;&gt; # 元组不可被修改：... t[0] = 88888Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment&gt;&gt;&gt; # 但是可以包含可以被修改的对象：... v = ([1, 2, 3], [3, 2, 1])&gt;&gt;&gt; v([1, 2, 3], [3, 2, 1]) 元组在输出时总是带有两侧的括号，这样一来，嵌套的元组可以被清楚地区分开；但是在输入时，并不一定要带上两侧的括号，尽管有时带上括号非常有必要（例如元组作为一个很长的表达式的一部分）。不能对元组中的项进行赋值，但在创建元组时，可以传入可修改的对象，例如列表。 虽然元组看起来和列表很像，但它们的使用场合和使用目的往往不同。元组是 不可修改的, 并且经常包含着不同类型的元素，总是通过解包（本章的后面会介绍）或索引（命名元组可以通过属性索引的方式）来访问。而列表是 可修改的，并且往往包含着同样类型的元素，通过遍历的方式来进行访问。 一个特别的问题是如何创建一个空的或只有一个元素的元组：语法上有一些小窍门。空的元组可以用一对空的括号来创建；只有一个元素的元组可以用一个后面跟着逗号的值来创建（只在括号里放一个元素可不行）。这些方法虽然有点丑陋，但挺好用的。例如： 12345678&gt;&gt;&gt; empty = ()&gt;&gt;&gt; singleton = 'hello', # &lt;-- 注意后面的逗号&gt;&gt;&gt; len(empty)0&gt;&gt;&gt; len(singleton)1&gt;&gt;&gt; singleton('hello',) 语句 t = 12345, 54321, &#39;hello!&#39;是一个 元组解包的例子：元素 12345， 54321 和 &#39;hello!&#39; 一起组成了一个元组。下面这样的操作也同样可以做到： 1&gt;&gt;&gt; x, y, z = t 这被称为 序列解包 ，所有右值的序列都可以使用这种语法。序列解包要求在等号的左边有着和序列内元素数量相同的变量。到这里也许你也发现了，多重赋值就是利用元组和序列解包来实现的。 集合(set)Python 内建集合的数据类型。一个集合是由多个无重复元素构成的无序整体。集合支持的基本功能包括成员检查以及重复元素的去除。集合同时支持求并集、交集、差集以及对称差集等操作。 集合可以通过大括号符号或者调用 set() 函数创建。注意：如果需要创建一个空的集合实例，需使用 set()而非 {} ，因为后者会创建一个空的字典实例。我们将在下一个章节介绍字典类型。 下面我们来看一个简单的示范代码： 12345678910111213141516171819202122&gt;&gt;&gt; basket = &#123;'apple', 'orange', 'apple', 'pear', 'orange', 'banana'&#125;&gt;&gt;&gt; print(basket) # 可以看到重复的元素被去除&#123;'orange', 'banana', 'pear', 'apple'&#125;&gt;&gt;&gt; 'orange' in basket # 快速成员检查True&gt;&gt;&gt; 'crabgrass' in basketFalse&gt;&gt;&gt; # 由两个单词中独特的字母构成的集合进行的集合间操作...&gt;&gt;&gt; a = set('abracadabra')&gt;&gt;&gt; b = set('alacazam')&gt;&gt;&gt; a # a 集合中独特的字母&#123;'a', 'r', 'b', 'c', 'd'&#125;&gt;&gt;&gt; a - b # 在 a 中但是不在 b 中的字母&#123;'r', 'd', 'b'&#125;&gt;&gt;&gt; a | b # 在 a 中或在 b 中的字母&#123;'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'&#125;&gt;&gt;&gt; a &amp; b # a 和 b 共有的字母&#123;'a', 'c'&#125;&gt;&gt;&gt; a ^ b # 在 a 中或在 b 中但两者不共有的字母&#123;'r', 'd', 'b', 'm', 'z', 'l'&#125; Python支持类似于 递推式构造列表 的递推式构造集合： 123&gt;&gt;&gt; a = &#123;x for x in 'abracadabra' if x not in 'abc'&#125;&gt;&gt;&gt; a&#123;'r', 'd'&#125; 判断条件进阶被用在 while 和 if 语句中的判断条件不仅仅可以包含比较运算，还可以包含任何的运算符。 比较运算符 in 和 not in 能够检查某个值是否在一个序列里出现（或不出现）。比较运算符 is 和 is not 比较两个对象是否是同一个对象；这只会影响如列表之类可修改的对象。所有的比较运算符的优先级都相同，比所有的算术运算法的优先级都要低。 比较运算符可以采用连写的方式。例如， a &lt; b == c 用来检查是否 a 小于 b 并且 b 等于 c 。 比较运算符可以用布尔运算符 and 和 or 进行组合，然后他们的结果（或者任何其他的布尔表达式）可以被 not 否定。这些布尔运算符的优先级又比比较运算符更低；而在他们之间， not 的优先级最高，而 or 的优先级最低，因此 A and not B or C 就等价于 (A and (not B)) or C。 当然，括号可以用来提升优先级。 布尔运算符 and 和 or 往往被称为 短路 运算符：它们的参数从左往右一个个被计算，而当最终结果已经能够确定时，就不再计算剩余的参数了。举个例子，如果 A 和 C 是真的，而 B 是假的，那么 A and B and C 不会计算表达式 C 的值。当不作为布尔值使用，而是作为普通的值来使用时，短路运算符的返回值将会是最后一个被计算的参数。 也可以把比较运算的结果或其他布尔表达式赋值给一个变量。例如， 1234&gt;&gt;&gt; string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'&gt;&gt;&gt; non_null = string1 or string2 or string3&gt;&gt;&gt; non_null'Trondheim' 注意， Python 和 C 不同，赋值不能在表达式内部进行。 C 程序员们可能会抱怨这一点，但这种特性有效地防止了 C 程序中那种常见的错误发生：把 == 不小心写成了 = 。 序列及其他类型的比较拥有相同序列类型的序列对象之间可以进行比较。序列间的比较基于字典排序：首先比较两序列的首项，如果它们不同，那么比较就有了结果；如果它们相同，接下来的两项将继续进行比较，以此类推，直到两者中任何一个序列被遍历完毕。如果比较的项所在的序列是同样的类型，那么可以按照字典排序的方法递归进行下去。如果两序列所有的项比较过后都是相同的，则认为这两个序列相等。如果其中一个序列是另一个序列从头开始的一个子序列，那么更短的一个被认为更小。字符串的字典排序对于单个字符按照 Unicode 的编码大小进行排序。 一些同类型序列的比较示例如下： 1234567(1, 2, 3) &lt; (1, 2, 4)[1, 2, 3] &lt; [1, 2, 4]'ABC' &lt; 'C' &lt; 'Pascal' &lt; 'Python'(1, 2, 3, 4) &lt; (1, 2, 4)(1, 2) &lt; (1, 2, -1)(1, 2, 3) == (1.0, 2.0, 3.0)(1, 2, ('aa', 'ab')) &lt; (1, 2, ('abc', 'a'), 4) 需要注意，如果有适当的比较方法，对于不同类型对象间的比较使用 &lt; 或者 &gt; 也是合法的。例如，混合数字类型可以根据它们的数值大小进行比较，如 0 等于 0.0 ，以此类推。否则，Python解释器会抛出一个TypeError 的异常，而非给出一个随机的排序。 参考资料 https://docs.python.org/3/tutorial/datastructures.html","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"从容器到容器云","date":"2018-07-22T13:09:46.079Z","path":"2018/07/22/从容器到容器云/","text":"2013年初，一个名字从云计算领域横空出世，并在整个IT行业激起千层浪。这就是Docker——一个孕育着新思想的“容器”。Docker选择容器作为核心和基础，依靠容器技术支撑的Docker迅速成为国内外各大云计算厂商以及开发者手中的至宝。在一片热火朝天之后，新的革命已经悄然来临。 云计算平台回首历史，云计算时代蕴育出了众多的云计算平台，虽然在服务类型或平台功能上有所差异，但它们的本质上如出一辙，都与NIST1对于云计算平台的定义有着密切的关系。 云计算是一种按使用量付费的模式，该模式提供可用的、便捷的、按需的网络访问， 纳入可配置的计算资源共享池（资源包括网络、服务器、存储、应用软件、服务），统一管理的资源能够被快速提供，大大减少了资源管理工作开销，你甚至可以再也不用理会那些令人头痛的传统服务供应商了。 经典云计算架构包括了IaaS（Infrastructure as a Service，基础设施即服务）、PaaS（Platform as a Service，平台即服务）、SaaS（Software as a Service，软件即服务）三层服务，如图1-1所示。 图1-1 云平台经典架构 IaaS层为基础设施运维人员服务，提供计算、存储、网络及其他基础资源，云平台使用者可以在上面部署和运行包括操作系统和应用程序在内的任意软件，无需再为基础设施的管理而分心。 PaaS层为应用开发人员服务，提供支撑应用运行所需的软件运行时环境、相关工具与服务，如数据库服务、日志服务、监控服务等，让应用开发者可以专注于核心业务的开发。 SaaS层为一般为用户服务，提供了一套完整可用的软件系统，让一般用户无需关注技术细节，只需通过浏览器、应用客户端等方式就能使用部署在云上的应用服务。 同时，随着计算机技术推陈出新，应用的规模愈发庞大，逻辑愈发复杂，迭代更新愈发频繁，应用开发所需的统一规范和原有开发模式杂乱无章成了追求进步的主要障碍。在尖锐的矛盾中，云时代应用生命周期管理机制（Application Lifecycle Management，ALM）和十二要素应用规范（The Twelve-Factor App）2应运而生。 所有理论设计和预想一定是美好的，只是对于一个新的理论而言，如何经受住实践的考验，并将美好的愿景转化为生产力才是重中之重。IaaS的发展主要以虚拟机为最小粒度的资源调度单位，出现了资源利用率低、调度分发缓慢、软件栈环境不统一等一堆问题。PaaS在IaaS基础上发展而来，众多PaaS已经意识到可以利用容器技术解决资源利用率问题，但是PaaS通常在应用架构选择、支持的软件环境服务方面有较大的限制，这带来了应用与平台无法解耦、应用运行时环境局限性强、运维人员控制力下降的问题。 可见，不论IaaS还是PaaS都有各自适用的场景，但依旧存在诸多缺陷，人们亟需一个真正可用的解决方案。 容器，新的革命每一场革命背后都有着深刻的历史背景和矛盾冲突，新陈代谢是历史的必然结果，新生取代陈旧得益于理念的飞跃和对时代发展需求的契合，很显然Docker抓住了这个契机。 Docker是什么？ 基于官方的定义，Docker是以Docker容器为资源分割和调度的基本单位，封装整个软件运行时环境，为开发者和系统管理员设计的，用于构建、发布和运行分布式应用的平台。它是一个跨平台、可移植并且简单易用的容器解决方案。Docker的源代码托管在GitHub上，基于Go语言开发并遵从Apache 2.0协议。Docker可在容器内部快速自动化地部署应用，并通过内核技术（namespaces、cgroups等）为容器提供资源隔离与安全保障。 我们应该看看Docker的发展历程。 每一个传奇都需要一个这样的开头，很久很久以前：Docker项目由Solomon Hykes所带领的团队发起，在Docker公司的前身dotCloud内部启动孕育，代码托管于GitHub。 2013年11月：REHL 6.5正式版发布，集成了对Docker的支持，拉开了业界各大厂商竞相支持Docker的序幕。 2014年4月到6月：云技术市场上的三大巨头Amazon、Google及MicroSoft Azure相继宣布支持Docker，并着手开发基于容器的全新产品。 2014年6月：DockerCon 2014大会召开，会上来自Google、IBM、Amazon、Red Hat、Facebook及Twitter等全球领先企业的演讲嘉宾组成了豪华的阵容。此时， Docker自开源版本后又经历了15个月左右的飞速发展，Docker 1.0版本正式发布。 2014年8月：VMware宣布与Docker建立合作关系，标志了虚拟化市场形成了新的格局。 2014年10月：微软宣布将整合Docker进入下一代的Windows Server中。 2014年10月15日：Azure和Docker共同举办了Docker全球开发者大会，并宣布双方建立战略合作伙伴关系。 2014年底：Google率先发布容器引擎Google Container Engine（GCE），整合了Docker、Google自有容器技术和在DockerCon 2014大会上发布的Kubernetes，致力于为用户提供完善的基于Docker应用打造的云计算平台；Amazon发布EC2 Container Service（ECS），它是一项高度可扩展、高性能、免费的容器管理服务，并能够在托管的Amazon EC2实例集群上轻松地发布、管理和扩展Docker容器，使得Amazon Web Services（AWS）用户能够使用AWS上的容器轻松地运行和管理分布式应用。 2015年4月：Docker公司宣布完成了9500万美元的D轮融资。此前，他们已完成三轮融资，包括1500万美元的B轮融资及4000万美元的C轮融资。 2015年6月：Linux基金会携手AWS、思科、Docker、EMC、富士通、高盛、Google、惠普、华为、IBM、Intel等公司在DockerCon上共同宣布成立容器标准化组织OCP（Open Container Project），旨在实现容器标准化，为Docker生态圈内成员的协作互通打下良好的基础。该组织后更名为OCI（Open Container Initiative）。 2016年2月：Docker公司发布商业版容器及服务平台DDC（Docker Datacenter），迈出了Docker商业化的重要一步。 截至2016年6月：GitHub中Docker的贡献者超过千人，被关注和喜爱（star）多达三万两千余次（相比之下，此时Linux源码多年来积累的被关注次数仅为两万两千余次），并有九千多个开发分支（fork），Docker成为了GitHub上排名前20的明星项目。 Docker官方存储应用镜像的容器仓库也获得了大量开发者支持，其镜像仓库里已有超过12万个不同应用功能的公共镜像。最受欢迎的Ubuntu、MySQL、Nginx、WordPress镜像，下载量已超过千万次。这些数字还在不断地增长！ 在国内一线城市，几乎每一两周就有一场关于Docker的讨论大会，Docker永远不会让你孤独。 在从此以后的未来，以Docker为代表的容器技术已经给云计算乃至整个IT界带来了深远的影响，这是一次真正的计算机技术革命，来吧，拥抱变化！ 一个软件项目成功与否的标志是看其是否能够带动一个生态系统的发展，以Docker为代表的容器技术显然做到了这一点。容器技术的快速普及促进了围绕容器技术的相关项目日臻丰富和完善，容器本身的功能和易用性也随之增加。反过来，容器技术的迅猛发展也与其强大的生态系统息息相关。 图1-3 容器技术生态系统（不完全统计 从图1-3可以看出，容器技术的生态系统自下而上分别覆盖了IaaS层和PaaS层所涉及的各类问题，包括资源调度、编排、部署、监控、配置管理、存储网络管理、安全、容器化应用支撑平台等。除了基于容器技术解决构建分布式平台无法回避的经典问题，容器技术主要带来了以下几点好处。 持续部署与测试。容器消除了线上线下的环境差异，保证了应用生命周期的环境一致性和标准化。开发人员使用镜像实现标准开发环境的构建，开发完成后通过封装着完整环境和应用的镜像进行迁移，由此，测试和运维人员可以直接部署软件镜像来进行测试和发布，大大简化了持续集成、测试和发布的过程。 跨云平台支持。容器带来的最大好处之一就是其适配性，越来越多的云平台都支持容器，用户再也无需担心受到云平台的捆绑，同时也让应用多平台混合部署成为可能。目前支持容器的IaaS云平台包括但不限于亚马逊云平台（AWS）、Google云平台（GCP）、微软云平台（Azure）、OpenStack等，还包括如Chef、Puppet、Ansible等配置管理工具。 环境标准化和版本控制。基于容器提供的环境一致性和标准化，你可以使用Git等工具对容器镜像进行版本控制，相比基于代码的版本控制来说，你还能够对整个应用运行环境实现版本控制，一旦出现故障可以快速回滚。相比以前的虚拟机镜像，容器压缩和备份速度更快，镜像启动也像启动一个普通进程一样快速。 高资源利用率与隔离。容器没有管理程序的额外开销，与底层共享操作系统，性能更加优良，系统负载更低，在同等条件下可以运行更多的应用实例，可以更充分地利用系统资源。同时，容器拥有不错的资源隔离与限制能力，可以精确地对应用分配CPU、内存等资源，保证了应用间不会相互影响。 容器便携性与镜像。Linux容器虽然早在Linux 2.6版本内核已经存在，但是缺少容器的便携性，难以推广。容器在原有Linux容器的基础上进行大胆革新，为容器设定了一整套标准化的配置方法，将应用及其依赖的运行环境打包成镜像，真正实现了“构建一次，到处运行”的理念，大大提高了容器的便携性。 易于理解且易用。Docker的英文原意是处理集装箱的码头工人，标志是鲸鱼运送一大堆集装箱，集装箱就是容器，生动好记，易于理解。一个开发者可以在15分钟之内入门Docker并进行安装和部署，这是容器使用史上的一次飞跃。因为它的易用性，有更多的人开始关注容器技术，加速了容器标准化的步伐。 应用镜像仓库。Docker官方构建了一个镜像仓库，组织和管理形式类似于GitHub，其上已累积了成千上万的镜像。因为Docker的跨平台适配性，相当于为用户提供了一个非常有用的应用商店，所有人都可以自由地下载微服务组件，这为开发者提供了巨大便利。 进化：从容器到容器云容器为用户打开了一扇通往新世界的大门，真正进入这个容器的世界后，却发现新的生态系统如此庞大。在生产使用中，不论是个人还是企业，都会提出更复杂的需求。这时，我们需要众多跨主机的容器协同工作，需要支持各种类型的工作负载，企业级应用开发更是需要基于容器技术，实现支持多人协作的持续集成、持续交付平台。即使Docker只需一条命令便可启动一个容器，一旦试图将其推广到软件开发和生产环境中，麻烦便层出不穷，容器相关的网络、存储、集群、高可用等就是不得不面对的问题。从容器到容器云的进化应运而生。 什么是容器云？ 容器云以容器为资源分割和调度的基本单位，封装整个软件运行时环境，为开发者和系统管理员提供用于构建、发布和运行分布式应用的平台。当容器云专注于资源共享与隔离、容器编排与部署时，它是一种IaaS；当容器云渗透到应用支撑与运行时环境时，它是一种PaaS。 容器云并不仅限于Docker，基于rkt容器的CoreOS项目也是容器云。Docker的出现让人们意识到了容器的价值，使得一直以来长期存在但并未被重视的轻量级虚拟化技术得到快速的发展和应用。鉴于Docker的里程碑意义，本书在讨论容器云时，都以分析Docker为支撑技术的容器云为主。 Docker公司本身的技术发展，亦是从一个容器管理工具一步步向容器云发展的历史过程。Docker最初发布时只是一个单机下的容器管理工具，随后Docker公司发布了Compose、Machine、Swarm等编排部署工具，并收购了Socketplane解决集群化后的网络问题。本书提及Docker时，一般指Docker容器核心，并不包含它向容器云迈进的一系列扩展工具，这些工具则将在本书第二部分进行分析。 除了Docker公司之外，业界许多云计算厂商也对基于Docker的容器云做了巨大的投入，以Docker容器为核心的第三方Docker容器云正在迎来春天。第6章将要介绍的Fleet、第7章将要介绍的Flynn和Deis以及第8章的Kubernetes，都是基于Docker技术构建的广为人知的容器云。 从容器到容器云是一种伟大的进化，并依旧在日积月累中不断前行，现在让我们一起进入Docker的世界，感受容器与容器云的魅力。 参考资料 Docker——容器与容器云（第2版）","tags":[]},{"title":"DevOps And AIOps","date":"2018-07-22T08:38:48.627Z","path":"2018/07/22/DevOps-And-AIOps/","text":"先论DevOpsDevOps 是一天实践方法，在保证高质量的前提下缩短系统变更从提交到部署。 DevOps 对传统职能部门的挑战对于传统技术组织架构，团队通常是按照技能划分，除了业务开发部门，通常还会有测试部、运维部、安全部，项目管理部等技术支撑部门，大家按照职责各行其是搭建各自的工具平台，并通过项目的方式协作，完成系统的交付。这样相互隔离的各部门沟通效率比较低，出了问题大家总是互怼。 DevOps 文化提倡打破原有职能组织的限制，每个职能团队都开始拥抱和接受 DevOps 高度协同，研发和交付一体化的思维，同时也看到各个团队都正面临着转型、痛苦和挑战。 运维团队大概 10 年前我的一个老大曾经问我一个问题：如果一个公司快倒闭了，最后一个失业的岗位会是谁？他给的答案是运维，因为一个公司只要存在一天就需要有运维去确保机器运行正常。 这个答案看似正确，然而在公有云的大潮下，一切都被冲击的支离破碎，传统运维工程师的需求大量减少开始面临着岗位危机，运维开发团队开发的传统的资产管理、运维监控等系统在公有云上都已经有成熟的产品。流程导向的 ITIL 运维管理体系已经过时，优秀的运维开发工程师开始转向技术导向的 DevOps 平台建设，研究和开发 docker 容器、自动化运维、智能运维等技术，顺利的完成了自身技能和职能的转变。可能的问题是由于长期工作在交付末端，很多人会面临着对软件研发工程理解不足的问题。 DevOps 模式定义DevOps 集文化理念、实践和工具于一身，可以提高组织高速交付应用程序和服务的能力，与使用传统软件开发和基础设施管理流程相比，能够帮助组织更快地发展和改进产品。这种速度使组织能够更好地服务其客户，并在市场上更高效地参与竞争。 DevOps 的工作原理在 DevOps 模式下，开发团队和运营团队都不再是“孤立”的团队。有时，这两个团队会合为一个团队，他们的工程师会在应用程序的整个生命周期（从开发测试到部署再到运营）内相互协作，开发出一系列不限于单一职能的技能。 在一些 DevOps 模式下，质保和安全团队也会与开发和运营团队更紧密地结合在一起，贯穿应用程序的整个生命周期。当安全是所有 DevOps 团队成员的工作重心时，这有时被称为“DevSecOps”。这些团队会使用实践经验自动执行之前手动操作的缓慢流程。他们使用能够帮助其快速可靠地操作和发展应用程序的技术体系和工具。这些工具还可以帮助工程师独立完成通常需要其他团队协作才能完成的任务（例如部署代码或预置基础设施），从而进一步提高团队的工作速度。 DevOps 的优势速度高速运转，让您可以更快速地针对客户进行创新、更好地适应不断变化的市场，同时更有效地推动业务成果。DevOps 模式能够帮助您的开发人员和运营团队实现这些目标。例如，微服务和持续交付能够让团队充分掌控服务，然后更快速地发布更新。 快速交付提高发布的频率和速度，以便您能够更快速地进行创新并完善产品。您发布新功能和修复错误的速度越快，就越能快速地响应客户需求并建立竞争优势。持续集成和持续交付是自动执行软件发布流程（从构建到部署）的两项实践经验。 可靠性确保应用程序更新和基础设施变更的品质，以便您能够在保持最终用户优质体验的同时，更加快速可靠地进行交付。使用持续集成和持续交付等实践经验来测试每次变更是否安全以及能够正常运行。进行监控和记录实践经验能够帮助您实时了解当前的性能。 规模大规模运行和管理您的基础设施及开发流程。自动化和一致性可在降低风险的同时，帮助您有效管理复杂或不断变化的系统。例如，基础设施即代码能够帮助您以一种可重复且更有效的方式来管理部署、测试和生产环境。 增强合作建立一个适应 DevOps 文化模式的更高效的团队，强调主人翁精神和责任感。开发人员和运营团队密切合作，共同承担诸多责任，并将各自的工作流程相互融合。这有助于减少效率低下的工作，同时节约大家的时间（例如，缩短开发人员和运营团队之间的交接时间，编写将运行环境考虑在内的代码）。 安全性在快速运转的同时保持控制力和合规性。利用自动实施的合规性策略、精细控制和配置管理技术，您可以在不牺牲安全性的前提下采用 DevOps 模式。例如，利用基础设施即代码和策略即代码，您可以大规模定义并追踪合规性。 DevOps 实践经验以下列举了一些 DevOps 最佳实践： 持续集成 持续交付 微服务 基础设施即代码 监控和日志记录 沟通与合作 关键字:云平台，微服务，容器化，CI/CD，SRE，敏捷开发…. 参考资料 DevOps实践视频InfoQ","tags":[]},{"title":"深夜的口琴声","date":"2018-07-22T08:08:24.355Z","path":"2018/07/22/深夜的口琴声/","text":"深夜的口琴声","tags":[]},{"title":"关于云主机系统的初始化","date":"2018-07-02T07:21:19.688Z","path":"2018/07/02/关于云主机系统的初始化/","text":"在许多IaaS平台中新购买的机器资源并不是开箱即用，一般需根业务进行定制，又或者你作为一个强迫症患者想让自己的机器变得更加完美，所以在购买完机器后进行初始化流程是很有必要滴。 机器初始化完成可以打包为云平台的镜像，方便后续的集成。 云供应商：Ucloud系统版本号：Ubuntu 16.04 LTS。关于设置机器的数据盘视情况而操作禁用系统自动更新： sed -i '/Unattended-Upgrade/s/1/0/' /etc/apt/apt.conf.d/20auto-upgrades 设置别名： cat","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"许三观卖血记","date":"2018-06-25T14:32:47.833Z","path":"2018/06/25/许三观卖血记/","text":"《许三观卖血记》是余华1995年创作的一部长篇小说。小说讲述了一个名叫许三观的屁民通过卖血而活着的故事。 许三观是一名在城里丝厂的送蚕工，他从四叔的口中得知“没卖过血的人身子骨都不结实，娶不到女人”的规矩。 跟着根龙与啊方，许三观开始了他的卖血之路。他得知卖血前需要喝大量的水 阿方在下面说：“我们早晨什么都没吃，就喝了几碗水，现在又喝了几碗，到了城里还得再喝几碗，一直要喝到肚子又胀又疼，牙根一阵阵发酸……这水喝多了，人身上的血也会跟着多起来，水会浸到血里去的……” “这水浸到了血里，人身上的血是不是就淡了？” “淡是淡了，可身上的血就多了。” 卖血后便到胜利的饭店 然后，他们来到了那家名叫胜利的饭店，饭店是在一座石桥的桥堍，它的屋顶还没有桥高，屋顶上长满了杂草，在屋檐前伸出来像是脸上的眉毛。饭店看上去没有门，门和窗连成一片，中间只是隔了两根木条，许三观他们就是从旁边应该是窗户的地方走了进去，他们坐在了靠窗的桌子前，窗外是那条穿过城镇的小河，河面上漂过去了几片青菜叶子。 阿方对着跑堂的喊道：“一盘炒猪肝，二两黄酒，黄酒给我温一温。” 根龙也喊道：“一盘炒猪肝，二两黄酒，我的黄酒也温一温。” 许三观看着他们喊叫，觉得他们喊叫时手拍着桌子很神气，他也学他们的样子，手拍着桌子喊道： “一盘炒猪肝，二两黄酒，黄酒……温一温。” 黄血活血，猪肝补血这对许三观来说兴许是一剂良药。 每卖一次血可以赚35元，许三观感到颇为高兴便说： “四叔，我想找个女人去结婚了，四叔，这两天我一直在想这卖血挣来的三十五块钱怎么花？我想给爷爷几块钱，可是爷爷太老了，爷爷都老得不会花钱了。我还想给你几块钱，我爹的几个兄弟里，你对我最好，四叔，可我又舍不得给你，这是我卖血挣来的钱，不是我卖力气挣来的钱，我舍不得给。四叔，我刚才丫起来的时候突然想到娶女人了。四叔，我卖血挣来的钱总算是花对地方了……四叔，我吃了一肚子的瓜、怎么像是喝了一斤酒似的，四叔，我的脸，我的脖子我的脚底，我的手掌，都在一阵阵地发烧。 后面许三观便娶了城内出名的”油条西施“许玉兰为妻子。 文中有趣的摘抄(读到这里着实让人感到无比的滑稽:))： 第二天下午，许三观把许玉兰带到了那家胜利饭店，坐在靠窗的桌子旁，也就是他和阿方、根龙吃炒猪肝喝黄酒的桌前，他像阿方和根龙那样神气地拍着桌子，对跑堂的叫道： “来一客小笼包子。” 他请许玉兰吃了一客小笼包子，吃完小笼包子后，许玉兰说她还能吃一碗馄饨，许三观又拍起了桌子： “来一碗馄饨。” 许玉兰这天下午笑眯眯地还吃了话梅，吃了话梅以后说嘴咸，又吃了糖果，吃了糖果以后说口渴， 许三观就给她买了半个西瓜，她和许三观站在了那座木桥上，她笑眯眯地把半个西瓜全吃了下去，然后她笑眯眯地打起了嗝。当她的身体一抖一抖地打嗝时，许三观数着手指开始算一算这个下午花了多少钱。 “小笼包子两角四分，馄饨九分钱，话梅一角，糖果买了两次共计两角三分，西瓜半个有三斤四两花了一角七分，总共是八角三分钱……你什么时候嫁给我？” “啊呀，”许玉兰惊叫起来，“你凭什么要我嫁给你” 许三观说：“你花掉了我八角三分钱。” “是你自己请我吃的，”许玉兰打着嗝说，“我还以为是白吃的呢，你又没说吃了你的东西就要嫁给你……” “嫁给我有什么不好？”许三观说，“你嫁给我以后，我会疼你护着你，我会经常让你一个下午就吃掉八角三分钱。” “啊呀，”许玉兰叫了起来，“要是我嫁给了你，我就不会这么吃了，我嫁给你以后就是吃自己的了，我舍不得……早知道是这样，我就不吃了。” “你也不用后悔，”许三观安慰她，“你嫁给我就行了。” “我不能嫁给你，我有男朋友了，我爹也不会答应的，我爹喜欢何小勇……” 于是，许三观就提着一瓶黄酒一条大前门香烟，来到许玉兰家，他在许玉兰父亲的对面坐了下来，将黄酒和香烟推了过去，然后滔滔不绝地说了起来： “你知道我爹吧？我爹就是那个有名的许木匠，他老人家活着的时候专给城里大户人家做活，他做出来的桌于谁也比不上，伸手往桌面上一摸，就跟摸在绸缎上一样光滑。你知道我妈吧？我妈就是金花，你知道金花吗？就是那个城西的美人，从前别人都叫她城西美人，我爹死了以后她嫁给了一个国民党连长，后来跟着那个连长跑了。我爹只有我这么一个儿子，我妈和那个连长是不是生了我就不知道了。我叫许三观，我两个伯伯的儿子比我大，我在许家排行老三，所以我叫许三观，我是丝厂的工人，我比何小勇大两岁，比他早三年参加工作，我的钱肯定比他多，他想娶许玉兰还得筹几年钱，我结婚的钱都准备好了，我是万事皆备只欠东风了。” 许三观又说：“你只有许玉兰一个女儿，许玉兰要是嫁给了何小勇，你家就断后了，生出来的孩子不管是男是女，都得姓何。要是嫁给了我，我本来就姓许，生下来的孩子也不管是男是女，都姓许，你们许家后面的香火也就接上了，说起来我娶了许玉兰，其实我就和倒插门的女婿一样。许玉兰的父亲听到最后那几句话，嘿嘿笑了起来，他看着许三观，手指在桌上笃笃地敲着，他说：”这一瓶酒，这一条香烟，我收下了，你说得对，我女儿要是嫁给了何小勇，我许家就断后了。我女儿要是嫁给了你，我们两个许家的香火都接上了。” 不久，许三观便有了三个儿子，取名分别为：许一乐、许二乐、许三乐 许玉兰在五年时间里生下了三个儿子，许三观给他三个儿子取名为许一乐，许二乐，许三乐。 有一天，在许三乐一岁三个月的时候，许玉兰揪住许三观的耳朵问他： “我生孩子时，你是不是在外面哈哈大笑？” “我没有哈哈大笑，”许三观说，“我只是嘿嘿地笑，没有笑出声音。” “啊呀，”许玉兰叫道，“所以你让三个儿子叫一乐，二乐，三乐，我在产房里疼了一次，二次，三次；你在外面乐了一次，二次，三次，是不是？” 后续的故事，作者余华用诙谐幽默的方式来描写一个小人物许三观的家庭生活，阐释了这个社会的荒谬。 卖血是为了娶亲，是为了治重病的儿子，是为了郑重款待宾客，是为了生存，但最终还是为了爱和可笑的尊严。 再谈历史背景：从余华的《活着》、《许三观卖血记》故事的历史背景都是中国近代史。 1、1958年的人民公社、大跃进和大炼钢铁。2、接下来一两年的天灾人祸导致的全国性饥荒。3、文化大革命，知青下山。….. “你知道吗？为什么工厂停工了、商店关门了、学校不上课、你也用不着去炸抽条了？为什么有人被吊在了树上、有人被关进了牛棚、有人被活活打死？你知道吗？为什么毛主席一说话，就有人把他的话编成了歌，就有人把他的话刷到了墙上、刷到了地上、刷到了汽车上和轮船上、床单上和枕巾上、杯子上和锅上，连厕所的墙上和痰盂上都有。毛主席的名字为什么会这么长予你听着：伟大的领袖伟大的导师伟大的统帅伟大的舵手毛主席万岁万岁万万岁。一共有三十个字，这些都要一口气念下来，中间不能换气。你知道这是为什么？因为文化大革命来了。” 这样的一番阐释从许三观口中说出来，既符合人物的身份和层次，又启发读者自己的思考。许三观的逻辑和认识水平并不一定就是正确的，但那是真正身处其中的人物会说出的话，这样的话让读者信服的同时也给读者自己想象和思考的空间：文化大革命不只是发生在中国的那一场灾难，而是整个人类都会面临的一种变态与暴力的可能，因而许三观们面对的不仅仅是他个人的命运，而是有可能发生在每个人身上的命运。 韩国电影《许三观》正是根据余华的小说《许三观卖血记》而改编 再附上网友同样以诙谐幽默手法改编的《许三观卖码记》","tags":[{"name":"Books","slug":"Books","permalink":"https://yo42.github.io/tags/Books/"}]},{"title":"JumpServer 运维安全审计系统","date":"2018-06-23T10:31:43.211Z","path":"2018/06/23/JumpServer-运维安全审计系统/","text":"目前，使用的是SSHConfig+ansible的模式进行管控各开发&amp;运维人员的公钥，以及云主机的登录。 现阶段属于纯跳版机模式，并没有审计功能，存在安全隐患，对于人员离职权限的回收不够彻底，公钥的分发不够方便，开发&amp;运维人员都混用一个账号进行登录，没有审计功能，粗放式权限管理，外放了root密码。 综合上述缺点，需要一个审计系统。 目前业界比较良心的开源审计系统http://www.jumpserver.org/ 其实现在许多云供应商都在推自己的审计系统产品，有些也是基于jumpserver进行二次开发的。 堡垒机不仅集中管理和分配全部账号，更重要的是能对运维/开发人员的运维操作进行严格审计和权限控制，确保运维的安全合规和运维/开发人员的最小化权限管理。 从实际应用来看，堡垒机主要管控企业的服务器资源。 1、JumpServer的安装:略(参考官方文档),后续可能会进行Docker化的定制(coco-ssh server,jumpserver,luna web terminal插件)。 梳理权限与规则:JumpServer用户管理: 梳理各项目组的开发与运维人员的列表，以项目名创建组，通过手工的方式进行开发人员与运维人员的编制。 用户是授权和登陆的主体，将来为每个员工建立一个账户，用来登录跳板机，将资产授权给该用户，查看用户登陆记录命令历史等。创建用户，例如:以开发者张三的名称创建用户，后续张三将以dev的身份进行资产的登录如 web, sa, dba,dev,oc(ssh web@some-host) 管理用户是服务器的root，或拥有 NOPASSWD: ALL sudo权限的用户，Jumpserver使用该用户来 推送系统用户、获取资产硬件信息等，大概会使用root进行管理，采用密码管理的方式。 系统用户是服务器上建立的一些真实存在的可以ssh登陆的用户,如 dev,sa, dba等，系统用户可使用jumpserver推送到服务器上，也可以利用自己公司的工具进行推送，授权时将用户、资产、系统用户关联起来，则表明用户有权限登陆该资产的这个系统用户 如：用户 小明 以 dev 系统用户登录 172.16.1.1资产,简单理解就是 将某个资产上的某个系统用户映射给这个用户登录。 角色为用户的人员禁止授权su权限,不提供root密码就没有su权限，需要时再申请，sudo su。 创建系统用户如Dev和oc时需保存密钥。 JumpServer资产管理: 区分不同云供应商，每个节点对应每个云供应商、项目，节点下再区分正式服、辅助支撑服。 测试环境的部署: 选择一个云供应商和地区进行部署一台JumpServer服务器，以及一些测试服。 购买新资产进行自动添加还需参考JumpServer提供的API实现自动化。 测试使用REST API 进行资产的自动添加资产以及权限管理 jumpserver集成sdk 获取token curl -XPOST -d \"username=admin;password=xxxxx\" http://192.168.9.250/api/users/v1/token/ 查询用户可见资产 curl -X GET --header 'Content-Type: application/json' --header 'Accept: application/json' -H 'Authorization: Bearer b5abc7c5b5cf4be780370d607181c5fa' 'http://192.168.9.250/api/assets/v1/assets/' 示例: 1、用户登录 curl -XPOST -d 'username=admin;password=admin' http://192.168.188.40/api/users/v1/token/ {\"Token\":\"14a9f25397444abb8666c9fa00c294c9\",\"Keyword\":\"Bearer\"} 2、获取所有的用户 curl -H 'Authorization: Bearer 14a9f25397444abb8666c9fa00c294c9' -XGET http://192.168.188.84:8080/api/users/v1/users/ 3、创建用户组 curl -X POST --header 'Content-Type: application/json' --header 'Accept: application/json' -H 'Authorization: Bearer 14a9f25397444abb8666c9fa00c294c9' -d '{\"id\":\"1162e7a4-90f6-4e5e-b7cf-14581adb7621\",\"is_discard\": false,\"discard_time\": \"\",\"name\":\"epointgroup\",\"comment\":\"\",\"created_by\": \"administrator\",\"date_created\":\"2018-06-06 06:03:03 +0000\",\"discard_time\":\"2018-06-11 06:03:03 +0000\"}' 'http://192.168.188.84/api/users/v1/groups/' 4、创建用户并设置用户组 curl -X POST --header 'Content-Type: application/json' --header 'Accept: application/json' -H 'Authorization: Bearer 14a9f25397444abb8666c9fa00c294c9' 'http://192.168.188.84/api/users/v1/users/' -d '{\"id\": \"13f1432d-9a8c-4d83-aad9-c3177e3a387d\",\"groups\": [\"1162e7a4-90f6-4e5e-b7cf-14581adb7620\"],\"last_login\": \"2018-05-19 06:03:03 +0000\",\"is_active\": true,\"date_joined\": \"2018-06-06 06:03:03 +0000\",\"username\": \"ijarvis\",\"name\": \"ijarvis\",\"email\": \"ijarvis@sina.com\",\"role\": \"Admin\",\"avatar\": null,\"wechat\": \"\",\"phone\": \"\",\"otp_level\": 0,\"comment\": \"\",\"is_first_login\": true,\"date_expired\": \"2088-05-19 06:03:03 +0000\",\"created_by\": \"2018-05-19 06:03:03 +0000\"}' 5、 获取所有资产列表 curl -X GET --header 'Content-Type: application/json' --header 'Accept: application/json' -H 'Authorization: Bearer 14a9f25397444abb8666c9fa00c294c9' 'http://192.168.188.84/api/assets/v1/assets/' 6、创建用户资产 curl -X POST --header 'Content-Type: application/json' --header 'Accept: application/json' -H 'Authorization: Bearer 14a9f25397444abb8666c9fa00c294c9' -d '{\"id\": \"9f7a3cd5-b3be-4a4f-a7f6-0cbcb8529e71\",\"ip\": \"192.168.186.66\",\"hostname\": \"Hadoop_186_66\",\"port\": 22,\"platform\": \"Linux\",\"is_active\": true,\"public_ip\": null,\"created_by\": null,\"comment\": \"\",\"admin_user\": \"06fe163e-aacd-48ce-a7a7-a15800587b99\", \"nodes\": [\"7c0b0eda-8555-42e4-9205-992957c46d56\"]}' 'http://192.168.188.84/api/assets/v1/assets/' 逻辑图: 参考资料 https://www.zhihu.com/question/21036511 http://www.jumpserver.org/ https://github.com/jumpserver/jumpserver","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"[转载]程序员技术练级攻略","date":"2018-06-21T04:58:41.000Z","path":"2018/06/21/转载-程序员技术练级攻略/","text":"转载自左耳朵耗子的博文,感觉不错就记录下吧前言你是否觉得自己从学校毕业的时候只做过小玩具一样的程序？走入职场后哪怕没有什么经验也可以把以下这些课外练习走一遍（朋友的抱怨：学校课程总是从理论出发，作业项目都看不出有什么实际作用，不如从工作中的需求出发） 建议： 不要乱买书，不要乱追新技术新名词，基础的东西经过很长时间积累而且还会在未来至少10年通用。回顾一下历史，看看历史上时间线上技术的发展，你才能明白明天会是什么样。一定要动手，例子不管多么简单，建议至少自己手敲一遍看看是否理解了里头的细枝末节。一定要学会思考，思考为什么要这样，而不是那样。还要举一反三地思考。注：你也许会很奇怪为什么下面的东西很偏Unix/Linux，这是因为我觉得Windows下的编程可能会在未来很没有前途，原因如下： 现在的用户界面几乎被两个东西主宰了，1）Web，2）移动设备iOS或Android。Windows的图形界面不吃香了。越来越多的企业在用成本低性能高的Linux和各种开源技术来构架其系统，Windows的成本太高了。微软的东西变得太快了，很不持久，他们完全是在玩弄程序员。详情参见《Windows编程革命史》所以，我个人认为以后的趋势是前端是Web+移动，后端是Linux+开源。开发这边基本上没Windows什么事。 启蒙入门1、 学习一门脚本语言，例如Python/Ruby 可以让你摆脱对底层语言的恐惧感，脚本语言可以让你很快开发出能用得上的小程序。实践项目: 处理文本文件，或者csv (关键词 python csv, python open, python sys) 读一个本地文件，逐行处理（例如 word count，或者处理log）遍历本地文件系统 (sys, os, path)，例如写一个程序统计一个目录下所有文件大小并按各种条件排序并保存结果跟数据库打交道 (python sqlite)，写一个小脚本统计数据库里条目数量学会用各种print之类简单粗暴的方式进行调试学会用Google (phrase, domain, use reader to follow tech blogs)为什么要学脚本语言，因为他们实在是太方便了，很多时候我们需要写点小工具或是脚本来帮我们解决问题，你就会发现正规的编程语言太难用了。 2、 用熟一种程序员的编辑器(不是IDE) 和一些基本工具 Vim / Emacs / Notepad++，学会如何配置代码补全，外观，外部命令等。Source Insight (或 ctag)使用这些东西不是为了Cool，而是这些编辑器在查看、修改代码/配置文章/日志会更快更有效率。 3、 熟悉Unix/Linux Shell和常见的命令行 如果你用windows，至少学会用虚拟机里的linux， vmware player是免费的，装个Ubuntu吧一定要少用少用图形界面。学会使用man来查看帮助文件系统结构和基本操作 ls/chmod/chown/rm/find/ln/cat/mount/mkdir/tar/gzip …学会使用一些文本操作命令 sed/awk/grep/tail/less/more …学会使用一些管理命令 ps/top/lsof/netstat/kill/tcpdump/iptables/dd…了解/etc目录下的各种配置文章，学会查看/var/log下的系统日志，以及/proc下的系统运行信息了解正则表达式，使用正则表达式来查找文件。对于程序员来说Unix/Linux比Windows简单多了。（参看我四年前CSDN的博文《其实Unix很简单》）学会使用Unix/Linux你会发现图形界面在某些时候实在是太难用了，相当地相当地降低工作效率。 4、 学习Web基础（HTML/CSS/JS) + 服务器端技术 (LAMP) 未来必然是Web的世界，学习WEB基础的最佳网站是W3School。 学习HTML基本语法学习CSS如何选中HTML元素并应用一些基本样式（关键词：box model）学会用 Firefox + Firebug 或 chrome 查看你觉得很炫的网页结构，并动态修改。学习使用Javascript操纵HTML元件。理解DOM和动态网页（http://oreilly.com/catalog/9780596527402) 网上有免费的章节，足够用了。或参看 DOM 。学会用 Firefox + Firebug 或 chrome 调试Javascript代码（设置断点，查看变量，性能，控制台等）在一台机器上配置Apache 或 Nginx学习PHP，让后台PHP和前台HTML进行数据交互，对服务器相应浏览器请求形成初步认识。实现一个表单提交和反显的功能。把PHP连接本地或者远程数据库 MySQL（MySQL 和 SQL现学现用够了）跟完一个名校的网络编程课程（例如：http://www.stanford.edu/~ouster/cgi-bin/cs142-fall10/index.php ) 不要觉得需要多于一学期时间，大学生是全职一学期选3-5门课，你业余时间一定可以跟上学习一个javascript库（例如jQuery 或 ExtJS）+ Ajax (异步读入一个服务器端图片或者数据库内容）+JSON数据格式。HTTP: The Definitive Guide 读完前4章你就明白你每天上网用浏览器的时候发生的事情了(proxy, gateway, browsers)做个小网站（例如：一个小的留言板，支持用户登录，Cookie/Session，增、删、改、查，上传图片附件，分页显示）买个域名，租个空间，做个自己的网站。进阶加深1、 C语言和操作系统调用 重新学C语言，理解指针和内存模型，用C语言实现一下各种经典的算法和数据结构。推荐《计算机程序设计艺术》、《算法导论》和《编程珠玑》。学习（麻省理工免费课程）计算机科学和编程导论学习（麻省理工免费课程）C语言内存管理学习Unix/Linux系统调用（Unix高级环境编程），，了解系统层面的东西。用这些系统知识操作一下文件系统，用户（实现一个可以拷贝目录树的小程序）用fork/wait/waitpid写一个多进程的程序，用pthread写一个多线程带同步或互斥的程序。多进程多进程购票的程序。用signal/kill/raise/alarm/pause/sigprocmask实现一个多进程间的信号量通信的程序。学会使用gcc和gdb来编程和调试程序（参看我的《用gdb调试程序》）学会使用makefile来编译程序。（参看我的《跟我一起写makefile》）IPC和Socket的东西可以放到高级中来实践。学习Windows SDK编程（Windows 程序设计 ，MFC程序设计）写一个窗口，了解WinMain/WinProcedure，以及Windows的消息机制。写一些程序来操作Windows SDK中的资源文件或是各种图形控件，以及作图的编程。学习如何使用MSDN查看相关的SDK函数，各种WM_消息以及一些例程。这本书中有很多例程，在实践中请不要照抄，试着自己写一个自己的例程。不用太多于精通这些东西，因为GUI正在被Web取代，主要是了解一下Windows 图形界面的编程。@virushuo 说：“ 我觉得GUI确实不那么热门了，但充分理解GUI工作原理是很重要的。包括移动设备开发，如果没有基础知识仍然很吃力。或者说移动设备开发必须理解GUI工作，或者在win那边学，或者在mac/iOS上学”。2、学习Java Java 的学习主要是看经典的Core Java 《Java 核心技术编程》和《Java编程思想》（有两卷，我仅链了第一卷，足够了，因为Java的图形界面了解就可以了）学习JDK，学会查阅Java API Doc http://download.oracle.com/javase/6/docs/api/了解一下Java这种虚拟机语言和C和Python语言在编译和执行上的差别。从C、Java、Python思考一下“跨平台”这种技术。学会使用IDE Eclipse，使用Eclipse 编译，调试和开发Java程序。建一个Tomcat的网站，尝试一下JSP/Servlet/JDBC/MySQL的Web开发。把前面所说的那个PHP的小项目试着用JSP和Servlet实现一下。3、Web的安全与架构学习HTML5，网上有很多很多教程，以前酷壳也介绍过很多，我在这里就不罗列了。学习Web开发的安全问题（参考新浪微博被攻击的这个事，以及Ruby的这篇文章）学习HTTP Server的rewrite机制，Nginx的反向代理机制，fast-cgi（如：PHP-FPM）学习Web的静态页面缓存技术。学习Web的异步工作流处理，数据Cache，数据分区，负载均衡，水平扩展的构架。实践任务：使用HTML5的canvas 制作一些Web动画。尝试在前面开发过的那个Web应用中进行SQL注入，JS注入，以及XSS攻击。把前面开发过的那个Web应用改成构造在Nginx + PHP-FPM + 静态页面缓存的网站4、学习关系型数据库 你可以安装MSSQLServer或MySQL来学习数据库。学习教科书里数据库设计的那几个范式，1NF，2NF，3NF，……学习数据库的存过，触发器，视图，建索引，游标等。学习SQL语句，明白表连接的各种概念（参看《SQL Join的图示》）学习如何优化数据库查询（参看《MySQL的优化》）实践任务：设计一个论坛的数据库，至少满足3NF，使用SQL语句查询本周，本月的最新文章，评论最多的文章，最活跃用户。5、一些开发工具 学会使用SVN或Git来管理程序版本。学会使用JUnit来对Java进行单元测试。学习C语言和Java语言的coding standard 或 coding guideline。（我N年前写过一篇关C语言非常简单的文章——《编程修养》，这样的东西你可以上网查一下，一大堆）。推荐阅读《代码大全》《重构》《代码整洁之道》高级深入1、C++ / Java 和面向对象 我个人以为学好C++，Java也就是举手之劳。但是C++的学习曲线相当的陡。不过，我觉得C++是最需要学好的语言了。参看两篇趣文“C++学习信心图” 和“21天学好C++” 学习（麻省理工免费课程）C++面向对象编程读我的 “如何学好C++”中所推荐的那些书至少两遍以上（如果你对C++的理解能够深入到像我所写的《C++虚函数表解析》或是《C++对象内存存局》，或是《C/C++返回内部静态成员的陷阱》那就非常不错了）然后反思为什么C++要干成这样，Java则不是？你一定要学会对比C++和Java的不同。比如，Java中的初始化，垃圾回收，接口，异常，虚函数，等等。实践任务：用C++实现一个BigInt，支持128位的整形的加减乘除的操作。用C++封装一个数据结构的容量，比如hash table。用C++封装并实现一个智能指针（一定要使用模板）。《设计模式》必需一读，两遍以上，思考一下，这23个模式的应用场景。主要是两点：1）钟爱组合而不是继承，2）钟爱接口而不是实现。（也推荐《深入浅出设计模式》）实践任务：使用工厂模式实现一个内存池。使用策略模式制做一个类其可以把文本文件进行左对齐，右对齐和中对齐。使用命令模式实现一个命令行计算器，并支持undo和redo。使用修饰模式实现一个酒店的房间价格订价策略——旺季，服务，VIP、旅行团、等影响价格的因素。学习STL的用法和其设计概念 – 容器，算法，迭代器，函数子。如果可能，请读一下其源码。实践任务：尝试使用面向对象、STL，设计模式、和WindowsSDK图形编程的各种技能做一个贪吃蛇或是俄罗斯方块的游戏。支持不同的级别和难度。做一个文件浏览器，可以浏览目录下的文件，并可以对不同的文件有不同的操作，文本文件可以打开编辑，执行文件则执行之，mp3或avi文件可以播放，图片文件可以展示图片。学习C++的一些类库的设计，如： MFC（看看候捷老师的《深入浅出MFC》） ，Boost, ACE, CPPUnit，STL （STL可能会太难了，但是如果你能了解其中的设计模式和设计那就太好了，如果你能深入到我写的《STL string类的写时拷贝技术》那就非常不错了，ACE需要很强在的系统知识，参见后面的“加强对系统的了解”）Java是真正的面向对象的语言，Java的设计模式多得不能再多，也是用来学习面向对象的设计模式的最佳语言了（参看Java中的设计模式）。推荐阅读《Effective Java》 and 《Java解惑》学习Java的框架，Java的框架也是多，如Spring, Hibernate，Struts 等等，主要是学习Java的设计，如IoC等。Java的技术也是烂多，重点学习J2EE架构以及JMS， RMI, 等消息传递和远程调用的技术。学习使用Java做Web Service （官方教程在这里）实践任务： 尝试在Spring或Hibernate框架下构建一个有网络的Web Service的远程调用程序，并可以在两个Service中通过JMS传递消息。C++和Java都不是能在短时间内能学好的，C++玩是的深，Java玩的是广，我建议两者选一个。我个人的学习经历是： 深究C++（我深究C/C++了十来年了）学习Java的各种设计模式。2、加强系统了解 重要阅读下面的几本书： 《Unix编程艺术》了解Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验。你一定会有一种醍醐灌顶的感觉。《Unix网络编程卷1，套接字》这是一本看完你就明白网络编程的书。重要注意TCP、UDP，以及多路复用的系统调用select/poll/epoll的差别。《TCP/IP详解 卷1:协议》- 这是一本看完后你就可以当网络黑客的书。了解以太网的的运作原理，了解TCP/IP的协议，运作原理以及如何TCP的调优。实践任务：理解什么是阻塞（同步IO），非阻塞（异步IO），多路复用（select, poll, epoll）的IO技术。写一个网络聊天程序，有聊天服务器和多个聊天客户端（服务端用UDP对部分或所有的的聊天客户端进Multicast或Broadcast）。写一个简易的HTTP服务器。《Unix网络编程卷2，进程间通信》信号量，管道，共享内存，消息等各种IPC…… 这些技术好像有点老掉牙了，不过还是值得了解。实践任务：主要实践各种IPC进程序通信的方法。尝试写一个管道程序，父子进程通过管道交换数据。尝试写一个共享内存的程序，两个进程通过共享内存交换一个C的结构体数组。学习《Windows核心编程》一书。把CreateProcess，Windows线程、线程调度、线程同步（Event, 信号量，互斥量）、异步I/O，内存管理，DLL，这几大块搞精通。实践任务：使用CreateProcess启动一个记事本或IE，并监控该程序的运行。把前面写过的那个简易的HTTP服务用线程池实现一下。写一个DLL的钩子程序监控指定窗口的关闭事件，或是记录某个窗口的按键。有了多线程、多进程通信，TCP/IP，套接字，C++和设计模式的基本，你可以研究一下ACE了。使用ACE重写上述的聊天程序和HTTP服务器（带线程池）实践任务：通过以上的所有知识，尝试写一个服务端给客户端传大文件，要求把100M的带宽用到80%以上。（注意，磁盘I/O和网络I/O可能会很有问题，想一想怎么解决，另外，请注意网络传输最大单元MTU）了解BT下载的工作原理，用多进程的方式模拟BT下载的原理。3、系统架构 负载均衡。HASH式的，纯动态式的。（可以到Google学术里搜一些关于负载均衡的文章读读）多层分布式系统 – 客户端服务结点层、计算结点层、数据cache层，数据层。J2EE是经典的多层结构。CDN系统 – 就近访问，内容边缘化。P2P式系统，研究一下BT和电驴的算法。比如：DHT算法。服务器备份，双机备份系统（Live-Standby和Live-Live系统），两台机器如何通过心跳监测对方？集群主结点备份。虚拟化技术，使用这个技术，可以把操作系统当应用程序一下切换或重新配置和部署。学习Thrift，二进制的高性能的通讯中间件，支持数据(对象)序列化和多种类型的RPC服务。学习Hadoop。Hadoop框架中最核心的设计就是：MapReduce和HDFS。MapReduce的思想是由Google的一篇论文所提及而被广为流传的，简单的一句话解释MapReduce就是“任务的分解与结果的汇总”。HDFS是Hadoop分布式文件系统（Hadoop Distributed File System）的缩写，为分布式计算存储提供了底层支持。了解NoSQL数据库（有人说可能是一个过渡炒作的技术），不过因为超大规模以及高并发的纯动态型网站日渐成为主流，而SNS类网站在数据存取过程中有着实时性等刚性需求，这使得目前NoSQL数据库慢慢成了人们所关注的焦点，并大有成为取代关系型数据库而成为未来主流数据存储模式的趋势。当前NoSQL数据库很多，大部分都是开源的，其中比较知名的有：MemcacheDB、Redis、Tokyo Cabinet(升级版为Kyoto Cabinet)、Flare、MongoDB、CouchDB、Cassandra、Voldemort等。写了那么多，回顾一下，觉得自己相当的有成就感。希望大家不要吓着，我自己这十来年也在不断地学习，今天我也在学习中，人生本来就是一个不断学习和练级的过程。不过，一定有漏的，也有不对的，还希望大家补充和更正。（我会根据大家的反馈随时更新此文）欢迎大家通过我的微博（@左耳朵耗子）和twitter（@haoel）和我交流。 —– 更新 2011/07/19 —– 1）有朋友奇怪为什么我在这篇文章开头说了web+移动，却没有在后面提到iOS/Android的前端开发。因为我心里有一种感觉，移动设备上的UI最终也会被Javascript取代。大家可以用iPhone或Android看看google+，你就会明白了。 2）有朋友说我这里的东西太多了，不能为了学习而学习，我非常同意。我在文章的前面也说了要思考。另外，千万不要以为我说的这些东西是一些新的技术，这份攻略里95%以上的全是基础。而且都是久经考验的基础技术。即是可以让你一通百通的技术，也是可以让你找到一份不错工作的技术。 3）有朋友说学这些东西学完都40了，还不如想想怎么去挣钱。我想告诉大家，一是我今年还没有40岁，二是学无止境啊，三是我不觉得挣钱有多难，难的是怎么让你值那么多钱？无论是打工还是创业，是什么东西让你自己的价值，让你公司的价值更值钱？别的地方我不敢说，对于互联网或IT公司来说，技术实力绝对是其中之一。 4）有朋友说技术都是工具，不应该如此痴迷这句话没有错，有时候我们需要更多的是抬起头来看看技术以外的事情，或者是说我们在作技术的时候不去思考为什么会有这个技术，为什么不是别的，问题不在于技术，问题在于我们死读书，读死书，成了技术的书呆子。 5） 对于NoSQL，最近比较火，但我对其有点保守，所以，我只是说了解就可以。对于Hadoop，我觉得其在分布式系统上有巨大的潜力，所以需要学习。 对于关系型数据库，的确是很重要的东西，这点是我的疏忽，在原文里补充。 （全文完） 参考资料 https://coolshell.cn/articles/4990.html","tags":[]},{"title":"[转载]每个程序员都该知道的事","date":"2018-06-21T04:50:30.000Z","path":"2018/06/21/转载-每个程序员都该知道的事/","text":"在每个月月中，我会推荐一些有价值的内容，供你参考。这个月，我将为你推荐五篇阅读文章，这五篇文章我觉得都是比较不错的经验总结，是我们每一个技术人员都需要知道的东西。它们分别是： Stack Overflow 上开出来的一个经典书书单；美国某大学教授给计算机专业学生的一些建议，其中有很多的资源；LinkedIn 的高效代码复查实践，很不错的方法，值得你一读；一份关于程序语言和 bug 数相关的有趣的报告，可以让你对各种语言有所了解 每个程序员都应该要读的书在 Stack Overflow 上有一个问题 What is the single most influential book every programmer should read，网址为： https://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read 虽然这个问题被关闭了，但是这是一个非常热门的问题。排在第一个的人给了一大串书的列表，看上去着实吓人，不过都是一些相当经典相当有影响力的书，在这里我重罗列一些我觉得你必需要看的。 《代码大全》虽然这本书有点过时了，而且厚到可以垫显示器，但是这是一本绝对经典的书。《程序员修练之道》这本书也是相当的经典，我觉得就是你的指路明灯。《计算机的构造和解释》经典中的经典，必需读的书。《算法导论》美国的本科生教材，这本书应该也是中国计算机学生的教材。《设计模式》这本书是面向对象设计的经典书。《重构》代码坏味道和相应的代码的最佳实践。《人月神话》这本书可能也有点过时了。但还是经典书。《代码整洁之道》细节之处的效率，完美和简单。《Effective C++》/《More Effective C++》C++ 中两本经典得不能再经典的书。也许你觉得 C++ 复杂，但这两本书中带来对代码稳定性的探索方式让人非常受益，因为这种思维方式同样可以用在其它地方。以至于各种模仿者，比如《Effective Java》也是一本经典书。《Unix 编程艺术》、《Unix 高级环境编程》也是相关的经典。还有好多，我就不在这里一一列了。你可以看看其它的答案，我发现自己虽然读过好多书，但也有好些书没有读过，这个问答对我也很有用。 每个搞计算机专业的学生应有的知识What every computer science major should know，每个搞计算机专业的学生应有的知识，网址为：http://matt.might.net/articles/what-cs-majors-should-know/ 本文作者马修·迈特（Matthew Might）是美国犹他大学计算机学院的副教授，2007 年于佐治亚理工学院取得博士学位。计算机专业的课程繁多，而且随着时代的变化，科目的课程组成也在不断变化。如果不经过思考，直接套用现有的计算机专业课程列表，则有可能忽略一些将来可能变得重要的知识点。为此，马修力求从四个方面来总结，得出这篇文章的内容。 要获得一份好工作，学生需要知道什么？为了一辈子都有工作干，学生需要知道什么？学生需要知道什么，才能考进研究生院？学生需要知道什么，才能对社会有益？这篇文章不仅仅对刚毕业的学生有用，对有工作经验的人同样有用，这里我把这篇文章的内容摘要如下。 首先，对于我们每个人来说，作品集（Portfolio）会比简历（Resume）更有参考意义。所以，在自己的简历中应该放上自己的一些项目经历，或是一些开源软件的贡献，或是你完成的软件的网址等。最好有一个自己的个人网址，上面有一些你做的事，自己的技能，经历，以及你的一些文章和思考会比简历更好。 其次，计算机专业工作者也要学会与人交流的技巧，包括如何写演示文稿，以及面对质疑时如何与人辩论的能力。 最后，他就各个方面展开计算机专业人士所需要的硬技能：工程类数学、Unix 哲学和实践、系统管理、程序设计语言、离散数学、数据结构与算法、计算机体系结构、操作系统、网络、安全、密码学、软件测试、用户体验、可视化、并行计算、软件工程、形式化方法、图形学、机器人、人工智能、机器学习、数据库，等等。详读本文可以了解计算机专业知识的全貌。 这篇文章的第三部分简直就是一个知识资源向导库，给出了各个技能的方向和关键知识点，你可以跟随着这篇文章里的相关链接学到很多东西。 LinkedIn 高效的代码复查技巧LinkedIn’s Tips for Highly Effective Code Review，LinkedIn 的高效代码复查技巧，网址为：https://thenewstack.io/linkedin-code-review/ 对于 Code Review，我有一篇文章 《从 Code Review 谈如何做技术》，讲述了为什么 Code Review 是一件很重要事情。今天推荐的这篇文章是 LinkedIn 公司的相关实践。 这篇文章介绍了 LinkedIn 公司内部实践的 Code Review 形式。具体来说，LinkedIn 的代码复查有以下几个特点。 从 2011 年开始，强制要求在团队成员之间做代码复查。Code Review 带来的反馈意见让团队成员能够迅速提升自己的技能水平，这解决了 LinkedIn 各个团队近年来因迅速扩张带来的技能不足的问题。通过建立公司范围的 Code Review 工具，这就可以做跨团队的 Code Review。既有利于消除 bug，提升质量，也有利于大家对代码的学习和技能的传播。Code Review 的经验作为员工晋升的参考因素之一。Code Review 的一个难点是，Reviewer 可能不了解某个修改的背景和目的。所以 LinkedIn 要求代码签入版本管理系统前，就对其做清晰的说明，以便复查者了解其目的，促进 Review 的进行。我认为，这个方法实在在太赞了。因为，我看到很多时候，Reviewer 都会说不了解对方代码的背景或是代码量比较大而无法做 Code Review，然而，却没有找到相应的方法解决这个问题。 LinkedIn 对提交代码写说明文档这个方法是一个非常不错的方法，因为代码提交人写文档的过程其实也是重头梳理的过程。我的个人经验是，写文档的时候通常会发现自己把事儿干复杂了，应该把代码再简化一下，于是就会回头去改代码。是的，写文档就是在写代码。 有些 Code Review 工具所允许给出的反馈只是代码怎样修改以变得更好，但长此以往会让人觉得复查提出的意见都表示原先的代码不够好。为了提高员工积极性，LinkedIn 的代码复查工具允许提出“这段代码很棒”之类的话语，以便让好代码的作者得到鼓励。我认为，这个方法也很赞，正面鼓励的价值也不可小看。为 Code Review 的结果写出有目的性的注释。比如“消除重复代码”，“增加了测试覆盖率”，等等。长此以往也让团队的价值观得以明确。Code Review 中，不但要 Review 提交者的代码，还要 Reivew 提交者做过的测试。除了一些单元测试，还有一些可能是手动的测试。提交者最好列出所有测试过的案例。这样可以让 Reviewer 可以做出更多的测试建议，从而可以提高质量。对 Code Review 有明确的期望，不过分关注细枝末节，也不要炫技，而是对要 Review 的代码有一个明确的目标。编程语言和代码质量的研究报告A Large-Scale Study of Programming Languages and Code Quality in GitHub，编程语言和代码质量的研究报告，网址为： https://cacm.acm.org/magazines/2017/10/221326-a-large-scale-study-of-programming-languages-and-code-quality-in-github/ 这是一项有趣的研究。有四个人从 Github 上分析了 728 个项目，6300 万行代码，近 3 万个提交人，150 万个 commits，以及 17 种编程语言（如下图所示），然后，他们想找到编程语言对软件质量的影响。 然后，他们还对编程语言做了一个分类，想找到不同类型的编程语言的 bug 问题。如下图所示： 以及，他们还对这众多的开源软件做了个聚类，如下图： 对 bug 的类型也做了一个聚类，如下图： 其中分析的方法我不多说了。我们来看一下相关的结果。 首先，他们得出来的第一个结果是，从查看 bug fix 的 commits 的个数情况来看，C、C++、Objective-C、PHP 和 Python 中有很多很多的 commits 都是和 bug fix 相关的，而 Clojure、Haskell、Ruby、Scala 在 bug fix 的 commits 的数明显要少很多。 下图是各个语言出 bug 的情况。如果你看到是正数，说明高于平均水平，如果你看到是负数，则是低于平均水平。 第二个结论是，函数式编程语言的 bug 明显比大多数其它语言的要好很多。有隐式类型转换的语言明显产生的 bug 数要比强类型的语言要少很多。函数式的静态类型的语言要比函数式的动态类型语言的程序出 bug 的可能性要小很多。 第三，研究者想搞清是否 bug 数会和软件的领域相关。比如，业务型的，中间件型、框架、lib，或是数据库。研究表明，并没有什么相关性。下面这个图是各个语言在不同领域的 bug 率。 第四，研究人员想搞清楚 bug 的类型是否会和语言有关系。的确如此，bug 的类型和语言是强相关性的。下图是各个语言在不同的 bug 类型的情况。如果你看到的是正数，说明高于平均水平，如果你看到的是负数，则是低于平均水平。 也许，这份报告可以在你评估语言时有一定的借鉴作用。 电子书：《C++ 软件性能优化》 Optimizing Software in C++ - Agner Fog - PDF，C++ 软件性能优化，http://agner.org/optimize/optimizing_cpp.pdf 这本书是所有 C++ 程序员都应该要读的一本书。这本书从事无巨细地从语言层面，编译器层面，内存访问层面，多线程层面，CPU 层面……讲述了如果对软件性能的调优。实在是一本经典的电子书。 Agner Fog 还写了其它几本和性能调优相关的书（你可以到这个网址下载：http://www.agner.org/optimize/ ） Optimizing subroutines in assembly language: An optimization guide for x86 platformsThe microarchitecture of Intel, AMD and VIA CPUs: An optimization guide for assembly programmers and compiler makersInstruction tables: Lists of instruction latencies, throughputs and micro-operation breakdowns for Intel, AMD and VIA CPUsCalling conventions for different C++ compilers and operating systems我今天推荐的内容比较干，需要慢慢吸收体会，最好能借鉴到实践中用用，相信会有更多的感悟和收获。你还对哪些方面的内容感兴趣，欢迎留言给我。我后面收集推荐内容的时候，会有意识地关注整理。 参考资料 http://www.infoq.com/cn/articles/programer-knowledge?utm_source=infoq&amp;utm_medium=popular_widget&amp;utm_campaign=popular_content_list&amp;utm_content=homepage","tags":[]},{"title":"JVM性能调优监控工具","date":"2018-06-20T09:03:09.800Z","path":"2018/06/20/JVM性能调优监控工具/","text":"以下是一些JVM性能调优监控工具1jps、jstack、jmap、jhat、jstat、hprof.... 对于java程序,有时可能会碰到以下问题 OutOfMemoryError，内存不足 内存泄露 线程死锁 锁争用（Lock Contention） Java进程消耗CPU过高 …. 简单的脚本12345678910111213141516#!/bin/bash# vim:set et ts=4 sw=4:#set -xapp_list='inner core scene outer'current_unix=$(date +\"%s\")while truedo current_date=$(date -d @$current_unix +\"%H%M%S\") # 举例core的pid /home/app/jdk/bin/jmap -heap PID | gzip &gt; /home/changyou/jmap-heap/core-heap-$&#123;current_date&#125;.log.gz /home/app/jdk/bin/jmap -histo PID | gzip &gt; /home/changyou/jmap-histo/core-histo-$&#123;current_date&#125;.log.gz sleep 10 current_unix=$(date +\"%s\")done 通过一些监控工具去对java程序进行调优以及监控,在发生问题时使用工具去进行定位问题为后续的排障、修复问题起到了很好的辅助作用。","tags":[{"name":"Technology","slug":"Technology","permalink":"https://yo42.github.io/tags/Technology/"}]},{"title":"人间失格","date":"2018-06-11T08:20:56.293Z","path":"2018/06/11/人间失格/","text":"《人间失格》是日本作家太宰治的长篇小说。人间失格意为丧失了做人的资格。 由序、第一手札、第二手札、第三手札、后记共五个部分构成，其中序和后记以作者口吻叙说，三个手札则以主人公叶藏的口吻叙述。 小说的前半部分以大庭叶藏这位主人公的口吻,讲述了他奇特而悲催的人生经历叶藏自小仿佛便看穿了人世间的种种阴暗，遂以一种诡异的笑容面对他的人生，他时常在饰演一个小丑般的角色去对待人世间的事与物，病态且嬉戏的童年，至青年酗酒、沉溺女色、参加“非法”左翼团体，到中年与娼妓一起殉情(女死男生)，种种的经历让他饱受了人世间的情苦，这从一开始也埋下了伏笔，预示着叶藏最终走向毁灭之路。 《人间失格》可以说是太宰治本人的自传了，主角大庭叶藏就是他为原型的,在文中的”GoodBye” 章节写道”一位文坛大师辞世，告别仪式结束时，忽然下起了雨….”(太宰治留在人世间的一个彩蛋？) 21岁的太宰治和银座咖啡馆女侍投海自杀未遂…39岁与崇拜他的女读者山崎富荣跳玉川上水自杀… 以下是《人间失格的》的一些摘抄: 早晨，我睁眼醒来翻身下床，又变成了原来那个浅薄无知、善于伪装的滑稽角色。胆小鬼连幸福都会惧怕，碰到棉花都会受伤，有时也会被幸福所伤。趁着还没有受伤，我想就这样赶快分道扬镳。我又放出了惯用的逗笑烟幕弹。 而那些相互欺瞒却又过着单纯、明了生活的人，抑或相互欺瞒却又胸有成竹地面对生活的人，着实令人费解。人类终究未能让我明白其中真谛。若我能明了，或许就不必如此地畏惧人类，也不必竭力讨好众人，更不至于与人类的生活对立，夜夜遭受地狱般的苦难。 附上一张太宰治很”丧”的照片 太宰治君","tags":[{"name":"Books","slug":"Books","permalink":"https://yo42.github.io/tags/Books/"}]},{"title":"爱你就像爱生命","date":"2018-06-11T08:20:33.587Z","path":"2018/06/11/爱你就像爱生命/","text":"爱你就像爱生命,爱你要了我的命。(后半句我瞎编的，科科..)《爱你就像爱生命》是一本书信集,是王小波和李银河情书信集。(文人说起情话来真的是无法抗拒呀….) 关于王小波: 王小波在白话文叙述方面有很深的造诣，写作小说的同时他也创作过一些杂文与随笔文章。并且很多人都是由于精彩而睿智的杂文作品接触和认识到王小波。王小波的东西方生活与求学经历，使他成为一个富有自由人文精神和独立知识分子品格的写作者。 在他的作品中，贯穿着其特有的黑色幽默，这些也表明了王小波对于生命和生活的态度。王小波的一系列小说都以自己所经历过的生活作为蓝本，如下放到云南的知识青年，在某个医院或高等专科学校从事技术工种的工程师等等，作品的年代背景也与王小波的生活与成长时期相重叠，在这些作品中，他刻画了这样一种现实：“我看到一个无智的世界，但是智慧在混沌中存在；我看到一个无性的世界，但是性爱在混沌中存在；我看到一个无趣的世界，但是有趣在混沌中存在”。 从杂文作品中看，哲学家伯特兰·罗素对他思想影响很深，他推崇和提倡科学与理性，并且认为人的生活应该追求未知，他反对进行思想禁锢，主张人们思维应该保持多样化，使生活变得有意思有趣，去热爱智慧。 他的作品在他身后盛行于世，影响了众多青年，特别是二十世纪九十年代的大学生，他们至今还会常常引用王小波作品中的文字，来表明自己的激昂和犀利。其曾编写过电影剧本《东宫西宫》，并由此获得了阿根廷国际电影节最佳编剧。 下方是些摘抄: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849我现在已经养成了一种习惯，就是每三二天要找你说几句不想对别人说的话。当然还有更多的话没有说出口来，但是只要我把它带到了你面前，我走开的时候自己就满意了，这些念头就不会做再折磨我了。我现在不坏了，我有了良心。我的良心就是你。我的灵魂里有很多地方玩世不恭 ，对人傲慢无礼，但是它有一个核心，这个核心害怕黑暗，柔弱得像绵羊一样。只有顶平等的有爱才能使他得到安慰。你对我是属于这个核心的。我是爱你的，看见就爱上了。我爱你爱到不自私的地步。我会不爱你吗？不爱你？不会。爱你就像爱生命。我真不知怎么才能和你亲近起来，你好像是一个可望而不可及的目标，我琢磨不透，追也追不上，就坐下哭了起来。你要是喜欢别人我会哭，但是还是喜欢你。我把我整个的灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗， 一千八百种坏毛病。它真讨厌，只有一点好，爱你。你知道我在世界上最珍视的东西吗？那就是我自己的性格，也就是我自己思想的自由。在这个问题上我都放下刀枪了–也就是说，听任你的改造和影响。你为什么还要计较我一两次我无心的过失和对你的伤害呢？我对好多人怀有最深的感情，尤其是对你。我很想为别人做好事，尤其是对你。你是非常可爱的人，真应该遇到最好的人，我也真希望我就是。假如你愿意，你就恋爱吧，爱我。不一定要你爱我，但是我爱你，这是我的命运。你要是回来我就高兴了，马上我就要放个震动北京城的大炮仗。男孩子们都喜欢女孩子，可是谁也没有我喜欢你这么厉害。我现在就很高兴，因为你又好又喜欢我，希望我高兴，有什么事情也喜欢说给我听。比方说你对于我，主要是因为你可爱。我从来没有在男人或者女人中发现这么可爱的人。但愿我和你，是一支唱不完的歌。谁也管不住我爱你，真的，谁管谁就真傻，我和你谁也管不住呢。你别怕，真的你谁也不要怕，最亲爱的好银河，要爱就爱个够吧，世界上没有比爱情更好的东西了。你真好，我真爱你。可惜我不是诗人，说不出再动人一点的话了。有时候你难过了，这时候我更爱你。只要你不拒绝我就拥抱你，我会告诉你这是因为什么。就是我不知是为了什么。不，我对你什么要求也没有，什么要求也没有，只要你来看我。我也不知道为什么。你愿意要什么，就给什么。你知道吗？要，对我来说，就是给啊。你要什么就是给我什么。不管我本人多么平庸，我总觉得对你的爱很美。静下来想你，觉得一切都没好得不可思议。以前我不知道爱情这么美好，爱到深处这么美好。真不想让任何人来管我们。谁也管不着，和谁都无关。告诉你，一想到你，我这张丑脸上就泛起微笑。我只希望你和我好，互不猜忌，也互不称誉，安如平日，你和我说话就像对自己说话一样，我和你说话也像对自己说话一样。你说，和我好么？","tags":[{"name":"Books","slug":"Books","permalink":"https://yo42.github.io/tags/Books/"}]},{"title":"恶意","date":"2018-06-09T08:14:20.748Z","path":"2018/06/09/恶意/","text":"东野圭吾《恶意》花了大约三小时拜读了东野圭吾的《恶意》相较之前的《白夜行》,此次更令我倒吸一口凉气,依然是十分具有东野圭吾特色的推理、悬疑的小说。小说绝大部分以第一人称 “手记” 的特点更令人感觉真实,以及更具有代入感。 小说故事讲述了一个畅销作家在出国前一晚被杀害的故事,以及后续一系列让人们匪夷所思的情节。 以第一人称的方式写手记的凶手被逮捕了,但当警方盘问其杀人动机时却令人疑惑不解,而隐藏在故事背后令人不寒而栗的真相又会是什么呢？ 在故事的最后 真相之章来自加贺警官的阐述经过层层深挖,发现凶案背后的真相竟如此令人难以接受。 东野圭吾前期巧妙的铺垫,一开始就蒙蔽了读者的双眼,到故事的最后真相慢慢浮出水面,情节反转的巧妙性就不言而喻了。 人性中的恶意：贪婪、嫉妒…真是十分可怕的负面能量，让人寒毛凛凛。 我发现东野圭吾书的一些特点,善与恶的对立面双方都是智商极高的人无论是《嫌疑人X的献身》里的数学天才石神与神探伽利略汤川亦或是《恶意》中的野野口与加贺。 东野圭吾的书不仅仅在于情节故事的铺垫地精彩,剧情反转地极为巧妙,而且在每个悬疑故事背后的真相把人性的丑恶面刻画地淋漓尽致,以及所映射出来的社会问题令人感到窒息。","tags":[{"name":"Books","slug":"Books","permalink":"https://yo42.github.io/tags/Books/"}]},{"title":"Material.io","date":"2018-05-28T06:17:56.827Z","path":"2018/05/28/Material-io/","text":"关于Material.io&nbsp; &nbsp; &nbsp; Material.io 是谷歌的一套设计交互系统,是一种视觉语言，将优秀设计的经典原则与科技创新相结合。 &nbsp; &nbsp; &nbsp; 起初我并不知道有这东西,纯粹的觉得它好看,Google的原生安卓系统也是与此有关系,所以博客的主题就选择了这款indigo。 &nbsp; &nbsp; &nbsp; 我们都需要有善于发现美的眼睛,你说是么?","tags":[]},{"title":"关于Docker Build 目录与GIT库共存的一些技巧","date":"2018-05-27T02:48:18.000Z","path":"2018/05/27/关于Docker-Build-目录与GIT库共存的一些技巧/","text":"如下 echo .git/ > .dockerignore 这样操作后，能加快docker build的速度","tags":[]},{"title":"《白日梦想家》","date":"2018-05-13T06:24:27.852Z","path":"2018/05/13/Movie/","text":"《白日梦想家》献给对生活乏味的人们 经典台词To see the world, things dangerous to come to,To see behind walls, draw closer,To find each other, and To feel.That is the purpose of life 开拓视野, 冲破艰险.看见世界, 身临其境.贴近彼此, 感受生活. “Sometimes I don’t.If I like a moment, for me, personallyI don’t like to have the distraction of the camera.I just want to stay in it.” Sean O'Connell More info: This Movie","tags":[]},{"title":"Hello World! Why Blogs?","date":"2018-05-13T06:24:27.852Z","path":"2018/05/13/hello-world/","text":"很久之前便有此念头，但迟迟却不见行动。 由于自己时常会有些天马行空的想法，以此为记。 博客大概会记录些关于学习上的东西&amp;技术上的文档，以及些杂谈吧。","tags":[]}]
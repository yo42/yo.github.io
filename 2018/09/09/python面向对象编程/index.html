<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>python面向对象编程  | Yo42 | Dont&#39;t Panic,Do not go gentle into that good night~</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Technology">
    <meta name="description" content="类就是一组数据和函数的集合。创建了一个新的类意味着创建了一个全新的对象 类型，也就允许我们创建新的此类型的 实例。每个类实例都带有属性以维护其状态。同样也有方法（在它自己的类中定义）来修改这些状态。 相比其他编程语言，使用 Python 的类机制创建类是最方便简洁的。Python 的类机制结合了 C++ 和 Modua-3 的机制，同时也符合所有面向对象编程的标准：类继承机制允许有多个基类，一个派">
<meta name="keywords" content="Technology">
<meta property="og:type" content="article">
<meta property="og:title" content="python面向对象编程 ">
<meta property="og:url" content="https://yo42.github.io/2018/09/09/python面向对象编程/index.html">
<meta property="og:site_name" content="Yo42">
<meta property="og:description" content="类就是一组数据和函数的集合。创建了一个新的类意味着创建了一个全新的对象 类型，也就允许我们创建新的此类型的 实例。每个类实例都带有属性以维护其状态。同样也有方法（在它自己的类中定义）来修改这些状态。 相比其他编程语言，使用 Python 的类机制创建类是最方便简洁的。Python 的类机制结合了 C++ 和 Modua-3 的机制，同时也符合所有面向对象编程的标准：类继承机制允许有多个基类，一个派">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2018-09-09T09:34:16.804Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python面向对象编程 ">
<meta name="twitter:description" content="类就是一组数据和函数的集合。创建了一个新的类意味着创建了一个全新的对象 类型，也就允许我们创建新的此类型的 实例。每个类实例都带有属性以维护其状态。同样也有方法（在它自己的类中定义）来修改这些状态。 相比其他编程语言，使用 Python 的类机制创建类是最方便简洁的。Python 的类机制结合了 C++ 和 Modua-3 的机制，同时也符合所有面向对象编程的标准：类继承机制允许有多个基类，一个派">
    
        <link rel="alternate" type="application/atom+xml" title="Yo42" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/yo.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Yo</h5>
          <a href="mailto:edyo7024@gmail.com" title="edyo7024@gmail.com" class="mail">edyo7024@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://yo42.github.io/Aobut-Me/"  >
                <i class="icon icon-lg icon-user"></i>
                About Me
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">python面向对象编程 </div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">python面向对象编程 </h1>
        <h5 class="subtitle">
            
                <time datetime="2018-09-09T06:09:14.543Z" itemprop="datePublished" class="page-time">
  2018-09-09
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Technology/">Technology</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面向对象技术简介"><span class="post-toc-number">1.</span> <span class="post-toc-text">面向对象技术简介</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Python-作用域与命名空间"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">Python 作用域与命名空间</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#作用域和命名空间例子"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">作用域和命名空间例子</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类对象"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">类对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#类定义语法"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">类定义语法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#类编码风格"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">类编码风格</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#类对象-1"><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">类对象</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实例对象"><span class="post-toc-number">1.3.4.</span> <span class="post-toc-text">实例对象</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#方法对象"><span class="post-toc-number">1.3.5.</span> <span class="post-toc-text">方法对象</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#类和实例变量"><span class="post-toc-number">1.3.6.</span> <span class="post-toc-text">类和实例变量</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#补充说明"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">补充说明</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用-property"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">使用 @property</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#继承"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多重继承"><span class="post-toc-number">1.6.1.</span> <span class="post-toc-text">多重继承</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#你不知道的-super"><span class="post-toc-number">1.6.2.</span> <span class="post-toc-text">你不知道的 super</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#深入-super"><span class="post-toc-number">1.6.3.</span> <span class="post-toc-text">深入 super()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#MRO-列表"><span class="post-toc-number">1.6.4.</span> <span class="post-toc-text">MRO 列表</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#super-原理"><span class="post-toc-number">1.6.5.</span> <span class="post-toc-text">super 原理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#小结"><span class="post-toc-number">1.6.6.</span> <span class="post-toc-text">小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#私有变量"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">私有变量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#零碎知识点"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">零碎知识点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#迭代器"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">迭代器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#生成器"><span class="post-toc-number">1.10.</span> <span class="post-toc-text">生成器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#生成器表达式"><span class="post-toc-number">1.11.</span> <span class="post-toc-text">生成器表达式</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考资料"><span class="post-toc-number">2.</span> <span class="post-toc-text">参考资料</span></a></li></ol>
        </nav>
    </aside>


<article id="post-python面向对象编程"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">python面向对象编程 </h1>
        <div class="post-meta">
            <time class="post-time" title="2018-09-09 14:09:14" datetime="2018-09-09T06:09:14.543Z"  itemprop="datePublished">2018-09-09</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Technology/">Technology</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>类就是一组数据和函数的集合。创建了一个新的类意味着创建了一个全新的对象 <em>类型</em>，也就允许我们创建新的此类型的 <em>实例</em>。每个类实例都带有属性以维护其状态。同样也有方法（在它自己的类中定义）来修改这些状态。</p>
<p>相比其他编程语言，使用 Python 的类机制创建类是最方便简洁的。Python 的类机制结合了 C++ 和 Modua-3 的机制，同时也符合所有面向对象编程的标准：类继承机制允许有多个基类，一个派生的类可以覆盖基类的任意方法，每个方法也可以调用基类的同名方法。每个对象都可以包含任意数量和类型的数据。与模块一样，类也具有 Python 动态的特性：即时创建，创建后仍可修改。</p>
<p>在 C++ 的概念中，常规的类成员都是 <em>公共（public）</em> 的（例外的情况请看 <a href="https://docs.python.org/3/tutorial/classes.html#tut-private" target="_blank" rel="noopener">Private Variables</a> 这一节）成员函数都是 <em>虚（virtual）</em> 的。 到了 Modula-3 中，我们没有从其自身的方法中引用对象成员的快速写法：方法函数声明时要在第一参数中标明对象，这样就会在调用时隐式的调用。在 Smalltalk 中，类本身就是对象。同时还有导入和重命名语法。但不同于 C++ 和 Modula-3，它的内置类型可以直接作为基类由用户进行扩展。同样，它也有类似 C++ 的地方，大部分有特殊语法的内置操作符（算术运算符，下标等等）都可以被类实例重定义。</p>
<h2 id="面向对象技术简介"><a href="#面向对象技术简介" class="headerlink" title="面向对象技术简介"></a>面向对象技术简介</h2><ul>
<li><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li>
<li><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li>
<li><strong>数据成员：</strong>类变量或者实例变量用于处理类及其实例对象的相关的数据。</li>
<li><strong>方法重载：</strong>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重载。</li>
<li><strong>实例变量：</strong>定义在方法中的变量，只作用于当前实例的类。</li>
<li><strong>继承：</strong>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li>
<li><strong>实例化：</strong>创建一个类的实例，类的具体对象。</li>
<li><strong>方法：</strong>类中定义的函数。</li>
<li><strong>对象：</strong>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li>
</ul>
<h3 id="Python-作用域与命名空间"><a href="#Python-作用域与命名空间" class="headerlink" title="Python 作用域与命名空间"></a>Python 作用域与命名空间</h3><p>介绍类之前，我必须先向你介绍一下 Python 的作用域规则。类定义在命名空间中有一些非常聪明的技巧，而且你需要知道作用域和命名空间是如何工作的这样才能完全理解它做了什么。顺便一提，本节的知识对任何高级的 Python 编程都很！有！用！</p>
<p>让我们先从几个定义开始。</p>
<p><em>namespace（命名空间）</em> 是一个从名字到对象的映射。大部分命名空间当前都由 Python 字典实现，但一般情况下基本不会去关注它们（除了要面对性能问题时），而且也有可能在将来更改。下面是几个命名空间的例子：存放内置函数的集合（里面含有 <a href="https://docs.python.org/3/library/functions.html#abs" target="_blank" rel="noopener"><code>abs()</code></a> 这样的函数，和其他的内置名称）；模块中的全局名称；函数调用中的本地名称。从某种意义上说，某对象的的属性集合也是一种命名空间的形式；比如，两个不同的模块都可能定义了一个 <code>maximize</code> 的函数，为了不引起混乱用户必须用模块名作为前缀修饰一下。</p>
<p>顺便一提， 接下来所有跟在 <code>.</code> 后面的单词我都称其为 <em>attribute（属性）</em>，比如， <code>z.real</code> 中的 <code>real</code> 就是对象 <code>z</code> 的一个属性。严格来说，引用模块中的名称就是属性引用： <code>modname.funcname</code> 中的 <code>modname</code> 是一个模块对象，<code>funcname</code> 自然就是它的一个属性了。还有一种在模块的属性与本模块的全局名称之间恰好发生了一个直接的映射的情况：它们共享了同一个命名空间！<a href="https://docs.python.org/3/tutorial/classes.html#id2" target="_blank" rel="noopener">[1]</a>。</p>
<p>属性可以是只读的，也可以是可写的。在后一种情况中，可以指定某个属性某些内容。如果模块属性可写：你可以用 <code>modname.the_answer = 42</code> 来指定。可写的属性也同样可以被 <a href="https://docs.python.org/3/reference/simple_stmts.html#del" target="_blank" rel="noopener"><code>del</code></a> 语句删除。 例如， <code>del modname.the_answer</code> 将会删除掉 <code>modname</code> 的 <code>the_answer</code> 属性。</p>
<p>命名空间会在不同时刻被创建，也会拥有不同的命名空间。命名空间中包含着在 Python 解释器启动之初创建的内置名称，并且永远不会被删除。模块中的全局命名空间也会在模块被读入时创建，一般情况下也会持续到解释器退出。声明的执行由上层解释器调用，不管是从文件中读入还是交互式的，模块中包含最多的是一个叫 <a href="https://docs.python.org/3/library/__main__.html#module-__main__" target="_blank" rel="noopener"><code>__main__</code></a> 的东西，每个模块都有自己的全局命名空间（实际上内置名称也在模块中存在，它们被称为 <a href="https://docs.python.org/3/library/builtins.html#module-builtins" target="_blank" rel="noopener"><code>builtins</code></a>.) ）。</p>
<p>函数的本地命名空间在函数被调用时创建，函数返回或抛出异常时但没在函数内处理时删除。（实际上，忘记处理可能是描述实际所发生的了什么的更好的方式..）当然，递归调用每一次都有自己的本地命名空间。</p>
<p><em>scope (作用域)</em> 是一段 Python 程序的文本区域，处于其中的命名空间是可直接访问的。「可直接访问」在这里的意思是非限定性引用的某名称会尝试在此命名空间中查找。</p>
<p>尽管作用域一般都是静态的，不过也常常被动态的用。在任何执行的时候，每段代码都至少有3个嵌套的作用域可直接访问。</p>
<ul>
<li>最内层的作用域，会被首先搜索，里面放的是本地名称。</li>
<li>任何处于函数内的作用域，会从在最接近它的作用域中开始寻找，这层的命名空间中放的是非本地但也非全局的名称。</li>
<li>倒数第二层作用域是包含着当前模块的全局名称。</li>
<li>最外层作用域（最后搜索的一层）是包含内置名称的命名空间。</li>
</ul>
<p>如果某名称是在全局进行的声明，那么所有的引用和分配都会直接导向中间的这层包含模块的全局名称的作用域中。要想让最内层的作用域重新绑定一个在外层出现过的变量，我们可以用 <a href="https://docs.python.org/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a> 声明来完成；如果不声明 nonlocal (非本地)，这些变量则都是只读的（任何尝试写入这种变量的行为都将会创建一个 <em>全新</em> 的本地变量，不会对最外层的那个有丝毫影响。）</p>
<p>通常情况下，本地作用域引用着当前函数的本地名称。外层的函数引用的是和全局作用域一样的命名空间：模块的命名空间。类定义放置在本地作用域的另一个命名空间中。</p>
<p>意识到作用域取决于文本是很重要的：某个模块中所定义的函数的全局作用域是它所在的模块的命名空间，不管这函数来自什么地方或以什么别名被调用。换句话说，实际的名称搜索是在动态的情况下完成的，也就是运行时 — 但，语言定义的发展是朝着静态命名去的，在 「编译」阶段完成，所以不要试图依赖任何动态的命名！（实际上，本地变量已经是静态定义的了。）</p>
<p>Python 中也有皮一下的地方 – 如果不用 <a href="https://docs.python.org/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 声明，那么所分配的变量总是在它所处位置的最内层。分配不会复制数据 – 它们只是把名字绑定到对象上。对删除来讲也是一样： <code>del x</code> 声明会把 <code>x</code> 从本地作用域所引用的命名空间中移除绑定。实际上，所有引入新名称的操作都会使用本地作用域：尤其是 <a href="https://docs.python.org/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 声明和绑定在模块中的函数定义或者在本地作用域的函数名称。</p>
<p><a href="https://docs.python.org/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 声明被用在要指定某个特殊的变量要在全局作用域中存活且应该在这重新被绑定的情况下；<a href="https://docs.python.org/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a>声明则是用在指示某变量存在于某封闭的作用域且应该在这被重新绑定的情况下。</p>
<h3 id="作用域和命名空间例子"><a href="#作用域和命名空间例子" class="headerlink" title="作用域和命名空间例子"></a>作用域和命名空间例子</h3><p>用个小例子来演示下如何引用不同的作用域和命名空间，以及 <a href="https://docs.python.org/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 和 <a href="https://docs.python.org/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a> 是如何影响变量绑定的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scope_test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_local</span><span class="params">()</span>:</span></span><br><span class="line">        spam = <span class="string">"local spam"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_nonlocal</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> spam</span><br><span class="line">        spam = <span class="string">"nonlocal spam"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_global</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">global</span> spam</span><br><span class="line">        spam = <span class="string">"global spam"</span></span><br><span class="line"></span><br><span class="line">    spam = <span class="string">"test spam"</span></span><br><span class="line">    do_local()</span><br><span class="line">    print(<span class="string">"After local assignment:"</span>, spam)</span><br><span class="line">    do_nonlocal()</span><br><span class="line">    print(<span class="string">"After nonlocal assignment:"</span>, spam)</span><br><span class="line">    do_global()</span><br><span class="line">    print(<span class="string">"After global assignment:"</span>, spam)</span><br><span class="line"></span><br><span class="line">scope_test()</span><br><span class="line">print(<span class="string">"In global scope:"</span>, spam)</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">After local assignment: test spam</span><br><span class="line">After <span class="keyword">nonlocal</span> assignment: <span class="keyword">nonlocal</span> spam</span><br><span class="line">After <span class="keyword">global</span> assignment: <span class="keyword">nonlocal</span> spam</span><br><span class="line">In <span class="keyword">global</span> scope: <span class="keyword">global</span> spam</span><br></pre></td></tr></table></figure>
<p>注意 <em>本地</em> 的分配并未改变 <em>scope_test</em> 中绑定的 <em>spam</em>，而 <a href="https://docs.python.org/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a> 标明过的分配则改变了 <em>scope_test</em> 绑定的 <em>spam</em>，<a href="https://docs.python.org/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 则更改的是模块层面的绑定。</p>
<p>不知道你有没有注意到，我们在 <a href="https://docs.python.org/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 之前是没有绑定 <em>spam</em> 的。</p>
<h3 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h3><h4 id="类定义语法"><a href="#类定义语法" class="headerlink" title="类定义语法"></a>类定义语法</h4><p>类定义的形式很简单像这样既可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>类的定义与函数定义（<a href="https://docs.python.org/3/reference/compound_stmts.html#def" target="_blank" rel="noopener"><code>def</code></a> statements）差不多，在它们生效前我们需要预先执行这些定义（你也可以在  <a href="https://docs.python.org/3/reference/compound_stmts.html#if" target="_blank" rel="noopener"><code>if</code></a>分支或函数内部声明类）。</p>
<p>在实践中，类定义内的声明通常是函数定义，不过也有其他的声明，而且还挺有用 – 我们之后再谈这个。在类中定义的函数通常有一个特有的参数列表，指代是作为方法调用的 — 同样我们稍后再解释。</p>
<p>进入到类定义后，会创建一个新的命名空间作为本地作用域 — 也因此，所有的本地变量的指定都会进到这个新的作用域里。尤其是定义函数所绑定的是此函数的名字。</p>
<p>类定义正常结束时，一个新的 <em>类对象</em> 就被创建出来了。这是类定义在命名空间中最基本的一层包装；我们在下一节中详细讨论这个。原始的本地作用域（在进入类定义前生效的那个）会被重新安装，然后将类名字（就是上例中的 <code>ClassName</code>）绑定到这个类对象上。</p>
<h4 id="类编码风格"><a href="#类编码风格" class="headerlink" title="类编码风格"></a>类编码风格</h4><p>类名应采用驼峰命名法，即类名中的每个单词首字母都大写，而不使用下划线。实例名和模块名都采用小写的格式，并且在单词之间加上下划线。</p>
<h4 id="类对象-1"><a href="#类对象-1" class="headerlink" title="类对象"></a>类对象</h4><p>类对象支持两种操作：属性引用和实例化。</p>
<p><em>Attribute references （属性引用）</em> 使用的是 Python 中标准的属性引用语法： <code>obj.name</code>。有效的属性名都会在此类创建时被塞入的命名空间中。所以，如果一个类定义看起来像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="string">"""简单的例子"""</span></span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure>
<p><code>MyClass.i</code> 和 <code>MyClass.f</code> 都是有效的属性引用，分别返回的是一个整数和一个函数对象。类属性同样是可分配的，所以你可以更改 <code>MyClass.i</code> 的值。<code>__doc__</code> 同样也是一个有效属性，返回的是此类的文档字符串： <code>&quot;简单的例子&quot;</code>。</p>
<p>类的 <em>实例化</em> 类似函数的形式。把它假装成一个无参数且返回的是此类实例的函数就行。看代码（用的上面那个类）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = MyClass()</span><br></pre></td></tr></table></figure>
<p>这样就创建一个新的类 <em>实例</em> 并把它分配给了本地变量 <code>x</code>。</p>
<p>实例化操作（「调用」类对象）创建的是一个空对象。大多数类都想在创建时自定义初始化状态。所以类通常也会定义一个名为 <a href="https://docs.python.org/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.data = []</span><br></pre></td></tr></table></figure>
<p>当某类定义了 <a href="https://docs.python.org/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a>  方法，类实例化时就会为新的类实例自动调用 <a href="https://docs.python.org/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法。所以，我们不需要做任何改变：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = MyClass()</span><br></pre></td></tr></table></figure>
<p>当然，<a href="https://docs.python.org/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法也可以有参数变得更加易用。需要参数时，在参数实例化时给定的参数会传递到 <a href="https://docs.python.org/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, realpart, imagpart)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.r = realpart</span><br><span class="line"><span class="meta">... </span>        self.i = imagpart</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Complex(<span class="number">3.0</span>, <span class="number">-4.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.r, x.i</span><br><span class="line">(<span class="number">3.0</span>, <span class="number">-4.5</span>)</span><br></pre></td></tr></table></figure>
<h4 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h4><p>那么..我们要用这个实例对象干什么呢？最基本的操作时属性引用。我们现在有两种有效的属性名：数据属性和方法。</p>
<p><em>data attributes（数据属性）</em> 等同于 Smalltalk 中的「实例变量」，以及 C++ 中的 「数据成员」。数据属性不需要提前声明；就像本地变量一样，它们会在第一次分配时传播到已有的命名空间中。举个例子，假设我们已经创建了 <code>MyClass</code> 的实例 <code>x</code>，下面的代码会打印出 <code>16</code>且不留下痕迹：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x.counter = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> x.counter &lt; <span class="number">10</span>:</span><br><span class="line">    x.counter = x.counter * <span class="number">2</span></span><br><span class="line">print(x.counter)</span><br><span class="line"><span class="keyword">del</span> x.counter</span><br></pre></td></tr></table></figure>
<p>另一种实例属性引用是 <em>method (方法)</em>。一个方法也就是一个 「属于」某个对象的函数。（在 Python 中，方法一词并不被类实例独占：其他对象属性也同样具有方法。比如，列表对象也有如 <code>append</code>, <code>insert</code>, <code>remove</code>, <code>sort</code> 的方法。不过，接下来的讨论中我们所说的方法只指代类实例对象中的方法，除非特别指明。）</p>
<p>实例对象的有效方法名依赖于它的类。基于定义，所有是函数对象的类属性定义都会等同于它所实例化后的方法。所以在我们的例子中，<code>x.f</code> 是一个有效的方法引用，因为 <code>MyClass.f</code> 就是一个函数，但 <code>x.i</code> 则不是，因为 <code>MyClass.i</code> 就不是。但 <code>x.f</code> 并不是 <code>MyClass.f</code> – 在这里它变成了 <em>方法对象</em> 而不是函数对象。</p>
<h4 id="方法对象"><a href="#方法对象" class="headerlink" title="方法对象"></a>方法对象</h4><p>通常，绑定后可以立即调用方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.f()</span><br></pre></td></tr></table></figure>
<p>在 <code>MyClass</code> 例子中，会返回一个字符串 <code>&quot;hello world&quot;</code>。不过，我们并不需要立即调用：<code>x.f</code> 是一个方法对象，可以被存储下来并且在任何其他时间调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xf = x.f</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    print(xf())</span><br></pre></td></tr></table></figure>
<p>将会一直打印 <code>hello world</code>。</p>
<p>调用方法时到底发生了什么？你可能注意到了，上面的 <code>x.f()</code> 调用并没有写参数，即使我们定义 <code>f()</code> 时指定了一个参数。那个函数呢？没错，如果没有足够的函数所需的参数 Python 会抛出一个异常 – 即使这参数可能实际并没有用到。</p>
<p>聪明的你，可能已经猜到了答案：关于方法最特殊的一件事就是实例对象会传递第一个参数到函数中。在我们的例子中， <code>x.f()</code> 实际上等同于 <code>MyClass.f(x)</code>。通俗点讲，调用一个有 <em>n</em> 个参数的方法等同于调用在这些参数前插入了一个方法的实例作为第一个参数的函数。</p>
<p>如果仍然不明白方法是怎么工作的，我们了解下实现过程可能会有些帮助。当一个引用一个实例的非数据属性时，实例对象类会首先被搜索。如果这个名字指代的是一个有些的类属性而且还是一个函数对象，那方法对象就会被创建用于包装（指针指向）实例对象和函数对象在同一个抽象对象中：这就是方法对象的形成。当带着参数调用方法对象时，会结合实例对象和参数列表创建一个新的参数列表，方法对象所调用的就是这个新的参数列表。</p>
<h4 id="类和实例变量"><a href="#类和实例变量" class="headerlink" title="类和实例变量"></a>类和实例变量</h4><p>通俗来讲，实例变量是每个实例独有的数据，而类变量则是会让所有此类的实例所共享的方法和属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line"></span><br><span class="line">    kind = <span class="string">'canine'</span>         <span class="comment"># 类变量会在所有实例里共享</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name    <span class="comment"># 每个实例都有独立的实例变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Dog(<span class="string">'Fido'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Dog(<span class="string">'Buddy'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.kind                  <span class="comment"># 所有 dog 都会共享</span></span><br><span class="line"><span class="string">'canine'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.kind                  <span class="comment"># 同上</span></span><br><span class="line"><span class="string">'canine'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.name                  <span class="comment"># d 所独有的</span></span><br><span class="line"><span class="string">'Fido'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.name                  <span class="comment"># e 所独有的</span></span><br><span class="line"><span class="string">'Buddy'</span></span><br></pre></td></tr></table></figure>
<p>在 <a href="https://docs.python.org/3/tutorial/classes.html#tut-object" target="_blank" rel="noopener">A Word About Names and Objects</a> 的讨论中，共享的数据可能在调用 <a href="https://docs.python.org/3/glossary.html#term-mutable" target="_blank" rel="noopener">mutable</a> 可变对象（比如列表和字典）时有意料之外的效果。举个例子， 下面写的 <em>tricks</em> 列表就不应该作为一个类变量存在，因为同一个列表会在所有的 <em>Dog</em>实例中共享：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line"></span><br><span class="line">    tricks = []             <span class="comment"># 不要作为类变量误用。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_trick</span><span class="params">(self, trick)</span>:</span></span><br><span class="line">        self.tricks.append(trick)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Dog(<span class="string">'Fido'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Dog(<span class="string">'Buddy'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.add_trick(<span class="string">'roll over'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.add_trick(<span class="string">'play dead'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.tricks                <span class="comment"># 我们不希望它在所有 dog 中共享。</span></span><br><span class="line">[<span class="string">'roll over'</span>, <span class="string">'play dead'</span>]</span><br></pre></td></tr></table></figure>
<p>正确的设计应该是用实例变量代替：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.tricks = []    <span class="comment"># 每只 dog 都有一个全新的列表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_trick</span><span class="params">(self, trick)</span>:</span></span><br><span class="line">        self.tricks.append(trick)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Dog(<span class="string">'Fido'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Dog(<span class="string">'Buddy'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.add_trick(<span class="string">'roll over'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.add_trick(<span class="string">'play dead'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.tricks</span><br><span class="line">[<span class="string">'roll over'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.tricks</span><br><span class="line">[<span class="string">'play dead'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>数据属性会覆盖同名的方法属性；为了避免命名冲突（冲突的话在大型程序中往往会引起很难查找的 bug），用一些大家都遵守的约定来最小化冲突的机会是非常明智的。一般有大写方法名字，使用独特的短字符串来给数据属性加上前缀（也可以是仅仅一个下划线），或者使用动词命名方法，而使用名词命名数据属性。</p>
<p>数据属性不光可以被此对象的用户（「客户」）一方使用，我们在方法内同样可以使用。换句话说，类不能用于实现纯粹的抽象数据类型。实际上，在 Python 中强制数据隐藏起来也是不可能的 — 它们只是在约定。（换..换句话说， Python 中实现于 C 的部分可以做到完全的隐藏实现细节，也可以控制一个对象的访问；这一点可以用在用 C 写 Python 的扩展上）。</p>
<p>客户一方（就是创建了实例后再用）也应该小心地使用数据属性 — 因为有可能弄乱方法们维护的数据属性一致性。不过客户一方也可以添加自己的数据属性进去，只要避免影响到方法的有效性就行，也就是说避免命名冲突 — 再说一遍！避免命名冲突很！重！要！</p>
<p>Python 中并无在方法内快捷访问数据熟悉的途径（方法的也没有！）。因为这样可以提高可读性：这样就可以快速弄清楚本地变量和实例变量。</p>
<p>通常我们把方法的第一个参数命名为 <code>self</code>. 这只是一个约定： <code>self</code> 这个名字对 Python 来讲并无特殊含义。不过要注意，如果不遵守的话~，其他的 Python 程序猿可能会不知道你写的啥呦~，而且还可依据此来写一个 <em>class browser</em> 的程序</p>
<p>任何作为类属性定义的函数对象都会作为实例或类的方法。把相关的函数定义在类的文本域内并不是必须的：指定一个函数对象到类的本地变量中同样是 Ok 的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义在类外了...</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> min(x, x+y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    f = f1</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line">    h = g</span><br></pre></td></tr></table></figure>
<p><code>f</code>，<code>g</code>， <code>h</code> 都是类 <code>C</code> 的属性，全都是属性对象，同时也都是 <code>C</code> 实例的方法 — <code>h</code> 等同于 <code>g</code>。要注意，这里这种写法一般是为了让程序变得混乱。</p>
<p>使用 <code>self</code> 参数可以在方法内调用其他的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.data = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.data.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addtwice</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.add(x)</span><br><span class="line">        self.add(x)</span><br></pre></td></tr></table></figure>
<p>方法也可以像引用普通函数一样引用全局名称。与方法关联的全局作用域是包含着它的模块。（类永远不能作为全局作用域使用）若是有一个在方法中必须要用到全局数据的理由，那要遵守以下几点：其实只有一件事，全局作用域中引入的函数和模块可以使用，在全局作用域中的函数和类也可以使用。通常，全局作用域中的类所包含的方法都是它自己定义的，我们将在下一节找到几个合理的理由来解释为什么一个方法需要引用它自己的类。</p>
<p>每个值都是一个对象，也因此都有 <em>class</em> (也被称为 <em>type</em>)。这些东西都被放在了 <code>object.__class__</code> 中。</p>
<h3 id="使用-property"><a href="#使用-property" class="headerlink" title="使用 @property"></a>使用 @property</h3><p>在使用 <code>@property</code> 之前，让我们先来看一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        self._score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val &lt; <span class="number">0</span>:</span><br><span class="line">            self._score = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> val &gt; <span class="number">100</span>:</span><br><span class="line">            self._score = <span class="number">100</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._score = val</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Exam(<span class="number">60</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.get_score()</span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.set_score(<span class="number">70</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.get_score()</span><br><span class="line"><span class="number">70</span></span><br></pre></td></tr></table></figure>
<p>在上面，我们定义了一个 Exam 类，为了避免直接对 <code>_score</code> 属性操作，我们提供了 get_score 和 set_score 方法，这样起到了封装的作用，把一些不想对外公开的属性隐蔽起来，而只是提供方法给用户操作，在方法里面，我们可以检查参数的合理性等。</p>
<p>这样做没什么问题，但是我们有更简单的方式来做这件事，Python 提供了 <code>property</code> 装饰器，被装饰的方法，我们可以将其『当作』属性来用，看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        self._score = score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val &lt; <span class="number">0</span>:</span><br><span class="line">            self._score = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> val &gt; <span class="number">100</span>:</span><br><span class="line">            self._score = <span class="number">100</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._score = val</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Exam(<span class="number">60</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.score</span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.score = <span class="number">90</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.score</span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.score = <span class="number">200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.score</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>在上面，我们给方法 score 加上了 <code>@property</code>，于是我们可以把 score 当成一个属性来用，此时，又会创建一个新的装饰器 <code>score.setter</code>，它可以把被装饰的方法变成属性来赋值。</p>
<p>另外，我们也不一定要使用 <code>score.setter</code> 这个装饰器，这时 score 就变成一个只读属性了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        self._score = score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Exam(<span class="number">60</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.score</span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.score = <span class="number">200</span>  <span class="comment"># score 是只读属性，不能设置值</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-676</span>-b0515304f6e0&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 e.score = 200</span><br><span class="line"></span><br><span class="line">AttributeError: can<span class="string">'t set attribute</span></span><br></pre></td></tr></table></figure>
<p><code>@property</code> 把方法『变成』了属性。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在面向对象编程中，当我们已经创建了一个类，而又想再创建一个与之相似的类，比如添加几个方法，或者修改原来的方法，这时我们不必从头开始，可以从原来的类<strong>派生</strong>出一个新的类，我们把原来的类称为<strong>父类</strong>或<strong>基类</strong>，而派生出的类称为<strong>子类</strong>，<strong>子类</strong>继承了<strong>父类</strong>的所有数据和方法。</p>
<ul>
<li>继承可以拿到父类的所有数据和方法，子类可以重写父类的方法，也可以新增自己特有的方法。</li>
<li>有了继承，才有了多态，不同类的对象对同一消息会作出不同的相应。</li>
</ul>
<p>当然，一个不支持继承的「类」不足以被称为类。在类的定义中，继承的语法是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(BaseClassName)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>类名 <code>BaseClassName</code> 必须被定义在一个包含派生类 <code>DerivedClassName</code> 定义的作用域下。相较于直接使用基类名，任何其它表达式也是可以被填入的。这个特性经常被用到，比如，当基类被定义在其它模块中时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(modname.BaseClassName)</span>:</span></span><br></pre></td></tr></table></figure>
<p>派生类定义时的执行流程和基类相同。当一个类对象被创建，它会记录它的基类。这将被用于解析对象的属性：如果一个需要的属性不存在于当前类中，紧接着就会去基类中寻找。如果该基类也是从其他类派生出来的，那么相同的过程也会递归地被应用到这些类中。</p>
<p>实例化派生类也没有什么特别的： <code>DerivedClassName()</code> 就会创建类的一个新的实例。方法引用则按如下的方式被解析：首先在当前类中搜索对应的属性，然后沿着继承链往下搜索，如果找到了一个函数对象，那么这个方法引用就是可用的。</p>
<p>派生类可以重写基类的方法。因为方法在调用同一对象其它方法的时候没有什么特权，所以当派生类的实例调用某个基类的方法后，该基类的方法可能会再次调用派生类覆写的另一个基类方法。（对于 C++ 程序员而言， Python 中所有的方法都是 <code>virtual</code> 函数。）</p>
<p>派生类中重写的方法一般用于扩展同名的基类方法，而非简单的替换。 Python 中有一种简单的直接调用基类方法的方案：调用 <code>BaseClassName.methodname(self, arguments)</code> 即可。这在某些情景下也是有用的。（注意这个方法只有在基类 <code>BaseClassName</code> 在全局作用域下可以访问才能使用。）</p>
<p>Python 提供了两个判断继承关系的内建函数：</p>
<ul>
<li>使用 <a href="https://docs.python.org/3/library/functions.html#isinstance" target="_blank" rel="noopener"><code>isinstance()</code></a> 检查一个实例的类型：当且仅当 <code>obj.__class__</code> 是 <a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 或其它从 <a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 派生的类时， <code>isinstance(obj, int)</code> 才会返回 <code>True</code> 。</li>
<li>使用 <a href="https://docs.python.org/3/library/functions.html#issubclass" target="_blank" rel="noopener"><code>issubclass()</code></a> 检查类之间的继承关系：因为 <a href="https://docs.python.org/3/library/functions.html#issubclass" target="_blank" rel="noopener"><code>bool</code></a> 是 <a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的一个子类，所以 <code>issubclass(bool, int)</code> 返回 <code>True</code> 。然而，因为 <a href="https://docs.python.org/3/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 不是 <a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的派生类，所以 <code>issubclass(float, int)</code> 返回 <code>False</code> 。</li>
</ul>
<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>Python 也支持多重继承。一个具有多个基类的类定义如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(Base1, Base2, Base3)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>对于多数目的，在最简单的情况下，你可以认为搜索父类中继承的属性是深度优先，从左到右，而不是在继承结构中重叠的同一个类中搜索两次。因此，如果一个属性在 <code>DerivedClassName</code> 中没有找到，则在 <code>Base1</code> 中查找，再在 <code>Base1</code> 的基类中（递归地）查找，如果未能找到，则在 <code>Base2</code> 中查找，以此类推。</p>
<p>事实上，这个过程要稍稍更复杂一些；方法解析顺序是动态变化的，以支持合作调用 <a href="https://docs.python.org/3/library/functions.html#super" target="_blank" rel="noopener"><code>super()</code></a> 。这种方法在其他多继承语言中被称为调用下一方法，比单继承语言中的 super 调用更加强大。</p>
<p>动态排序是必要的，因为所有多重继承的情况都表现出一个或多个菱形关系（其中至少有一个父类可以通过最底层的多个路径访问）。例如，所有的类都继承自 <a href="https://docs.python.org/3/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> ，所以任何情况的多重继承都提供了不止一条的路径到达 <a href="https://docs.python.org/3/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 。 为了避免基类被多次访问，动态算法保证在每个类中进行从左到右特定顺序的线性搜索，因此每个父类只被调用一次，并且这个方法是单调的（意味着类可以被子类化而不影响其的优先顺序）。 总之，这些特性使得设计具有多重继承的可靠的且可扩展的类成为可能。 更多细节请参考 <a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="noopener">https://www.python.org/download/releases/2.3/mro/</a>.</p>
<h4 id="你不知道的-super"><a href="#你不知道的-super" class="headerlink" title="你不知道的 super"></a>你不知道的 super</h4><p>在类的继承中，如果重定义某个方法，该方法会覆盖父类的同名方法，但有时，我们希望能同时实现父类的功能，这时，我们就需要调用父类的方法了，可通过使用 <code>super</code> 来实现，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Hello, I am %s.'</span> % self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Dog, self).greet()   <span class="comment"># Python3 可使用 super().greet()</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'WangWang...'</span></span><br></pre></td></tr></table></figure>
<p>在上面，Animal 是父类，Dog 是子类，我们在 Dog 类重定义了 <code>greet</code> 方法，为了能同时实现父类的功能，我们又调用了父类的方法，看下面的使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog = Dog(<span class="string">'dog'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog.greet()</span><br><span class="line">Hello, I am dog.</span><br><span class="line">WangWang..</span><br></pre></td></tr></table></figure>
<p><code>super</code> 的一个最常见用法可以说是在子类中调用父类的初始化方法了，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a, b, c)</span>:</span></span><br><span class="line">        super(A, self).__init__(a, b)  <span class="comment"># Python3 可使用 super().__init__(a, b)</span></span><br><span class="line">        self.c = c</span><br></pre></td></tr></table></figure>
<h4 id="深入-super"><a href="#深入-super" class="headerlink" title="深入 super()"></a>深入 super()</h4><p>看了上面的使用，你可能会觉得 <code>super</code> 的使用很简单，无非就是获取了父类，并调用父类的方法。其实，在上面的情况下，super 获得的类刚好是父类，但在其他情况就不一定了，<strong>super 其实和父类没有实质性的关联</strong>。</p>
<p>让我们看一个稍微复杂的例子，涉及到多重继承，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"enter Base"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"leave Base"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"enter A"</span></span><br><span class="line">        super(A, self).__init__()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"leave A"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"enter B"</span></span><br><span class="line">        super(B, self).__init__()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"leave B"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"enter C"</span></span><br><span class="line">        super(C, self).__init__()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"leave C"</span></span><br></pre></td></tr></table></figure>
<p>其中，Base 是父类，A, B 继承自 Base, C 继承自 A, B，它们的继承关系是一个典型的『菱形继承』，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  Base</span><br><span class="line">  /  \</span><br><span class="line"> /    \</span><br><span class="line">A      B</span><br><span class="line"> \    /</span><br><span class="line">  \  /</span><br><span class="line">   C</span><br></pre></td></tr></table></figure>
<p>现在，让我们看一下使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line">enter C</span><br><span class="line">enter A</span><br><span class="line">enter B</span><br><span class="line">enter Base</span><br><span class="line">leave Base</span><br><span class="line">leave B</span><br><span class="line">leave A</span><br><span class="line">leave C</span><br></pre></td></tr></table></figure>
<p>如果你认为 <code>super</code> 代表『调用父类的方法』，那你很可能会疑惑为什么 enter A 的下一句不是 enter Base 而是 enter B。原因是，<strong>super 和父类没有实质性的关联</strong>，现在让我们搞清 <code>super</code> 是怎么运作的。</p>
<h4 id="MRO-列表"><a href="#MRO-列表" class="headerlink" title="MRO 列表"></a>MRO 列表</h4><p>事实上，对于你定义的每一个类，Python 会计算出一个<strong>方法解析顺序（Method Resolution Order, MRO）列表</strong>，<strong>它代表了类继承的顺序</strong>，我们可以使用下面的方式获得某个类的 MRO 列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.mro()   <span class="comment"># or C.__mro__ or C().__class__.mro()</span></span><br><span class="line">[__main__.C, __main__.A, __main__.B, __main__.Base, object]</span><br></pre></td></tr></table></figure>
<p>那这个 MRO 列表的顺序是怎么定的呢，它是通过一个 <a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="noopener">C3 线性化算法</a>来实现的，这里我们就不去深究这个算法了，感兴趣的读者可以自己去了解一下，总的来说，一个类的 MRO 列表就是合并所有父类的 MRO 列表，并遵循以下三条原则：</p>
<ul>
<li>子类永远在父类前面</li>
<li>如果有多个父类，会根据它们在列表中的顺序被检查</li>
<li>如果对下一个类存在两个合法的选择，选择第一个父类</li>
</ul>
<h4 id="super-原理"><a href="#super-原理" class="headerlink" title="super 原理"></a>super 原理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">super</span><span class="params">(cls, inst)</span>:</span></span><br><span class="line">    mro = inst.__class__.mro()</span><br><span class="line">    <span class="keyword">return</span> mro[mro.index(cls) + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>其中，cls 代表类，inst 代表实例，上面的代码做了两件事：</p>
<ul>
<li>获取 inst 的 MRO 列表</li>
<li>查找 cls 在当前 MRO 列表中的 index, 并返回它的下一个类，即 mro[index + 1]</li>
</ul>
<p>当你使用 <code>super(cls, inst)</code> 时，Python 会在 inst 的 MRO 列表上搜索 cls 的下一个类。</p>
<p>现在，让我们回到前面的例子。</p>
<p>首先看类 C 的 <code>__init__</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super(C, self).__init__()</span><br></pre></td></tr></table></figure>
<p>这里的 self 是当前 C 的实例，self.<strong>class</strong>.mro() 结果是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[__main__.C, __main__.A, __main__.B, __main__.Base, object]</span><br></pre></td></tr></table></figure>
<p>可以看到，C 的下一个类是 A，于是，跳到了 A 的 <code>__init__</code>，这时会打印出 enter A，并执行下面一行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super(A, self).__init__()</span><br></pre></td></tr></table></figure>
<p>注意，这里的 self 也是当前 C 的实例，MRO 列表跟上面是一样的，搜索 A 在 MRO 中的下一个类，发现是 B，于是，跳到了 B 的 <code>__init__</code>，这时会打印出 enter B，而不是 enter Base。</p>
<p>整个过程还是比较清晰的，关键是要理解 super 的工作方式，而不是想当然地认为 super 调用了父类的方法。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>事实上，<code>super</code> 和父类没有实质性的关联。</li>
<li><code>super(cls, inst)</code> 获得的是 cls 在 inst 的 MRO 列表中的下一个类。</li>
</ul>
<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>只能从对像内部访问的『私有』实例变量，在 Python 中不存在。然而，在大多数 Python 代码中存在一个这样的约定：以一个下划线开头的命名（例如 <code>_spam</code> ）会被处理为 API 的非公开部分（无论它是一个函数、方法或数据成员）。它会被视为一个实现细节，无需公开。</p>
<p>因为有一个正当的类私有成员用途（即避免子类里定义的命名与之冲突），Python 提供了对这种结构的有限支持，称为 <em>name mangling</em> （命名编码） 。任何形如 <code>__spam</code> 的标识（前面至少两个下划线，后面至多一个下划线），被替代为 <code>_classname__spam</code> ，去掉前导下划线的 <code>classname</code> 即当前的类名。此语法不关注标识的位置，只要求在类定义内。</p>
<p>名称重整是有助于子类重写方法，而不会打破组内的方法调用。例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mapping</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        self.items_list = []</span><br><span class="line">        self.__update(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">            self.items_list.append(item)</span><br><span class="line"></span><br><span class="line">    __update = update   <span class="comment"># private copy of original update() method</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MappingSubclass</span><span class="params">(Mapping)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, keys, values)</span>:</span></span><br><span class="line">        <span class="comment"># provides new signature for update()</span></span><br><span class="line">        <span class="comment"># but does not break __init__()</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> zip(keys, values):</span><br><span class="line">            self.items_list.append(item)</span><br></pre></td></tr></table></figure>
<p>需要注意的是编码规则设计为尽可能的避免冲突，被认作为私有的变量仍然有可能被访问或修改。在特定的场合它也是有用的，比如调试的时候。</p>
<p>要注意的是代码传入 <code>exec()</code>， <code>eval()</code> 时不考虑所调用的类的类名，视其为当前类，这类似于 <code>global</code> 语句的效应，已经按字节编译的部分也有同样的限制。这也同样作用于 <code>getattr()</code>， <code>setattr()</code> 和 <code>delattr()</code>，像直接引用 <code>__dict__</code> 一样。</p>
<h3 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="零碎知识点"></a>零碎知识点</h3><p>有时候，有一个类似于 Pascal 「记录」或者 C 「结构体」的数据类型是非常有用的，它能够将一些命名数据项捆绑在一起：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">john = Employee()  <span class="comment"># 创建一个新的 employee 记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给记录的各个字段赋值</span></span><br><span class="line">john.name = <span class="string">'John Doe'</span></span><br><span class="line">john.dept = <span class="string">'computer lab'</span></span><br><span class="line">john.salary = <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>一块 Python 代码通常希望能够传递特定抽象数据类型 ，而一个类则会模拟该数据类型的方法。例如，如果你有一个函数，可以格式化文件对象当中的一些数据；那么，你就可以定义一个带有 <code>read()</code> 方法和 <code>readline()</code> 方法的类，这两个方法可以从数据缓冲区中读取数据没并且将其作为参数传递出去。</p>
<p>实例方法对象也有属性： <code>m.__self__</code> 是带有方法 <code>m()</code> 的实例对象，并且 <code>m.__func__</code> 是和方法相对应的函数对象。</p>
<ul>
<li>类是具有相同<strong>属性</strong>和<strong>方法</strong>的一组对象的集合，实例是一个个具体的对象。</li>
<li>方法是与实例绑定的函数。</li>
<li><p>获取对象信息可使用下面方法：</p>
<ul>
<li><code>type(obj)</code>：来获取对象的相应类型；</li>
<li><code>isinstance(obj, type)</code>：判断对象是否为指定的 type 类型的实例；</li>
<li><code>hasattr(obj, attr)</code>：判断对象是否具有指定属性/方法；</li>
<li><code>getattr(obj, attr[, default])</code> 获取属性/方法的值, 要是没有对应的属性则返回 default 值（前提是设置了 default），否则会抛出 AttributeError 异常；</li>
<li><code>setattr(obj, attr, value)</code>：设定该属性/方法的值，类似于 obj.attr=value；</li>
<li><code>dir(obj)</code>：可以获取相应对象的<strong>所有</strong>属性和方法名的列表：</li>
</ul>
</li>
<li><p><code>__new__</code> 在 <code>__init__</code> 之前被调用，用来创建实例。</p>
</li>
<li><code>__str__</code> 是用 print 和 str 显示的结果，<code>__repr__</code> 是直接显示的结果。</li>
<li><code>__getitem__</code> 用类似 <code>obj[key]</code> 的方式对对象进行取值</li>
<li><code>__getattr__</code> 用于获取不存在的属性 obj.attr</li>
<li><code>__call__</code> 使得可以对实例进行调用</li>
</ul>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>目前为止，你可能发现了，大部分容器对象都能被 <a href="https://docs.python.org/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 所循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    print(element)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>):</span><br><span class="line">    print(element)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> &#123;<span class="string">'one'</span>:<span class="number">1</span>, <span class="string">'two'</span>:<span class="number">2</span>&#125;:</span><br><span class="line">    print(key)</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> <span class="string">"123"</span>:</span><br><span class="line">    print(char)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">"myfile.txt"</span>):</span><br><span class="line">    print(line, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>这种形式的访问很清晰，简洁，方便。其背后是迭代器在起作用，<a href="https://docs.python.org/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a><br>声明会调用容器对象的 <a href="https://docs.python.org/3/library/functions.html#iter" target="_blank" rel="noopener"><code>iter()</code></a> 函数，这个函数则返回一个迭代器对象，迭代器对象有 <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法，它会让容器中的元素一次返回一个。 <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a>  会抛出 <a href="https://docs.python.org/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 异常来让 <a href="https://docs.python.org/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 结束。你也可以用 <a href="https://docs.python.org/3/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> 函数来调用它的 <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法；下面的例子显示了迭代器是如何工作的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it</span><br><span class="line">&lt;iterator object at <span class="number">0x00A1DB50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line"><span class="string">'b'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line"><span class="string">'c'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    next(it)</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>了解了迭代器协议背后的机制，我们就可以很容易得在我们自己的类中添加迭代器行为。<a href="https://docs.python.org/3/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 方法需要返回一个带有 <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法的对象。如果类仅仅定义了<code>__next__()</code>， <a href="https://docs.python.org/3/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 那么返回的对象就是它自己 <code>self</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Reverse:</span><br><span class="line">    &quot;&quot;&quot;从后向前的迭代器&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = len(data)</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.index == 0:</span><br><span class="line">            raise StopIteration</span><br><span class="line">        self.index = self.index - 1</span><br><span class="line">        return self.data[self.index]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rev = Reverse(<span class="string">'spam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(rev)</span><br><span class="line">&lt;__main__.Reverse object at <span class="number">0x00A1DB50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char <span class="keyword">in</span> rev:</span><br><span class="line"><span class="meta">... </span>    print(char)</span><br><span class="line">...</span><br><span class="line">m</span><br><span class="line">a</span><br><span class="line">p</span><br><span class="line">s</span><br></pre></td></tr></table></figure>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p><a href="https://docs.python.org/3/glossary.html#term-generator" target="_blank" rel="noopener">Generator</a> 是一个简单又强大的创建迭代器的工具。写它们只要像常规函数一样就可以，只不过用的是 <a href="https://docs.python.org/3/reference/simple_stmts.html#yield" target="_blank" rel="noopener"><code>yield</code></a> 代替 <code>return</code> 返回数据。 每次 <a href="https://docs.python.org/3/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> 调用生成器时，生成器就会从它断开的地方恢复（它会记录所有的数据和最后执行的声明）。下面写个例子来展示下生成器并不神秘难写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(len(data)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">yield</span> data[index]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char <span class="keyword">in</span> reverse(<span class="string">'golf'</span>):</span><br><span class="line"><span class="meta">... </span>    print(char)</span><br><span class="line">...</span><br><span class="line">f</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">g</span><br></pre></td></tr></table></figure>
<p>所以生成器能做的事情，我们之前介绍过的以类为基础的迭代器也可以做。生成器之所以显得更加紧凑，是因为 <a href="https://docs.python.org/3/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 和 <a href="https://docs.python.org/3/reference/expressions.html#generator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法都被自动隐式的创建了。</p>
<p>生成器的另一个特色是本地变量和执行条件都会被自动保存。这就让我们很容易写出生成器函数，同时也比使用实例属性像是 <code>self.index</code>，<code>self.data</code> 来的简洁。</p>
<p>除了自动创建的方法和保存的程序状态，当生成器结束时，还会自动抛出 <a href="https://docs.python.org/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a>. 这些东西组合起来，就变成了一个让我们非常容易书写的迭代器形式。</p>
<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>一些简单的生成器我们可以用类似列表表达式的代码做出来，只要把方括号换成圆括号就行了。生成器表达式用来一般用在在函数内需要写即用即删的数据的时候。生成器表达式比起完整的生成器要更加紧凑但并不如它功能强大，不过比起列表表达式来内存占用更少。</p>
<p>例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(i*i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))                 <span class="comment"># 平方之和</span></span><br><span class="line"><span class="number">285</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>xvec = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>yvec = [<span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(x*y <span class="keyword">for</span> x,y <span class="keyword">in</span> zip(xvec, yvec))         <span class="comment"># 乘积</span></span><br><span class="line"><span class="number">260</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> pi, sin</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sine_table = &#123;x: sin(x*pi/<span class="number">180</span>) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">91</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unique_words = set(word  <span class="keyword">for</span> line <span class="keyword">in</span> page  <span class="keyword">for</span> word <span class="keyword">in</span> line.split())</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>valedictorian = max((student.gpa, student.name) <span class="keyword">for</span> student <span class="keyword">in</span> graduates)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = <span class="string">'golf'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(data[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>))</span><br><span class="line">[<span class="string">'f'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'g'</span>]</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://docs.python.org/3/tutorial/classes.html" target="_blank" rel="noopener">python官方文档</a></li>
<li><a href="http://funhacks.net/explore-python/Class/class_and_object.html" target="_blank" rel="noopener">python之旅</a></li>
<li><a href="https://bop.mol.uno/14.oop.html" target="_blank" rel="noopener">简明python</a></li>
<li><a href="https://wizardforcel.gitbooks.io/w3school-python/content/24.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/w3school-python/content/24.html</a></li>
<li><a href="http://yangcongchufang.com/%E9%AB%98%E7%BA%A7python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/python-object-class.html" target="_blank" rel="noopener">http://yangcongchufang.com/%E9%AB%98%E7%BA%A7python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/python-object-class.html</a></li>
<li><a href="https://mrlongx.com/index.php/2017/09/27/core-python-ch13/" target="_blank" rel="noopener">https://mrlongx.com/index.php/2017/09/27/core-python-ch13/</a></li>
</ul>
</blockquote>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2018-09-09T09:34:16.804Z" itemprop="dateUpdated">2018-09-09 17:34:16</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://yo42.github.io">
            <img src="/img/yo.jpg" alt="Yo">
            Yo
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Technology/">Technology</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://yo42.github.io/2018/09/09/python面向对象编程/&title=《python面向对象编程 》 — Yo42&pic=https://yo42.github.io/img/yo.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://yo42.github.io/2018/09/09/python面向对象编程/&title=《python面向对象编程 》 — Yo42&source=aaa" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://yo42.github.io/2018/09/09/python面向对象编程/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《python面向对象编程 》 — Yo42&url=https://yo42.github.io/2018/09/09/python面向对象编程/&via=https://yo42.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://yo42.github.io/2018/09/09/python面向对象编程/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/09/09/python-next-step/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">python next step</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/09/08/python错误和异常/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">python错误和异常</h4>
      </a>
    </div>
  
</nav>



    

















</article>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Yo &copy; 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> 
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://yo42.github.io/2018/09/09/python面向对象编程/&title=《python面向对象编程 》 — Yo42&pic=https://yo42.github.io/img/yo.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://yo42.github.io/2018/09/09/python面向对象编程/&title=《python面向对象编程 》 — Yo42&source=aaa" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://yo42.github.io/2018/09/09/python面向对象编程/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《python面向对象编程 》 — Yo42&url=https://yo42.github.io/2018/09/09/python面向对象编程/&via=https://yo42.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://yo42.github.io/2018/09/09/python面向对象编程/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://yo42.github.io/2018/09/09/python面向对象编程/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>










<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>